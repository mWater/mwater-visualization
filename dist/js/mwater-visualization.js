require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var ColumnNotFoundException,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

module.exports = ColumnNotFoundException = (function(superClass) {
  extend(ColumnNotFoundException, superClass);

  function ColumnNotFoundException(message) {
    this.name = this.constructor.name;
    this.message = message;
    this.stack = (new Error(message)).stack;
  }

  ColumnNotFoundException.prototype.constructor = ColumnNotFoundException;

  return ColumnNotFoundException;

})(Error);

},{}],2:[function(require,module,exports){
var DataSource, _;

_ = require('lodash');

module.exports = DataSource = (function() {
  function DataSource() {}

  DataSource.prototype.performQuery = function(query, cb) {
    throw new Error("Not implemented");
  };

  DataSource.prototype.getImageUrl = function(imageId, height) {
    throw new Error("Not implemented");
  };

  DataSource.prototype.clearCache = function() {};

  return DataSource;

})();

},{"lodash":"lodash"}],3:[function(require,module,exports){
var ExprCleaner, ExprUtils, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

ExprUtils = require('./ExprUtils');

module.exports = ExprCleaner = (function() {
  function ExprCleaner(schema) {
    this.cleanCountExpr = bind(this.cleanCountExpr, this);
    this.cleanLogicalExpr = bind(this.cleanLogicalExpr, this);
    this.cleanComparisonExpr = bind(this.cleanComparisonExpr, this);
    this.schema = schema;
    this.exprUtils = new ExprUtils(schema);
  }

  ExprCleaner.prototype.cleanExpr = function(expr, options) {
    var aggrOpItems, args, booleanOnly, i, k, l, opItem, ref, ref1, ref2, ref3, type;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      aggrStatuses: ["individual", "literal"]
    });
    if (!expr) {
      return null;
    }
    if (_.isEmpty(expr)) {
      return expr;
    }
    if (expr.type === "comparison") {
      return this.cleanComparisonExpr(expr, options);
    }
    if (expr.type === "logical") {
      return this.cleanLogicalExpr(expr, options);
    }
    if (expr.type === "count") {
      return this.cleanCountExpr(expr, options);
    }
    if (expr.type === "literal" && expr.valueType === "enum[]") {
      expr = {
        type: "literal",
        valueType: "enumset",
        value: expr.value
      };
    }
    if (options.table && expr.type !== "literal" && expr.table !== options.table) {
      return null;
    }
    if (!expr.table && expr.type !== "literal") {
      return null;
    }
    if (expr.table && !this.schema.getTable(expr.table)) {
      return null;
    }
    if (this.exprUtils.getExprAggrStatus(expr) === "individual" && indexOf.call(options.aggrStatuses, "individual") < 0 && indexOf.call(options.aggrStatuses, "aggregate") >= 0) {
      aggrOpItems = this.exprUtils.findMatchingOpItems({
        resultTypes: options.types,
        lhsExpr: expr,
        aggr: true,
        ordered: ((ref = this.schema.getTable(expr.table)) != null ? ref.ordering : void 0) != null
      });
      if (aggrOpItems.length > 0) {
        expr = {
          type: "op",
          op: aggrOpItems[0].op,
          table: expr.table,
          exprs: [expr]
        };
      }
    }
    if (this.exprUtils.getExprAggrStatus(expr) === "individual" && indexOf.call(options.aggrStatuses, "individual") < 0 && indexOf.call(options.aggrStatuses, "aggregate") >= 0) {
      if (!options.types || indexOf.call(options.types, "number") >= 0) {
        opItem = this.exprUtils.findMatchingOpItems({
          resultTypes: ["boolean"],
          lhsExpr: expr
        })[0];
        if (opItem) {
          expr = {
            type: "op",
            table: expr.table,
            op: opItem.op,
            exprs: [expr]
          };
          args = opItem.exprTypes.length - 1;
          for (i = k = 1, ref1 = args; 1 <= ref1 ? k <= ref1 : k >= ref1; i = 1 <= ref1 ? ++k : --k) {
            expr.exprs.push(null);
          }
          expr = {
            type: "op",
            op: "percent where",
            table: expr.table,
            exprs: [expr]
          };
        }
      }
    }
    if (this.exprUtils.getExprAggrStatus(expr) && (ref2 = this.exprUtils.getExprAggrStatus(expr), indexOf.call(options.aggrStatuses, ref2) < 0)) {
      return null;
    }
    type = this.exprUtils.getExprType(expr);
    booleanOnly = options.types && options.types.length === 1 && options.types[0] === "boolean";
    if (booleanOnly && type && type !== "boolean") {
      opItem = this.exprUtils.findMatchingOpItems({
        resultTypes: ["boolean"],
        lhsExpr: expr
      })[0];
      if (opItem) {
        expr = {
          type: "op",
          table: expr.table,
          op: opItem.op,
          exprs: [expr]
        };
        args = opItem.exprTypes.length - 1;
        for (i = l = 1, ref3 = args; 1 <= ref3 ? l <= ref3 : l >= ref3; i = 1 <= ref3 ? ++l : --l) {
          expr.exprs.push(null);
        }
      }
    }
    type = this.exprUtils.getExprType(expr);
    if (type && options.types && indexOf.call(options.types, type) < 0) {
      if (expr.type !== "case") {
        return null;
      }
    }
    switch (expr.type) {
      case "field":
        return this.cleanFieldExpr(expr, options);
      case "scalar":
        return this.cleanScalarExpr(expr, options);
      case "op":
        return this.cleanOpExpr(expr, options);
      case "literal":
        return this.cleanLiteralExpr(expr, options);
      case "case":
        return this.cleanCaseExpr(expr, options);
      case "id":
        return this.cleanIdExpr(expr, options);
      case "score":
        return this.cleanScoreExpr(expr, options);
      case "build enumset":
        return this.cleanBuildEnumsetExpr(expr, options);
      default:
        throw new Error("Unknown expression type " + expr.type);
    }
  };

  ExprCleaner.prototype.cleanFieldExpr = function(expr, options) {
    var column;
    if (!expr.column || !expr.table) {
      return null;
    }
    if (!this.schema.getTable(expr.table)) {
      return null;
    }
    column = this.schema.getColumn(expr.table, expr.column);
    if (!column) {
      return null;
    }
    if (options.enumValueIds && column.type === "enum") {
      if (_.difference(_.pluck(column.enumValues, "id"), options.enumValueIds).length > 0) {
        return null;
      }
    }
    if (options.enumValueIds && column.type === "expr") {
      if (this.exprUtils.getExprType(column.expr) === "enum") {
        if (_.difference(_.pluck(this.exprUtils.getExprEnumValues(column.expr), "id"), options.enumValueIds).length > 0) {
          return null;
        }
      }
    }
    return expr;
  };

  ExprCleaner.prototype.cleanOpExpr = function(expr, options) {
    var aggr, enumValueIds, enumValues, exprs, innerAggrStatuses, lhsExpr, lhsTypes, opIsAggr, opItem, opItems, ref;
    switch (expr.op) {
      case "and":
      case "or":
        expr = _.extend({}, expr, {
          exprs: _.map(expr.exprs, (function(_this) {
            return function(e) {
              return _this.cleanExpr(e, {
                types: ["boolean"],
                table: expr.table
              });
            };
          })(this))
        });
        if (expr.exprs.length === 1) {
          return expr.exprs[0];
        }
        if (expr.exprs.length === 0) {
          return null;
        }
        return expr;
      case "+":
      case "*":
        expr = _.extend({}, expr, {
          exprs: _.map(expr.exprs, (function(_this) {
            return function(e) {
              return _this.cleanExpr(e, {
                types: ["number"],
                table: expr.table,
                aggrStatuses: options.aggrStatuses
              });
            };
          })(this))
        });
        if (expr.exprs.length === 1) {
          return expr.exprs[0];
        }
        if (expr.exprs.length === 0) {
          return null;
        }
        return expr;
      default:
        if (expr.op === "count" && (!options.types || indexOf.call(options.types, "number") >= 0) && indexOf.call(options.aggrStatuses, "aggregate") >= 0) {
          return {
            type: "op",
            op: "count",
            table: expr.table,
            exprs: []
          };
        }
        opIsAggr = ExprUtils.isOpAggr(expr.op);
        if (opIsAggr && indexOf.call(options.aggrStatuses, "aggregate") < 0) {
          return null;
        }
        aggr = null;
        if (indexOf.call(options.aggrStatuses, "aggregate") < 0 && indexOf.call(options.aggrStatuses, "individual") >= 0) {
          aggr = false;
        }
        if (opIsAggr) {
          innerAggrStatuses = ["literal", "individual"];
        } else {
          innerAggrStatuses = options.aggrStatuses;
        }
        lhsExpr = this.cleanExpr(expr.exprs[0], {
          table: expr.table,
          aggrStatuses: innerAggrStatuses
        });
        if (lhsExpr) {
          lhsTypes = _.uniq(_.compact(_.map(this.exprUtils.findMatchingOpItems({
            op: expr.op
          }), function(opItem) {
            return opItem.exprTypes[0];
          })));
          lhsExpr = this.cleanExpr(expr.exprs[0], {
            table: expr.table,
            aggrStatuses: innerAggrStatuses,
            types: lhsTypes
          });
          if (lhsExpr == null) {
            lhsExpr = this.cleanExpr(expr.exprs[0], {
              table: expr.table,
              aggrStatuses: innerAggrStatuses
            });
          }
        }
        if (!lhsExpr && !ExprUtils.isOpPrefix(expr.op)) {
          return null;
        }
        opItems = this.exprUtils.findMatchingOpItems({
          op: expr.op,
          lhsExpr: lhsExpr,
          resultTypes: options.types,
          aggr: aggr,
          ordered: ((ref = this.schema.getTable(expr.table)) != null ? ref.ordering : void 0) != null
        });
        if (opItems.length > 1) {
          return _.extend({}, expr, {
            exprs: _.map(expr.exprs, (function(_this) {
              return function(e, i) {
                return _this.cleanExpr(e, {
                  table: expr.table,
                  aggrStatuses: innerAggrStatuses
                });
              };
            })(this))
          });
        }
        if (!opItems[0]) {
          opItem = this.exprUtils.findMatchingOpItems({
            lhsExpr: lhsExpr,
            resultTypes: options.types,
            aggr: aggr
          })[0];
          if (!opItem) {
            return null;
          }
          expr = {
            type: "op",
            table: expr.table,
            op: opItem.op,
            exprs: [lhsExpr || null]
          };
        } else {
          opItem = opItems[0];
        }
        while (expr.exprs.length < opItem.exprTypes.length) {
          exprs = expr.exprs.slice();
          exprs.push(null);
          expr = _.extend({}, expr, {
            exprs: exprs
          });
        }
        if (expr.exprs.length > opItem.exprTypes.length) {
          expr = _.extend({}, expr, {
            exprs: _.take(expr.exprs, opItem.exprTypes.length)
          });
        }
        if (lhsExpr) {
          enumValues = this.exprUtils.getExprEnumValues(lhsExpr);
          if (enumValues) {
            enumValueIds = _.pluck(enumValues, "id");
          }
        }
        expr = _.extend({}, expr, {
          exprs: _.map(expr.exprs, (function(_this) {
            return function(e, i) {
              return _this.cleanExpr(e, {
                table: expr.table,
                types: (opItem.exprTypes[i] ? [opItem.exprTypes[i]] : void 0),
                enumValueIds: enumValueIds,
                idTable: _this.exprUtils.getExprIdTable(expr.exprs[0]),
                aggrStatuses: innerAggrStatuses
              });
            };
          })(this))
        });
        return expr;
    }
  };

  ExprCleaner.prototype.areJoinsValid = function(table, joins) {
    var j, joinCol, k, len, t;
    t = table;
    for (k = 0, len = joins.length; k < len; k++) {
      j = joins[k];
      joinCol = this.schema.getColumn(t, j);
      if (!joinCol) {
        return false;
      }
      t = joinCol.join.toTable;
    }
    return true;
  };

  ExprCleaner.prototype.cleanScalarExpr = function(expr, options) {
    var aggrStatuses, innerTable, isMultiple, joins, ref;
    if (expr.joins.length === 0) {
      return this.cleanExpr(expr.expr, options);
    }
    joins = _.map(expr.joins, (function(_this) {
      return function(j) {
        if (j.match(/^entities\.[a-z_0-9]+\./)) {
          return j.split(".")[2];
        }
        return j;
      };
    })(this));
    expr = _.extend({}, expr, {
      joins: joins
    });
    if (!this.exprUtils.areJoinsValid(expr.table, expr.joins)) {
      return null;
    }
    innerTable = this.exprUtils.followJoins(expr.table, expr.joins);
    if (expr.aggr) {
      expr = _.extend({}, _.omit(expr, "aggr"), {
        expr: {
          type: "op",
          table: innerTable,
          op: expr.aggr,
          exprs: [expr.expr]
        }
      });
    }
    if (expr.where) {
      expr.where = this.cleanExpr(expr.where, {
        table: innerTable
      });
    }
    if (!expr.where && expr.joins.length === 1 && ((ref = expr.expr) != null ? ref.type : void 0) === "id") {
      return {
        type: "field",
        table: expr.table,
        column: expr.joins[0]
      };
    }
    if (expr.expr) {
      isMultiple = this.exprUtils.isMultipleJoins(expr.table, expr.joins);
      aggrStatuses = isMultiple ? ["literal", "aggregate"] : ["literal", "individual"];
      expr = _.extend({}, expr, {
        expr: this.cleanExpr(expr.expr, _.extend({}, options, {
          table: innerTable,
          aggrStatuses: aggrStatuses
        }))
      });
    }
    return expr;
  };

  ExprCleaner.prototype.cleanLiteralExpr = function(expr, options) {
    var ref, ref1;
    if ((ref = expr.valueType) === 'decimal' || ref === 'integer') {
      expr = _.extend({}, expr, {
        valueType: "number"
      });
    }
    if (expr.valueType === "enum" && options.enumValueIds && expr.value && (ref1 = expr.value, indexOf.call(options.enumValueIds, ref1) < 0)) {
      return null;
    }
    if (expr.valueType === "enumset" && options.enumValueIds && expr.value) {
      expr = _.extend({}, expr, {
        value: _.intersection(options.enumValueIds, expr.value)
      });
    }
    if (expr.valueType === "id" && options.idTable && expr.idTable !== options.idTable) {
      return null;
    }
    return expr;
  };

  ExprCleaner.prototype.cleanCaseExpr = function(expr, options) {
    if (expr.cases.length === 0) {
      return expr["else"] || null;
    }
    expr = _.extend({}, expr, {
      cases: _.map(expr.cases, (function(_this) {
        return function(c) {
          return _.extend({}, c, {
            when: _this.cleanExpr(c.when, {
              types: ["boolean"],
              table: expr.table
            }),
            then: _this.cleanExpr(c.then, options)
          });
        };
      })(this)),
      "else": this.cleanExpr(expr["else"], options)
    });
    return expr;
  };

  ExprCleaner.prototype.cleanIdExpr = function(expr, options) {
    if (options.idTable && expr.table !== options.idTable) {
      return null;
    }
    return expr;
  };

  ExprCleaner.prototype.cleanScoreExpr = function(expr, options) {
    var enumValues;
    expr = _.extend({}, expr, {
      input: this.cleanExpr(expr.input, {
        types: ['enum', 'enumset']
      })
    });
    if (!expr.input) {
      expr = _.extend({}, expr, {
        scores: {}
      });
    }
    expr = _.extend({}, expr, {
      scores: _.mapValues(expr.scores, (function(_this) {
        return function(scoreExpr) {
          return _this.cleanExpr(scoreExpr, {
            table: expr.table,
            types: ['number']
          });
        };
      })(this))
    });
    if (expr.input) {
      enumValues = this.exprUtils.getExprEnumValues(expr.input);
      expr = _.extend({}, expr, {
        scores: _.pick(expr.scores, (function(_this) {
          return function(value, key) {
            return _.findWhere(enumValues, {
              id: key
            }) && (value != null);
          };
        })(this))
      });
    }
    return expr;
  };

  ExprCleaner.prototype.cleanBuildEnumsetExpr = function(expr, options) {
    expr = _.extend({}, expr, {
      values: _.mapValues(expr.values, (function(_this) {
        return function(valueExpr) {
          return _this.cleanExpr(valueExpr, {
            table: expr.table,
            types: ['boolean']
          });
        };
      })(this))
    });
    if (options.enumValueIds) {
      expr = _.extend({}, expr, {
        values: _.pick(expr.values, (function(_this) {
          return function(value, key) {
            return indexOf.call(options.enumValueIds, key) >= 0;
          };
        })(this))
      });
    }
    expr = _.extend({}, expr, {
      values: _.pick(expr.values, (function(_this) {
        return function(value, key) {
          return value != null;
        };
      })(this))
    });
    return expr;
  };

  ExprCleaner.prototype.cleanComparisonExpr = function(expr, options) {
    var newExpr;
    newExpr = {
      type: "op",
      table: expr.table,
      op: expr.op,
      exprs: [expr.lhs]
    };
    if (expr.rhs) {
      newExpr.exprs.push(expr.rhs);
    }
    newExpr.exprs = _.map(newExpr.exprs, (function(_this) {
      return function(e) {
        return _this.cleanExpr(e);
      };
    })(this));
    if (expr.op === "= true") {
      newExpr = expr.lhs;
    }
    if (expr.op === "= false") {
      newExpr = {
        type: "op",
        op: "not",
        table: expr.table,
        exprs: [expr.lhs]
      };
    }
    if (expr.op === "between" && expr.rhs && expr.rhs.type === "literal" && expr.rhs.valueType === "daterange") {
      newExpr.exprs = [
        expr.lhs, {
          type: "literal",
          valueType: "date",
          value: expr.rhs.value[0]
        }, {
          type: "literal",
          valueType: "date",
          value: expr.rhs.value[1]
        }
      ];
    }
    if (expr.op === "between" && expr.rhs && expr.rhs.type === "literal" && expr.rhs.valueType === "datetimerange") {
      if (this.exprUtils.getExprType(expr.lhs) === "date") {
        newExpr.exprs = [
          expr.lhs, {
            type: "literal",
            valueType: "date",
            value: expr.rhs.value[0].substr(0, 10)
          }, {
            type: "literal",
            valueType: "date",
            value: expr.rhs.value[1].substr(0, 10)
          }
        ];
      } else {
        newExpr.exprs = [
          expr.lhs, {
            type: "literal",
            valueType: "datetime",
            value: expr.rhs.value[0]
          }, {
            type: "literal",
            valueType: "datetime",
            value: expr.rhs.value[1]
          }
        ];
      }
    }
    return this.cleanExpr(newExpr, options);
  };

  ExprCleaner.prototype.cleanLogicalExpr = function(expr, options) {
    var newExpr;
    newExpr = {
      type: "op",
      op: expr.op,
      table: expr.table,
      exprs: expr.exprs
    };
    return this.cleanExpr(newExpr, options);
  };

  ExprCleaner.prototype.cleanCountExpr = function(expr, options) {
    var newExpr;
    newExpr = {
      type: "id",
      table: expr.table
    };
    return this.cleanExpr(newExpr, options);
  };

  return ExprCleaner;

})();

},{"./ExprUtils":6,"lodash":"lodash"}],4:[function(require,module,exports){
var ColumnNotFoundException, ExprCompiler, ExprUtils, _, injectTableAlias, injectTableAliases, moment,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

injectTableAlias = require('./injectTableAlias');

injectTableAliases = require('./injectTableAliases');

ExprUtils = require('./ExprUtils');

moment = require('moment');

ColumnNotFoundException = require('./ColumnNotFoundException');

module.exports = ExprCompiler = (function() {
  function ExprCompiler(schema) {
    this.compileExpr = bind(this.compileExpr, this);
    this.schema = schema;
  }

  ExprCompiler.prototype.compileExpr = function(options) {
    var compiledExpr, expr;
    expr = options.expr;
    if (!expr) {
      return null;
    }
    switch (expr.type) {
      case "id":
        compiledExpr = this.compileColumnRef(this.schema.getTable(expr.table).primaryKey, options.tableAlias);
        break;
      case "field":
        compiledExpr = this.compileFieldExpr(options);
        break;
      case "scalar":
        compiledExpr = this.compileScalarExpr(options);
        break;
      case "literal":
        if (expr.value != null) {
          compiledExpr = {
            type: "literal",
            value: expr.value
          };
        } else {
          compiledExpr = null;
        }
        break;
      case "op":
        compiledExpr = this.compileOpExpr(options);
        break;
      case "case":
        compiledExpr = this.compileCaseExpr(options);
        break;
      case "score":
        compiledExpr = this.compileScoreExpr(options);
        break;
      case "build enumset":
        compiledExpr = this.compileBuildEnumsetExpr(options);
        break;
      case "count":
        compiledExpr = null;
        break;
      case "comparison":
        compiledExpr = this.compileComparisonExpr(options);
        break;
      case "logical":
        compiledExpr = this.compileLogicalExpr(options);
        break;
      default:
        throw new Error("Expr type " + expr.type + " not supported");
    }
    return compiledExpr;
  };

  ExprCompiler.prototype.compileFieldExpr = function(options) {
    var column, expr, ref;
    expr = options.expr;
    column = this.schema.getColumn(expr.table, expr.column);
    if (!column) {
      throw new ColumnNotFoundException("Column " + expr.table + "." + expr.column + " not found");
    }
    if (column.type === "join") {
      if ((ref = column.join.type) === '1-1' || ref === 'n-1') {
        return this.compileScalarExpr({
          expr: {
            type: "scalar",
            table: expr.table,
            joins: [column.id],
            expr: {
              type: "id",
              table: column.join.toTable
            }
          },
          tableAlias: options.tableAlias
        });
      } else {
        return {
          type: "scalar",
          expr: {
            type: "op",
            op: "to_jsonb",
            exprs: [
              {
                type: "op",
                op: "array_agg",
                exprs: [this.compileColumnRef(this.schema.getTable(column.join.toTable).primaryKey, "inner")]
              }
            ]
          },
          from: this.compileTable(column.join.toTable, "inner"),
          where: this.compileJoin(column.join, options.tableAlias, "inner")
        };
      }
    }
    if (column.type === "expr") {
      return this.compileExpr({
        expr: column.expr,
        tableAlias: options.tableAlias
      });
    }
    return this.compileColumnRef(column.jsonql || column.id, options.tableAlias);
  };

  ExprCompiler.prototype.compileScalarExpr = function(options) {
    var alias, expr, extraWhere, from, generateAlias, i, j, join, joinColumn, limit, nextAlias, onClause, orderBy, ordering, ref, scalar, scalarExpr, table, tableAlias, where;
    expr = options.expr;
    where = null;
    from = null;
    orderBy = null;
    limit = null;
    if (!expr.expr) {
      return null;
    }
    if (!expr.aggr && !expr.where && expr.joins.length === 1 && expr.expr.type === "id" && this.schema.getColumn(expr.table, expr.joins[0]).join.toColumn === this.schema.getTable(expr.expr.table).primaryKey) {
      return this.compileColumnRef(this.schema.getColumn(expr.table, expr.joins[0]).join.fromColumn, options.tableAlias);
    }
    generateAlias = function(expr, joinIndex) {
      return expr.joins[joinIndex].replace(/[^a-zA-Z0-9]/g, "_").toLowerCase();
    };
    table = expr.table;
    tableAlias = options.tableAlias;
    if (expr.joins && expr.joins.length > 0) {
      joinColumn = this.schema.getColumn(expr.table, expr.joins[0]);
      if (!joinColumn) {
        throw new ColumnNotFoundException("Join column " + expr.table + ":" + expr.joins[0] + " not found");
      }
      join = joinColumn.join;
      alias = generateAlias(expr, 0);
      where = this.compileJoin(join, tableAlias, alias);
      from = this.compileTable(join.toTable, alias);
      table = join.toTable;
      tableAlias = alias;
    }
    if (expr.joins.length > 1) {
      for (i = j = 1, ref = expr.joins.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
        joinColumn = this.schema.getColumn(table, expr.joins[i]);
        if (!joinColumn) {
          throw new ColumnNotFoundException("Join column " + expr.table + ":" + expr.joins[0] + " not found");
        }
        join = joinColumn.join;
        nextAlias = generateAlias(expr, i);
        onClause = this.compileJoin(join, tableAlias, nextAlias);
        from = {
          type: "join",
          left: from,
          right: this.compileTable(join.toTable, nextAlias),
          kind: "inner",
          on: onClause
        };
        table = join.toTable;
        tableAlias = nextAlias;
      }
    }
    if (expr.where) {
      extraWhere = this.compileExpr({
        expr: expr.where,
        tableAlias: tableAlias
      });
      if (where) {
        where = {
          type: "op",
          op: "and",
          exprs: [where, extraWhere]
        };
      } else {
        where = extraWhere;
      }
    }
    scalarExpr = this.compileExpr({
      expr: expr.expr,
      tableAlias: tableAlias
    });
    if (expr.aggr) {
      switch (expr.aggr) {
        case "last":
          ordering = this.schema.getTable(table).ordering;
          if (!ordering) {
            throw new Error("No ordering defined");
          }
          limit = 1;
          orderBy = [
            {
              expr: this.compileColumnRef(ordering, tableAlias),
              direction: "desc"
            }
          ];
          break;
        case "sum":
        case "count":
        case "avg":
        case "max":
        case "min":
        case "stdev":
        case "stdevp":
          if (!scalarExpr) {
            scalarExpr = {
              type: "op",
              op: expr.aggr,
              exprs: []
            };
          } else {
            scalarExpr = {
              type: "op",
              op: expr.aggr,
              exprs: [scalarExpr]
            };
          }
          break;
        default:
          throw new Error("Unknown aggregation " + expr.aggr);
      }
    }
    if (!scalarExpr) {
      return null;
    }
    if (!from && !where && !orderBy && !limit) {
      return scalarExpr;
    }
    scalar = {
      type: "scalar",
      expr: scalarExpr
    };
    if (from) {
      scalar.from = from;
    }
    if (where) {
      scalar.where = where;
    }
    if (orderBy) {
      scalar.orderBy = orderBy;
    }
    if (limit) {
      scalar.limit = limit;
    }
    return scalar;
  };

  ExprCompiler.prototype.compileJoin = function(join, fromAlias, toAlias) {
    if (join.jsonql) {
      return injectTableAliases(join.jsonql, {
        "{from}": fromAlias,
        "{to}": toAlias
      });
    } else {
      return {
        type: "op",
        op: "=",
        exprs: [this.compileColumnRef(join.toColumn, toAlias), this.compileColumnRef(join.fromColumn, fromAlias)]
      };
    }
  };

  ExprCompiler.prototype.compileOpExpr = function(options) {
    var compiledExprs, enumValues, expr, expr0Type, exprUtils, idTable, ordering, ref, ref1, ref2;
    exprUtils = new ExprUtils(this.schema);
    expr = options.expr;
    compiledExprs = _.map(expr.exprs, (function(_this) {
      return function(e) {
        return _this.compileExpr({
          expr: e,
          tableAlias: options.tableAlias
        });
      };
    })(this));
    expr0Type = exprUtils.getExprType(expr.exprs[0]);
    switch (expr.op) {
      case "and":
      case "or":
      case "+":
      case "*":
        compiledExprs = _.compact(compiledExprs);
        if (compiledExprs.length === 0) {
          return null;
        }
        return {
          type: "op",
          op: expr.op,
          exprs: compiledExprs
        };
      case "-":
      case "/":
      case ">":
      case "<":
      case ">=":
      case "<=":
      case "<>":
      case "=":
      case "~*":
      case "round":
      case "floor":
      case "ceiling":
      case "sum":
      case "avg":
      case "min":
      case "max":
      case "count":
      case "stdev":
      case "stdevp":
      case "var":
      case "varp":
        if (_.any(compiledExprs, function(ce) {
          return ce == null;
        })) {
          return null;
        }
        return {
          type: "op",
          op: expr.op,
          exprs: compiledExprs
        };
      case "last":
        if (!compiledExprs[0]) {
          return null;
        }
        ordering = (ref = this.schema.getTable(expr.table)) != null ? ref.ordering : void 0;
        if (!ordering) {
          throw new Error("Table " + expr.table + " must be ordered to use last()");
        }
        return {
          type: "op",
          op: "[]",
          exprs: [
            {
              type: "op",
              op: "array_agg",
              exprs: [compiledExprs[0]],
              orderBy: [
                {
                  expr: this.compileColumnRef(ordering, options.tableAlias),
                  direction: "desc",
                  nulls: "last"
                }
              ]
            }, 1
          ]
        };
      case "last where":
        if (!compiledExprs[0]) {
          return null;
        }
        ordering = (ref1 = this.schema.getTable(expr.table)) != null ? ref1.ordering : void 0;
        if (!ordering) {
          throw new Error("Table " + expr.table + " must be ordered to use last()");
        }
        if (!compiledExprs[1]) {
          return {
            type: "op",
            op: "[]",
            exprs: [
              {
                type: "op",
                op: "array_agg",
                exprs: [compiledExprs[0]],
                orderBy: [
                  {
                    expr: this.compileColumnRef(ordering, options.tableAlias),
                    direction: "desc",
                    nulls: "last"
                  }
                ]
              }, 1
            ]
          };
        }
        return {
          type: "op",
          op: "[]",
          exprs: [
            {
              type: "op",
              op: "array_agg",
              exprs: [
                {
                  type: "case",
                  cases: [
                    {
                      when: compiledExprs[1],
                      then: compiledExprs[0]
                    }
                  ],
                  "else": null
                }
              ],
              orderBy: [
                {
                  expr: {
                    type: "case",
                    cases: [
                      {
                        when: compiledExprs[1],
                        then: 0
                      }
                    ],
                    "else": 1
                  }
                }, {
                  expr: this.compileColumnRef(ordering, options.tableAlias),
                  direction: "desc",
                  nulls: "last"
                }
              ]
            }, 1
          ]
        };
      case "previous":
        if (!compiledExprs[0]) {
          return null;
        }
        ordering = (ref2 = this.schema.getTable(expr.table)) != null ? ref2.ordering : void 0;
        if (!ordering) {
          throw new Error("Table " + expr.table + " must be ordered to use previous()");
        }
        return {
          type: "op",
          op: "[]",
          exprs: [
            {
              type: "op",
              op: "array_agg",
              exprs: [compiledExprs[0]],
              orderBy: [
                {
                  expr: this.compileColumnRef(ordering, options.tableAlias),
                  direction: "desc",
                  nulls: "last"
                }
              ]
            }, 2
          ]
        };
      case '= any':
        if (_.any(compiledExprs, function(ce) {
          return ce == null;
        })) {
          return null;
        }
        if (expr.exprs[1].type === "literal") {
          if (!expr.exprs[1].value || (_.isArray(expr.exprs[1].value) && expr.exprs[1].value.length === 0)) {
            return null;
          }
        }
        return {
          type: "op",
          op: "=",
          modifier: "any",
          exprs: compiledExprs
        };
      case "between":
        if (!compiledExprs[0]) {
          return null;
        }
        if (!compiledExprs[1] && !compiledExprs[2]) {
          return null;
        }
        if (!compiledExprs[2]) {
          return {
            type: "op",
            op: ">=",
            exprs: [compiledExprs[0], compiledExprs[1]]
          };
        }
        if (!compiledExprs[1]) {
          return {
            type: "op",
            op: "<=",
            exprs: [compiledExprs[0], compiledExprs[2]]
          };
        }
        return {
          type: "op",
          op: "between",
          exprs: compiledExprs
        };
      case "not":
      case "is null":
      case "is not null":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: expr.op,
          exprs: compiledExprs
        };
      case "contains":
        if (!compiledExprs[0] || !compiledExprs[1]) {
          return null;
        }
        if (compiledExprs[1].type === "literal" && compiledExprs[1].value.length === 0) {
          return null;
        }
        return {
          type: "op",
          op: "@>",
          exprs: [
            {
              type: "op",
              op: "::jsonb",
              exprs: [
                {
                  type: "op",
                  op: "to_json",
                  exprs: [compiledExprs[0]]
                }
              ]
            }, {
              type: "op",
              op: "::jsonb",
              exprs: [
                {
                  type: "op",
                  op: "to_json",
                  exprs: [compiledExprs[1]]
                }
              ]
            }
          ]
        };
      case "length":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "jsonb_array_length",
          exprs: [
            {
              type: "op",
              op: "::jsonb",
              exprs: [
                {
                  type: "op",
                  op: "to_json",
                  exprs: [compiledExprs[0]]
                }
              ]
            }
          ]
        };
      case "to text":
        if (!compiledExprs[0]) {
          return null;
        }
        if (exprUtils.getExprType(expr.exprs[0]) === "enum") {
          enumValues = exprUtils.getExprEnumValues(expr.exprs[0]);
          if (!enumValues) {
            return null;
          }
          return {
            type: "case",
            input: compiledExprs[0],
            cases: _.map(enumValues, (function(_this) {
              return function(ev) {
                return {
                  when: {
                    type: "literal",
                    value: ev.id
                  },
                  then: {
                    type: "literal",
                    value: exprUtils.localizeString(ev.name, expr.locale)
                  }
                };
              };
            })(this))
          };
        }
        if (exprUtils.getExprType(expr.exprs[0]) === "number") {
          return {
            type: "op",
            op: "::text",
            exprs: [compiledExprs[0]]
          };
        }
        return null;
      case "count where":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "sum",
          exprs: [
            {
              type: "case",
              cases: [
                {
                  when: compiledExprs[0],
                  then: 1
                }
              ],
              "else": 0
            }
          ]
        };
      case "percent where":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "/",
          exprs: [
            {
              type: "op",
              op: "sum",
              exprs: [
                {
                  type: "case",
                  cases: [
                    {
                      when: compiledExprs[1] ? {
                        type: "op",
                        op: "and",
                        exprs: [compiledExprs[0], compiledExprs[1]]
                      } : compiledExprs[0],
                      then: 100
                    }
                  ],
                  "else": 0
                }
              ]
            }, compiledExprs[1] ? {
              type: "op",
              op: "nullif",
              exprs: [
                {
                  type: "op",
                  op: "sum",
                  exprs: [
                    {
                      type: "case",
                      cases: [
                        {
                          when: compiledExprs[1],
                          then: 1
                        }
                      ],
                      "else": 0
                    }
                  ]
                }, 0
              ]
            } : {
              type: "op",
              op: "sum",
              exprs: [1]
            }
          ]
        };
      case "sum where":
        if (!compiledExprs[0]) {
          return null;
        }
        if (!compiledExprs[1]) {
          return {
            type: "op",
            op: "sum",
            exprs: [compiledExprs[0]]
          };
        }
        return {
          type: "op",
          op: "sum",
          exprs: [
            {
              type: "case",
              cases: [
                {
                  when: compiledExprs[1],
                  then: compiledExprs[0]
                }
              ],
              "else": 0
            }
          ]
        };
      case "count distinct":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "count",
          exprs: [compiledExprs[0]],
          modifier: "distinct"
        };
      case "within":
        if (!compiledExprs[0] || !compiledExprs[1]) {
          return null;
        }
        idTable = exprUtils.getExprIdTable(expr.exprs[0]);
        return {
          type: "op",
          op: "in",
          exprs: [
            compiledExprs[0], {
              type: "scalar",
              expr: this.compileColumnRef(this.schema.getTable(idTable).primaryKey, "subwithin"),
              from: {
                type: "table",
                table: idTable,
                alias: "subwithin"
              },
              where: {
                type: "op",
                op: "@>",
                exprs: [
                  {
                    type: "field",
                    tableAlias: "subwithin",
                    column: this.schema.getTable(idTable).ancestry
                  }, {
                    type: "op",
                    op: "::jsonb",
                    exprs: [
                      {
                        type: "op",
                        op: "json_build_array",
                        exprs: [compiledExprs[1]]
                      }
                    ]
                  }
                ]
              }
            }
          ]
        };
      case "within any":
        if (!compiledExprs[0] || !compiledExprs[1]) {
          return null;
        }
        idTable = exprUtils.getExprIdTable(expr.exprs[0]);
        return {
          type: "op",
          op: "in",
          exprs: [
            compiledExprs[0], {
              type: "scalar",
              expr: this.compileColumnRef(this.schema.getTable(idTable).primaryKey, "subwithin"),
              from: {
                type: "table",
                table: idTable,
                alias: "subwithin"
              },
              where: {
                type: "op",
                op: "?|",
                exprs: [
                  {
                    type: "field",
                    tableAlias: "subwithin",
                    column: this.schema.getTable(idTable).ancestry
                  }, compiledExprs[1]
                ]
              }
            }
          ]
        };
      case "latitude":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "ST_Y",
          exprs: [
            {
              type: "op",
              op: "ST_Transform",
              exprs: [compiledExprs[0], 4326]
            }
          ]
        };
      case "longitude":
        if (!compiledExprs[0]) {
          return null;
        }
        return {
          type: "op",
          op: "ST_X",
          exprs: [
            {
              type: "op",
              op: "ST_Transform",
              exprs: [compiledExprs[0], 4326]
            }
          ]
        };
      case 'days difference':
        if (!compiledExprs[0] || !compiledExprs[1]) {
          return null;
        }
        if (exprUtils.getExprType(expr.exprs[0]) === "date") {
          return {
            type: "op",
            op: "-",
            exprs: [
              {
                type: "op",
                op: "::date",
                exprs: [compiledExprs[0]]
              }, {
                type: "op",
                op: "::date",
                exprs: [compiledExprs[1]]
              }
            ]
          };
        }
        if (exprUtils.getExprType(expr.exprs[0]) === "datetime") {
          return {
            type: "op",
            op: "/",
            exprs: [
              {
                type: "op",
                op: "-",
                exprs: [
                  {
                    type: "op",
                    op: "date_part",
                    exprs: [
                      'epoch', {
                        type: "op",
                        op: "::timestamp",
                        exprs: [compiledExprs[0]]
                      }
                    ]
                  }, {
                    type: "op",
                    op: "date_part",
                    exprs: [
                      'epoch', {
                        type: "op",
                        op: "::timestamp",
                        exprs: [compiledExprs[1]]
                      }
                    ]
                  }
                ]
              }, 86400
            ]
          };
        }
        return null;
      case 'days since':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "-",
              exprs: [
                {
                  type: "op",
                  op: "::date",
                  exprs: [moment().format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "::date",
                  exprs: [compiledExprs[0]]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "/",
              exprs: [
                {
                  type: "op",
                  op: "-",
                  exprs: [
                    {
                      type: "op",
                      op: "date_part",
                      exprs: [
                        'epoch', {
                          type: "op",
                          op: "::timestamp",
                          exprs: [moment().toISOString()]
                        }
                      ]
                    }, {
                      type: "op",
                      op: "date_part",
                      exprs: [
                        'epoch', {
                          type: "op",
                          op: "::timestamp",
                          exprs: [compiledExprs[0]]
                        }
                      ]
                    }
                  ]
                }, 86400
              ]
            };
          default:
            return null;
        }
        break;
      case 'thisyear':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("year").format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("year").add(1, 'years').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("year").toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("year").add(1, 'years').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'lastyear':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("year").subtract(1, 'years').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("year").format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("year").subtract(1, 'years').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("year").toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'thismonth':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("month").format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("month").add(1, 'months').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("month").toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("month").add(1, 'months').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'lastmonth':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("month").subtract(1, 'months').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("month").format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("month").subtract(1, 'months').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("month").toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'today':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().add(1, 'days').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("day").toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("day").add(1, 'days').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'yesterday':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(1, 'days').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("day").subtract(1, 'days').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("day").toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'last24hours':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(1, 'days').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<=",
                  exprs: [compiledExprs[0], moment().format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(24, 'hours').toISOString()]
                }, {
                  type: "op",
                  op: "<=",
                  exprs: [compiledExprs[0], moment().toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'last7days':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(7, 'days').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().add(1, 'days').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("day").subtract(7, 'days').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("day").add(1, 'days').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'last30days':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(30, 'days').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().add(1, 'days').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("day").subtract(30, 'days').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("day").add(1, 'days').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'last365days':
        if (!compiledExprs[0]) {
          return null;
        }
        switch (expr0Type) {
          case "date":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().subtract(365, 'days').format("YYYY-MM-DD")]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().add(1, 'days').format("YYYY-MM-DD")]
                }
              ]
            };
          case "datetime":
            return {
              type: "op",
              op: "and",
              exprs: [
                {
                  type: "op",
                  op: ">=",
                  exprs: [compiledExprs[0], moment().startOf("day").subtract(365, 'days').toISOString()]
                }, {
                  type: "op",
                  op: "<",
                  exprs: [compiledExprs[0], moment().startOf("day").add(1, 'days').toISOString()]
                }
              ]
            };
          default:
            return null;
        }
        break;
      case 'distance':
        if (!compiledExprs[0] || !compiledExprs[1]) {
          return null;
        }
        return {
          type: "op",
          op: "ST_Distance_Sphere",
          exprs: [
            {
              type: "op",
              op: "ST_Transform",
              exprs: [compiledExprs[0], 4326]
            }, {
              type: "op",
              op: "ST_Transform",
              exprs: [compiledExprs[1], 4326]
            }
          ]
        };
      default:
        throw new Error("Unknown op " + expr.op);
    }
  };

  ExprCompiler.prototype.compileCaseExpr = function(options) {
    var compiled, expr;
    expr = options.expr;
    compiled = {
      type: "case",
      cases: _.map(expr.cases, (function(_this) {
        return function(c) {
          return {
            when: _this.compileExpr({
              expr: c.when,
              tableAlias: options.tableAlias
            }),
            then: _this.compileExpr({
              expr: c.then,
              tableAlias: options.tableAlias
            })
          };
        };
      })(this)),
      "else": this.compileExpr({
        expr: expr["else"],
        tableAlias: options.tableAlias
      })
    };
    compiled.cases = _.filter(compiled.cases, function(c) {
      return c.when != null;
    });
    if (compiled.cases.length === 0) {
      return null;
    }
    return compiled;
  };

  ExprCompiler.prototype.compileScoreExpr = function(options) {
    var expr, exprUtils, inputType;
    expr = options.expr;
    exprUtils = new ExprUtils(this.schema);
    if (_.isEmpty(expr.scores)) {
      return {
        type: "literal",
        value: 0
      };
    }
    inputType = exprUtils.getExprType(expr.input);
    switch (inputType) {
      case "enum":
        return {
          type: "case",
          input: this.compileExpr({
            expr: expr.input,
            tableAlias: options.tableAlias
          }),
          cases: _.map(_.pairs(expr.scores), (function(_this) {
            return function(pair) {
              return {
                when: {
                  type: "literal",
                  value: pair[0]
                },
                then: _this.compileExpr({
                  expr: pair[1],
                  tableAlias: options.tableAlias
                })
              };
            };
          })(this)),
          "else": {
            type: "literal",
            value: 0
          }
        };
      case "enumset":
        return {
          type: "op",
          op: "+",
          exprs: _.map(_.pairs(expr.scores), (function(_this) {
            return function(pair) {
              return {
                type: "case",
                cases: [
                  {
                    when: {
                      type: "op",
                      op: "@>",
                      exprs: [
                        {
                          type: "op",
                          op: "::jsonb",
                          exprs: [
                            {
                              type: "op",
                              op: "to_json",
                              exprs: [
                                _this.compileExpr({
                                  expr: expr.input,
                                  tableAlias: options.tableAlias
                                })
                              ]
                            }
                          ]
                        }, {
                          type: "op",
                          op: "::jsonb",
                          exprs: [
                            {
                              type: "op",
                              op: "to_json",
                              exprs: [
                                {
                                  type: "literal",
                                  value: [pair[0]]
                                }
                              ]
                            }
                          ]
                        }
                      ]
                    },
                    then: _this.compileExpr({
                      expr: pair[1],
                      tableAlias: options.tableAlias
                    })
                  }
                ],
                "else": {
                  type: "literal",
                  value: 0
                }
              };
            };
          })(this))
        };
      default:
        return null;
    }
  };

  ExprCompiler.prototype.compileBuildEnumsetExpr = function(options) {
    var expr;
    expr = options.expr;
    return {
      type: "scalar",
      expr: {
        type: "op",
        op: "to_jsonb",
        exprs: [
          {
            type: "op",
            op: "array_agg",
            exprs: [
              {
                type: "field",
                tableAlias: "bes",
                column: "v"
              }
            ]
          }
        ]
      },
      from: {
        type: "subquery",
        alias: "bes",
        query: {
          type: "union all",
          queries: _.map(_.pairs(expr.values), (function(_this) {
            return function(pair) {
              return {
                type: "query",
                selects: [
                  {
                    type: "select",
                    expr: {
                      type: "case",
                      cases: [
                        {
                          when: _this.compileExpr({
                            expr: pair[1],
                            tableAlias: options.tableAlias
                          }),
                          then: pair[0]
                        }
                      ]
                    },
                    alias: "v"
                  }
                ]
              };
            };
          })(this))
        }
      },
      where: {
        type: "op",
        op: "is not null",
        exprs: [
          {
            type: "field",
            tableAlias: "bes",
            column: "v"
          }
        ]
      }
    };
  };

  ExprCompiler.prototype.compileComparisonExpr = function(options) {
    var expr, exprLhsType, exprUtils, exprs, lhsExpr, rhsExpr;
    expr = options.expr;
    exprUtils = new ExprUtils(this.schema);
    exprLhsType = exprUtils.getExprType(expr.lhs);
    if (!exprLhsType) {
      return null;
    }
    if (exprUtils.getComparisonRhsType(exprLhsType, expr.op) && (expr.rhs == null)) {
      return null;
    }
    lhsExpr = this.compileExpr({
      expr: expr.lhs,
      tableAlias: options.tableAlias
    });
    if (expr.rhs) {
      rhsExpr = this.compileExpr({
        expr: expr.rhs,
        tableAlias: options.tableAlias
      });
      exprs = [lhsExpr, rhsExpr];
    } else {
      exprs = [lhsExpr];
    }
    switch (expr.op) {
      case '= true':
        return {
          type: "op",
          op: "=",
          exprs: [
            lhsExpr, {
              type: "literal",
              value: true
            }
          ]
        };
      case '= false':
        return {
          type: "op",
          op: "=",
          exprs: [
            lhsExpr, {
              type: "literal",
              value: false
            }
          ]
        };
      case '= any':
        return {
          type: "op",
          op: "=",
          modifier: "any",
          exprs: exprs
        };
      case 'between':
        return {
          type: "op",
          op: "between",
          exprs: [
            lhsExpr, {
              type: "literal",
              value: expr.rhs.value[0]
            }, {
              type: "literal",
              value: expr.rhs.value[1]
            }
          ]
        };
      default:
        return {
          type: "op",
          op: expr.op,
          exprs: exprs
        };
    }
  };

  ExprCompiler.prototype.compileLogicalExpr = function(options) {
    var compiledExprs, expr;
    expr = options.expr;
    compiledExprs = _.map(expr.exprs, (function(_this) {
      return function(e) {
        return _this.compileExpr({
          expr: e,
          tableAlias: options.tableAlias
        });
      };
    })(this));
    compiledExprs = _.compact(compiledExprs);
    if (compiledExprs.length === 1) {
      return compiledExprs[0];
    }
    if (compiledExprs.length === 0) {
      return null;
    }
    return {
      type: "op",
      op: expr.op,
      exprs: compiledExprs
    };
  };

  ExprCompiler.prototype.compileColumnRef = function(column, tableAlias) {
    if (_.isString(column)) {
      return {
        type: "field",
        tableAlias: tableAlias,
        column: column
      };
    }
    return injectTableAlias(column, tableAlias);
  };

  ExprCompiler.prototype.compileTable = function(tableId, alias) {
    var table;
    table = this.schema.getTable(tableId);
    if (!table.jsonql) {
      return {
        type: "table",
        table: tableId,
        alias: alias
      };
    } else {
      return {
        type: "subquery",
        query: table.jsonql,
        alias: alias
      };
    }
  };

  return ExprCompiler;

})();

},{"./ColumnNotFoundException":1,"./ExprUtils":6,"./injectTableAlias":15,"./injectTableAliases":16,"lodash":"lodash","moment":19}],5:[function(require,module,exports){
var ExprEvaluator, ExprUtils, _, async, deg2rad, getDistanceFromLatLngInM, moment;

_ = require('lodash');

moment = require('moment');

async = require('async');

ExprUtils = require('./ExprUtils');

module.exports = ExprEvaluator = (function() {
  function ExprEvaluator() {}

  ExprEvaluator.prototype.evaluate = function(expr, context, callback) {
    if (expr == null) {
      return callback(null, null);
    }
    switch (expr.type) {
      case "field":
        return context.row.getField(expr.column, (function(_this) {
          return function(error, value) {
            if (error) {
              return callback(error);
            }
            if (value && value.getPrimaryKey) {
              return value.getPrimaryKey(callback);
            }
            if (value && _.isArray(value) && value.length > 0 && value[0].getPrimaryKey) {
              async.map(value, (function(item, cb) {
                return item.getPrimaryKey(cb);
              }), function(error, ids) {
                return callback(error, ids);
              });
              return;
            }
            return callback(null, value);
          };
        })(this));
      case "literal":
        return callback(null, expr.value);
      case "op":
        return this.evaluateOp(expr.op, expr.exprs, context, callback);
      case "id":
        return context.row.getPrimaryKey(callback);
      case "case":
        return this.evaluateCase(expr, context, callback);
      case "scalar":
        return this.evaluateScalar(expr, context, callback);
      case "score":
        return this.evaluateScore(expr, context, callback);
      case "build enumset":
        return this.evaluateBuildEnumset(expr, context, callback);
      default:
        throw new Error("Unsupported expression type " + expr.type);
    }
  };

  ExprEvaluator.prototype.evaluateOp = function(op, exprs, context, callback) {
    if (ExprUtils.isOpAggr(op)) {
      return this.evaluteAggrOp(op, exprs, context, callback);
    }
    return async.map(exprs, ((function(_this) {
      return function(expr, cb) {
        return _this.evaluate(expr, context, cb);
      };
    })(this)), (function(_this) {
      return function(error, values) {
        var result;
        if (error) {
          return callback(error);
        }
        try {
          result = _this.evaluateOpValues(op, values);
          return callback(null, result);
        } catch (error1) {
          error = error1;
          return callback(error);
        }
      };
    })(this));
  };

  ExprEvaluator.prototype.evaluateOpValues = function(op, values) {
    var date, hasNull, point, point1, point2;
    hasNull = _.any(values, function(v) {
      return v == null;
    });
    switch (op) {
      case "+":
        if (hasNull) {
          return null;
        }
        return _.reduce(values, function(acc, value) {
          return acc + value;
        });
      case "*":
        if (hasNull) {
          return null;
        }
        return _.reduce(values, function(acc, value) {
          return acc * value;
        });
      case "-":
        if (hasNull) {
          return null;
        }
        return values[0] - values[1];
      case "/":
        if (hasNull) {
          return null;
        }
        return values[0] / values[1];
      case "and":
        return _.reduce(values, function(acc, value) {
          return acc && value;
        });
      case "or":
        return _.reduce(values, function(acc, value) {
          return acc || value;
        });
      case "not":
        if (hasNull) {
          return null;
        }
        return !values[0];
      case "=":
        if (hasNull) {
          return null;
        }
        return values[0] === values[1];
      case "<>":
        if (hasNull) {
          return null;
        }
        return values[0] !== values[1];
      case ">":
        if (hasNull) {
          return null;
        }
        return values[0] > values[1];
      case ">=":
        if (hasNull) {
          return null;
        }
        return values[0] >= values[1];
      case "<":
        if (hasNull) {
          return null;
        }
        return values[0] < values[1];
      case "<=":
        if (hasNull) {
          return null;
        }
        return values[0] <= values[1];
      case "= false":
        if (hasNull) {
          return null;
        }
        return values[0] === false;
      case "is null":
        return values[0] == null;
      case "is not null":
        return values[0] != null;
      case "~*":
        if (hasNull) {
          return null;
        }
        return values[0].match(new RegExp(values[1], "i")) != null;
      case "= any":
        if (hasNull) {
          return null;
        }
        return _.contains(values[1], values[0]);
      case "contains":
        if (hasNull) {
          return null;
        }
        return _.difference(values[1], values[0]).length === 0;
      case "length":
        if (hasNull) {
          return null;
        }
        return values[0].length;
      case "between":
        if (hasNull) {
          return null;
        }
        return values[0] >= values[1] && values[0] <= values[2];
      case "round":
        if (hasNull) {
          return null;
        }
        return Math.round(values[0]);
      case "floor":
        if (hasNull) {
          return null;
        }
        return Math.floor(values[0]);
      case "ceiling":
        if (hasNull) {
          return null;
        }
        return Math.ceil(values[0]);
      case "days difference":
        if (hasNull) {
          return null;
        }
        return moment(values[0], moment.ISO_8601).diff(moment(values[1], moment.ISO_8601)) / 24 / 3600 / 1000;
      case "days since":
        if (hasNull) {
          return null;
        }
        return moment().diff(moment(values[0], moment.ISO_8601)) / 24 / 3600 / 1000;
      case "today":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).format("YYYY-MM-DD") === moment().format("YYYY-MM-DD");
      case "yesterday":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).add(1, "days").format("YYYY-MM-DD") === moment().format("YYYY-MM-DD");
      case "thismonth":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).format("YYYY-MM") === moment().format("YYYY-MM");
      case "lastmonth":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).add(1, "months").format("YYYY-MM") === moment().format("YYYY-MM");
      case "thisyear":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).format("YYYY") === moment().format("YYYY");
      case "lastyear":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).add(1, "years").format("YYYY") === moment().format("YYYY");
      case "last24hours":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).isSameOrBefore(moment()) && moment(date, moment.ISO_8601).isAfter(moment().subtract(24, "hours"));
      case "last7days":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(7, "days"));
      case "last30days":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(30, "days"));
      case "last365days":
        if (hasNull) {
          return null;
        }
        date = values[0];
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(365, "days"));
      case "latitude":
        if (hasNull) {
          return null;
        }
        point = values[0];
        if ((point != null ? point.type : void 0) === "Point") {
          return point.coordinates[1];
        }
        break;
      case "longitude":
        if (hasNull) {
          return null;
        }
        point = values[0];
        if ((point != null ? point.type : void 0) === "Point") {
          return point.coordinates[0];
        }
        break;
      case "distance":
        if (hasNull) {
          return null;
        }
        point1 = values[0];
        point2 = values[1];
        if ((point1 != null ? point1.type : void 0) === "Point" && (point2 != null ? point2.type : void 0) === "Point") {
          return getDistanceFromLatLngInM(point1.coordinates[1], point1.coordinates[0], point2.coordinates[1], point2.coordinates[0]);
        }
        break;
      case "to text":
        if (hasNull) {
          return null;
        }
        return values[0] + "";
      default:
        throw new Error("Unknown op " + op);
    }
  };

  ExprEvaluator.prototype.evaluteAggrOp = function(op, exprs, context, callback) {
    switch (op) {
      case "count":
        return callback(null, context.rows.length);
      case "sum":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            if (error) {
              return callback(error);
            }
            return callback(null, _.sum(values));
          };
        })(this));
      case "avg":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            if (error) {
              return callback(error);
            }
            return callback(null, _.sum(values) / values.length);
          };
        })(this));
      case "min":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            if (error) {
              return callback(error);
            }
            return callback(null, _.min(values));
          };
        })(this));
      case "max":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            if (error) {
              return callback(error);
            }
            return callback(null, _.max(values));
          };
        })(this));
      case "last":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return row.getOrdering(cb);
          };
        })(this)), (function(_this) {
          return function(error, orderValues) {
            if (error) {
              return callback(error);
            }
            return async.map(context.rows, (function(row, cb) {
              return _this.evaluate(exprs[0], {
                row: row
              }, cb);
            }), function(error, values) {
              var j, len, value, zipped;
              if (error) {
                return callback(error);
              }
              zipped = _.zip(values, orderValues);
              zipped = _.sortByOrder(zipped, [
                function(entry) {
                  return entry[1];
                }
              ], ["desc"]);
              values = _.map(zipped, function(entry) {
                return entry[0];
              });
              for (j = 0, len = values.length; j < len; j++) {
                value = values[j];
                if (value != null) {
                  callback(null, value);
                  return;
                }
              }
              return callback(null, null);
            });
          };
        })(this));
      case "last where":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return row.getOrdering(cb);
          };
        })(this)), (function(_this) {
          return function(error, ordering) {
            if (error) {
              return callback(error);
            }
            return async.map(context.rows, (function(row, cb) {
              return _this.evaluate(exprs[1], {
                row: row
              }, cb);
            }), function(error, wheres) {
              if (error) {
                return callback(error);
              }
              return async.map(context.rows, (function(row, cb) {
                return _this.evaluate(exprs[0], {
                  row: row
                }, cb);
              }), function(error, values) {
                var i, index, j, largest, len, ref, row;
                if (error) {
                  return callback(error);
                }
                if (ordering.length === 0) {
                  return callback(null, null);
                }
                index = -1;
                largest = null;
                ref = context.rows;
                for (i = j = 0, len = ref.length; j < len; i = ++j) {
                  row = ref[i];
                  if ((wheres[i] || !exprs[1]) && (index === -1 || ordering[i] > largest) && (values[i] != null)) {
                    index = i;
                    largest = ordering[i];
                  }
                }
                if (index >= 0) {
                  return callback(null, values[index]);
                } else {
                  return callback(null, null);
                }
              });
            });
          };
        })(this));
      case "count where":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, wheres) {
            var count, j, len, where;
            if (error) {
              return callback(error);
            }
            count = 0;
            for (j = 0, len = wheres.length; j < len; j++) {
              where = wheres[j];
              if (where === true) {
                count += 1;
              }
            }
            return callback(null, count);
          };
        })(this));
      case "sum where":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            if (error) {
              return callback(error);
            }
            return async.map(context.rows, (function(row, cb) {
              return _this.evaluate(exprs[1], {
                row: row
              }, cb);
            }), function(error, wheres) {
              var i, j, len, ref, row, sum;
              if (error) {
                return callback(error);
              }
              sum = 0;
              ref = context.rows;
              for (i = j = 0, len = ref.length; j < len; i = ++j) {
                row = ref[i];
                if (wheres[i] === true) {
                  sum += values[i];
                }
              }
              return callback(null, sum);
            });
          };
        })(this));
      case "percent where":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, wheres) {
            if (error) {
              return callback(error);
            }
            return async.map(context.rows, (function(row, cb) {
              return _this.evaluate(exprs[1], {
                row: row
              }, cb);
            }), function(error, ofs) {
              var count, i, j, len, ref, row, sum;
              if (error) {
                return callback(error);
              }
              sum = 0;
              count = 0;
              ref = context.rows;
              for (i = j = 0, len = ref.length; j < len; i = ++j) {
                row = ref[i];
                if (wheres[i] === true && (!exprs[1] || ofs[i] === true)) {
                  sum += 1;
                }
                if (!exprs[1] || ofs[i] === true) {
                  count += 1;
                }
              }
              if (count === 0) {
                return callback(null, null);
              } else {
                return callback(null, sum / count * 100);
              }
            });
          };
        })(this));
      case "count distinct":
        return async.map(context.rows, ((function(_this) {
          return function(row, cb) {
            return _this.evaluate(exprs[0], {
              row: row
            }, cb);
          };
        })(this)), (function(_this) {
          return function(error, values) {
            var count;
            if (error) {
              return callback(error);
            }
            count = _.uniq(values).length;
            return callback(null, count);
          };
        })(this));
      default:
        return callback(new Error("Unknown op " + op));
    }
  };

  ExprEvaluator.prototype.evaluateCase = function(expr, context, callback) {
    return async.map(expr.cases, ((function(_this) {
      return function(acase, cb) {
        return _this.evaluate(acase.when, context, cb);
      };
    })(this)), (function(_this) {
      return function(error, whens) {
        if (error) {
          return callback(error);
        }
        return async.map(expr.cases, (function(acase, cb) {
          return _this.evaluate(acase.then, context, cb);
        }), function(error, thens) {
          if (error) {
            return callback(error);
          }
          return _this.evaluate(expr["else"], context, function(error, aelse) {
            var acase, i, j, len, ref;
            if (error) {
              return callback(error);
            }
            ref = expr.cases;
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              acase = ref[i];
              if (whens[i]) {
                return callback(null, thens[i]);
              }
            }
            return callback(null, aelse);
          });
        });
      };
    })(this));
  };

  ExprEvaluator.prototype.evaluateScalar = function(expr, context, callback) {
    if (!expr.expr) {
      return callback(null, null);
    }
    return async.reduce(expr.joins, context, (function(_this) {
      return function(memo, join, cb) {
        if (memo.rows) {
          return async.map(memo.rows, (function(row, cb2) {
            return row.getField(join, cb2);
          }), function(error, results) {
            if (error) {
              return cb(error);
            }
            if (results) {
              return cb(null, {
                rows: _.flatten(results)
              });
            }
          });
        } else if (memo.row) {
          return memo.row.getField(join, function(error, result) {
            if (error) {
              return cb(error);
            }
            if (_.isArray(result)) {
              return cb(null, {
                rows: result
              });
            } else {
              return cb(null, {
                row: result
              });
            }
          });
        } else {
          return cb(null, {
            row: null
          });
        }
      };
    })(this), (function(_this) {
      return function(error, exprContext) {
        if (error) {
          return callback(error);
        }
        if ((exprContext.row == null) && ((exprContext.rows == null) || exprContext.rows.length === 0)) {
          return callback(null, null);
        }
        return _this.evaluate(expr.expr, exprContext, callback);
      };
    })(this));
  };

  ExprEvaluator.prototype.evaluateScore = function(expr, context, callback) {
    var sum;
    if (!expr.input) {
      return callback(null, null);
    }
    sum = 0;
    return this.evaluate(expr.input, context, (function(_this) {
      return function(error, input) {
        var scorePairs;
        if (error) {
          return callback(error);
        }
        scorePairs = _.pairs(expr.scores);
        return async.map(scorePairs, (function(scorePair, cb) {
          return _this.evaluate(scorePair[1], context, cb);
        }), function(error, values) {
          var i, j, k, len, len1, scorePair, scoreValues, val;
          if (error) {
            return callback(error);
          }
          scoreValues = {};
          for (i = j = 0, len = scorePairs.length; j < len; i = ++j) {
            scorePair = scorePairs[i];
            scoreValues[scorePair[0]] = values[i];
          }
          if (_.isArray(input)) {
            for (k = 0, len1 = input.length; k < len1; k++) {
              val = input[k];
              if (scoreValues[val]) {
                sum += scoreValues[val];
              }
            }
          } else if (input) {
            if (scoreValues[input]) {
              sum += scoreValues[input];
            }
          }
          return callback(null, sum);
        });
      };
    })(this));
  };

  ExprEvaluator.prototype.evaluateBuildEnumset = function(expr, context, callback) {
    var valuePairs;
    valuePairs = _.pairs(expr.values);
    return async.map(valuePairs, ((function(_this) {
      return function(valuePair, cb) {
        return _this.evaluate(valuePair[1], context, cb);
      };
    })(this)), (function(_this) {
      return function(error, values) {
        var i, j, len, result, valuePair;
        if (error) {
          return callback(error);
        }
        result = [];
        for (i = j = 0, len = valuePairs.length; j < len; i = ++j) {
          valuePair = valuePairs[i];
          if (values[i]) {
            result.push(valuePair[0]);
          }
        }
        return callback(null, result);
      };
    })(this));
  };

  return ExprEvaluator;

})();

getDistanceFromLatLngInM = function(lat1, lng1, lat2, lng2) {
  var R, a, c, d, dLat, dLng;
  R = 6370986;
  dLat = deg2rad(lat2 - lat1);
  dLng = deg2rad(lng2 - lng1);
  a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
  c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  d = R * c;
  return d;
};

deg2rad = function(deg) {
  return deg * (Math.PI / 180);
};

},{"./ExprUtils":6,"async":17,"lodash":"lodash","moment":19}],6:[function(require,module,exports){
var ExprUtils, _, addOpItem, i, k, l, len, len1, len2, len3, len4, len5, len6, m, moment, n, o, op, opItems, p, ref, ref1, ref2, ref3, ref4, ref5, relativeDateOp, relativeDateOps, type,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

_ = require('lodash');

moment = require('moment');

module.exports = ExprUtils = (function() {
  function ExprUtils(schema) {
    this.schema = schema;
  }

  ExprUtils.prototype.findMatchingOpItems = function(search) {
    return _.filter(opItems, (function(_this) {
      return function(opItem) {
        var lhsType, ref;
        if (search.resultTypes) {
          if (ref = opItem.resultType, indexOf.call(search.resultTypes, ref) < 0) {
            return false;
          }
        }
        if (search.op && opItem.op !== search.op) {
          return false;
        }
        if ((search.aggr != null) && opItem.aggr !== search.aggr) {
          return false;
        }
        if (search.ordered === false && opItem.ordered) {
          return false;
        }
        if ((search.prefix != null) && opItem.prefix !== search.prefix) {
          return false;
        }
        if (search.lhsExpr) {
          lhsType = _this.getExprType(search.lhsExpr);
          if (lhsType && opItem.exprTypes[0] !== null && opItem.exprTypes[0] !== lhsType && opItem.moreExprType !== lhsType) {
            return false;
          }
        }
        if (search.lhsExpr && opItem.lhsCond && !opItem.lhsCond(search.lhsExpr, _this)) {
          return false;
        }
        return true;
      };
    })(this));
  };

  ExprUtils.isOpAggr = function(op) {
    return _.findWhere(opItems, {
      op: op,
      aggr: true
    }) != null;
  };

  ExprUtils.isOpPrefix = function(op) {
    return _.findWhere(opItems, {
      op: op,
      prefix: true
    }) != null;
  };

  ExprUtils.prototype.followJoins = function(startTable, joins) {
    var i, j, joinCol, len, t;
    t = startTable;
    for (i = 0, len = joins.length; i < len; i++) {
      j = joins[i];
      joinCol = this.schema.getColumn(t, j);
      t = joinCol.join.toTable;
    }
    return t;
  };

  ExprUtils.prototype.isMultipleJoins = function(table, joins) {
    var i, j, joinCol, len, ref, t;
    t = table;
    for (i = 0, len = joins.length; i < len; i++) {
      j = joins[i];
      joinCol = this.schema.getColumn(t, j);
      if ((ref = joinCol.join.type) === '1-n' || ref === 'n-n') {
        return true;
      }
      t = joinCol.join.toTable;
    }
    return false;
  };

  ExprUtils.prototype.getExprEnumValues = function(expr) {
    var column, cse, enumValues, i, len, ref, ref1;
    if (!expr) {
      return;
    }
    if (expr.type === "field") {
      column = this.schema.getColumn(expr.table, expr.column);
      if (!column) {
        return null;
      }
      if (column.enumValues) {
        return column.enumValues;
      }
      if (column.type === "expr") {
        return this.getExprEnumValues(column.expr);
      }
      return null;
    }
    if (expr.type === "scalar") {
      if (expr.expr) {
        return this.getExprEnumValues(expr.expr);
      }
    }
    if (expr.type === "op" && ((ref = expr.op) === "last" || ref === "last where" || ref === "previous") && expr.exprs[0]) {
      return this.getExprEnumValues(expr.exprs[0]);
    }
    if (expr.type === "case") {
      ref1 = expr.cases;
      for (i = 0, len = ref1.length; i < len; i++) {
        cse = ref1[i];
        enumValues = this.getExprEnumValues(cse.then);
        if (enumValues) {
          return enumValues;
        }
      }
      return this.getExprEnumValues(expr["else"]);
    }
  };

  ExprUtils.prototype.getExprIdTable = function(expr) {
    var column, ref;
    if (!expr) {
      return null;
    }
    if (expr.type === "literal" && ((ref = expr.valueType) === "id" || ref === "id[]")) {
      return expr.idTable;
    }
    if (expr.type === "id") {
      return expr.table;
    }
    if (expr.type === "scalar") {
      return this.getExprIdTable(expr.expr);
    }
    if (expr.type === "field") {
      column = this.schema.getColumn(expr.table, expr.column);
      if ((column != null ? column.type : void 0) === "join") {
        return column.join.toTable;
      }
      if ((column != null ? column.type : void 0) === "expr") {
        return this.getExprIdTable(column.expr);
      }
      if ((column != null ? column.type : void 0) === "id[]") {
        return column.idTable;
      }
      return null;
    }
  };

  ExprUtils.prototype.getExprType = function(expr) {
    var column, cse, i, len, matchingOpItems, ref, ref1, resultTypes, type;
    if ((expr == null) || !expr.type) {
      return null;
    }
    switch (expr.type) {
      case "field":
        column = this.schema.getColumn(expr.table, expr.column);
        if (column) {
          if (column.type === "join") {
            if ((ref = column.join.type) === '1-1' || ref === 'n-1') {
              return "id";
            } else {
              return "id[]";
            }
          } else if (column.type === "expr") {
            return this.getExprType(column.expr);
          }
          return column.type;
        }
        return null;
      case "id":
        return "id";
      case "scalar":
        if (expr.aggr) {
          return this.getExprType({
            type: "op",
            op: expr.aggr,
            table: expr.table,
            exprs: [expr.expr]
          });
        }
        return this.getExprType(expr.expr);
      case "op":
        matchingOpItems = this.findMatchingOpItems({
          op: expr.op
        });
        resultTypes = _.uniq(_.compact(_.pluck(matchingOpItems, "resultType")));
        if (resultTypes.length === 1) {
          return resultTypes[0];
        }
        matchingOpItems = this.findMatchingOpItems({
          op: expr.op,
          lhsExpr: expr.exprs[0]
        });
        resultTypes = _.uniq(_.compact(_.pluck(matchingOpItems, "resultType")));
        if (resultTypes.length === 1) {
          return resultTypes[0];
        }
        return null;
      case "literal":
        return expr.valueType;
      case "case":
        ref1 = expr.cases;
        for (i = 0, len = ref1.length; i < len; i++) {
          cse = ref1[i];
          type = this.getExprType(cse.then);
          if (type) {
            return type;
          }
        }
        return this.getExprType(expr["else"]);
      case "build enumset":
        return "enumset";
      case "score":
        return "number";
      case "count":
        return "count";
      default:
        throw new Error("Not implemented for " + expr.type);
    }
  };

  ExprUtils.prototype.getExprAggrStatus = function(expr) {
    var column, exprs, getListAggrStatus;
    if ((expr == null) || !expr.type) {
      return null;
    }
    getListAggrStatus = (function(_this) {
      return function(exprs) {
        var i, k, l, len, len1, len2, subExpr;
        for (i = 0, len = exprs.length; i < len; i++) {
          subExpr = exprs[i];
          if (_this.getExprAggrStatus(subExpr) === "aggregate") {
            return "aggregate";
          }
        }
        for (k = 0, len1 = exprs.length; k < len1; k++) {
          subExpr = exprs[k];
          if (_this.getExprAggrStatus(subExpr) === "individual") {
            return "individual";
          }
        }
        for (l = 0, len2 = exprs.length; l < len2; l++) {
          subExpr = exprs[l];
          if (_this.getExprAggrStatus(subExpr) === "literal") {
            return "literal";
          }
        }
        return null;
      };
    })(this);
    switch (expr.type) {
      case "id":
      case "scalar":
        return "individual";
      case "field":
        column = this.schema.getColumn(expr.table, expr.column);
        if ((column != null ? column.type : void 0) === "expr") {
          return this.getExprAggrStatus(column.expr);
        }
        return "individual";
      case "op":
        if (this.findMatchingOpItems({
          op: expr.op,
          aggr: true
        })[0]) {
          return "aggregate";
        }
        return getListAggrStatus(expr.exprs);
      case "literal":
        return "literal";
      case "case":
        exprs = [expr.input, expr["else"]];
        exprs = exprs.concat(_.map(expr.cases, function(cs) {
          return cs.when;
        }));
        exprs = exprs.concat(_.map(expr.cases, function(cs) {
          return cs.then;
        }));
        return getListAggrStatus(exprs);
      case "score":
        return this.getExprAggrStatus(expr.input);
      case "build enumset":
        exprs = _.values(expr.values);
        return getListAggrStatus(exprs);
      case "count":
      case "comparison":
      case "logical":
        return "individual";
      default:
        throw new Error("Not implemented for " + expr.type);
    }
  };

  ExprUtils.prototype.areJoinsValid = function(table, joins) {
    var i, j, joinCol, len, t;
    t = table;
    for (i = 0, len = joins.length; i < len; i++) {
      j = joins[i];
      joinCol = this.schema.getColumn(t, j);
      if (!joinCol) {
        return false;
      }
      t = joinCol.join.toTable;
    }
    return true;
  };

  ExprUtils.prototype.getExprTable = function(expr) {
    if (!expr) {
      return null;
    }
    return expr.table;
  };

  ExprUtils.prototype.getAggrTypes = function(expr) {
    var aggrOpItems, ref;
    aggrOpItems = this.findMatchingOpItems({
      lhsExpr: expr,
      aggr: true,
      ordered: ((ref = this.schema.getTable(expr.table)) != null ? ref.ordering : void 0) != null
    });
    return _.uniq(_.pluck(aggrOpItems, "resultType"));
  };

  ExprUtils.prototype.localizeString = function(name, locale) {
    return ExprUtils.localizeString(name, locale);
  };

  ExprUtils.localizeString = function(name, locale) {
    if (!name) {
      return name;
    }
    if (typeof name === "string") {
      return name;
    }
    if (locale && (name[locale] != null)) {
      return name[locale];
    }
    if (name._base && (name[name._base] != null)) {
      return name[name._base];
    }
    if (name.en != null) {
      return name.en;
    }
    return null;
  };

  ExprUtils.andExprs = function() {
    var exprs;
    exprs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    exprs = _.map(exprs, function(expr) {
      if ((expr != null ? expr.type : void 0) === "op" && expr.op === "and") {
        return expr.exprs;
      } else {
        return expr;
      }
    });
    exprs = _.compact(_.flatten(exprs));
    if (exprs.length === 0) {
      return null;
    }
    if (exprs.length === 1) {
      return exprs[0];
    }
    return {
      type: "op",
      op: "and",
      exprs: exprs
    };
  };

  ExprUtils.prototype.summarizeExpr = function(expr, locale) {
    var opItem, ref, ref1, ref2, ref3, ref4, ref5;
    if (!expr) {
      return "None";
    }
    switch (expr.type) {
      case "scalar":
        return this.summarizeScalarExpr(expr, locale);
      case "field":
        return this.localizeString((ref = this.schema.getColumn(expr.table, expr.column)) != null ? ref.name : void 0, locale);
      case "id":
        return this.localizeString((ref1 = this.schema.getTable(expr.table)) != null ? ref1.name : void 0, locale);
      case "op":
        if (expr.op === "contains" && ((ref2 = expr.exprs[1]) != null ? ref2.type : void 0) === "literal") {
          return this.summarizeExpr(expr.exprs[0], locale) + " includes all of " + this.stringifyLiteralValue("enumset", expr.exprs[1].value, locale, this.getExprEnumValues(expr.exprs[0]));
        }
        if (expr.op === "= any" && ((ref3 = expr.exprs[1]) != null ? ref3.type : void 0) === "literal") {
          return this.summarizeExpr(expr.exprs[0], locale) + " is any of " + this.stringifyLiteralValue("enumset", expr.exprs[1].value, locale, this.getExprEnumValues(expr.exprs[0]));
        }
        if (expr.op === "=" && ((ref4 = expr.exprs[1]) != null ? ref4.type : void 0) === "literal" && ((ref5 = expr.exprs[1]) != null ? ref5.valueType : void 0) === "enum") {
          return this.summarizeExpr(expr.exprs[0], locale) + " is " + this.stringifyLiteralValue("enum", expr.exprs[1].value, locale, this.getExprEnumValues(expr.exprs[0]));
        }
        if (expr.op === "count") {
          return "Number of " + this.localizeString(this.schema.getTable(expr.table).name, locale);
        }
        opItem = this.findMatchingOpItems({
          op: expr.op
        })[0];
        if (opItem) {
          if (opItem.prefix) {
            return opItem.name + " " + _.map(expr.exprs, (function(_this) {
              return function(e) {
                return _this.summarizeExpr(e, locale);
              };
            })(this)).join(", ");
          }
          if (expr.exprs.length === 1) {
            return this.summarizeExpr(expr.exprs[0], locale) + " " + opItem.name;
          }
          return _.map(expr.exprs, (function(_this) {
            return function(e) {
              return _this.summarizeExpr(e, locale);
            };
          })(this)).join(" " + opItem.name + " ");
        } else {
          return "";
        }
        break;
      case "case":
        return this.summarizeCaseExpr(expr, locale);
      case "literal":
        return expr.value + "";
      case "score":
        return "Score of " + this.summarizeExpr(expr.input, locale);
      case "build enumset":
        return "Build Enumset";
      case "count":
        return "Count";
      default:
        throw new Error("Unsupported type " + expr.type);
    }
  };

  ExprUtils.prototype.summarizeScalarExpr = function(expr, locale) {
    var exprType, i, innerExpr, join, joinCol, len, ref, ref1, ref2, str, t;
    exprType = this.getExprType(expr.expr);
    str = "";
    t = expr.table;
    ref = expr.joins;
    for (i = 0, len = ref.length; i < len; i++) {
      join = ref[i];
      joinCol = this.schema.getColumn(t, join);
      str += this.localizeString(joinCol.name, locale) + " > ";
      t = joinCol.join.toTable;
    }
    if (((ref1 = expr.expr) != null ? ref1.type : void 0) === "id" && !expr.aggr) {
      str = str.substring(0, str.length - 3);
    } else {
      innerExpr = expr.expr;
      if (expr.aggr) {
        innerExpr = {
          type: "op",
          op: expr.aggr,
          table: (ref2 = expr.expr) != null ? ref2.table : void 0,
          exprs: [expr.expr]
        };
      }
      str += this.summarizeExpr(innerExpr, locale);
    }
    return str;
  };

  ExprUtils.prototype.summarizeCaseExpr = function(expr, locale) {
    var c, i, len, ref, str;
    str = "If";
    ref = expr.cases;
    for (i = 0, len = ref.length; i < len; i++) {
      c = ref[i];
      str += " " + this.summarizeExpr(c.when);
      str += " Then " + this.summarizeExpr(c.then);
    }
    if (expr["else"]) {
      str += " Else " + this.summarizeExpr(expr["else"]);
    }
    return str;
  };

  ExprUtils.prototype.stringifyExprLiteral = function(expr, literal, locale, preferEnumCodes) {
    if (preferEnumCodes == null) {
      preferEnumCodes = false;
    }
    return this.stringifyLiteralValue(this.getExprType(expr), literal, locale, this.getExprEnumValues(expr), preferEnumCodes);
  };

  ExprUtils.prototype.stringifyLiteralValue = function(type, value, locale, enumValues, preferEnumCodes) {
    var item;
    if (preferEnumCodes == null) {
      preferEnumCodes = false;
    }
    if (value == null) {
      return "None";
    }
    switch (type) {
      case "text":
        return value;
      case "number":
        return "" + value;
      case "enum":
        item = _.findWhere(enumValues, {
          id: value
        });
        if (item) {
          if (preferEnumCodes && item.code) {
            return item.code;
          }
          return ExprUtils.localizeString(item.name, locale);
        }
        return "???";
      case "enumset":
        return _.map(value, (function(_this) {
          return function(val) {
            item = _.findWhere(enumValues, {
              id: val
            });
            if (item) {
              if (preferEnumCodes && item.code) {
                return item.code;
              }
              return ExprUtils.localizeString(item.name, locale);
            }
            return "???";
          };
        })(this)).join(', ');
      case "text[]":
        if (_.isString(value)) {
          value = JSON.parse(value || "[]");
        }
        return value.join(', ');
      case "date":
        return moment(value, moment.ISO_8601).format("ll");
      case "datetime":
        return moment(value, moment.ISO_8601).format("lll");
    }
    if (value === true) {
      return "True";
    }
    if (value === false) {
      return "False";
    }
    return "" + value;
  };

  ExprUtils.prototype.getComparisonOps = function(lhsType) {
    var ops;
    ops = [];
    switch (lhsType) {
      case "number":
        ops.push({
          id: "=",
          name: "equals"
        });
        ops.push({
          id: ">",
          name: "is greater than"
        });
        ops.push({
          id: ">=",
          name: "is greater or equal to"
        });
        ops.push({
          id: "<",
          name: "is less than"
        });
        ops.push({
          id: "<=",
          name: "is less than or equal to"
        });
        break;
      case "text":
        ops.push({
          id: "= any",
          name: "is one of"
        });
        ops.push({
          id: "=",
          name: "is"
        });
        ops.push({
          id: "~*",
          name: "matches"
        });
        break;
      case "date":
      case "datetime":
        ops.push({
          id: "between",
          name: "between"
        });
        ops.push({
          id: ">",
          name: "after"
        });
        ops.push({
          id: "<",
          name: "before"
        });
        break;
      case "enum":
        ops.push({
          id: "= any",
          name: "is one of"
        });
        ops.push({
          id: "=",
          name: "is"
        });
        break;
      case "boolean":
        ops.push({
          id: "= true",
          name: "is true"
        });
        ops.push({
          id: "= false",
          name: "is false"
        });
    }
    ops.push({
      id: "is null",
      name: "has no value"
    });
    ops.push({
      id: "is not null",
      name: "has a value"
    });
    return ops;
  };

  ExprUtils.prototype.getComparisonRhsType = function(lhsType, op) {
    if (op === '= true' || op === '= false' || op === 'is null' || op === 'is not null') {
      return null;
    }
    if (op === '= any') {
      if (lhsType === "enum") {
        return 'enum[]';
      } else if (lhsType === "text") {
        return "text[]";
      } else {
        throw new Error("Invalid lhs type for op = any");
      }
    }
    if (op === "between") {
      if (lhsType === "date") {
        return 'daterange';
      }
      if (lhsType === "datetime") {
        return 'datetimerange';
      } else {
        throw new Error("Invalid lhs type for op between");
      }
    }
    return lhsType;
  };

  ExprUtils.prototype.getReferencedFields = function(expr) {
    var cols, column, i, join, k, l, len, len1, len2, len3, len4, m, n, ref, ref1, ref2, ref3, ref4, subcase, subexpr, table, value;
    cols = [];
    if (!expr) {
      return cols;
    }
    switch (expr.type) {
      case "field":
        cols.push(expr);
        column = this.schema.getColumn(expr.table, expr.column);
        if (column != null ? column.expr : void 0) {
          cols = cols.concat(this.getReferencedFields(column.expr));
        }
        break;
      case "op":
        ref = expr.exprs;
        for (i = 0, len = ref.length; i < len; i++) {
          subexpr = ref[i];
          cols = cols.concat(this.getReferencedFields(subexpr));
        }
        break;
      case "case":
        ref1 = expr.cases;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          subcase = ref1[k];
          cols = cols.concat(this.getReferencedFields(subcase.when));
          cols = cols.concat(this.getReferencedFields(subcase.then));
        }
        cols = cols.concat(this.getReferencedFields(expr["else"]));
        break;
      case "scalar":
        table = expr.table;
        ref2 = expr.joins;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          join = ref2[l];
          cols.push({
            type: "field",
            table: table,
            column: join
          });
          column = this.schema.getColumn(table, join);
          if (!column) {
            break;
          }
          table = column.join.toTable;
        }
        cols = cols.concat(this.getReferencedFields(expr.expr));
        break;
      case "score":
        cols = cols.concat(this.getReferencedFields(expr.input));
        ref3 = _.values(expr.scores);
        for (m = 0, len3 = ref3.length; m < len3; m++) {
          value = ref3[m];
          cols = cols.concat(this.getReferencedFields(value));
        }
        break;
      case "build enumset":
        ref4 = _.values(expr.values);
        for (n = 0, len4 = ref4.length; n < len4; n++) {
          value = ref4[n];
          cols = cols.concat(this.getReferencedFields(value));
        }
    }
    return _.uniq(cols, function(col) {
      return col.table + "/" + col.column;
    });
  };

  return ExprUtils;

})();

opItems = [];

addOpItem = (function(_this) {
  return function(item) {
    return opItems.push(_.defaults(item, {
      prefix: false,
      rhsLiteral: true,
      aggr: false,
      ordered: false
    }));
  };
})(this);

addOpItem({
  op: "= any",
  name: "is any of",
  resultType: "boolean",
  exprTypes: ["text", "text[]"]
});

addOpItem({
  op: "= any",
  name: "is any of",
  resultType: "boolean",
  exprTypes: ["enum", "enumset"]
});

addOpItem({
  op: "contains",
  name: "includes all of",
  resultType: "boolean",
  exprTypes: ["enumset", "enumset"]
});

relativeDateOps = [['thisyear', 'is this year'], ['lastyear', 'is last year'], ['thismonth', 'is this month'], ['lastmonth', 'is last month'], ['today', 'is today'], ['yesterday', 'is yesterday'], ['last24hours', 'is in last 24 hours'], ['last7days', 'is in last 7 days'], ['last30days', 'is in last 30 days'], ['last365days', 'is in last 365 days']];

for (i = 0, len = relativeDateOps.length; i < len; i++) {
  relativeDateOp = relativeDateOps[i];
  addOpItem({
    op: relativeDateOp[0],
    name: relativeDateOp[1],
    resultType: "boolean",
    exprTypes: ['date']
  });
  addOpItem({
    op: relativeDateOp[0],
    name: relativeDateOp[1],
    resultType: "boolean",
    exprTypes: ['datetime']
  });
}

addOpItem({
  op: "between",
  name: "is between",
  resultType: "boolean",
  exprTypes: ["date", "date", "date"]
});

addOpItem({
  op: "between",
  name: "is between",
  resultType: "boolean",
  exprTypes: ["datetime", "datetime", "datetime"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["text", "text"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["enum", "enum"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["date", "date"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["datetime", "datetime"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["boolean", "boolean"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["text", "text"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["enum", "enum"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["date", "date"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["datetime", "datetime"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["boolean", "boolean"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: ">",
  name: "is greater than",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: "<",
  name: "is less than",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: ">=",
  name: "is greater or equal to",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: "<=",
  name: "is less or equal to",
  resultType: "boolean",
  exprTypes: ["number", "number"]
});

ref = ['date', 'datetime'];
for (k = 0, len1 = ref.length; k < len1; k++) {
  type = ref[k];
  addOpItem({
    op: ">",
    name: "is after",
    resultType: "boolean",
    exprTypes: [type, type]
  });
  addOpItem({
    op: "<",
    name: "is before",
    resultType: "boolean",
    exprTypes: [type, type]
  });
  addOpItem({
    op: ">=",
    name: "is after or same as",
    resultType: "boolean",
    exprTypes: [type, type]
  });
  addOpItem({
    op: "<=",
    name: "is before or same as",
    resultType: "boolean",
    exprTypes: [type, type]
  });
}

addOpItem({
  op: "between",
  name: "is between",
  resultType: "boolean",
  exprTypes: ["number", "number", "number"]
});

addOpItem({
  op: "round",
  name: "Round",
  desc: "Round a number to closest whole number",
  resultType: "number",
  exprTypes: ["number"],
  prefix: true
});

addOpItem({
  op: "floor",
  name: "Floor",
  desc: "Round a number down",
  resultType: "number",
  exprTypes: ["number"],
  prefix: true
});

addOpItem({
  op: "ceiling",
  name: "Ceiling",
  desc: "Round a number up",
  resultType: "number",
  exprTypes: ["number"],
  prefix: true
});

addOpItem({
  op: "latitude",
  name: "Latitude of",
  desc: "Get latitude in degrees of a location",
  resultType: "number",
  exprTypes: ["geometry"],
  prefix: true
});

addOpItem({
  op: "longitude",
  name: "Longitude of",
  desc: "Get longitude in degrees of a location",
  resultType: "number",
  exprTypes: ["geometry"],
  prefix: true
});

addOpItem({
  op: "distance",
  name: "Distance between",
  desc: "Get distance in meters between two locations",
  resultType: "number",
  exprTypes: ["geometry", "geometry"],
  prefix: true,
  rhsLiteral: false,
  joiner: "and"
});

addOpItem({
  op: "and",
  name: "and",
  resultType: "boolean",
  exprTypes: [],
  moreExprType: "boolean"
});

addOpItem({
  op: "or",
  name: "or",
  resultType: "boolean",
  exprTypes: [],
  moreExprType: "boolean"
});

ref1 = ['+', '*'];
for (l = 0, len2 = ref1.length; l < len2; l++) {
  op = ref1[l];
  addOpItem({
    op: op,
    name: op,
    resultType: "number",
    exprTypes: [],
    moreExprType: "number"
  });
}

addOpItem({
  op: "-",
  name: "-",
  resultType: "number",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: "/",
  name: "/",
  resultType: "number",
  exprTypes: ["number", "number"]
});

addOpItem({
  op: "days difference",
  name: "Days between",
  desc: "Get the number of days between two dates",
  resultType: "number",
  exprTypes: ["date", "date"],
  prefix: true,
  rhsLiteral: false,
  joiner: "and"
});

addOpItem({
  op: "days difference",
  name: "Days between",
  desc: "Get the number of days between two dates",
  resultType: "number",
  exprTypes: ["datetime", "datetime"],
  prefix: true,
  rhsLiteral: false,
  joiner: "and"
});

addOpItem({
  op: "days since",
  name: "Days since",
  desc: "Get number of days from a date to the present",
  resultType: "number",
  exprTypes: ["date"],
  prefix: true,
  rhsLiteral: false
});

addOpItem({
  op: "days since",
  name: "Days since",
  desc: "Get number of days from a date to the present",
  resultType: "number",
  exprTypes: ["datetime"],
  prefix: true,
  rhsLiteral: false
});

ref2 = ['text', 'number', 'enum', 'enumset', 'boolean', 'date', 'datetime', 'geometry'];
for (m = 0, len3 = ref2.length; m < len3; m++) {
  type = ref2[m];
  addOpItem({
    op: "last",
    name: "Latest",
    desc: "Get latest value when there are multiple",
    resultType: type,
    exprTypes: [type],
    prefix: true,
    aggr: true,
    ordered: true
  });
  addOpItem({
    op: "last where",
    name: "Latest where",
    desc: "Get latest value that matches a condition",
    resultType: type,
    exprTypes: [type, "boolean"],
    prefix: true,
    prefixLabel: "Latest",
    aggr: true,
    ordered: true,
    rhsLiteral: false,
    joiner: "where",
    rhsPlaceholder: "All"
  });
  addOpItem({
    op: "previous",
    name: "Previous",
    desc: "Get 2nd latest value when there are multiple",
    resultType: type,
    exprTypes: [type],
    prefix: true,
    aggr: true,
    ordered: true
  });
}

addOpItem({
  op: "sum",
  name: "Total",
  desc: "Add all values together",
  resultType: "number",
  exprTypes: ["number"],
  prefix: true,
  aggr: true
});

addOpItem({
  op: "avg",
  name: "Average",
  desc: "Average all values together",
  resultType: "number",
  exprTypes: ["number"],
  prefix: true,
  aggr: true
});

ref3 = ['number', 'date', 'datetime'];
for (n = 0, len4 = ref3.length; n < len4; n++) {
  type = ref3[n];
  addOpItem({
    op: "min",
    name: "Minimum",
    desc: "Get smallest value",
    resultType: type,
    exprTypes: [type],
    prefix: true,
    aggr: true
  });
  addOpItem({
    op: "max",
    name: "Maximum",
    desc: "Get largest value",
    resultType: type,
    exprTypes: [type],
    prefix: true,
    aggr: true
  });
}

addOpItem({
  op: "percent where",
  name: "Percent where",
  desc: "Get percent of items that match a condition",
  resultType: "number",
  exprTypes: ["boolean", "boolean"],
  prefix: true,
  aggr: true,
  rhsLiteral: false,
  joiner: "of",
  rhsPlaceholder: "All"
});

addOpItem({
  op: "count where",
  name: "Number where",
  desc: "Get number of items that match a condition",
  resultType: "number",
  exprTypes: ["boolean"],
  prefix: true,
  aggr: true
});

addOpItem({
  op: "sum where",
  name: "Total where",
  desc: "Add together only values that match a condition",
  resultType: "number",
  exprTypes: ["number", "boolean"],
  prefix: true,
  prefixLabel: "Total",
  aggr: true,
  rhsLiteral: false,
  joiner: "where",
  rhsPlaceholder: "All"
});

addOpItem({
  op: "within",
  name: "is within",
  resultType: "boolean",
  exprTypes: ["id", "id"],
  lhsCond: (function(_this) {
    return function(lhsExpr, exprUtils) {
      var lhsIdTable;
      lhsIdTable = exprUtils.getExprIdTable(lhsExpr);
      if (lhsIdTable) {
        return exprUtils.schema.getTable(lhsIdTable).ancestry != null;
      }
      return false;
    };
  })(this)
});

addOpItem({
  op: "within any",
  name: "is within any of",
  resultType: "boolean",
  exprTypes: ["id", "id[]"],
  lhsCond: (function(_this) {
    return function(lhsExpr, exprUtils) {
      var lhsIdTable;
      lhsIdTable = exprUtils.getExprIdTable(lhsExpr);
      if (lhsIdTable) {
        return exprUtils.schema.getTable(lhsIdTable).ancestry != null;
      }
      return false;
    };
  })(this)
});

addOpItem({
  op: "= any",
  name: "is any of",
  resultType: "boolean",
  exprTypes: ["id", "id[]"]
});

addOpItem({
  op: "contains",
  name: "includes all of",
  resultType: "boolean",
  exprTypes: ["id[]", "id[]"]
});

addOpItem({
  op: "=",
  name: "is",
  resultType: "boolean",
  exprTypes: ["id", "id"]
});

addOpItem({
  op: "<>",
  name: "is not",
  resultType: "boolean",
  exprTypes: ["id", "id"]
});

addOpItem({
  op: "count",
  name: "Number of",
  desc: "Get total number of items",
  resultType: "number",
  exprTypes: [],
  prefix: true,
  aggr: true
});

addOpItem({
  op: "~*",
  name: "matches",
  resultType: "boolean",
  exprTypes: ["text", "text"]
});

addOpItem({
  op: "not",
  name: "Not",
  desc: "Opposite of a value",
  resultType: "boolean",
  exprTypes: ["boolean"],
  prefix: true
});

ref4 = ['text', 'number', 'enum', 'enumset', 'boolean', 'date', 'datetime', 'geometry', 'image', 'imagelist', 'id'];
for (o = 0, len5 = ref4.length; o < len5; o++) {
  type = ref4[o];
  addOpItem({
    op: "is null",
    name: "is blank",
    resultType: "boolean",
    exprTypes: [type]
  });
  addOpItem({
    op: "is not null",
    name: "is not blank",
    resultType: "boolean",
    exprTypes: [type]
  });
}

ref5 = ['id', 'text'];
for (p = 0, len6 = ref5.length; p < len6; p++) {
  type = ref5[p];
  addOpItem({
    op: "count distinct",
    name: "Number of unique",
    desc: "Count number of unique values",
    resultType: "number",
    exprTypes: [type],
    prefix: true,
    aggr: true
  });
}

addOpItem({
  op: "length",
  name: "Number of values in",
  desc: "Advanced: number of values selected in a multi-choice field",
  resultType: "number",
  exprTypes: ["enumset"],
  prefix: true
});

addOpItem({
  op: "length",
  name: "Number of values in",
  desc: "Advanced: number of images present",
  resultType: "number",
  exprTypes: ["imagelist"],
  prefix: true
});

addOpItem({
  op: "length",
  name: "Number of values in",
  desc: "Advanced: number of items present in a text list",
  resultType: "number",
  exprTypes: ["text[]"],
  prefix: true
});

addOpItem({
  op: "to text",
  name: "Convert to text",
  desc: "Advanced: convert a choice or number type to a text value",
  resultType: "text",
  exprTypes: ["enum"],
  prefix: true
});

addOpItem({
  op: "to text",
  name: "Convert to text",
  desc: "Advanced: convert a choice or number type to a text value",
  resultType: "text",
  exprTypes: ["number"],
  prefix: true
});

},{"lodash":"lodash","moment":19}],7:[function(require,module,exports){
var ExprUtils, ExprValidator, _,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

ExprUtils = require('./ExprUtils');

module.exports = ExprValidator = (function() {
  function ExprValidator(schema) {
    this.schema = schema;
    this.exprUtils = new ExprUtils(schema);
  }

  ExprValidator.prototype.validateExpr = function(expr, options) {
    var column, cse, enumValueIds, error, i, j, key, len, len1, opItems, ref, ref1, ref2, ref3, ref4, ref5, ref6, subexpr, value;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      aggrStatuses: ["individual", "literal"]
    });
    if (!expr) {
      return null;
    }
    if (_.isEmpty(expr)) {
      return null;
    }
    if (options.depth > 100) {
      return "Circular reference";
    }
    if (expr.type !== "literal") {
      if (options.table && expr.table !== options.table) {
        return "Wrong table " + expr.table + " (expected " + options.table + ")";
      }
    }
    switch (expr.type) {
      case "literal":
        if (options.types && (ref = expr.valueType, indexOf.call(options.types, ref) < 0)) {
          return "Wrong type";
        }
        if (options.idTable && expr.valueType === "id" && options.idTable !== expr.idTable) {
          return "Wrong table";
        }
        break;
      case "field":
        column = this.schema.getColumn(expr.table, expr.column);
        if (!column) {
          return "Missing column";
        }
        if (column.expr) {
          error = this.validateExpr(column.expr, _.extend({}, options, {
            depth: (options.depth || 0) + 1
          }));
          if (error) {
            return error;
          }
        }
        break;
      case "op":
        ref1 = expr.exprs;
        for (i = 0, len = ref1.length; i < len; i++) {
          subexpr = ref1[i];
          error = this.validateExpr(subexpr, _.omit(options, "types"));
          if (error) {
            return error;
          }
        }
        opItems = this.exprUtils.findMatchingOpItems({
          op: expr.op,
          lhsExpr: expr.exprs[0],
          resultTypes: options.types
        });
        if (opItems.length === 0) {
          return "No matching op";
        }
        break;
      case "case":
        ref2 = expr.cases;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          cse = ref2[j];
          error = this.validateExpr(cse.when, _.extend({}, options, {
            types: ["boolean"]
          }));
          if (error) {
            return error;
          }
          error = this.validateExpr(cse.then, options);
          if (error) {
            return error;
          }
        }
        error = this.validateExpr(expr["else"], options);
        if (error) {
          return error;
        }
        break;
      case "score":
        error = this.validateExpr(expr.input, _.extend({}, options, {
          types: ["enum", "enumset"]
        }));
        if (error) {
          return error;
        }
        if (expr.input) {
          enumValueIds = _.pluck(this.exprUtils.getExprEnumValues(expr.input), "id");
        } else {
          enumValueIds = null;
        }
        ref3 = expr.scores;
        for (key in ref3) {
          value = ref3[key];
          if (enumValueIds && indexOf.call(enumValueIds, key) < 0) {
            return "Invalid score enum";
          }
          error = this.validateExpr(value, _.extend({}, options, {
            types: ["number"]
          }));
          if (error) {
            return error;
          }
        }
        break;
      case "build enumset":
        ref4 = expr.values;
        for (key in ref4) {
          value = ref4[key];
          if (options.enumValueIds && indexOf.call(options.enumValueIds, key) < 0) {
            return "Invalid score enum";
          }
          error = this.validateExpr(value, _.extend({}, options, {
            types: ["boolean"]
          }));
          if (error) {
            return error;
          }
        }
    }
    if (options.idTable && this.exprUtils.getExprIdTable(expr) && this.exprUtils.getExprIdTable(expr) !== options.idTable) {
      return "Wrong idTable";
    }
    if (options.types && this.exprUtils.getExprType(expr) && (ref5 = this.exprUtils.getExprType(expr), indexOf.call(options.types, ref5) < 0)) {
      return "Invalid type";
    }
    if (options.enumValueIds && ((ref6 = this.exprUtils.getExprType(expr)) === 'enum' || ref6 === 'enumset')) {
      if (_.difference(_.pluck(this.exprUtils.getExprEnumValues(expr), "id"), options.enumValueIds).length > 0) {
        return "Invalid enum";
      }
    }
    return null;
  };

  return ExprValidator;

})();

},{"./ExprUtils":6,"lodash":"lodash"}],8:[function(require,module,exports){
var DataSource, LRU, MWaterDataSource, _, querystring,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

DataSource = require('./DataSource');

LRU = require("lru-cache");

querystring = require('querystring');

module.exports = MWaterDataSource = (function(superClass) {
  extend(MWaterDataSource, superClass);

  function MWaterDataSource(apiUrl, client, options) {
    if (options == null) {
      options = {};
    }
    this.apiUrl = apiUrl;
    this.client = client;
    _.defaults(options, {
      serverCaching: true,
      localCaching: true
    });
    this.options = options;
    if (this.options.localCaching) {
      this.cache = LRU({
        max: 500,
        maxAge: 1000 * 15 * 60
      });
    }
  }

  MWaterDataSource.prototype.performQuery = function(jsonql, cb) {
    var cacheKey, cachedRows, headers, jsonqlStr, method, queryParams, url;
    if (this.options.localCaching) {
      cacheKey = JSON.stringify(jsonql);
      cachedRows = this.cache.get(cacheKey);
      if (cachedRows) {
        return cb(null, cachedRows);
      }
    }
    queryParams = {};
    if (this.client) {
      queryParams.client = this.client;
    }
    jsonqlStr = JSON.stringify(jsonql);
    if (jsonqlStr.length < 10000) {
      queryParams.jsonql = jsonqlStr;
      method = "GET";
    } else {
      method = "POST";
    }
    url = this.apiUrl + "jsonql?" + querystring.stringify(queryParams);
    headers = {};
    if (!this.options.serverCaching && method === "GET") {
      headers['Cache-Control'] = "no-cache";
    }
    return $.ajax({
      dataType: "json",
      method: method,
      url: url,
      headers: headers,
      data: method === "POST" ? {
        jsonql: jsonqlStr
      } : void 0
    }).done((function(_this) {
      return function(rows) {
        if (_this.options.localCaching) {
          _this.cache.set(cacheKey, rows);
        }
        return cb(null, rows);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        return cb(new Error(xhr.responseText));
      };
    })(this));
  };

  MWaterDataSource.prototype.clearCache = function() {
    var ref;
    return (ref = this.cache) != null ? ref.reset() : void 0;
  };

  MWaterDataSource.prototype.getImageUrl = function(imageId, height) {
    var apiUrl, query, url;
    apiUrl = this.options.imageApiUrl || this.apiUrl;
    url = apiUrl + ("images/" + imageId);
    query = {};
    if (height) {
      query.h = height;
    }
    if (this.client) {
      query.client = this.client;
    }
    if (!_.isEmpty(query)) {
      url += "?" + querystring.stringify(query);
    }
    return url;
  };

  return MWaterDataSource;

})(DataSource);

},{"./DataSource":2,"lodash":"lodash","lru-cache":18,"querystring":400}],9:[function(require,module,exports){
var DataSource, NullDataSource,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DataSource = require('./DataSource');

module.exports = NullDataSource = (function(superClass) {
  extend(NullDataSource, superClass);

  function NullDataSource() {
    return NullDataSource.__super__.constructor.apply(this, arguments);
  }

  NullDataSource.prototype.performQuery = function(query, cb) {
    return cb(null, []);
  };

  return NullDataSource;

})(DataSource);

},{"./DataSource":2}],10:[function(require,module,exports){
var ExprEvaluator, _, deg2rad, getDistanceFromLatLngInM, moment;

_ = require('lodash');

moment = require('moment');

module.exports = ExprEvaluator = (function() {
  function ExprEvaluator() {}

  ExprEvaluator.prototype.evaluate = function(expr, row) {
    if (expr == null) {
      return null;
    }
    switch (expr.type) {
      case "field":
        return row.getField(expr.column);
      case "literal":
        return expr.value;
      case "op":
        return this.evaluateOp(expr.op, expr.exprs, row);
      case "id":
        return row.getPrimaryKey();
      case "case":
        return this.evaluateCase(expr, row);
      case "scalar":
        return this.evaluateScalar(expr, row);
      case "score":
        return this.evaluateScore(expr, row);
      default:
        throw new Error("Unsupported expression type " + expr.type);
    }
  };

  ExprEvaluator.prototype.evaluateOp = function(op, exprs, row) {
    var date, point, point1, point2;
    switch (op) {
      case "and":
        return this.evaluate(exprs[0], row) && this.evaluate(exprs[1], row);
      case "or":
        return this.evaluate(exprs[0], row) || this.evaluate(exprs[1], row);
      case "=":
        return this.evaluate(exprs[0], row) === this.evaluate(exprs[1], row);
      case "<>":
        return this.evaluate(exprs[0], row) !== this.evaluate(exprs[1], row);
      case ">":
        return this.evaluate(exprs[0], row) > this.evaluate(exprs[1], row);
      case ">=":
        return this.evaluate(exprs[0], row) >= this.evaluate(exprs[1], row);
      case "<":
        return this.evaluate(exprs[0], row) < this.evaluate(exprs[1], row);
      case "<=":
        return this.evaluate(exprs[0], row) <= this.evaluate(exprs[1], row);
      case "= false":
        return this.evaluate(exprs[0], row) === false;
      case "is null":
        return this.evaluate(exprs[0], row) == null;
      case "is not null":
        return this.evaluate(exprs[0], row) != null;
      case "~*":
        return this.evaluate(exprs[0], row).match(new RegExp(this.evaluate(exprs[1], row), "i")) != null;
      case "= any":
        return _.contains(this.evaluate(exprs[1], row), this.evaluate(exprs[0], row));
      case "between":
        return this.evaluate(exprs[0], row) >= this.evaluate(exprs[1], row) && this.evaluate(exprs[0], row) <= this.evaluate(exprs[2], row);
      case "round":
        return Math.round(this.evaluate(exprs[0], row));
      case "floor":
        return Math.floor(this.evaluate(exprs[0], row));
      case "ceiling":
        return Math.ceil(this.evaluate(exprs[0], row));
      case "days difference":
        return moment(this.evaluate(exprs[0], row), moment.ISO_8601).diff(moment(this.evaluate(exprs[1], row), moment.ISO_8601)) / 24 / 3600 / 1000;
      case "today":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).format("YYYY-MM-DD") === moment().format("YYYY-MM-DD");
      case "yesterday":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).add(1, "days").format("YYYY-MM-DD") === moment().format("YYYY-MM-DD");
      case "thismonth":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).format("YYYY-MM") === moment().format("YYYY-MM");
      case "lastmonth":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).add(1, "months").format("YYYY-MM") === moment().format("YYYY-MM");
      case "thisyear":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).format("YYYY") === moment().format("YYYY");
      case "lastyear":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).add(1, "years").format("YYYY") === moment().format("YYYY");
      case "last7days":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(7, "days"));
      case "last30days":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(30, "days"));
      case "last365days":
        date = this.evaluate(exprs[0], row);
        if (!date) {
          return false;
        }
        return moment(date, moment.ISO_8601).isBefore(moment().add(1, "days")) && moment(date, moment.ISO_8601).isAfter(moment().subtract(365, "days"));
      case "latitude":
        point = this.evaluate(exprs[0], row);
        if ((point != null ? point.type : void 0) === "Point") {
          return point.coordinates[1];
        }
        break;
      case "longitude":
        point = this.evaluate(exprs[0], row);
        if ((point != null ? point.type : void 0) === "Point") {
          return point.coordinates[0];
        }
        break;
      case "distance":
        point1 = this.evaluate(exprs[0], row);
        point2 = this.evaluate(exprs[1], row);
        if ((point1 != null ? point1.type : void 0) === "Point" && (point2 != null ? point2.type : void 0) === "Point") {
          return getDistanceFromLatLngInM(point1.coordinates[1], point1.coordinates[0], point2.coordinates[1], point2.coordinates[0]);
        }
    }
  };

  ExprEvaluator.prototype.evaluateCase = function(expr, row) {
    var acase, i, len, ref;
    ref = expr.cases;
    for (i = 0, len = ref.length; i < len; i++) {
      acase = ref[i];
      if (this.evaluate(acase.when, row)) {
        return this.evaluate(acase.then, row);
      }
    }
    return this.evaluate(expr["else"], row);
  };

  ExprEvaluator.prototype.evaluateScalar = function(expr, row) {
    var innerRow;
    if (expr.aggr) {
      throw new Error("Aggr not supported");
    }
    if (expr.joins.length > 1) {
      throw new Error("Multi-joins not supported");
    }
    innerRow = row.getField(expr.joins[0]);
    if (innerRow) {
      return this.evaluate(expr.expr, innerRow);
    } else {
      return null;
    }
  };

  ExprEvaluator.prototype.evaluateScore = function(expr, row) {
    var i, input, len, sum, val;
    if (!expr.input) {
      return null;
    }
    sum = 0;
    input = this.evaluate(expr.input, row);
    if (_.isArray(input)) {
      for (i = 0, len = input.length; i < len; i++) {
        val = input[i];
        if (expr.scores[val]) {
          sum += this.evaluate(expr.scores[val], row);
        }
      }
    } else if (input) {
      if (expr.scores[input]) {
        sum += this.evaluate(expr.scores[input], row);
      }
    }
    return sum;
  };

  return ExprEvaluator;

})();

getDistanceFromLatLngInM = function(lat1, lng1, lat2, lng2) {
  var R, a, c, d, dLat, dLng;
  R = 6370986;
  dLat = deg2rad(lat2 - lat1);
  dLng = deg2rad(lng2 - lng1);
  a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
  c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  d = R * c;
  return d;
};

deg2rad = function(deg) {
  return deg * (Math.PI / 180);
};

},{"lodash":"lodash","moment":19}],11:[function(require,module,exports){
var PriorityDataQueue, PriorityDataSource, _, async;

async = require('async');

_ = require('lodash');

PriorityDataSource = require('./PriorityDataSource');

module.exports = PriorityDataQueue = (function() {
  function PriorityDataQueue(dataSource, concurrency) {
    var worker;
    this.dataSource = dataSource;
    worker = function(query, callback) {
      return _.defer((function(_this) {
        return function() {
          return dataSource.performQuery(query, callback);
        };
      })(this));
    };
    this.performQueryPriorityQueue = new async.priorityQueue(worker, concurrency);
  }

  PriorityDataQueue.prototype.createPriorityDataSource = function(priority) {
    return new PriorityDataSource(this, priority);
  };

  PriorityDataQueue.prototype.performQuery = function(query, cb, priority) {
    return this.performQueryPriorityQueue.push(query, priority, cb);
  };

  PriorityDataQueue.prototype.getImageUrl = function(imageId, height) {
    return this.dataSource.getImageUrl(imageId, height);
  };

  PriorityDataQueue.prototype.kill = function() {
    if (this.performQueryPriorityQueue != null) {
      return this.performQueryPriorityQueue.kill();
    }
  };

  return PriorityDataQueue;

})();

},{"./PriorityDataSource":12,"async":17,"lodash":"lodash"}],12:[function(require,module,exports){
var PriorityDataSource;

module.exports = PriorityDataSource = (function() {
  function PriorityDataSource(priorityDataQueue, priority) {
    this.priorityDataQueue = priorityDataQueue;
    this.priority = priority;
  }

  PriorityDataSource.prototype.performQuery = function(query, cb) {
    return this.priorityDataQueue.performQuery(query, cb, this.priority);
  };

  PriorityDataSource.prototype.getImageUrl = function(imageId, height) {
    return this.priorityDataQueue.getImageUrl(imageId, height);
  };

  return PriorityDataSource;

})();

},{}],13:[function(require,module,exports){
var Schema, _;

_ = require('lodash');

module.exports = Schema = (function() {
  function Schema(json) {
    var i, len, ref, table;
    this.tables = [];
    this.tableMap = {};
    this.columnMap = {};
    if (json) {
      this.tables = json.tables;
      ref = this.tables;
      for (i = 0, len = ref.length; i < len; i++) {
        table = ref[i];
        this.tableMap[table.id] = table;
        this.columnMap[table.id] = this._indexTable(table);
      }
    }
  }

  Schema.prototype._indexTable = function(table) {
    var i, item, len, map, mapContent, ref;
    mapContent = (function(_this) {
      return function(t, map, item) {
        var i, item2, len, ref, results;
        if (item.type === "section") {
          ref = item.contents;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            item2 = ref[i];
            results.push(mapContent(t, map, item2));
          }
          return results;
        } else {
          return map[item.id] = item;
        }
      };
    })(this);
    map = {};
    ref = table.contents;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      mapContent(table, map, item);
    }
    return map;
  };

  Schema.prototype.getTables = function() {
    return this.tables;
  };

  Schema.prototype.getTable = function(tableId) {
    return this.tableMap[tableId];
  };

  Schema.prototype.getColumn = function(tableId, columnId) {
    var map;
    map = this.columnMap[tableId];
    if (!map) {
      return null;
    }
    return map[columnId];
  };

  Schema.prototype.getColumns = function(tableId) {
    var columns, i, item, len, ref, searchContent, table;
    columns = [];
    searchContent = (function(_this) {
      return function(item) {
        var i, item2, len, ref, results;
        if (item.type === "section") {
          ref = item.contents;
          results = [];
          for (i = 0, len = ref.length; i < len; i++) {
            item2 = ref[i];
            results.push(searchContent(item2));
          }
          return results;
        } else {
          return columns.push(item);
        }
      };
    })(this);
    table = this.getTable(tableId);
    ref = table.contents;
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      searchContent(item);
    }
    return columns;
  };

  Schema.prototype.addTable = function(table) {
    var columnMap, schema, tableMap, tables;
    tables = _.filter(this.tables, function(t) {
      return t.id !== table.id;
    });
    tables.push(table);
    tableMap = _.clone(this.tableMap);
    tableMap[table.id] = table;
    columnMap = _.clone(this.columnMap);
    columnMap[table.id] = this._indexTable(table);
    schema = new Schema();
    schema.tables = tables;
    schema.tableMap = tableMap;
    schema.columnMap = columnMap;
    return schema;
  };

  Schema.prototype.toJSON = function() {
    return {
      tables: this.tables
    };
  };

  return Schema;

})();

},{"lodash":"lodash"}],14:[function(require,module,exports){
exports.Schema = require('./Schema');

exports.DataSource = require('./DataSource');

exports.PriorityDataQueue = require('./PriorityDataQueue');

exports.NullDataSource = require('./NullDataSource');

exports.ExprCleaner = require('./ExprCleaner');

exports.ExprValidator = require('./ExprValidator');

exports.ExprUtils = require('./ExprUtils');

exports.ExprCompiler = require('./ExprCompiler');

exports.ExprEvaluator = require('./ExprEvaluator');

exports.OldExprEvaluator = require('./OldExprEvaluator');

exports.injectTableAlias = require('./injectTableAlias');

exports.injectTableAliases = require('./injectTableAliases');

exports.ColumnNotFoundException = require('./ColumnNotFoundException');

},{"./ColumnNotFoundException":1,"./DataSource":2,"./ExprCleaner":3,"./ExprCompiler":4,"./ExprEvaluator":5,"./ExprUtils":6,"./ExprValidator":7,"./NullDataSource":9,"./OldExprEvaluator":10,"./PriorityDataQueue":11,"./Schema":13,"./injectTableAlias":15,"./injectTableAliases":16}],15:[function(require,module,exports){
var _, injectTableAlias, injectTableAliases;

_ = require('lodash');

injectTableAliases = require('./injectTableAliases');

injectTableAlias = function(jsonql, tableAlias) {
  return injectTableAliases(jsonql, {
    "{alias}": tableAlias
  });
};

module.exports = injectTableAlias;

},{"./injectTableAliases":16,"lodash":"lodash"}],16:[function(require,module,exports){
var _, injectTableAliases;

_ = require('lodash');

injectTableAliases = function(jsonql, aliases) {
  if (!jsonql) {
    return jsonql;
  }
  if (_.isArray(jsonql)) {
    return _.map(jsonql, (function(_this) {
      return function(item) {
        return injectTableAliases(item, aliases);
      };
    })(this));
  }
  if (!_.isObject(jsonql)) {
    return jsonql;
  }
  if (jsonql.type === "field" && aliases[jsonql.tableAlias]) {
    return _.extend({}, jsonql, {
      tableAlias: aliases[jsonql.tableAlias]
    });
  }
  return _.mapValues(jsonql, (function(_this) {
    return function(value) {
      return injectTableAliases(value, aliases);
    };
  })(this));
};

module.exports = injectTableAliases;

},{"lodash":"lodash"}],17:[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (typeof arguments[1] === 'function') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var hasError = false;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            if (hasError) return;
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    hasError = true;

                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback.apply(null, [null].concat(args));
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                while(!q.paused && workers < q.concurrency && q.tasks.length){

                    var tasks = q.payload ?
                        q.tasks.splice(0, q.payload) :
                        q.tasks.splice(0, q.tasks.length);

                    var data = _map(tasks, function (task) {
                        return task.data;
                    });

                    if (q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    workersList.push(tasks[0]);
                    var cb = only_once(_next(q, tasks));
                    worker(data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (has.call(memo, key)) {   
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (has.call(queues, key)) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":395}],18:[function(require,module,exports){
module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = require('pseudomap')
var util = require('util')

// A linked list to keep track of recently-used-ness
var Yallist = require('yallist')

// use symbols if possible, otherwise just _props
var symbols = {}
var hasSymbol = typeof Symbol === 'function'
var makeSymbol
/* istanbul ignore if */
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol.for(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

function priv (obj, key, val) {
  var sym
  if (symbols[key]) {
    sym = symbols[key]
  } else {
    sym = makeSymbol(key)
    symbols[key] = sym
  }
  if (arguments.length === 2) {
    return obj[sym]
  } else {
    obj[sym] = val
    return val
  }
}

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = priv(this, 'max', options.max)
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    priv(this, 'max', Infinity)
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  priv(this, 'lengthCalculator', lc)

  priv(this, 'allowStale', options.stale || false)
  priv(this, 'maxAge', options.maxAge || 0)
  priv(this, 'dispose', options.dispose)
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    priv(this, 'max', mL)
    trim(this)
  },
  get: function () {
    return priv(this, 'max')
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    priv(this, 'allowStale', !!allowStale)
  },
  get: function () {
    return priv(this, 'allowStale')
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    priv(this, 'maxAge', mA)
    trim(this)
  },
  get: function () {
    return priv(this, 'maxAge')
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== priv(this, 'lengthCalculator')) {
      priv(this, 'lengthCalculator', lC)
      priv(this, 'length', 0)
      priv(this, 'lruList').forEach(function (hit) {
        hit.length = priv(this, 'lengthCalculator').call(this, hit.value, hit.key)
        priv(this, 'length', priv(this, 'length') + hit.length)
      }, this)
    }
    trim(this)
  },
  get: function () { return priv(this, 'lengthCalculator') },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return priv(this, 'length') },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return priv(this, 'lruList').length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = priv(this, 'lruList').tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!priv(self, 'allowStale')) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = priv(this, 'lruList').head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return priv(this, 'lruList').toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return priv(this, 'lruList').toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (priv(this, 'dispose') &&
      priv(this, 'lruList') &&
      priv(this, 'lruList').length) {
    priv(this, 'lruList').forEach(function (hit) {
      priv(this, 'dispose').call(this, hit.key, hit.value)
    }, this)
  }

  priv(this, 'cache', new Map()) // hash of items by key
  priv(this, 'lruList', new Yallist()) // list of items in order of use recency
  priv(this, 'length', 0) // length of items in the list
}

LRUCache.prototype.dump = function () {
  return priv(this, 'lruList').map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return priv(this, 'lruList')
}

LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = priv(this, 'allowStale')
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = priv(this, 'max')
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = priv(this, 'maxAge')
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = priv(this, 'lengthCalculator')
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(priv(this, 'length'), opts)
    extras = true
  }

  var didFirst = false
  priv(this, 'lruList').forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || priv(this, 'maxAge')

  var now = maxAge ? Date.now() : 0
  var len = priv(this, 'lengthCalculator').call(this, value, key)

  if (priv(this, 'cache').has(key)) {
    if (len > priv(this, 'max')) {
      del(this, priv(this, 'cache').get(key))
      return false
    }

    var node = priv(this, 'cache').get(key)
    var item = node.value

    // dispose of the old one before overwriting
    if (priv(this, 'dispose')) {
      priv(this, 'dispose').call(this, key, item.value)
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    priv(this, 'length', priv(this, 'length') + (len - item.length))
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > priv(this, 'max')) {
    if (priv(this, 'dispose')) {
      priv(this, 'dispose').call(this, key, value)
    }
    return false
  }

  priv(this, 'length', priv(this, 'length') + hit.length)
  priv(this, 'lruList').unshift(hit)
  priv(this, 'cache').set(key, priv(this, 'lruList').head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!priv(this, 'cache').has(key)) return false
  var hit = priv(this, 'cache').get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = priv(this, 'lruList').tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, priv(this, 'cache').get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  priv(this, 'cache').forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = priv(self, 'cache').get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!priv(self, 'allowStale')) hit = undefined
    } else {
      if (doUse) {
        priv(self, 'lruList').unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !priv(self, 'maxAge'))) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = priv(self, 'maxAge') && (diff > priv(self, 'maxAge'))
  }
  return stale
}

function trim (self) {
  if (priv(self, 'length') > priv(self, 'max')) {
    for (var walker = priv(self, 'lruList').tail;
         priv(self, 'length') > priv(self, 'max') && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (priv(self, 'dispose')) {
      priv(self, 'dispose').call(this, hit.key, hit.value)
    }
    priv(self, 'length', priv(self, 'length') - hit.length)
    priv(self, 'cache').delete(hit.key)
    priv(self, 'lruList').removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}

},{"pseudomap":20,"util":1006,"yallist":22}],19:[function(require,module,exports){
//! moment.js
//! version : 2.17.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

function isUndefined(input) {
    return input === void 0;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _ordinalParseLenient.
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return this._months;
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return this._monthsShort;
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var date = new Date(y, m, d, h, M, s, ms);

    //the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    //the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return this._weekdays;
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
        hooks.createFromInputFallback(config);
    }
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }

    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (typeof(input) === 'object') {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString () {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$1 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$1;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this[units + 's']();
}

function makeGetter(name) {
    return function () {
        return this._data[name];
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    s: 45,  // seconds to minute
    m: 45,  // minutes to hour
    h: 22,  // hours to day
    d: 26,  // days to month
    M: 11   // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds < thresholds.s && ['s', seconds]  ||
            minutes <= 1           && ['m']           ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours   <= 1           && ['h']           ||
            hours   < thresholds.h && ['hh', hours]   ||
            days    <= 1           && ['d']           ||
            days    < thresholds.d && ['dd', days]    ||
            months  <= 1           && ['M']           ||
            months  < thresholds.M && ['MM', months]  ||
            years   <= 1           && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
}

function humanize (withSuffix) {
    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.17.0';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],20:[function(require,module,exports){
(function (process){
if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = require('./pseudomap')
}

}).call(this,require('_process'))
},{"./pseudomap":21,"_process":395}],21:[function(require,module,exports){
var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}

},{}],22:[function(require,module,exports){
module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length --
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length ++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length ++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail)
    return undefined

  var res = this.tail.value
  this.tail = this.tail.prev
  this.tail.next = null
  this.length --
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head)
    return undefined

  var res = this.head.value
  this.head = this.head.next
  this.head.prev = null
  this.length --
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null; ) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length ++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length ++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

},{}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @ignore
 * base event object for custom and dom event.
 * @author yiminghe@gmail.com
 */

function returnFalse() {
  return false;
}

function returnTrue() {
  return true;
}

function EventBaseObject() {
  this.timeStamp = Date.now();
  this.target = undefined;
  this.currentTarget = undefined;
}

EventBaseObject.prototype = {
  isEventObject: 1,

  constructor: EventBaseObject,

  isDefaultPrevented: returnFalse,

  isPropagationStopped: returnFalse,

  isImmediatePropagationStopped: returnFalse,

  preventDefault: function preventDefault() {
    this.isDefaultPrevented = returnTrue;
  },
  stopPropagation: function stopPropagation() {
    this.isPropagationStopped = returnTrue;
  },
  stopImmediatePropagation: function stopImmediatePropagation() {
    this.isImmediatePropagationStopped = returnTrue;
    // fixed 1.2
    // call stopPropagation implicitly
    this.stopPropagation();
  },
  halt: function halt(immediate) {
    if (immediate) {
      this.stopImmediatePropagation();
    } else {
      this.stopPropagation();
    }
    this.preventDefault();
  }
};

exports["default"] = EventBaseObject;
module.exports = exports['default'];
},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _EventBaseObject = require('./EventBaseObject');

var _EventBaseObject2 = _interopRequireDefault(_EventBaseObject);

var _objectAssign = require('object-assign');

var _objectAssign2 = _interopRequireDefault(_objectAssign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * @ignore
 * event object for dom
 * @author yiminghe@gmail.com
 */

var TRUE = true;
var FALSE = false;
var commonProps = ['altKey', 'bubbles', 'cancelable', 'ctrlKey', 'currentTarget', 'eventPhase', 'metaKey', 'shiftKey', 'target', 'timeStamp', 'view', 'type'];

function isNullOrUndefined(w) {
  return w === null || w === undefined;
}

var eventNormalizers = [{
  reg: /^key/,
  props: ['char', 'charCode', 'key', 'keyCode', 'which'],
  fix: function fix(event, nativeEvent) {
    if (isNullOrUndefined(event.which)) {
      event.which = !isNullOrUndefined(nativeEvent.charCode) ? nativeEvent.charCode : nativeEvent.keyCode;
    }

    // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
    if (event.metaKey === undefined) {
      event.metaKey = event.ctrlKey;
    }
  }
}, {
  reg: /^touch/,
  props: ['touches', 'changedTouches', 'targetTouches']
}, {
  reg: /^hashchange$/,
  props: ['newURL', 'oldURL']
}, {
  reg: /^gesturechange$/i,
  props: ['rotation', 'scale']
}, {
  reg: /^(mousewheel|DOMMouseScroll)$/,
  props: [],
  fix: function fix(event, nativeEvent) {
    var deltaX = void 0;
    var deltaY = void 0;
    var delta = void 0;
    var wheelDelta = nativeEvent.wheelDelta;
    var axis = nativeEvent.axis;
    var wheelDeltaY = nativeEvent.wheelDeltaY;
    var wheelDeltaX = nativeEvent.wheelDeltaX;
    var detail = nativeEvent.detail;

    // ie/webkit
    if (wheelDelta) {
      delta = wheelDelta / 120;
    }

    // gecko
    if (detail) {
      // press control e.detail == 1 else e.detail == 3
      delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
    }

    // Gecko
    if (axis !== undefined) {
      if (axis === event.HORIZONTAL_AXIS) {
        deltaY = 0;
        deltaX = 0 - delta;
      } else if (axis === event.VERTICAL_AXIS) {
        deltaX = 0;
        deltaY = delta;
      }
    }

    // Webkit
    if (wheelDeltaY !== undefined) {
      deltaY = wheelDeltaY / 120;
    }
    if (wheelDeltaX !== undefined) {
      deltaX = -1 * wheelDeltaX / 120;
    }

    // 默认 deltaY (ie)
    if (!deltaX && !deltaY) {
      deltaY = delta;
    }

    if (deltaX !== undefined) {
      /**
       * deltaX of mousewheel event
       * @property deltaX
       * @member Event.DomEvent.Object
       */
      event.deltaX = deltaX;
    }

    if (deltaY !== undefined) {
      /**
       * deltaY of mousewheel event
       * @property deltaY
       * @member Event.DomEvent.Object
       */
      event.deltaY = deltaY;
    }

    if (delta !== undefined) {
      /**
       * delta of mousewheel event
       * @property delta
       * @member Event.DomEvent.Object
       */
      event.delta = delta;
    }
  }
}, {
  reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
  props: ['buttons', 'clientX', 'clientY', 'button', 'offsetX', 'relatedTarget', 'which', 'fromElement', 'toElement', 'offsetY', 'pageX', 'pageY', 'screenX', 'screenY'],
  fix: function fix(event, nativeEvent) {
    var eventDoc = void 0;
    var doc = void 0;
    var body = void 0;
    var target = event.target;
    var button = nativeEvent.button;

    // Calculate pageX/Y if missing and clientX/Y available
    if (target && isNullOrUndefined(event.pageX) && !isNullOrUndefined(nativeEvent.clientX)) {
      eventDoc = target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = nativeEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = nativeEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }

    // which for click: 1 === left; 2 === middle; 3 === right
    // do not use button
    if (!event.which && button !== undefined) {
      if (button & 1) {
        event.which = 1;
      } else if (button & 2) {
        event.which = 3;
      } else if (button & 4) {
        event.which = 2;
      } else {
        event.which = 0;
      }
    }

    // add relatedTarget, if necessary
    if (!event.relatedTarget && event.fromElement) {
      event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
    }

    return event;
  }
}];

function retTrue() {
  return TRUE;
}

function retFalse() {
  return FALSE;
}

function DomEventObject(nativeEvent) {
  var type = nativeEvent.type;

  var isNative = typeof nativeEvent.stopPropagation === 'function' || typeof nativeEvent.cancelBubble === 'boolean';

  _EventBaseObject2["default"].call(this);

  this.nativeEvent = nativeEvent;

  // in case dom event has been mark as default prevented by lower dom node
  var isDefaultPrevented = retFalse;
  if ('defaultPrevented' in nativeEvent) {
    isDefaultPrevented = nativeEvent.defaultPrevented ? retTrue : retFalse;
  } else if ('getPreventDefault' in nativeEvent) {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
    isDefaultPrevented = nativeEvent.getPreventDefault() ? retTrue : retFalse;
  } else if ('returnValue' in nativeEvent) {
    isDefaultPrevented = nativeEvent.returnValue === FALSE ? retTrue : retFalse;
  }

  this.isDefaultPrevented = isDefaultPrevented;

  var fixFns = [];
  var fixFn = void 0;
  var l = void 0;
  var prop = void 0;
  var props = commonProps.concat();

  eventNormalizers.forEach(function (normalizer) {
    if (type.match(normalizer.reg)) {
      props = props.concat(normalizer.props);
      if (normalizer.fix) {
        fixFns.push(normalizer.fix);
      }
    }
  });

  l = props.length;

  // clone properties of the original event object
  while (l) {
    prop = props[--l];
    this[prop] = nativeEvent[prop];
  }

  // fix target property, if necessary
  if (!this.target && isNative) {
    this.target = nativeEvent.srcElement || document; // srcElement might not be defined either
  }

  // check if target is a text node (safari)
  if (this.target && this.target.nodeType === 3) {
    this.target = this.target.parentNode;
  }

  l = fixFns.length;

  while (l) {
    fixFn = fixFns[--l];
    fixFn(this, nativeEvent);
  }

  this.timeStamp = nativeEvent.timeStamp || Date.now();
}

var EventBaseObjectProto = _EventBaseObject2["default"].prototype;

(0, _objectAssign2["default"])(DomEventObject.prototype, EventBaseObjectProto, {
  constructor: DomEventObject,

  preventDefault: function preventDefault() {
    var e = this.nativeEvent;

    // if preventDefault exists run it on the original event
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      // otherwise set the returnValue property of the original event to FALSE (IE)
      e.returnValue = FALSE;
    }

    EventBaseObjectProto.preventDefault.call(this);
  },
  stopPropagation: function stopPropagation() {
    var e = this.nativeEvent;

    // if stopPropagation exists run it on the original event
    if (e.stopPropagation) {
      e.stopPropagation();
    } else {
      // otherwise set the cancelBubble property of the original event to TRUE (IE)
      e.cancelBubble = TRUE;
    }

    EventBaseObjectProto.stopPropagation.call(this);
  }
});

exports["default"] = DomEventObject;
module.exports = exports['default'];
},{"./EventBaseObject":23,"object-assign":373}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = addEventListener;

var _EventObject = require('./EventObject');

var _EventObject2 = _interopRequireDefault(_EventObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function addEventListener(target, eventType, callback) {
  function wrapCallback(e) {
    var ne = new _EventObject2["default"](e);
    callback.call(target, ne);
  }

  if (target.addEventListener) {
    target.addEventListener(eventType, wrapCallback, false);
    return {
      remove: function remove() {
        target.removeEventListener(eventType, wrapCallback, false);
      }
    };
  } else if (target.attachEvent) {
    target.attachEvent('on' + eventType, wrapCallback);
    return {
      remove: function remove() {
        target.detachEvent('on' + eventType, wrapCallback);
      }
    };
  }
}
module.exports = exports['default'];
},{"./EventObject":24}],26:[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":27}],27:[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof global !== "undefined" ? global : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],28:[function(require,module,exports){

module.exports = function(asyncFunc, options) {
	if (options && options.serial) {
		var inProgress = false;
		var pending = null;

		return function() {
			// If in progress, set pending and return
			if (inProgress) {
				pending = arguments;
				return;
			}

			// Set inProgress
			inProgress = true;

			// Process arguments and call 
			function process(args) {
				// Copy args
				var argsCopy = [];
				for (var i = 0; i < args.length; i++) {
					argsCopy.push(args[i]);
				}
				var callback = argsCopy[argsCopy.length - 1];

				newCallback = function() {
					// If pending, ignore result and call pending
					if (pending) {
						// Reset pending
						var pendingCopy = pending;
						pending = null;
						return process(pendingCopy);
					}
					else {
						inProgress = false;
						callback.apply(null, arguments);
					}
				};

				argsCopy[argsCopy.length - 1] = newCallback;
				asyncFunc.apply(null, argsCopy);
			};

			process(arguments);
		}
	}
	else {
		var callNum = 0;

		// Non-serial. Only take latest call
		return function() {
			// Save call number for this function
			callNum++;
			var myCallNum = callNum;

			// Call function with args, but replace callback function
			var args = [];
			for (var i = 0; i< arguments.length - 1; i++) {
				args[i] = arguments[i];
			}
			callback = arguments[arguments.length - 1];

			var newCallback = function() {
				// If not latest call, ignore
				if (myCallNum != callNum)
					return;

				// Call callback
				callback.apply(null, arguments);
			};

			// Call function with new callback
			args.push(newCallback);
			asyncFunc.apply(null, args);
		}
	}
}
},{}],29:[function(require,module,exports){
arguments[4][17][0].apply(exports,arguments)
},{"_process":395,"dup":17}],30:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":42}],31:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
},{"core-js/library/fn/object/create":43}],32:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":44}],33:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
},{"core-js/library/fn/object/set-prototype-of":45}],34:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":46}],35:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":47}],36:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
},{}],37:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _assign = require("../core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
},{"../core-js/object/assign":30}],38:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _setPrototypeOf = require("../core-js/object/set-prototype-of");

var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

var _create = require("../core-js/object/create");

var _create2 = _interopRequireDefault(_create);

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
  }

  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
};
},{"../core-js/object/create":31,"../core-js/object/set-prototype-of":33,"../helpers/typeof":41}],39:[function(require,module,exports){
"use strict";

exports.__esModule = true;

exports.default = function (obj, keys) {
  var target = {};

  for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;
    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;
    target[i] = obj[i];
  }

  return target;
};
},{}],40:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _typeof2 = require("../helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
};
},{"../helpers/typeof":41}],41:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":34,"../core-js/symbol/iterator":35}],42:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;
},{"../../modules/_core":53,"../../modules/es6.object.assign":108}],43:[function(require,module,exports){
require('../../modules/es6.object.create');
var $Object = require('../../modules/_core').Object;
module.exports = function create(P, D){
  return $Object.create(P, D);
};
},{"../../modules/_core":53,"../../modules/es6.object.create":109}],44:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/_core').Object.entries;
},{"../../modules/_core":53,"../../modules/es7.object.entries":114}],45:[function(require,module,exports){
require('../../modules/es6.object.set-prototype-of');
module.exports = require('../../modules/_core').Object.setPrototypeOf;
},{"../../modules/_core":53,"../../modules/es6.object.set-prototype-of":110}],46:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;
},{"../../modules/_core":53,"../../modules/es6.object.to-string":111,"../../modules/es6.symbol":113,"../../modules/es7.symbol.async-iterator":115,"../../modules/es7.symbol.observable":116}],47:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');
},{"../../modules/_wks-ext":105,"../../modules/es6.string.iterator":112,"../../modules/web.dom.iterable":117}],48:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],49:[function(require,module,exports){
module.exports = function(){ /* empty */ };
},{}],50:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":69}],51:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":97,"./_to-iobject":99,"./_to-length":100}],52:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],53:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],54:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":48}],55:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],56:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":61}],57:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":62,"./_is-object":69}],58:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],59:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":84,"./_object-keys":87,"./_object-pie":88}],60:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , ctx       = require('./_ctx')
  , hide      = require('./_hide')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , IS_WRAP   = type & $export.W
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE]
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
    , key, own, out;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if(own && key in exports)continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function(C){
      var F = function(a, b, c){
        if(this instanceof C){
          switch(arguments.length){
            case 0: return new C;
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if(IS_PROTO){
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":53,"./_ctx":54,"./_global":62,"./_hide":64}],61:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],62:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],63:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],64:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":56,"./_object-dp":79,"./_property-desc":90}],65:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":62}],66:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":56,"./_dom-create":57,"./_fails":61}],67:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":52}],68:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":52}],69:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],70:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":64,"./_object-create":78,"./_property-desc":90,"./_set-to-string-tag":93,"./_wks":106}],71:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":60,"./_has":63,"./_hide":64,"./_iter-create":70,"./_iterators":73,"./_library":75,"./_object-gpo":85,"./_redefine":91,"./_set-to-string-tag":93,"./_wks":106}],72:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],73:[function(require,module,exports){
module.exports = {};
},{}],74:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":87,"./_to-iobject":99}],75:[function(require,module,exports){
module.exports = true;
},{}],76:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":61,"./_has":63,"./_is-object":69,"./_object-dp":79,"./_uid":103}],77:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":61,"./_iobject":67,"./_object-gops":84,"./_object-keys":87,"./_object-pie":88,"./_to-object":101}],78:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":50,"./_dom-create":57,"./_enum-bug-keys":58,"./_html":65,"./_object-dps":80,"./_shared-key":94}],79:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":50,"./_descriptors":56,"./_ie8-dom-define":66,"./_to-primitive":102}],80:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":50,"./_descriptors":56,"./_object-dp":79,"./_object-keys":87}],81:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":56,"./_has":63,"./_ie8-dom-define":66,"./_object-pie":88,"./_property-desc":90,"./_to-iobject":99,"./_to-primitive":102}],82:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":83,"./_to-iobject":99}],83:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":58,"./_object-keys-internal":86}],84:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],85:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":63,"./_shared-key":94,"./_to-object":101}],86:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":51,"./_has":63,"./_shared-key":94,"./_to-iobject":99}],87:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":58,"./_object-keys-internal":86}],88:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],89:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":87,"./_object-pie":88,"./_to-iobject":99}],90:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],91:[function(require,module,exports){
module.exports = require('./_hide');
},{"./_hide":64}],92:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":50,"./_ctx":54,"./_is-object":69,"./_object-gopd":81}],93:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":63,"./_object-dp":79,"./_wks":106}],94:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":95,"./_uid":103}],95:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":62}],96:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":55,"./_to-integer":98}],97:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":98}],98:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],99:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":55,"./_iobject":67}],100:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":98}],101:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":55}],102:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":69}],103:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],104:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":53,"./_global":62,"./_library":75,"./_object-dp":79,"./_wks-ext":105}],105:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":106}],106:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":62,"./_shared":95,"./_uid":103}],107:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":49,"./_iter-define":71,"./_iter-step":72,"./_iterators":73,"./_to-iobject":99}],108:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":60,"./_object-assign":77}],109:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":60,"./_object-create":78}],110:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":60,"./_set-proto":92}],111:[function(require,module,exports){

},{}],112:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":71,"./_string-at":96}],113:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":50,"./_descriptors":56,"./_enum-keys":59,"./_export":60,"./_fails":61,"./_global":62,"./_has":63,"./_hide":64,"./_is-array":68,"./_keyof":74,"./_library":75,"./_meta":76,"./_object-create":78,"./_object-dp":79,"./_object-gopd":81,"./_object-gopn":83,"./_object-gopn-ext":82,"./_object-gops":84,"./_object-keys":87,"./_object-pie":88,"./_property-desc":90,"./_redefine":91,"./_set-to-string-tag":93,"./_shared":95,"./_to-iobject":99,"./_to-primitive":102,"./_uid":103,"./_wks":106,"./_wks-define":104,"./_wks-ext":105}],114:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":60,"./_object-to-array":89}],115:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":104}],116:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":104}],117:[function(require,module,exports){
require('./es6.array.iterator');
var global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , TO_STRING_TAG = require('./_wks')('toStringTag');

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype;
  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}
},{"./_global":62,"./_hide":64,"./_iterators":73,"./_wks":106,"./es6.array.iterator":107}],118:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],119:[function(require,module,exports){
/* MIT license */
var cssKeywords = require('color-name');

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};

},{"color-name":123}],120:[function(require,module,exports){
var conversions = require('./conversions');
var route = require('./route');

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

module.exports = convert;

},{"./conversions":119,"./route":121}],121:[function(require,module,exports){
var conversions = require('./conversions');

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

// https://jsperf.com/object-keys-vs-for-in-with-closure/3
var models = Object.keys(conversions);

function buildGraph() {
	var graph = {};

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

module.exports = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};


},{"./conversions":119}],122:[function(require,module,exports){
!function() {
    var c_c = {};

    c_c.VERSION = '0.0.1';

    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = c_c;
        }
        exports.c_c = c_c;
    } else {
        this.c_c = c_c;
    }

    // color viewing helper for browser console
    c_c.print = function (color){
        var bg, fg, data;
        if(typeof window === 'undefined'){
            if(Array.isArray(color)){
                color.map(function(c){
                    console.log(c.hex() +' : '+c.command)
                })
                return;
            }else{
                console.log(color.hex());
                return color.hex();
            }
        }

        if(Array.isArray(color)){
            color.forEach(function(c){
                var value = c.values();
                bg = value.hex;
                fg = value.hsl[2] > 50 ? '#000000' : '#ffffff';
                blockCss = 'background:'+bg+'; color:'+fg+'; font-size:45px;';
                guideCss = 'background:'+bg+'; color:'+fg+'; font-size:10px;';
                console.log('%c  ', blockCss);
                console.log('%c '+bg+' ', guideCss);
                console.log(c.command);
            });
            return {
                hex: color.map(function(c){ return c.hex(); }),
                rgba: color.map(function(c){ return c.rgba(); }),
                hsl: color.map(function(c){ return c.hsl(); })
            }
        }

        if(color.values){
            bg = color.hex();
            fg = color.hsl()[2]>50 ? '#000000' : '#ffffff';
        }else{
            bg = color.hex;
            fg = '#ffffff';
        }
        blockCss = 'background:'+bg+';color:'+fg+';font-size:45px;';
        guideCss = 'background:'+bg+';color:'+fg+';font-size:10px;';
        console.log('%c  ', blockCss);
        console.log('%c '+bg+' ', guideCss);
        console.log(color.command);

        return [color.hex()];
    };

    //  base color object constructor
    var Color = c_c.Color = function(opt){
        var rgbaval, hexval, hslaval, name;

        this.command = 'base';
        this.subcolors = [];

        this.hex = function(str){
            if(arguments.length <= 0){ return hexval; }
            hexval  = str.toLowerCase();
            rgbaval = hexToRGB(hexval);
            hslaval = rgbToHSL(rgbaval);
            name    = hexToName(hexval);
        };

        this.rgb = function(r,g,b){
            if(arguments.length <= 0){ return rgbaval.slice(0,3); }
            this.rgba(r,g,b,1);
        };

        this.rgba = function(r,g,b,a){
            if(arguments.length <= 0){ return rgbaval; }
            rgbaval = [r,g,b,a];
            hexval  = rgbToHEX(rgbaval);
            hslaval = rgbToHSL(rgbaval);
            name    = hexToName(hexval);
        };

        this.hsl = function(h,s,l){
            if(arguments.length <= 0){ return hslaval.slice(0,3); }
            this.hsla(h,s,l,1);
        };

        this.hsla = function(h,s,l,a){
            if(arguments.length <= 0){ return hslaval; }
            hslaval = [h,s,l,a];
            rgbaval = hslToRGB(hslaval);
            hexval  = rgbToHEX(rgbaval);
            name    = hexToName(hexval);
        };

        this.mix = function(color1, color2, w){
            var weight = w ? w : 50,
                base   = color1.rgba(),
                brend  = color2.rgba(),
                newcolor = base.map(function(c,i){
                    if(i === 3){
                        return brend[i] + (c - brend[i]) * (weight / 100);
                    }
                    return Math.floor(brend[i] + (c - brend[i]) * (weight / 100));
                });

            rgbaval = newcolor;
            hexval  = rgbToHEX(rgbaval);
            hslaval = rgbToHSL(rgbaval);
            name    = hexToName(hexval);
        };

        this.name = function(str) {
            if(arguments.length <= 0){ return name;} 
            if (getKeys(colorDict).indexOf(str) < 0){ return; }
            hexval  = colorDict[str];
            rgbaval = hexToRGB(hexval);
            hslaval = rgbToHSL(rgbaval);
            name    = hexToName(hexval);
        };

        this.values = function(){
            return {rgb: this.rgb(),
                    rgba: this.rgba(),
                    hex: this.hex(),
                    hsl: this.hsl(),
                    hsla: this.hsla(),
                    name: name};
        };

        this.set = function(opt){
            var options = {
                            hex: function(arg){ this.hex.call(this,arg); },
                            rgb: function(arg){ this.rgb.apply(this,arg); },
                            rgba: function(arg){ this.rgba.apply(this,arg); },
                            hsl: function(arg){ this.hsl.apply(this,arg); },
                            hsla: function(arg){ this.hsla.apply(this,arg); },
                            mix: function(arg){ this.mix.apply(this,arg); },
                            name: function(arg){ this.name.call(this,arg); }
                        },
                key = getKeys(opt)[0];
            options[key].call(this,opt[key]);
        };

        if(opt){ this.set(opt); }
    };

    Color.prototype = {
        red: function(){
           return this.hex().substr(1, 2);
        },
        green: function(){
            return this.hex().substr(3, 2);
        },
        blue: function(){
            return this.hex().substr(5, 2);
        },
        hue: function(){
            return this.hsl()[0];
        },
        saturation: function(){
            return this.hsl()[1];
        },
        lightness: function(){
            return this.hsl()[2];
        },
        alpha: function(){
            return this.rgba()[3];
        },
        opacity: function(){
            return this.alpha();
        },
        subcolormix: function(c1, c2, w, save) {
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.subcolormix(c1, c2, w, false);
                            },
                            'subcolormix('+c1.command+','+c2.command+','+w+')'
                        );
            }
            var weight = w ? w : 50,
                base = c1.rgba(),
                brend = c2.rgba(),
                newcolor = base.map(function(c,i){
                    if(i === 3){ return brend[i] + (c - brend[i]) * (weight / 100); }
                    return Math.floor(brend[i] + (c - brend[i]) * (weight / 100));
                });
            return {rgb: newcolor.slice(0, 3),
                    rgba: newcolor,
                    hex: rgbToHEX(newcolor),
                    hsl: rgbToHSL(newcolor),
                    hsla: rgbToHSL(newcolor).concat([newcolor[3]])};
        },
        invert: function(save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.invert(false); },
                            'invert()'
                        );
            }
            var inverted = this.rgba().map(function(c,i){
                if(i === 3) { return c; }
                return 255 - c;
            });
            return {rgb: inverted.slice(0, 3),
                    rgba: inverted,
                    hex: rgbToHEX(inverted),
                    hsl: rgbToHSL(inverted),
                    hsla: rgbToHSL(inverted).concat([inverted[3]])};
        },
        adjust_red: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.adjust_red(deg, scale, false);
                            },
                            'adjust_red('+deg+','+scale+')'
                        );
            }
            var hsla,
                rgba = this.rgba().slice(0);

            if(deg){
                rgba[0] = Math.max(Math.min(rgba[0] + deg, 255),0);
            }else{
                scale >= 0
                    ? rgba[0] = Math.floor((255 - rgba[0]) * scale/100 + rgba[0])
                    : rgba[0] = Math.floor(rgba[0] * Math.abs(scale)/100);
            }

            hsla = rgbToHSL(rgba);
            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_green: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ 
                                return this.adjust_green(deg, scale, false);
                            },
                            'adjust_green('+deg+','+scale+')'
                        );
            }
            var hsla,
                rgba = this.rgba().slice(0);

            if(deg){
                rgba[1] = Math.max(Math.min(rgba[1] + deg, 255),0);
            }else{
                scale>=0
                ? rgba[1] = Math.floor((255-rgba[1])*scale/100+rgba[1])
                : rgba[1] = Math.floor(rgba[1]*Math.abs(scale)/100);
            }

            hsla = rgbToHSL(rgba);
            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_blue: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.adjust_blue(deg, scale, false);
                            },
                            'adjust_blue('+deg+','+scale+')'
                        );
            }
            var hsla,
                rgba = this.rgba().slice(0);

            if(deg){
                rgba[2] = Math.max(Math.min(rgba[2] + deg, 255),0);
            }else{
                scale >= 0
                    ? rgba[2] = Math.floor((255 - rgba[2]) * scale/100 + rgba[2])
                    : rgba[2] = Math.floor(rgba[2] * Math.abs(scale)/100);
            }

            hsla = rgbToHSL(rgba);
            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_hue: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.adjust_hue(deg, false); },
                            'adjust_hue('+deg+')'
                        );
            }
            var rgb,
                hsla = this.hsla().slice(0),
                diff = 360 - (hsla[0] + deg);

            hsla[0] = diff > 360 ? 360 - (diff % 360) : Math.abs(diff % 360);
            rgba = hslToRGB(hsla);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_saturation: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.adjust_saturation(deg, scale, false);
                            },
                            'adjust_saturation('+deg+','+scale+')'
                        );
            }
            var rgb,
                hsla = this.hsla().slice(0);

            if(deg){
                hsla[1] = Math.max(Math.min(hsla[1] + deg, 100),0);
            }else{
                scale >= 0
                    ? hsla[1] = Math.floor((100 - hsla[1]) * scale/100 + hsla[1])
                    : hsla[1] = Math.floor(hsla[1] * Math.abs(scale)/100);
            }

            rgba = hslToRGB(hsla);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_lightness: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.adjust_lightness(deg, scale, false);
                            },
                            'adjust_lightness('+deg+','+scale+')'
                        );
            }
            var rgb,
                hsla = this.hsla().slice(0);

            if(deg){
                hsla[2] = Math.max(Math.min(hsla[2] + deg, 100),0);
            }else{
                scale >= 0
                    ? hsla[2] = Math.floor((100 - hsla[2]) * scale/100 + hsla[2])
                    : hsla[2] = Math.floor(hsla[2] * Math.abs(scale)/100);
            }

            rgba = hslToRGB(hsla);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        adjust_alpha: function(deg,scale,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){
                                return this.adjust_alpha(deg, scale, false);
                            },
                            'adjust_alpha('+deg+','+scale+')'
                        );
            }
            var rgba = this.rgba().slice(0),
                hsla = this.hsla().slice(0),
                a;

            if(deg){
                a = Math.round(Math.max(Math.min(this.alpha(color) + deg, 1),0) * 100)/100;
            }else{
                scale >= 0
                    ? a = Math.floor((1 - this.alpha(color)) * scale + (this.alpha(color) * 100))/100
                    : a = Math.floor(this.alpha(color) * Math.abs(scale))/100;
            }

            rgba[3] = a;
            hsla[3] = a;
            return {rgba: rgba,
                    hsla: hsla};
        },
        complement: function(save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.complement(false); },
                            'complement()'
                        );
            }
            return this.adjust_hue(180, false);
        },
        saturate: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.saturate(deg, false); },
                            'saturate('+deg+')'
                        );
            }
            return this.adjust_saturation(deg, false);
        },
        desaturate: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.desaturate(-deg, false); },
                            'desaturate('+deg+')'
                        );
            }
            return this.adjust_saturation(-deg, false);
        },
        grayscale: function(save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.grayscale(false); },
                            'grayscale()'
                        );
            }
            return this.adjust_saturation(100, false);
        },
        lighten: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.lighten(deg, false); },
                            'lighten('+deg+')'
                        );
            }
            return this.adjust_lightness(deg, false, false);
        },
        darken: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.darken(deg, false); },
                            'darken('+deg+')'
                        );
            }
            return this.adjust_lightness(-deg, false, false);
        },
        opacify: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.opacify(deg, false); },
                            'opacify('+deg+')'
                        );
            }
            return this.adjust_alpha(deg, false);
        },
        transparentize: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.transparentize(deg, false); },
                            'transparentize('+deg+')'
                        );
            }
            return this.adjust_alpha(-deg, false);
        },
        fade_in: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.fade_in(deg, false); },
                            'fade_in('+deg+')'
                        );
            }
            return this.adjust_alpha(deg, false);
        },
        fade_out: function(deg,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.fade_out(deg, false); },
                            'fade_out('+deg+')'
                        );
            }
            return this.adjust_alpha(-deg, false);
        },
        adjust_color: function(opt,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.adjust_color(opt, false); },
                            'adjust_color('+opt+')'
                        );
            }
            var rgba = this.rgba().slice(0),
                hsla = this.hsla().slice(0),
                operations = {
                    red: function(deg){ rgba[0] = this.adjust_red(deg,false,save).rgba[0]; },
                    green: function(deg){ rgba[1] = this.adjust_green(deg,false,save).rgba[1]; },
                    blue: function(deg){ rgba[2] = this.adjust_blue(deg,false,save).rgba[2]; },
                    hue: function(deg){ hsla[0] = this.adjust_hue(deg,save).hsla[0]; },
                    saturation: function(deg){ hsla[1] = this.adjust_saturation(deg,false,save).hsla[1]; },
                    lightoness: function(deg){ hsla[2] = this.adjust_lightness(deg,false,save).hsla[2]; },
                    alpha: function(deg){
                            var a =  this.adjust_alpha(deg,false,save).hsla[3];
                            rgba[3] = a;
                            hsla[3] = a;
                        }
                };

            getKeys(opt).forEach(function(key){
                operations[key].call(this,opt[key]);
            },this);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        scale_color: function(opt,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.scale_color(opt, save); },
                            'scale_color('+opt+')'
                        );
            }
            var rgba = this.rgba().slice(0),
                hsla = this.hsla().slice(0),
                operations = {
                    red: function(scale){ rgba[0] = this.adjust_red(null,scale,save).rgba[0]; },
                    green: function(scale){ rgba[1] = this.adjust_green(null,scale,save).rgba[1]; },
                    blue: function(scale){ rgba[2] = this.adjust_blue(null,scale,save).rgba[2]; },
                    saturation: function(scale){ hsla[1] = this.adjust_saturation(null,scale,save).hsla[1]; },
                    lightness: function(scale){ hsla[2] = this.adjust_lightness(null,scale,save).hsla[2]; },
                    alpha: function(scale){
                            var a =  this.adjust_alpha(null,scale,save).hsla[3];
                            rgba[3] = a;
                            hsla[3] = a;
                        }
                };

            getKeys(opt).forEach(function(key){
                operations[key].call(this,opt[key]);
            },this);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },
        change_color: function(opt,save){
            if(save===undefined||save===true){
                return addSubColor
                        .call(
                            this,
                            function(){ return this.change_color(opt, false); },
                            'change_color('+opt+')'
                        );
            }
            var rgba = this.rgba().slice(0),
                hsla = this.hsla().slice(0),
                operations = {
                    red: function(val){ rgba[0] = val; },
                    green: function(val){ rgba[1] = val; },
                    blue: function(val){ rgba[2] = val; },
                    hue: function(val){ hsla[0] = val; },
                    saturation: function(val){ hsla[1] = val; },
                    lightness: function(val){ hsla[2] = val; },
                    alpha: function(val){
                            rgba[3] = val;
                            hsla[3] = val;
                        }
                };

            Object.keys(opt).forEach(function(key){
                operations[key].call(this,opt[key]);
            },this);

            return {rgb: rgba.slice(0, 3),
                    rgba: rgba,
                    hex: rgbToHEX(rgba),
                    hsl: hsla.slice(0, 3),
                    hsla: hsla};
        },

        // Color Sets
        lighten_set: function(n){
            var arr = [this];
            var step = 100/ n;
            for(var i=1;i<n;i++){
                arr.push(this.adjust_lightness(null, step*i))
            }
            return arr;
        },
        darken_set: function(n){
            var arr = [this];
            var step = 100/ n;
            for(var i=n-1;i>0;i--){
                arr.push(this.adjust_lightness(null, -(step*i)))
            }
            return arr;
        },
        complement_set: function(n){
            var base = this,
                comp = this.complement(),
                arr = [],
                step = 100/ (n-1);

            for(var i=n-1;i>=0;i--){
                if(i==n-1){arr.push(base);
                }else if(i==0){arr.push(comp);
                }else{arr.push(this.subcolormix(base, comp, step*i))}
            }
            return arr;
        },
        invert_set: function(n){
            var base = this,
                inv = this.invert();
                arr = [],
                step = 100/ (n-1);

            for(var i=n-1;i>=0;i--){
                if(i==n-1){arr.push(base);
                }else if(i==0){arr.push(inv);
                }else{arr.push(this.subcolormix(base, inv, step*i))}
            }
            return arr;
        },
        desaturate_set: function(n){
            var arr = [this];
            var step = 100/ n;
            for(var i=n-1;i>0;i--){
                arr.push(this.adjust_saturation(null, -(step*i)))
            }
            return arr;
        }
    };

    var SubColor = function(parent,func,command){
        this.parent = parent;
        this.command = command;
        this.values = function(){
            return func.call(this.parent);
        };
        this.rgba = function(){
            return this.values().rgba;
        };
        this.rgb = function(){
            return this.values().rgb;
        };
        this.hex = function(){
            return this.values().hex;
        };
        this.hsla = function(){
            return this.values().hsla;
        };
        this.hsl = function(){
            return this.values().hsl;
        };
    };

    SubColor.prototype = {
        red: function(){
           return this.hex().substr(1, 2);
        },
        green: function(){
            return this.hex().substr(3, 2);
        },
        blue: function(){
            return this.hex().substr(5, 2);
        },
        hue: function(){
            return this.hsl()[0];
        },
        saturation: function(){
            return this.hsl()[1];
        },
        lightness: function(){
            return this.hsl()[2];
        },
        alpha: function(){
            return this.rgba()[3];
        },
        opacity: function(){
            return this.alpha();
        }
    };

    var colorDict = {
            'aqua': '#00ffff',
            'aliceblue': '#f0f8ff',
            'antiquewhite': '#faebd7',
            'black': '#000000',
            'blue': '#0000ff',
            'cyan': '#00ffff',
            'darkblue': '#00008b',
            'darkcyan': '#008b8b',
            'darkgreen': '#006400',
            'darkturquoise': '#00ced1',
            'deepskyblue': '#00bfff',
            'green': '#008000',
            'lime': '#00ff00',
            'mediumblue': '#0000cd',
            'mediumspringgreen': '#00fa9a',
            'navy': '#000080',
            'springgreen': '#00ff7f',
            'teal': '#008080',
            'midnightblue': '#191970',
            'dodgerblue': '#1e90ff',
            'lightseagreen': '#20b2aa',
            'forestgreen': '#228b22',
            'seagreen': '#2e8b57',
            'darkslategray': '#2f4f4f',
            'darkslategrey': '#2f4f4f',
            'limegreen': '#32cd32',
            'mediumseagreen': '#3cb371',
            'turquoise': '#40e0d0',
            'royalblue': '#4169e1',
            'steelblue': '#4682b4',
            'darkslateblue': '#483d8b',
            'mediumturquoise': '#48d1cc',
            'indigo': '#4b0082',
            'darkolivegreen': '#556b2f',
            'cadetblue': '#5f9ea0',
            'cornflowerblue': '#6495ed',
            'mediumaquamarine': '#66cdaa',
            'dimgray': '#696969',
            'dimgrey': '#696969',
            'slateblue': '#6a5acd',
            'olivedrab': '#6b8e23',
            'slategray': '#708090',
            'slategrey': '#708090',
            'lightslategray': '#778899',
            'lightslategrey': '#778899',
            'mediumslateblue': '#7b68ee',
            'lawngreen': '#7cfc00',
            'aquamarine': '#7fffd4',
            'chartreuse': '#7fff00',
            'gray': '#808080',
            'grey': '#808080',
            'maroon': '#800000',
            'olive': '#808000',
            'purple': '#800080',
            'lightskyblue': '#87cefa',
            'skyblue': '#87ceeb',
            'blueviolet': '#8a2be2',
            'darkmagenta': '#8b008b',
            'darkred': '#8b0000',
            'saddlebrown': '#8b4513',
            'darkseagreen': '#8fbc8f',
            'lightgreen': '#90ee90',
            'mediumpurple': '#9370db',
            'darkviolet': '#9400d3',
            'palegreen': '#98fb98',
            'darkorchid': '#9932cc',
            'yellowgreen': '#9acd32',
            'sienna': '#a0522d',
            'brown': '#a52a2a',
            'darkgray': '#a9a9a9',
            'darkgrey': '#a9a9a9',
            'greenyellow': '#adff2f',
            'lightblue': '#add8e6',
            'paleturquoise': '#afeeee',
            'lightsteelblue': '#b0c4de',
            'powderblue': '#b0e0e6',
            'firebrick': '#b22222',
            'darkgoldenrod': '#b8860b',
            'mediumorchid': '#ba55d3',
            'rosybrown': '#bc8f8f',
            'darkkhaki': '#bdb76b',
            'silver': '#c0c0c0',
            'mediumvioletred': '#c71585',
            'indianred': '#cd5c5c',
            'peru': '#cd853f',
            'chocolate': '#d2691e',
            'tan': '#d2b48c',
            'lightgray': '#d3d3d3',
            'lightgrey': '#d3d3d3',
            'thistle': '#d8bfd8',
            'goldenrod': '#daa520',
            'orchid': '#da70d6',
            'palevioletred': '#db7093',
            'crimson': '#dc143c',
            'gainsboro': '#dcdcdc',
            'plum': '#dda0dd',
            'burlywood': '#deb887',
            'lightcyan': '#e0ffff',
            'lavender': '#e6e6fa',
            'darksalmon': '#e9967a',
            'palegoldenrod': '#eee8aa',
            'violet': '#ee82ee',
            'azure': '#f0ffff',
            'honeydew': '#f0fff0',
            'khaki': '#f0e68c',
            'lightcoral': '#f08080',
            'sandybrown': '#f4a460',
            'beige': '#f5f5dc',
            'mintcream': '#f5fffa',
            'wheat': '#f5deb3',
            'whitesmoke': '#f5f5f5',
            'ghostwhite': '#f8f8ff',
            'lightgoldenrodyellow': '#fafad2',
            'linen': '#faf0e6',
            'salmon': '#fa8072',
            'oldlace': '#fdf5e6',
            'bisque': '#ffe4c4',
            'blanchedalmond': '#ffebcd',
            'coral': '#ff7f50',
            'cornsilk': '#fff8dc',
            'darkorange': '#ff8c00',
            'deeppink': '#ff1493',
            'floralwhite': '#fffaf0',
            'fuchsia': '#ff00ff',
            'gold': '#ffd700',
            'hotpink': '#ff69b4',
            'ivory': '#fffff0',
            'lavenderblush': '#fff0f5',
            'lemonchiffon': '#fffacd',
            'lightpink': '#ffb6c1',
            'lightsalmon': '#ffa07a',
            'lightyellow': '#ffffe0',
            'magenta': '#ff00ff',
            'mistyrose': '#ffe4e1',
            'moccasin': '#ffe4b5',
            'navajowhite': '#ffdead',
            'orange': '#ffa500',
            'orangered': '#ff4500',
            'papayawhip': '#ffefd5',
            'peachpuff': '#ffdab9',
            'pink': '#ffc0cb',
            'red': '#ff0000',
            'seashell': '#fff5ee',
            'snow': '#fffafa',
            'tomato': '#ff6347',
            'white': '#ffffff',
            'yellow': '#ffff00',
            'rebeccapurple': '#663399',
        };

    function subColorIndex(command){
        var arr = pluck(this.subcolors, 'command');
        return arr.indexOf(command);
    }
    function addSubColor(fn, command){
            if(subColorIndex.call(this, command) === -1){
                var sub = new SubColor(this, fn, command);
                this.subcolors.push(sub);
            }
            return this.subcolors[subColorIndex.call(this, command)];
        }
    function pluck(arr,key){
        return arr.map(function(d){ return d[key]; });
    }
    function getKeys(obj){
        return Object.keys(obj);
    }

    function getValues(obj){
        return  getKeys(obj).map(function(k){ return obj[k]; });
    }

    function findValue(obj,keyword){
        return getKeys(obj)[getValues(obj).indexOf(keyword)];
    }

    function hexToName(hex){
        return findValue(colorDict,hex);
    }

    // Conversion Functions
    function rgbToHEX(rgba){
        var rgb = rgba.slice(0,3);
        function d2h(d) {
            var hex = d.toString(16);
            hex = '00'.substr( 0, 2 - hex.length ) + hex;
            return hex;
        }

        return '#'+rgb.map(d2h).join('').toLowerCase();
    }

    function hexToRGB(hex){

        function h2d(h) {
            var decimal = parseInt(h, 16);
            return decimal;
        }

        return [
            h2d(hex.substr(1,2)),
            h2d(hex.substr(3,2)),
            h2d(hex.substr(5,2)),
        ].concat([1]);
    }

    function rgbToHSL(rgba){
        var r = rgba[0] / 255,
            g = rgba[1] / 255,
            b = rgba[2] / 255,
            max = Math.max(r,g,b),
            min = Math.min(r,g,b),
            h,
            s,
            l = (max + min) / 2,
            d = max - min,
            huecalc = {};
            huecalc[r] = function(){ return (60 * (g - b) / d) + (g < b ? 360 : 0); };
            huecalc[g] = function(){ return (60 * (b - r) / d) + 120; };
            huecalc[b] = function(){ return (60 * (r - g) / d) + 240; };
        if(d === 0){
            h = s = 0; // grayscaled color
        }else{
            s = l < 0.5 ? d / (max + min) : d / (2 - max - min) ;
            h = huecalc[String(max)]();
        }
        return [Math.round(h), Math.round(s*100), Math.round(l*100)].concat([rgba[3]]);
    }

    function hslToRGB(hsla){
        var r,
            g,
            b,
            h = hsla[0] / 360,
            s = hsla[1] / 100,
            l = hsla[2] / 100;

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0){
            r = g = b = l; // grayscaled color
        }else{
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s,
                p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }
        return [r,g,b].map(function(c){ return Math.round(c*255); }).concat([hsla[3]]);
    }

    return c_c;

}();

},{}],123:[function(require,module,exports){
module.exports = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};
},{}],124:[function(require,module,exports){
/* MIT license */
var colorNames = require('color-name');
var swizzle = require('simple-swizzle');

var reverseNames = {};

// create a list of reverse color names
for (var name in colorNames) {
	if (colorNames.hasOwnProperty(name)) {
		reverseNames[colorNames[name]] = name;
	}
}

var cs = module.exports = {
	to: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorNames[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = swizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = swizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = swizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = swizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = swizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}

},{"color-name":123,"simple-swizzle":998}],125:[function(require,module,exports){
'use strict';

var colorString = require('color-string');
var convert = require('color-convert');

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(convert).forEach(function (model) {
	hashedModelKeys[_slice.call(convert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in convert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (!obj) {
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = convert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = convert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = convert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = convert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = convert[this.model].channels;
		var labels = convert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return convert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	dark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	light: function () {
		return !this.dark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		var color1 = this.rgb();
		var color2 = mixinColor.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(convert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = convert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

module.exports = Color;

},{"color-convert":120,"color-string":124}],126:[function(require,module,exports){
/**
 * Module dependencies.
 */

try {
  var index = require('indexof');
} catch (err) {
  var index = require('component-indexof');
}

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error('A DOM element reference is required');
  }
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var className = this.el.getAttribute('class') || '';
  var str = className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

},{"component-indexof":127,"indexof":127}],127:[function(require,module,exports){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],128:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var EVENT_NAME_MAP = {
  transitionend: {
    transition: 'transitionend',
    WebkitTransition: 'webkitTransitionEnd',
    MozTransition: 'mozTransitionEnd',
    OTransition: 'oTransitionEnd',
    msTransition: 'MSTransitionEnd'
  },

  animationend: {
    animation: 'animationend',
    WebkitAnimation: 'webkitAnimationEnd',
    MozAnimation: 'mozAnimationEnd',
    OAnimation: 'oAnimationEnd',
    msAnimation: 'MSAnimationEnd'
  }
};

var endEvents = [];

function detectEvents() {
  var testEl = document.createElement('div');
  var style = testEl.style;

  if (!('AnimationEvent' in window)) {
    delete EVENT_NAME_MAP.animationend.animation;
  }

  if (!('TransitionEvent' in window)) {
    delete EVENT_NAME_MAP.transitionend.transition;
  }

  for (var baseEventName in EVENT_NAME_MAP) {
    if (EVENT_NAME_MAP.hasOwnProperty(baseEventName)) {
      var baseEvents = EVENT_NAME_MAP[baseEventName];
      for (var styleName in baseEvents) {
        if (styleName in style) {
          endEvents.push(baseEvents[styleName]);
          break;
        }
      }
    }
  }
}

if (typeof window !== 'undefined' && typeof document !== 'undefined') {
  detectEvents();
}

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var TransitionEvents = {
  addEndEventListener: function addEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },


  endEvents: endEvents,

  removeEndEventListener: function removeEndEventListener(node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

exports["default"] = TransitionEvents;
module.exports = exports['default'];
},{}],129:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _Event = require('./Event');

var _Event2 = _interopRequireDefault(_Event);

var _componentClasses = require('component-classes');

var _componentClasses2 = _interopRequireDefault(_componentClasses);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var isCssAnimationSupported = _Event2["default"].endEvents.length !== 0;


var capitalPrefixes = ['Webkit', 'Moz', 'O',
// ms is special .... !
'ms'];
var prefixes = ['-webkit-', '-moz-', '-o-', 'ms-', ''];

function getStyleProperty(node, name) {
  var style = window.getComputedStyle(node);

  var ret = '';
  for (var i = 0; i < prefixes.length; i++) {
    ret = style.getPropertyValue(prefixes[i] + name);
    if (ret) {
      break;
    }
  }
  return ret;
}

function fixBrowserByTimeout(node) {
  if (isCssAnimationSupported) {
    var transitionDelay = parseFloat(getStyleProperty(node, 'transition-delay')) || 0;
    var transitionDuration = parseFloat(getStyleProperty(node, 'transition-duration')) || 0;
    var animationDelay = parseFloat(getStyleProperty(node, 'animation-delay')) || 0;
    var animationDuration = parseFloat(getStyleProperty(node, 'animation-duration')) || 0;
    var time = Math.max(transitionDuration + transitionDelay, animationDuration + animationDelay);
    // sometimes, browser bug
    node.rcEndAnimTimeout = setTimeout(function () {
      node.rcEndAnimTimeout = null;
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }, time * 1000 + 200);
  }
}

function clearBrowserBugTimeout(node) {
  if (node.rcEndAnimTimeout) {
    clearTimeout(node.rcEndAnimTimeout);
    node.rcEndAnimTimeout = null;
  }
}

var cssAnimation = function cssAnimation(node, transitionName, endCallback) {
  var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) === 'object';
  var className = nameIsObj ? transitionName.name : transitionName;
  var activeClassName = nameIsObj ? transitionName.active : transitionName + '-active';
  var end = endCallback;
  var start = void 0;
  var active = void 0;
  var nodeClasses = (0, _componentClasses2["default"])(node);

  if (endCallback && Object.prototype.toString.call(endCallback) === '[object Object]') {
    end = endCallback.end;
    start = endCallback.start;
    active = endCallback.active;
  }

  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    nodeClasses.remove(className);
    nodeClasses.remove(activeClassName);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional end is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (end) {
      end();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  if (start) {
    start();
  }
  nodeClasses.add(className);

  node.rcAnimTimeout = setTimeout(function () {
    node.rcAnimTimeout = null;
    nodeClasses.add(activeClassName);
    if (active) {
      setTimeout(active, 0);
    }
    fixBrowserByTimeout(node);
    // 30ms for firefox
  }, 30);

  return {
    stop: function stop() {
      if (node.rcEndListener) {
        node.rcEndListener();
      }
    }
  };
};

cssAnimation.style = function (node, style, callback) {
  if (node.rcEndListener) {
    node.rcEndListener();
  }

  node.rcEndListener = function (e) {
    if (e && e.target !== node) {
      return;
    }

    if (node.rcAnimTimeout) {
      clearTimeout(node.rcAnimTimeout);
      node.rcAnimTimeout = null;
    }

    clearBrowserBugTimeout(node);

    _Event2["default"].removeEndEventListener(node, node.rcEndListener);
    node.rcEndListener = null;

    // Usually this optional callback is used for informing an owner of
    // a leave animation and telling it to remove the child.
    if (callback) {
      callback();
    }
  };

  _Event2["default"].addEndEventListener(node, node.rcEndListener);

  node.rcAnimTimeout = setTimeout(function () {
    for (var s in style) {
      if (style.hasOwnProperty(s)) {
        node.style[s] = style[s];
      }
    }
    node.rcAnimTimeout = null;
    fixBrowserByTimeout(node);
  }, 0);
};

cssAnimation.setTransition = function (node, p, value) {
  var property = p;
  var v = value;
  if (value === undefined) {
    v = property;
    property = '';
  }
  property = property || '';
  capitalPrefixes.forEach(function (prefix) {
    node.style[prefix + 'Transition' + property] = v;
  });
};

cssAnimation.isCssAnimationSupported = isCssAnimationSupported;

exports["default"] = cssAnimation;
module.exports = exports['default'];
},{"./Event":128,"component-classes":126}],130:[function(require,module,exports){
// https://d3js.org/d3-array/ Version 1.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var ascending = function(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
};

var bisector = function(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    },
    right: function(a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;
        else lo = mid + 1;
      }
      return lo;
    }
  };
};

function ascendingComparator(f) {
  return function(d, x) {
    return ascending(f(d), x);
  };
}

var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;

var pairs = function(array, f) {
  if (f == null) f = pair;
  var i = 0, n = array.length - 1, p = array[0], pairs = new Array(n < 0 ? 0 : n);
  while (i < n) pairs[i] = f(p, p = array[++i]);
  return pairs;
};

function pair(a, b) {
  return [a, b];
}

var cross = function(a, b, f) {
  var na = a.length, nb = b.length, c = new Array(na * nb), ia, ib, ic, va;
  if (f == null) f = pair;
  for (ia = ic = 0; ia < na; ++ia) for (va = a[ia], ib = 0; ib < nb; ++ib, ++ic) c[ic] = f(va, b[ib]);
  return c;
};

var descending = function(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
};

var number = function(x) {
  return x === null ? NaN : +x;
};

var variance = function(array, f) {
  var n = array.length,
      m = 0,
      a,
      d,
      s = 0,
      i = -1,
      j = 0;

  if (f == null) {
    while (++i < n) {
      if (!isNaN(a = number(array[i]))) {
        d = a - m;
        m += d / ++j;
        s += d * (a - m);
      }
    }
  }

  else {
    while (++i < n) {
      if (!isNaN(a = number(f(array[i], i, array)))) {
        d = a - m;
        m += d / ++j;
        s += d * (a - m);
      }
    }
  }

  if (j > 1) return s / (j - 1);
};

var deviation = function(array, f) {
  var v = variance(array, f);
  return v ? Math.sqrt(v) : v;
};

var extent = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b,
      c;

  if (f == null) {
    while (++i < n) if ((b = array[i]) != null && b >= b) { a = c = b; break; }
    while (++i < n) if ((b = array[i]) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  }

  else {
    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = c = b; break; }
    while (++i < n) if ((b = f(array[i], i, array)) != null) {
      if (a > b) a = b;
      if (c < b) c = b;
    }
  }

  return [a, c];
};

var array = Array.prototype;

var slice = array.slice;
var map = array.map;

var constant = function(x) {
  return function() {
    return x;
  };
};

var identity = function(x) {
  return x;
};

var range = function(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
};

var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);

var ticks = function(start, stop, count) {
  var step = tickStep(start, stop, count);
  return range(
    Math.ceil(start / step) * step,
    Math.floor(stop / step) * step + step / 2, // inclusive
    step
  );
};

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;
  else if (error >= e5) step1 *= 5;
  else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}

var sturges = function(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
};

var histogram = function() {
  var value = identity,
      domain = extent,
      threshold = sturges;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1);

    // Convert number of thresholds into uniform thresholds.
    if (!Array.isArray(tz)) tz = ticks(x0, x1, tz);

    // Remove any thresholds outside the domain.
    var m = tz.length;
    while (tz[0] <= x0) tz.shift(), --m;
    while (tz[m - 1] >= x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin;

    // Initialize bins.
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    }

    // Assign data to bins by value, ignoring any outside the domain.
    for (i = 0; i < n; ++i) {
      x = values[i];
      if (x0 <= x && x <= x1) {
        bins[bisectRight(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant(_), histogram) : value;
  };

  histogram.domain = function(_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : constant([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function(_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? constant(slice.call(_)) : constant(_), histogram) : threshold;
  };

  return histogram;
};

var quantile = function(array, p, f) {
  if (f == null) f = number;
  if (!(n = array.length)) return;
  if ((p = +p) <= 0 || n < 2) return +f(array[0], 0, array);
  if (p >= 1) return +f(array[n - 1], n - 1, array);
  var n,
      h = (n - 1) * p,
      i = Math.floor(h),
      a = +f(array[i], i, array),
      b = +f(array[i + 1], i + 1, array);
  return a + (b - a) * (h - i);
};

var freedmanDiaconis = function(values, min, max) {
  values = map.call(values, number).sort(ascending);
  return Math.ceil((max - min) / (2 * (quantile(values, 0.75) - quantile(values, 0.25)) * Math.pow(values.length, -1 / 3)));
};

var scott = function(values, min, max) {
  return Math.ceil((max - min) / (3.5 * deviation(values) * Math.pow(values.length, -1 / 3)));
};

var max = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;

  if (f == null) {
    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
    while (++i < n) if ((b = array[i]) != null && b > a) a = b;
  }

  else {
    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
    while (++i < n) if ((b = f(array[i], i, array)) != null && b > a) a = b;
  }

  return a;
};

var mean = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1,
      j = n;

  if (f == null) {
    while (++i < n) if (!isNaN(a = number(array[i]))) s += a; else --j;
  }

  else {
    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) s += a; else --j;
  }

  if (j) return s / j;
};

var median = function(array, f) {
  var numbers = [],
      n = array.length,
      a,
      i = -1;

  if (f == null) {
    while (++i < n) if (!isNaN(a = number(array[i]))) numbers.push(a);
  }

  else {
    while (++i < n) if (!isNaN(a = number(f(array[i], i, array)))) numbers.push(a);
  }

  return quantile(numbers.sort(ascending), 0.5);
};

var merge = function(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;
  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;
    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
};

var min = function(array, f) {
  var i = -1,
      n = array.length,
      a,
      b;

  if (f == null) {
    while (++i < n) if ((b = array[i]) != null && b >= b) { a = b; break; }
    while (++i < n) if ((b = array[i]) != null && a > b) a = b;
  }

  else {
    while (++i < n) if ((b = f(array[i], i, array)) != null && b >= b) { a = b; break; }
    while (++i < n) if ((b = f(array[i], i, array)) != null && a > b) a = b;
  }

  return a;
};

var permute = function(array, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--) permutes[i] = array[indexes[i]];
  return permutes;
};

var scan = function(array, compare) {
  if (!(n = array.length)) return;
  var i = 0,
      n,
      j = 0,
      xi,
      xj = array[j];

  if (!compare) compare = ascending;

  while (++i < n) if (compare(xi = array[i], xj) < 0 || compare(xj, xj) !== 0) xj = xi, j = i;

  if (compare(xj, xj) === 0) return j;
};

var shuffle = function(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
};

var sum = function(array, f) {
  var s = 0,
      n = array.length,
      a,
      i = -1;

  if (f == null) {
    while (++i < n) if (a = +array[i]) s += a; // Note: zero and null are equivalent.
  }

  else {
    while (++i < n) if (a = +f(array[i], i, array)) s += a;
  }

  return s;
};

var transpose = function(matrix) {
  if (!(n = matrix.length)) return [];
  for (var i = -1, m = min(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }
  return transpose;
};

function length(d) {
  return d.length;
}

var zip = function() {
  return transpose(arguments);
};

exports.bisect = bisectRight;
exports.bisectRight = bisectRight;
exports.bisectLeft = bisectLeft;
exports.ascending = ascending;
exports.bisector = bisector;
exports.cross = cross;
exports.descending = descending;
exports.deviation = deviation;
exports.extent = extent;
exports.histogram = histogram;
exports.thresholdFreedmanDiaconis = freedmanDiaconis;
exports.thresholdScott = scott;
exports.thresholdSturges = sturges;
exports.max = max;
exports.mean = mean;
exports.median = median;
exports.merge = merge;
exports.min = min;
exports.pairs = pairs;
exports.permute = permute;
exports.quantile = quantile;
exports.range = range;
exports.scan = scan;
exports.shuffle = shuffle;
exports.sum = sum;
exports.ticks = ticks;
exports.tickStep = tickStep;
exports.transpose = transpose;
exports.variance = variance;
exports.zip = zip;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],131:[function(require,module,exports){
// https://d3js.org/d3-collection/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var prefix = "$";

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function(key) {
    return (prefix + key) in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function() {
    var keys = [];
    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));
    return keys;
  },
  values: function() {
    var values = [];
    for (var property in this) if (property[0] === prefix) values.push(this[property]);
    return values;
  },
  entries: function() {
    var entries = [];
    for (var property in this) if (property[0] === prefix) entries.push({key: property.slice(1), value: this[property]});
    return entries;
  },
  size: function() {
    var size = 0;
    for (var property in this) if (property[0] === prefix) ++size;
    return size;
  },
  empty: function() {
    for (var property in this) if (property[0] === prefix) return false;
    return true;
  },
  each: function(f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map;

  // Copy constructor.
  if (object instanceof Map) object.each(function(value, key) { map.set(key, value); });

  // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
    var i = -1,
        n = object.length,
        o;

    if (f == null) while (++i < n) map.set(i, object[i]);
    else while (++i < n) map.set(f(o = object[i], i, object), o);
  }

  // Convert object to map.
  else if (object) for (var key in object) map.set(key, object[key]);

  return map;
}

var nest = function() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) return rollup != null
        ? rollup(array) : (sortValues != null
        ? array.sort(sortValues)
        : array);

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = map(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function(values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });

    return result;
  }

  function entries(map$$1, depth) {
    if (++depth > keys.length) return map$$1;
    var array, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map$$1.entries();
    else array = [], map$$1.each(function(v, k) { array.push({key: k, values: entries(v, depth)}); });
    return sortKey != null ? array.sort(function(a, b) { return sortKey(a.key, b.key); }) : array;
  }

  return nest = {
    object: function(array) { return apply(array, 0, createObject, setObject); },
    map: function(array) { return apply(array, 0, createMap, setMap); },
    entries: function(array) { return entries(apply(array, 0, createMap, setMap), 0); },
    key: function(d) { keys.push(d); return nest; },
    sortKeys: function(order) { sortKeys[keys.length - 1] = order; return nest; },
    sortValues: function(order) { sortValues = order; return nest; },
    rollup: function(f) { rollup = f; return nest; }
  };
};

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return map();
}

function setMap(map$$1, key, value) {
  map$$1.set(key, value);
}

function Set() {}

var proto = map.prototype;

Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set;

  // Copy constructor.
  if (object instanceof Set) object.each(function(value) { set.add(value); });

  // Otherwise, assume it’s an array.
  else if (object) {
    var i = -1, n = object.length;
    if (f == null) while (++i < n) set.add(object[i]);
    else while (++i < n) set.add(f(object[i], i, object));
  }

  return set;
}

var keys = function(map) {
  var keys = [];
  for (var key in map) keys.push(key);
  return keys;
};

var values = function(map) {
  var values = [];
  for (var key in map) values.push(map[key]);
  return values;
};

var entries = function(map) {
  var entries = [];
  for (var key in map) entries.push({key: key, value: map[key]});
  return entries;
};

exports.nest = nest;
exports.set = set;
exports.map = map;
exports.keys = keys;
exports.values = values;
exports.entries = entries;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],132:[function(require,module,exports){
// https://d3js.org/d3-color/ Version 1.0.3. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var define = function(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
};

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex3 = /^#([0-9a-f]{3})$/;
var reHex6 = /^#([0-9a-f]{6})$/;
var reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$");
var reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$");
var reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$");
var reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$");
var reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$");
var reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  displayable: function() {
    return this.rgb().displayable();
  },
  toString: function() {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb((m >> 8 & 0xf) | (m >> 4 & 0x0f0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1)) // #f00
      : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format])
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return (0 <= this.r && this.r <= 255)
        && (0 <= this.g && this.g <= 255)
        && (0 <= this.b && this.b <= 255)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  toString: function() {
    var a = this.opacity; a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(")
        + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", "
        + Math.max(0, Math.min(255, Math.round(this.b) || 0))
        + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  }
}));

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;

var Kn = 18;
var Xn = 0.950470;
var Yn = 1;
var Zn = 1.088830;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl) {
    var h = o.h * deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

define(Lab, lab, extend(Color, {
  brighter: function(k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function(k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new Rgb(
      xyz2rgb( 3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
      xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z),
      xyz2rgb( 0.0556434 * x - 0.2040259 * y + 1.0572252 * z),
      this.opacity
    );
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hcl, hcl, extend(Color, {
  brighter: function(k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function(k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function() {
    return labConvert(this).rgb();
  }
}));

var A = -0.14861;
var B = +1.78277;
var C = -0.29227;
var D = -0.90649;
var E = +1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb)) o = rgbConvert(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), // NaN if l=0 or l=1
      h = s ? Math.atan2(k, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Cubehelix, cubehelix, extend(Color, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh + B * sinh)),
      255 * (l + a * (C * cosh + D * sinh)),
      255 * (l + a * (E * cosh)),
      this.opacity
    );
  }
}));

exports.color = color;
exports.rgb = rgb;
exports.hsl = hsl;
exports.lab = lab;
exports.hcl = hcl;
exports.cubehelix = cubehelix;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],133:[function(require,module,exports){
// https://d3js.org/d3-format/ Version 1.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
var formatDecimal = function(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity
  var i, coefficient = x.slice(0, i);

  // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
};

var exponent = function(x) {
  return x = formatDecimal(Math.abs(x)), x ? x[1] : NaN;
};

var formatGroup = function(grouping, thousands) {
  return function(value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
};

var formatNumerals = function(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
};

var formatDefault = function(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".": i0 = i1 = i; break;
      case "0": if (i0 === 0) i0 = i; i1 = i; break;
      case "e": break out;
      default: if (i0 > 0) i0 = 0; break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
};

var prefixExponent;

var formatPrefixAuto = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient
      : i > n ? coefficient + new Array(i - n + 1).join("0")
      : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i)
      : "0." + new Array(1 - i).join("0") + formatDecimal(x, Math.max(0, p + i - 1))[0]; // less than 1y!
};

var formatRounded = function(x, p) {
  var d = formatDecimal(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient
      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1)
      : coefficient + new Array(exponent - coefficient.length + 2).join("0");
};

var formatTypes = {
  "": formatDefault,
  "%": function(x, p) { return (x * 100).toFixed(p); },
  "b": function(x) { return Math.round(x).toString(2); },
  "c": function(x) { return x + ""; },
  "d": function(x) { return Math.round(x).toString(10); },
  "e": function(x, p) { return x.toExponential(p); },
  "f": function(x, p) { return x.toFixed(p); },
  "g": function(x, p) { return x.toPrecision(p); },
  "o": function(x) { return Math.round(x).toString(8); },
  "p": function(x, p) { return formatRounded(x * 100, p); },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x) { return Math.round(x).toString(16).toUpperCase(); },
  "x": function(x) { return Math.round(x).toString(16); }
};

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);

  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || "";

  // The "n" type is an alias for ",g".
  if (type === "n") comma = true, type = "g";

  // Map invalid types to the default format.
  else if (!formatTypes[type]) type = "";

  // If zero fill is specified, padding goes after sign and before digits.
  if (zero || (fill === "0" && align === "=")) zero = true, fill = "0", align = "=";

  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function() {
  return this.fill
      + this.align
      + this.sign
      + this.symbol
      + (this.zero ? "0" : "")
      + (this.width == null ? "" : Math.max(1, this.width | 0))
      + (this.comma ? "," : "")
      + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0))
      + this.type;
};

var identity = function(x) {
  return x;
};

var prefixes = ["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];

var formatLocale = function(locale) {
  var group = locale.grouping && locale.thousands ? formatGroup(locale.grouping, locale.thousands) : identity,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? formatNumerals(locale.numerals) : identity;

  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);

    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type;

    // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.
    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? "%" : "";

    // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?
    var formatType = formatTypes[type],
        maybeSuffix = !type || /[defgprs%]/.test(type);

    // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].
    precision = precision == null ? (type ? 6 : 12)
        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))
        : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i, n, c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;

        // Perform the initial formatting.
        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision);

        // If a negative value rounds to zero during formatting, treat as positive.
        if (valueNegative && +value === 0) valueNegative = false;

        // Compute the prefix and suffix.
        valuePrefix = (valueNegative ? (sign === "(" ? sign : "-") : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = valueSuffix + (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + (valueNegative && sign === "(" ? ")" : "");

        // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }

      // If the fill character is not "0", grouping is applied before padding.
      if (comma && !zero) value = group(value, Infinity);

      // Compute the padding.
      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : "";

      // If the fill character is "0", grouping is applied after padding.
      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";

      // Reconstruct the final output based on the desired alignment.
      switch (align) {
        case "<": value = valuePrefix + value + valueSuffix + padding; break;
        case "=": value = valuePrefix + padding + value + valueSuffix; break;
        case "^": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;
        default: value = padding + valuePrefix + value + valueSuffix; break;
      }

      return numerals(value);
    }

    format.toString = function() {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function(value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
};

var locale;



defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  exports.format = locale.format;
  exports.formatPrefix = locale.formatPrefix;
  return locale;
}

var precisionFixed = function(step) {
  return Math.max(0, -exponent(Math.abs(step)));
};

var precisionPrefix = function(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
};

var precisionRound = function(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, exponent(max) - exponent(step)) + 1;
};

exports.formatDefaultLocale = defaultLocale;
exports.formatLocale = formatLocale;
exports.formatSpecifier = formatSpecifier;
exports.precisionFixed = precisionFixed;
exports.precisionPrefix = precisionPrefix;
exports.precisionRound = precisionRound;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],134:[function(require,module,exports){
// https://d3js.org/d3-interpolate/ Version 1.1.4. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Color) { 'use strict';

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1, t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0
      + (4 - 6 * t2 + 3 * t3) * v1
      + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2
      + t3 * v3) / 6;
}

var basis$1 = function(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? (t = 0) : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var basisClosed = function(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
};

var constant = function(x) {
  return function() {
    return x;
  };
};

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant(isNaN(a) ? b : a);
}

var rgb$1 = ((function rgbGamma(y) {
  var color$$1 = gamma(y);

  function rgb$$1(start, end) {
    var r = color$$1((start = d3Color.rgb(start)).r, (end = d3Color.rgb(end)).r),
        g = color$$1(start.g, end.g),
        b = color$$1(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$$1.gamma = rgbGamma;

  return rgb$$1;
}))(1);

function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i, color$$1;
    for (i = 0; i < n; ++i) {
      color$$1 = d3Color.rgb(colors[i]);
      r[i] = color$$1.r || 0;
      g[i] = color$$1.g || 0;
      b[i] = color$$1.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color$$1.opacity = 1;
    return function(t) {
      color$$1.r = r(t);
      color$$1.g = g(t);
      color$$1.b = b(t);
      return color$$1 + "";
    };
  };
}

var rgbBasis = rgbSpline(basis$1);
var rgbBasisClosed = rgbSpline(basisClosed);

var array = function(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(nb),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = value(a[i], b[i]);
  for (; i < nb; ++i) c[i] = b[i];

  return function(t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);
    return c;
  };
};

var date = function(a, b) {
  var d = new Date;
  return a = +a, b -= a, function(t) {
    return d.setTime(a + b * t), d;
  };
};

var number = function(a, b) {
  return a = +a, b -= a, function(t) {
    return a + b * t;
  };
};

var object = function(a, b) {
  var i = {},
      c = {},
      k;

  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = value(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function(t) {
    for (k in i) c[k] = i[k](t);
    return c;
  };
};

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

var string = function(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: number(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
};

var value = function(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant(b)
      : (t === "number" ? number
      : t === "string" ? ((c = d3Color.color(b)) ? (b = c, rgb$1) : string)
      : b instanceof d3Color.color ? rgb$1
      : b instanceof Date ? date
      : Array.isArray(b) ? array
      : isNaN(b) ? object
      : number)(a, b);
};

var round = function(a, b) {
  return a = +a, b -= a, function(t) {
    return Math.round(a + b * t);
  };
};

var degrees = 180 / Math.PI;

var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

var decompose = function(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
};

var cssNode;
var cssRoot;
var cssView;
var svgNode;

function parseCss(value) {
  if (value === "none") return identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: number(xa, xb)}, {i: i - 2, x: number(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var rho = Math.SQRT2;
var rho2 = 2;
var rho4 = 4;
var epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}

// p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]
var zoom = function(p0, p1) {
  var ux0 = p0[0], uy0 = p0[1], w0 = p0[2],
      ux1 = p1[0], uy1 = p1[1], w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S;

  // Special case for u0 ≅ u1.
  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  }

  // General case.
  else {
    var d1 = Math.sqrt(d2),
        b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
        b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
        r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
        r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s = t * S,
          coshr0 = cosh(r0),
          u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s + r0)
      ];
    };
  }

  i.duration = S * 1000;

  return i;
};

function hsl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hsl(start)).h, (end = d3Color.hsl(end)).h),
        s = nogamma(start.s, end.s),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hsl$2 = hsl$1(hue);
var hslLong = hsl$1(nogamma);

function lab$1(start, end) {
  var l = nogamma((start = d3Color.lab(start)).l, (end = d3Color.lab(end)).l),
      a = nogamma(start.a, end.a),
      b = nogamma(start.b, end.b),
      opacity = nogamma(start.opacity, end.opacity);
  return function(t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}

function hcl$1(hue$$1) {
  return function(start, end) {
    var h = hue$$1((start = d3Color.hcl(start)).h, (end = d3Color.hcl(end)).h),
        c = nogamma(start.c, end.c),
        l = nogamma(start.l, end.l),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
}

var hcl$2 = hcl$1(hue);
var hclLong = hcl$1(nogamma);

function cubehelix$1(hue$$1) {
  return (function cubehelixGamma(y) {
    y = +y;

    function cubehelix$$1(start, end) {
      var h = hue$$1((start = d3Color.cubehelix(start)).h, (end = d3Color.cubehelix(end)).h),
          s = nogamma(start.s, end.s),
          l = nogamma(start.l, end.l),
          opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix$$1.gamma = cubehelixGamma;

    return cubehelix$$1;
  })(1);
}

var cubehelix$2 = cubehelix$1(hue);
var cubehelixLong = cubehelix$1(nogamma);

var quantize = function(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));
  return samples;
};

exports.interpolate = value;
exports.interpolateArray = array;
exports.interpolateBasis = basis$1;
exports.interpolateBasisClosed = basisClosed;
exports.interpolateDate = date;
exports.interpolateNumber = number;
exports.interpolateObject = object;
exports.interpolateRound = round;
exports.interpolateString = string;
exports.interpolateTransformCss = interpolateTransformCss;
exports.interpolateTransformSvg = interpolateTransformSvg;
exports.interpolateZoom = zoom;
exports.interpolateRgb = rgb$1;
exports.interpolateRgbBasis = rgbBasis;
exports.interpolateRgbBasisClosed = rgbBasisClosed;
exports.interpolateHsl = hsl$2;
exports.interpolateHslLong = hslLong;
exports.interpolateLab = lab$1;
exports.interpolateHcl = hcl$2;
exports.interpolateHclLong = hclLong;
exports.interpolateCubehelix = cubehelix$2;
exports.interpolateCubehelixLong = cubehelixLong;
exports.quantize = quantize;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-color":132}],135:[function(require,module,exports){
// https://d3js.org/d3-scale-chromatic/ Version 1.1.1. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-interpolate')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-interpolate'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Interpolate) { 'use strict';

var colors = function(specifier) {
  var n = specifier.length / 6 | 0, colors = new Array(n), i = 0;
  while (i < n) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors;
};

var Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

var Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

var Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

var Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

var Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

var Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

var Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

var Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

var ramp = function(scheme) {
  return d3Interpolate.interpolateRgbBasis(scheme[scheme.length - 1]);
};

var scheme = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);

var BrBG = ramp(scheme);

var scheme$1 = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);

var PRGn = ramp(scheme$1);

var scheme$2 = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);

var PiYG = ramp(scheme$2);

var scheme$3 = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);

var PuOr = ramp(scheme$3);

var scheme$4 = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);

var RdBu = ramp(scheme$4);

var scheme$5 = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);

var RdGy = ramp(scheme$5);

var scheme$6 = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);

var RdYlBu = ramp(scheme$6);

var scheme$7 = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);

var RdYlGn = ramp(scheme$7);

var scheme$8 = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);

var Spectral = ramp(scheme$8);

var scheme$9 = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);

var BuGn = ramp(scheme$9);

var scheme$10 = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);

var BuPu = ramp(scheme$10);

var scheme$11 = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);

var GnBu = ramp(scheme$11);

var scheme$12 = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);

var OrRd = ramp(scheme$12);

var scheme$13 = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);

var PuBuGn = ramp(scheme$13);

var scheme$14 = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);

var PuBu = ramp(scheme$14);

var scheme$15 = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);

var PuRd = ramp(scheme$15);

var scheme$16 = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);

var RdPu = ramp(scheme$16);

var scheme$17 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);

var YlGnBu = ramp(scheme$17);

var scheme$18 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);

var YlGn = ramp(scheme$18);

var scheme$19 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);

var YlOrBr = ramp(scheme$19);

var scheme$20 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);

var YlOrRd = ramp(scheme$20);

var scheme$21 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);

var Blues = ramp(scheme$21);

var scheme$22 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);

var Greens = ramp(scheme$22);

var scheme$23 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);

var Greys = ramp(scheme$23);

var scheme$24 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);

var Purples = ramp(scheme$24);

var scheme$25 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);

var Reds = ramp(scheme$25);

var scheme$26 = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);

var Oranges = ramp(scheme$26);

exports.schemeAccent = Accent;
exports.schemeDark2 = Dark2;
exports.schemePaired = Paired;
exports.schemePastel1 = Pastel1;
exports.schemePastel2 = Pastel2;
exports.schemeSet1 = Set1;
exports.schemeSet2 = Set2;
exports.schemeSet3 = Set3;
exports.interpolateBrBG = BrBG;
exports.schemeBrBG = scheme;
exports.interpolatePRGn = PRGn;
exports.schemePRGn = scheme$1;
exports.interpolatePiYG = PiYG;
exports.schemePiYG = scheme$2;
exports.interpolatePuOr = PuOr;
exports.schemePuOr = scheme$3;
exports.interpolateRdBu = RdBu;
exports.schemeRdBu = scheme$4;
exports.interpolateRdGy = RdGy;
exports.schemeRdGy = scheme$5;
exports.interpolateRdYlBu = RdYlBu;
exports.schemeRdYlBu = scheme$6;
exports.interpolateRdYlGn = RdYlGn;
exports.schemeRdYlGn = scheme$7;
exports.interpolateSpectral = Spectral;
exports.schemeSpectral = scheme$8;
exports.interpolateBuGn = BuGn;
exports.schemeBuGn = scheme$9;
exports.interpolateBuPu = BuPu;
exports.schemeBuPu = scheme$10;
exports.interpolateGnBu = GnBu;
exports.schemeGnBu = scheme$11;
exports.interpolateOrRd = OrRd;
exports.schemeOrRd = scheme$12;
exports.interpolatePuBuGn = PuBuGn;
exports.schemePuBuGn = scheme$13;
exports.interpolatePuBu = PuBu;
exports.schemePuBu = scheme$14;
exports.interpolatePuRd = PuRd;
exports.schemePuRd = scheme$15;
exports.interpolateRdPu = RdPu;
exports.schemeRdPu = scheme$16;
exports.interpolateYlGnBu = YlGnBu;
exports.schemeYlGnBu = scheme$17;
exports.interpolateYlGn = YlGn;
exports.schemeYlGn = scheme$18;
exports.interpolateYlOrBr = YlOrBr;
exports.schemeYlOrBr = scheme$19;
exports.interpolateYlOrRd = YlOrRd;
exports.schemeYlOrRd = scheme$20;
exports.interpolateBlues = Blues;
exports.schemeBlues = scheme$21;
exports.interpolateGreens = Greens;
exports.schemeGreens = scheme$22;
exports.interpolateGreys = Greys;
exports.schemeGreys = scheme$23;
exports.interpolatePurples = Purples;
exports.schemePurples = scheme$24;
exports.interpolateReds = Reds;
exports.schemeReds = scheme$25;
exports.interpolateOranges = Oranges;
exports.schemeOranges = scheme$26;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-interpolate":134}],136:[function(require,module,exports){
// https://d3js.org/d3-scale/ Version 1.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-array'), require('d3-collection'), require('d3-interpolate'), require('d3-format'), require('d3-time'), require('d3-time-format'), require('d3-color')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-array', 'd3-collection', 'd3-interpolate', 'd3-format', 'd3-time', 'd3-time-format', 'd3-color'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3,global.d3,global.d3,global.d3,global.d3,global.d3,global.d3));
}(this, (function (exports,d3Array,d3Collection,d3Interpolate,d3Format,d3Time,d3TimeFormat,d3Color) { 'use strict';

var array = Array.prototype;

var map$1 = array.map;
var slice = array.slice;

var implicit = {name: "implicit"};

function ordinal(range$$1) {
  var index = d3Collection.map(),
      domain = [],
      unknown = implicit;

  range$$1 = range$$1 == null ? [] : slice.call(range$$1);

  function scale(d) {
    var key = d + "", i = index.get(key);
    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }
    return range$$1[(i - 1) % range$$1.length];
  }

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = d3Collection.map();
    var i = -1, n = _.length, d, key;
    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));
    return scale;
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), scale) : range$$1.slice();
  };

  scale.unknown = function(_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function() {
    return ordinal()
        .domain(domain)
        .range(range$$1)
        .unknown(unknown);
  };

  return scale;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range$$1 = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range$$1[1] < range$$1[0],
        start = range$$1[reverse - 0],
        stop = range$$1[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = d3Array.range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = [+_[0], +_[1]], rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band()
        .domain(domain())
        .range(range$$1)
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}

var constant = function(x) {
  return function() {
    return x;
  };
};

var number = function(x) {
  return +x;
};

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= (a = +a))
      ? function(x) { return (x - a) / b; }
      : constant(b);
}

function deinterpolateClamp(deinterpolate) {
  return function(a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function(x) { return x <= a ? 0 : x >= b ? 1 : d(x); };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function(a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function(t) { return t <= 0 ? a : t >= 1 ? b : r(t); };
  };
}

function bimap(domain, range$$1, deinterpolate, reinterpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range$$1[0], r1 = range$$1[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);
  else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function(x) { return r0(d0(x)); };
}

function polymap(domain, range$$1, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range$$1.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1;

  // Reverse descending domains.
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range$$1 = range$$1.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range$$1[i], range$$1[i + 1]);
  }

  return function(x) {
    var i = d3Array.bisect(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target
      .domain(source.domain())
      .range(source.range())
      .interpolate(source.interpolate())
      .clamp(source.clamp());
}

// deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].
function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range$$1 = unit,
      interpolate$$1 = d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range$$1.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range$$1, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate$$1)))(+x);
  }

  scale.invert = function(y) {
    return (input || (input = piecewise(range$$1, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), rescale()) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.rangeRound = function(_) {
    return range$$1 = slice.call(_), interpolate$$1 = d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function(_) {
    return arguments.length ? (interpolate$$1 = _, rescale()) : interpolate$$1;
  };

  return rescale();
}

var tickFormat = function(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = d3Array.tickStep(start, stop, count == null ? 10 : count),
      precision;
  specifier = d3Format.formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionPrefix(step, value))) specifier.precision = precision;
      return d3Format.formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionRound(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = d3Format.precisionFixed(step))) specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return d3Format.format(specifier);
};

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function(count) {
    var d = domain();
    return d3Array.ticks(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function(count, specifier) {
    return tickFormat(domain(), count, specifier);
  };

  scale.nice = function(count) {
    var d = domain(),
        i = d.length - 1,
        n = count == null ? 10 : count,
        start = d[0],
        stop = d[i],
        step = d3Array.tickStep(start, stop, n);

    if (step) {
      step = d3Array.tickStep(Math.floor(start / step) * step, Math.ceil(stop / step) * step, n);
      d[0] = Math.floor(start / step) * step;
      d[i] = Math.ceil(stop / step) * step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber);

  scale.copy = function() {
    return copy(scale, linear());
  };

  return linearish(scale);
}

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function(_) {
    return arguments.length ? (domain = map$1.call(_, number), scale) : domain.slice();
  };

  scale.copy = function() {
    return identity().domain(domain);
  };

  return linearish(scale);
}

var nice = function(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
};

function deinterpolate(a, b) {
  return (b = Math.log(b / a))
      ? function(x) { return Math.log(x / a) / b; }
      : constant(b);
}

function reinterpolate(a, b) {
  return a < 0
      ? function(t) { return -Math.pow(-b, t) * Math.pow(-a, 1 - t); }
      : function(t) { return Math.pow(b, t) * Math.pow(a, 1 - t); };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : function(x) { return Math.pow(base, x); };
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), function(x) { return Math.log(x) / base; });
}

function reflect(f) {
  return function(x) {
    return -f(-x);
  };
}

function log() {
  var scale = continuous(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function(count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;

    if (r = v < u) i = u, u = v, v = i;

    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = d3Array.ticks(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function(count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = d3Format.format(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x) { return pows(Math.floor(logs(x))); },
      ceil: function(x) { return pows(Math.ceil(logs(x))); }
    }));
  };

  scale.copy = function() {
    return copy(scale, log().base(base));
  };

  return scale;
}

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = continuous(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent)))
        ? function(x) { return (raise(x, exponent) - a) / b; }
        : constant(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function(t) { return raise(a + b * t, 1 / exponent); };
  }

  scale.exponent = function(_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function() {
    return copy(scale, pow().exponent(exponent));
  };

  return linearish(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}

function quantile$1() {
  var domain = [],
      range$$1 = [],
      thresholds = [];

  function rescale() {
    var i = 0, n = Math.max(1, range$$1.length);
    thresholds = new Array(n - 1);
    while (++i < n) thresholds[i - 1] = d3Array.quantile(domain, i / n);
    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range$$1[d3Array.bisect(thresholds, x)];
  }

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };

  scale.domain = function(_) {
    if (!arguments.length) return domain.slice();
    domain = [];
    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);
    domain.sort(d3Array.ascending);
    return rescale();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), rescale()) : range$$1.slice();
  };

  scale.quantiles = function() {
    return thresholds.slice();
  };

  scale.copy = function() {
    return quantile$1()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range$$1 = [0, 1];

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);
    return scale;
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function(_) {
    return arguments.length ? (n = (range$$1 = slice.call(_)).length - 1, rescale()) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return i < 0 ? [NaN, NaN]
        : i < 1 ? [x0, domain[0]]
        : i >= n ? [domain[n - 1], x1]
        : [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return quantize()
        .domain([x0, x1])
        .range(range$$1);
  };

  return linearish(scale);
}

function threshold() {
  var domain = [0.5],
      range$$1 = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range$$1[d3Array.bisect(domain, x, 0, n)];
  }

  scale.domain = function(_) {
    return arguments.length ? (domain = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : domain.slice();
  };

  scale.range = function(_) {
    return arguments.length ? (range$$1 = slice.call(_), n = Math.min(domain.length, range$$1.length - 1), scale) : range$$1.slice();
  };

  scale.invertExtent = function(y) {
    var i = range$$1.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function() {
    return threshold()
        .domain(domain)
        .range(range$$1);
  };

  return scale;
}

var durationSecond = 1000;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number$1(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format$$1) {
  var scale = continuous(deinterpolateLinear, d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format$$1(".%L"),
      formatSecond = format$$1(":%S"),
      formatMinute = format$$1("%I:%M"),
      formatHour = format$$1("%I %p"),
      formatDay = format$$1("%a %d"),
      formatWeek = format$$1("%b %d"),
      formatMonth = format$$1("%B"),
      formatYear = format$$1("%Y");

  var tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10;

    // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.
    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = d3Array.bisector(function(i) { return i[2]; }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step = d3Array.tickStep(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = d3Array.tickStep(start, stop, interval);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(map$1.call(_, number$1)) : domain().map(date);
  };

  scale.ticks = function(interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop
    return r ? t.reverse() : t;
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format$$1(specifier);
  };

  scale.nice = function(interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step))
        ? domain(nice(d, interval))
        : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format$$1));
  };

  return scale;
}

var time = function() {
  return calendar(d3Time.timeYear, d3Time.timeMonth, d3Time.timeWeek, d3Time.timeDay, d3Time.timeHour, d3Time.timeMinute, d3Time.timeSecond, d3Time.timeMillisecond, d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
};

var utcTime = function() {
  return calendar(d3Time.utcYear, d3Time.utcMonth, d3Time.utcWeek, d3Time.utcDay, d3Time.utcHour, d3Time.utcMinute, d3Time.utcSecond, d3Time.utcMillisecond, d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
};

var colors = function(s) {
  return s.match(/.{6}/g).map(function(x) {
    return "#" + x;
  });
};

var category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

var category20b = colors("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

var category20c = colors("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

var category20 = colors("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

var cubehelix$1 = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(300, 0.5, 0.0), d3Color.cubehelix(-240, 0.5, 1.0));

var warm = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(-100, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var cool = d3Interpolate.interpolateCubehelixLong(d3Color.cubehelix(260, 0.75, 0.35), d3Color.cubehelix(80, 1.50, 0.8));

var rainbow = d3Color.cubehelix();

var rainbow$1 = function(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
};

function ramp(range$$1) {
  var n = range$$1.length;
  return function(t) {
    return range$$1[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));

var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));

var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function(_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function(_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function() {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return linearish(scale);
}

exports.scaleBand = band;
exports.scalePoint = point;
exports.scaleIdentity = identity;
exports.scaleLinear = linear;
exports.scaleLog = log;
exports.scaleOrdinal = ordinal;
exports.scaleImplicit = implicit;
exports.scalePow = pow;
exports.scaleSqrt = sqrt;
exports.scaleQuantile = quantile$1;
exports.scaleQuantize = quantize;
exports.scaleThreshold = threshold;
exports.scaleTime = time;
exports.scaleUtc = utcTime;
exports.schemeCategory10 = category10;
exports.schemeCategory20b = category20b;
exports.schemeCategory20c = category20c;
exports.schemeCategory20 = category20;
exports.interpolateCubehelixDefault = cubehelix$1;
exports.interpolateRainbow = rainbow$1;
exports.interpolateWarm = warm;
exports.interpolateCool = cool;
exports.interpolateViridis = viridis;
exports.interpolateMagma = magma;
exports.interpolateInferno = inferno;
exports.interpolatePlasma = plasma;
exports.scaleSequential = sequential;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-array":130,"d3-collection":131,"d3-color":132,"d3-format":133,"d3-interpolate":134,"d3-time":138,"d3-time-format":137}],137:[function(require,module,exports){
// https://d3js.org/d3-time-format/ Version 2.0.5. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-time')) :
	typeof define === 'function' && define.amd ? define(['exports', 'd3-time'], factory) :
	(factory((global.d3 = global.d3 || {}),global.d3));
}(this, (function (exports,d3Time) { 'use strict';

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "S": formatSeconds,
    "U": formatWeekNumberSunday,
    "w": formatWeekdayNumber,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "S": formatUTCSeconds,
    "U": formatUTCWeekNumberSunday,
    "w": formatUTCWeekdayNumber,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "S": parseSeconds,
    "U": parseWeekNumberSunday,
    "w": parseWeekdayNumber,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function(string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0);
      if (i != string.length) return null;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "W" in d ? 1 : 0;
        var day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", localDate);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier, utcDate);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"};
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {}, i = -1, n = names.length;
  while (++i < n) map[names[i].toLowerCase()] = i;
  return map;
}

function parseWeekdayNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?:\:?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + d3Time.timeDay.count(d3Time.timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekNumberSunday(d, p) {
  return pad(d3Time.timeSunday.count(d3Time.timeYear(d), d), p, 2);
}

function formatWeekdayNumber(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(d3Time.timeMonday.count(d3Time.timeYear(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + d3Time.utcDay.count(d3Time.utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(d3Time.utcSunday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCWeekdayNumber(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(d3Time.utcMonday.count(d3Time.utcYear(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

var locale$1;





defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale$1 = formatLocale(definition);
  exports.timeFormat = locale$1.format;
  exports.timeParse = locale$1.parse;
  exports.utcFormat = locale$1.utcFormat;
  exports.utcParse = locale$1.utcParse;
  return locale$1;
}

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString
    ? formatIsoNative
    : exports.utcFormat(isoSpecifier);

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z")
    ? parseIsoNative
    : exports.utcParse(isoSpecifier);

exports.timeFormatDefaultLocale = defaultLocale;
exports.timeFormatLocale = formatLocale;
exports.isoFormat = formatIso;
exports.isoParse = parseIso;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{"d3-time":138}],138:[function(require,module,exports){
// https://d3js.org/d3-time/ Version 1.0.6. Copyright 2017 Mike Bostock.
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.d3 = global.d3 || {})));
}(this, (function (exports) { 'use strict';

var t0 = new Date;
var t1 = new Date;

function newInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function(date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function(date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function(date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function(start, stop, step) {
    var range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    do range.push(new Date(+start)); while (offseti(start, step), floori(start), start < stop)
    return range;
  };

  interval.filter = function(test) {
    return newInterval(function(date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function(date, step) {
      if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty
    });
  };

  if (count) {
    interval.count = function(start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function(step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? function(d) { return field(d) % step === 0; }
              : function(d) { return interval.count(0, d) % step === 0; });
    };
  }

  return interval;
}

var millisecond = newInterval(function() {
  // noop
}, function(date, step) {
  date.setTime(+date + step);
}, function(start, end) {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = function(k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return newInterval(function(date) {
    date.setTime(Math.floor(date / k) * k);
  }, function(date, step) {
    date.setTime(+date + step * k);
  }, function(start, end) {
    return (end - start) / k;
  });
};

var milliseconds = millisecond.range;

var durationSecond = 1e3;
var durationMinute = 6e4;
var durationHour = 36e5;
var durationDay = 864e5;
var durationWeek = 6048e5;

var second = newInterval(function(date) {
  date.setTime(Math.floor(date / durationSecond) * durationSecond);
}, function(date, step) {
  date.setTime(+date + step * durationSecond);
}, function(start, end) {
  return (end - start) / durationSecond;
}, function(date) {
  return date.getUTCSeconds();
});

var seconds = second.range;

var minute = newInterval(function(date) {
  date.setTime(Math.floor(date / durationMinute) * durationMinute);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getMinutes();
});

var minutes = minute.range;

var hour = newInterval(function(date) {
  var offset = date.getTimezoneOffset() * durationMinute % durationHour;
  if (offset < 0) offset += durationHour;
  date.setTime(Math.floor((+date - offset) / durationHour) * durationHour + offset);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getHours();
});

var hours = hour.range;

var day = newInterval(function(date) {
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setDate(date.getDate() + step);
}, function(start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay;
}, function(date) {
  return date.getDate() - 1;
});

var days = day.range;

function weekday(i) {
  return newInterval(function(date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function(start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);

var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;

var month = newInterval(function(date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setMonth(date.getMonth() + step);
}, function(start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function(date) {
  return date.getMonth();
});

var months = month.range;

var year = newInterval(function(date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function(date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function(start, end) {
  return end.getFullYear() - start.getFullYear();
}, function(date) {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
year.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var years = year.range;

var utcMinute = newInterval(function(date) {
  date.setUTCSeconds(0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationMinute);
}, function(start, end) {
  return (end - start) / durationMinute;
}, function(date) {
  return date.getUTCMinutes();
});

var utcMinutes = utcMinute.range;

var utcHour = newInterval(function(date) {
  date.setUTCMinutes(0, 0, 0);
}, function(date, step) {
  date.setTime(+date + step * durationHour);
}, function(start, end) {
  return (end - start) / durationHour;
}, function(date) {
  return date.getUTCHours();
});

var utcHours = utcHour.range;

var utcDay = newInterval(function(date) {
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function(start, end) {
  return (end - start) / durationDay;
}, function(date) {
  return date.getUTCDate() - 1;
});

var utcDays = utcDay.range;

function utcWeekday(i) {
  return newInterval(function(date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function(start, end) {
    return (end - start) / durationWeek;
  });
}

var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);

var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

var utcMonth = newInterval(function(date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function(start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function(date) {
  return date.getUTCMonth();
});

var utcMonths = utcMonth.range;

var utcYear = newInterval(function(date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function(date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function(start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function(date) {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = function(k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : newInterval(function(date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function(date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var utcYears = utcYear.range;

exports.timeInterval = newInterval;
exports.timeMillisecond = millisecond;
exports.timeMilliseconds = milliseconds;
exports.utcMillisecond = millisecond;
exports.utcMilliseconds = milliseconds;
exports.timeSecond = second;
exports.timeSeconds = seconds;
exports.utcSecond = second;
exports.utcSeconds = seconds;
exports.timeMinute = minute;
exports.timeMinutes = minutes;
exports.timeHour = hour;
exports.timeHours = hours;
exports.timeDay = day;
exports.timeDays = days;
exports.timeWeek = sunday;
exports.timeWeeks = sundays;
exports.timeSunday = sunday;
exports.timeSundays = sundays;
exports.timeMonday = monday;
exports.timeMondays = mondays;
exports.timeTuesday = tuesday;
exports.timeTuesdays = tuesdays;
exports.timeWednesday = wednesday;
exports.timeWednesdays = wednesdays;
exports.timeThursday = thursday;
exports.timeThursdays = thursdays;
exports.timeFriday = friday;
exports.timeFridays = fridays;
exports.timeSaturday = saturday;
exports.timeSaturdays = saturdays;
exports.timeMonth = month;
exports.timeMonths = months;
exports.timeYear = year;
exports.timeYears = years;
exports.utcMinute = utcMinute;
exports.utcMinutes = utcMinutes;
exports.utcHour = utcHour;
exports.utcHours = utcHours;
exports.utcDay = utcDay;
exports.utcDays = utcDays;
exports.utcWeek = utcSunday;
exports.utcWeeks = utcSundays;
exports.utcSunday = utcSunday;
exports.utcSundays = utcSundays;
exports.utcMonday = utcMonday;
exports.utcMondays = utcMondays;
exports.utcTuesday = utcTuesday;
exports.utcTuesdays = utcTuesdays;
exports.utcWednesday = utcWednesday;
exports.utcWednesdays = utcWednesdays;
exports.utcThursday = utcThursday;
exports.utcThursdays = utcThursdays;
exports.utcFriday = utcFriday;
exports.utcFridays = utcFridays;
exports.utcSaturday = utcSaturday;
exports.utcSaturdays = utcSaturdays;
exports.utcMonth = utcMonth;
exports.utcMonths = utcMonths;
exports.utcYear = utcYear;
exports.utcYears = utcYears;

Object.defineProperty(exports, '__esModule', { value: true });

})));

},{}],139:[function(require,module,exports){
// d3.tip
// Copyright (c) 2013 Justin Palmer
//
// Tooltips for d3.js SVG visualizations

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module with d3 as a dependency.
    define(['d3'], factory)
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = function(d3) {
      d3.tip = factory(d3)
      return d3.tip
    }
  } else {
    // Browser global.
    root.d3.tip = factory(root.d3)
  }
}(this, function (d3) {

  // Public - contructs a new tooltip
  //
  // Returns a tip
  return function() {
    var direction = d3_tip_direction,
        offset    = d3_tip_offset,
        html      = d3_tip_html,
        node      = initNode(),
        svg       = null,
        point     = null,
        target    = null

    function tip(vis) {
      svg = getSVGNode(vis)
      point = svg.createSVGPoint()
      document.body.appendChild(node)
    }

    // Public - show the tooltip on the screen
    //
    // Returns a tip
    tip.show = function() {
      var args = Array.prototype.slice.call(arguments)
      if(args[args.length - 1] instanceof SVGElement) target = args.pop()

      var content = html.apply(this, args),
          poffset = offset.apply(this, args),
          dir     = direction.apply(this, args),
          nodel   = getNodeEl(),
          i       = directions.length,
          coords,
          scrollTop  = document.documentElement.scrollTop || document.body.scrollTop,
          scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft

      nodel.html(content)
        .style({ opacity: 1, 'pointer-events': 'all' })

      while(i--) nodel.classed(directions[i], false)
      coords = direction_callbacks.get(dir).apply(this)
      nodel.classed(dir, true).style({
        top: (coords.top +  poffset[0]) + scrollTop + 'px',
        left: (coords.left + poffset[1]) + scrollLeft + 'px'
      })

      return tip
    }

    // Public - hide the tooltip
    //
    // Returns a tip
    tip.hide = function() {
      var nodel = getNodeEl()
      nodel.style({ opacity: 0, 'pointer-events': 'none' })
      return tip
    }

    // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
    //
    // n - name of the attribute
    // v - value of the attribute
    //
    // Returns tip or attribute value
    tip.attr = function(n, v) {
      if (arguments.length < 2 && typeof n === 'string') {
        return getNodeEl().attr(n)
      } else {
        var args =  Array.prototype.slice.call(arguments)
        d3.selection.prototype.attr.apply(getNodeEl(), args)
      }

      return tip
    }

    // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
    //
    // n - name of the property
    // v - value of the property
    //
    // Returns tip or style property value
    tip.style = function(n, v) {
      if (arguments.length < 2 && typeof n === 'string') {
        return getNodeEl().style(n)
      } else {
        var args =  Array.prototype.slice.call(arguments)
        d3.selection.prototype.style.apply(getNodeEl(), args)
      }

      return tip
    }

    // Public: Set or get the direction of the tooltip
    //
    // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
    //     sw(southwest), ne(northeast) or se(southeast)
    //
    // Returns tip or direction
    tip.direction = function(v) {
      if (!arguments.length) return direction
      direction = v == null ? v : d3.functor(v)

      return tip
    }

    // Public: Sets or gets the offset of the tip
    //
    // v - Array of [x, y] offset
    //
    // Returns offset or
    tip.offset = function(v) {
      if (!arguments.length) return offset
      offset = v == null ? v : d3.functor(v)

      return tip
    }

    // Public: sets or gets the html value of the tooltip
    //
    // v - String value of the tip
    //
    // Returns html value or tip
    tip.html = function(v) {
      if (!arguments.length) return html
      html = v == null ? v : d3.functor(v)

      return tip
    }

    // Public: destroys the tooltip and removes it from the DOM
    //
    // Returns a tip
    tip.destroy = function() {
      if(node) {
        getNodeEl().remove();
        node = null;
      }
      return tip;
    }

    function d3_tip_direction() { return 'n' }
    function d3_tip_offset() { return [0, 0] }
    function d3_tip_html() { return ' ' }

    var direction_callbacks = d3.map({
      n:  direction_n,
      s:  direction_s,
      e:  direction_e,
      w:  direction_w,
      nw: direction_nw,
      ne: direction_ne,
      sw: direction_sw,
      se: direction_se
    }),

    directions = direction_callbacks.keys()

    function direction_n() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.n.y - node.offsetHeight,
        left: bbox.n.x - node.offsetWidth / 2
      }
    }

    function direction_s() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.s.y,
        left: bbox.s.x - node.offsetWidth / 2
      }
    }

    function direction_e() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.e.y - node.offsetHeight / 2,
        left: bbox.e.x
      }
    }

    function direction_w() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.w.y - node.offsetHeight / 2,
        left: bbox.w.x - node.offsetWidth
      }
    }

    function direction_nw() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.nw.y - node.offsetHeight,
        left: bbox.nw.x - node.offsetWidth
      }
    }

    function direction_ne() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.ne.y - node.offsetHeight,
        left: bbox.ne.x
      }
    }

    function direction_sw() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.sw.y,
        left: bbox.sw.x - node.offsetWidth
      }
    }

    function direction_se() {
      var bbox = getScreenBBox()
      return {
        top:  bbox.se.y,
        left: bbox.e.x
      }
    }

    function initNode() {
      var node = d3.select(document.createElement('div'))
      node.style({
        position: 'absolute',
        top: 0,
        opacity: 0,
        'pointer-events': 'none',
        'box-sizing': 'border-box'
      })

      return node.node()
    }

    function getSVGNode(el) {
      el = el.node()
      if(el.tagName.toLowerCase() === 'svg')
        return el

      return el.ownerSVGElement
    }

    function getNodeEl() {
      if(node === null) {
        node = initNode();
        // re-add node to DOM
        document.body.appendChild(node);
      };
      return d3.select(node);
    }

    // Private - gets the screen coordinates of a shape
    //
    // Given a shape on the screen, will return an SVGPoint for the directions
    // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
    // sw(southwest).
    //
    //    +-+-+
    //    |   |
    //    +   +
    //    |   |
    //    +-+-+
    //
    // Returns an Object {n, s, e, w, nw, sw, ne, se}
    function getScreenBBox() {
      var targetel   = target || d3.event.target;

      while ('undefined' === typeof targetel.getScreenCTM && 'undefined' === targetel.parentNode) {
          targetel = targetel.parentNode;
      }

      var bbox       = {},
          matrix     = targetel.getScreenCTM(),
          tbbox      = targetel.getBBox(),
          width      = tbbox.width,
          height     = tbbox.height,
          x          = tbbox.x,
          y          = tbbox.y

      point.x = x
      point.y = y
      bbox.nw = point.matrixTransform(matrix)
      point.x += width
      bbox.ne = point.matrixTransform(matrix)
      point.y += height
      bbox.se = point.matrixTransform(matrix)
      point.x -= width
      bbox.sw = point.matrixTransform(matrix)
      point.y -= height / 2
      bbox.w  = point.matrixTransform(matrix)
      point.x += width
      bbox.e = point.matrixTransform(matrix)
      point.x -= width / 2
      point.y -= height / 2
      bbox.n = point.matrixTransform(matrix)
      point.y += height
      bbox.s = point.matrixTransform(matrix)

      return bbox
    }

    return tip
  };

}));

},{}],140:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

exports.__esModule = true;

var _isDisposable = require('./isDisposable');

var _isDisposable2 = _interopRequireWildcard(_isDisposable);

/**
 * Represents a group of disposable resources that are disposed together.
 */

var CompositeDisposable = (function () {
  function CompositeDisposable() {
    for (var _len = arguments.length, disposables = Array(_len), _key = 0; _key < _len; _key++) {
      disposables[_key] = arguments[_key];
    }

    _classCallCheck(this, CompositeDisposable);

    if (Array.isArray(disposables[0]) && disposables.length === 1) {
      disposables = disposables[0];
    }

    for (var i = 0; i < disposables.length; i++) {
      if (!_isDisposable2['default'](disposables[i])) {
        throw new Error('Expected a disposable');
      }
    }

    this.disposables = disposables;
    this.isDisposed = false;
  }

  /**
   * Adds a disposable to the CompositeDisposable or disposes the disposable if the CompositeDisposable is disposed.
   * @param {Disposable} item Disposable to add.
   */

  CompositeDisposable.prototype.add = function add(item) {
    if (this.isDisposed) {
      item.dispose();
    } else {
      this.disposables.push(item);
    }
  };

  /**
   * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
   * @param {Disposable} item Disposable to remove.
   * @returns {Boolean} true if found; false otherwise.
   */

  CompositeDisposable.prototype.remove = function remove(item) {
    if (this.isDisposed) {
      return false;
    }

    var index = this.disposables.indexOf(item);
    if (index === -1) {
      return false;
    }

    this.disposables.splice(index, 1);
    item.dispose();
    return true;
  };

  /**
   * Disposes all disposables in the group and removes them from the group.
   */

  CompositeDisposable.prototype.dispose = function dispose() {
    if (this.isDisposed) {
      return;
    }

    var len = this.disposables.length;
    var currentDisposables = new Array(len);
    for (var i = 0; i < len; i++) {
      currentDisposables[i] = this.disposables[i];
    }

    this.isDisposed = true;
    this.disposables = [];
    this.length = 0;

    for (var i = 0; i < len; i++) {
      currentDisposables[i].dispose();
    }
  };

  return CompositeDisposable;
})();

exports['default'] = CompositeDisposable;
module.exports = exports['default'];
},{"./isDisposable":144}],141:[function(require,module,exports){
"use strict";

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

exports.__esModule = true;
var noop = function noop() {};

/**
 * The basic disposable.
 */

var Disposable = (function () {
  function Disposable(action) {
    _classCallCheck(this, Disposable);

    this.isDisposed = false;
    this.action = action || noop;
  }

  Disposable.prototype.dispose = function dispose() {
    if (!this.isDisposed) {
      this.action.call(null);
      this.isDisposed = true;
    }
  };

  _createClass(Disposable, null, [{
    key: "empty",
    enumerable: true,
    value: { dispose: noop }
  }]);

  return Disposable;
})();

exports["default"] = Disposable;
module.exports = exports["default"];
},{}],142:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

exports.__esModule = true;

var _isDisposable = require('./isDisposable');

var _isDisposable2 = _interopRequireWildcard(_isDisposable);

var SerialDisposable = (function () {
  function SerialDisposable() {
    _classCallCheck(this, SerialDisposable);

    this.isDisposed = false;
    this.current = null;
  }

  /**
   * Gets the underlying disposable.
   * @return The underlying disposable.
   */

  SerialDisposable.prototype.getDisposable = function getDisposable() {
    return this.current;
  };

  /**
   * Sets the underlying disposable.
   * @param {Disposable} value The new underlying disposable.
   */

  SerialDisposable.prototype.setDisposable = function setDisposable() {
    var value = arguments[0] === undefined ? null : arguments[0];

    if (value != null && !_isDisposable2['default'](value)) {
      throw new Error('Expected either an empty value or a valid disposable');
    }

    var isDisposed = this.isDisposed;
    var previous = undefined;

    if (!isDisposed) {
      previous = this.current;
      this.current = value;
    }

    if (previous) {
      previous.dispose();
    }

    if (isDisposed && value) {
      value.dispose();
    }
  };

  /**
   * Disposes the underlying disposable as well as all future replacements.
   */

  SerialDisposable.prototype.dispose = function dispose() {
    if (this.isDisposed) {
      return;
    }

    this.isDisposed = true;
    var previous = this.current;
    this.current = null;

    if (previous) {
      previous.dispose();
    }
  };

  return SerialDisposable;
})();

exports['default'] = SerialDisposable;
module.exports = exports['default'];
},{"./isDisposable":144}],143:[function(require,module,exports){
'use strict';

var _interopRequireWildcard = function (obj) { return obj && obj.__esModule ? obj : { 'default': obj }; };

exports.__esModule = true;

var _isDisposable2 = require('./isDisposable');

var _isDisposable3 = _interopRequireWildcard(_isDisposable2);

exports.isDisposable = _isDisposable3['default'];

var _Disposable2 = require('./Disposable');

var _Disposable3 = _interopRequireWildcard(_Disposable2);

exports.Disposable = _Disposable3['default'];

var _CompositeDisposable2 = require('./CompositeDisposable');

var _CompositeDisposable3 = _interopRequireWildcard(_CompositeDisposable2);

exports.CompositeDisposable = _CompositeDisposable3['default'];

var _SerialDisposable2 = require('./SerialDisposable');

var _SerialDisposable3 = _interopRequireWildcard(_SerialDisposable2);

exports.SerialDisposable = _SerialDisposable3['default'];
},{"./CompositeDisposable":140,"./Disposable":141,"./SerialDisposable":142,"./isDisposable":144}],144:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = isDisposable;

function isDisposable(obj) {
  return Boolean(obj && typeof obj.dispose === 'function');
}

module.exports = exports['default'];
},{}],145:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _createStore = require('redux/lib/createStore');

var _createStore2 = _interopRequireDefault(_createStore);

var _reducers = require('./reducers');

var _reducers2 = _interopRequireDefault(_reducers);

var _dragDrop = require('./actions/dragDrop');

var dragDropActions = _interopRequireWildcard(_dragDrop);

var _DragDropMonitor = require('./DragDropMonitor');

var _DragDropMonitor2 = _interopRequireDefault(_DragDropMonitor);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DragDropManager = function () {
  function DragDropManager(createBackend) {
    var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, DragDropManager);

    var store = (0, _createStore2.default)(_reducers2.default);
    this.context = context;
    this.store = store;
    this.monitor = new _DragDropMonitor2.default(store);
    this.registry = this.monitor.registry;
    this.backend = createBackend(this);

    store.subscribe(this.handleRefCountChange.bind(this));
  }

  _createClass(DragDropManager, [{
    key: 'handleRefCountChange',
    value: function handleRefCountChange() {
      var shouldSetUp = this.store.getState().refCount > 0;
      if (shouldSetUp && !this.isSetUp) {
        this.backend.setup();
        this.isSetUp = true;
      } else if (!shouldSetUp && this.isSetUp) {
        this.backend.teardown();
        this.isSetUp = false;
      }
    }
  }, {
    key: 'getContext',
    value: function getContext() {
      return this.context;
    }
  }, {
    key: 'getMonitor',
    value: function getMonitor() {
      return this.monitor;
    }
  }, {
    key: 'getBackend',
    value: function getBackend() {
      return this.backend;
    }
  }, {
    key: 'getRegistry',
    value: function getRegistry() {
      return this.registry;
    }
  }, {
    key: 'getActions',
    value: function getActions() {
      var manager = this;
      var dispatch = this.store.dispatch;


      function bindActionCreator(actionCreator) {
        return function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          var action = actionCreator.apply(manager, args);
          if (typeof action !== 'undefined') {
            dispatch(action);
          }
        };
      }

      return Object.keys(dragDropActions).filter(function (key) {
        return typeof dragDropActions[key] === 'function';
      }).reduce(function (boundActions, key) {
        var action = dragDropActions[key];
        boundActions[key] = bindActionCreator(action); // eslint-disable-line no-param-reassign
        return boundActions;
      }, {});
    }
  }]);

  return DragDropManager;
}();

exports.default = DragDropManager;
},{"./DragDropMonitor":146,"./actions/dragDrop":150,"./reducers":157,"redux/lib/createStore":986}],146:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _matchesType = require('./utils/matchesType');

var _matchesType2 = _interopRequireDefault(_matchesType);

var _HandlerRegistry = require('./HandlerRegistry');

var _HandlerRegistry2 = _interopRequireDefault(_HandlerRegistry);

var _dragOffset = require('./reducers/dragOffset');

var _dirtyHandlerIds = require('./reducers/dirtyHandlerIds');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DragDropMonitor = function () {
  function DragDropMonitor(store) {
    _classCallCheck(this, DragDropMonitor);

    this.store = store;
    this.registry = new _HandlerRegistry2.default(store);
  }

  _createClass(DragDropMonitor, [{
    key: 'subscribeToStateChange',
    value: function subscribeToStateChange(listener) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var handlerIds = options.handlerIds;

      (0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');
      (0, _invariant2.default)(typeof handlerIds === 'undefined' || (0, _isArray2.default)(handlerIds), 'handlerIds, when specified, must be an array of strings.');

      var prevStateId = this.store.getState().stateId;
      var handleChange = function handleChange() {
        var state = _this.store.getState();
        var currentStateId = state.stateId;
        try {
          var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !(0, _dirtyHandlerIds.areDirty)(state.dirtyHandlerIds, handlerIds);

          if (!canSkipListener) {
            listener();
          }
        } finally {
          prevStateId = currentStateId;
        }
      };

      return this.store.subscribe(handleChange);
    }
  }, {
    key: 'subscribeToOffsetChange',
    value: function subscribeToOffsetChange(listener) {
      var _this2 = this;

      (0, _invariant2.default)(typeof listener === 'function', 'listener must be a function.');

      var previousState = this.store.getState().dragOffset;
      var handleChange = function handleChange() {
        var nextState = _this2.store.getState().dragOffset;
        if (nextState === previousState) {
          return;
        }

        previousState = nextState;
        listener();
      };

      return this.store.subscribe(handleChange);
    }
  }, {
    key: 'canDragSource',
    value: function canDragSource(sourceId) {
      var source = this.registry.getSource(sourceId);
      (0, _invariant2.default)(source, 'Expected to find a valid source.');

      if (this.isDragging()) {
        return false;
      }

      return source.canDrag(this, sourceId);
    }
  }, {
    key: 'canDropOnTarget',
    value: function canDropOnTarget(targetId) {
      var target = this.registry.getTarget(targetId);
      (0, _invariant2.default)(target, 'Expected to find a valid target.');

      if (!this.isDragging() || this.didDrop()) {
        return false;
      }

      var targetType = this.registry.getTargetType(targetId);
      var draggedItemType = this.getItemType();
      return (0, _matchesType2.default)(targetType, draggedItemType) && target.canDrop(this, targetId);
    }
  }, {
    key: 'isDragging',
    value: function isDragging() {
      return Boolean(this.getItemType());
    }
  }, {
    key: 'isDraggingSource',
    value: function isDraggingSource(sourceId) {
      var source = this.registry.getSource(sourceId, true);
      (0, _invariant2.default)(source, 'Expected to find a valid source.');

      if (!this.isDragging() || !this.isSourcePublic()) {
        return false;
      }

      var sourceType = this.registry.getSourceType(sourceId);
      var draggedItemType = this.getItemType();
      if (sourceType !== draggedItemType) {
        return false;
      }

      return source.isDragging(this, sourceId);
    }
  }, {
    key: 'isOverTarget',
    value: function isOverTarget(targetId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { shallow: false };
      var shallow = options.shallow;

      if (!this.isDragging()) {
        return false;
      }

      var targetType = this.registry.getTargetType(targetId);
      var draggedItemType = this.getItemType();
      if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
        return false;
      }

      var targetIds = this.getTargetIds();
      if (!targetIds.length) {
        return false;
      }

      var index = targetIds.indexOf(targetId);
      if (shallow) {
        return index === targetIds.length - 1;
      } else {
        return index > -1;
      }
    }
  }, {
    key: 'getItemType',
    value: function getItemType() {
      return this.store.getState().dragOperation.itemType;
    }
  }, {
    key: 'getItem',
    value: function getItem() {
      return this.store.getState().dragOperation.item;
    }
  }, {
    key: 'getSourceId',
    value: function getSourceId() {
      return this.store.getState().dragOperation.sourceId;
    }
  }, {
    key: 'getTargetIds',
    value: function getTargetIds() {
      return this.store.getState().dragOperation.targetIds;
    }
  }, {
    key: 'getDropResult',
    value: function getDropResult() {
      return this.store.getState().dragOperation.dropResult;
    }
  }, {
    key: 'didDrop',
    value: function didDrop() {
      return this.store.getState().dragOperation.didDrop;
    }
  }, {
    key: 'isSourcePublic',
    value: function isSourcePublic() {
      return this.store.getState().dragOperation.isSourcePublic;
    }
  }, {
    key: 'getInitialClientOffset',
    value: function getInitialClientOffset() {
      return this.store.getState().dragOffset.initialClientOffset;
    }
  }, {
    key: 'getInitialSourceClientOffset',
    value: function getInitialSourceClientOffset() {
      return this.store.getState().dragOffset.initialSourceClientOffset;
    }
  }, {
    key: 'getClientOffset',
    value: function getClientOffset() {
      return this.store.getState().dragOffset.clientOffset;
    }
  }, {
    key: 'getSourceClientOffset',
    value: function getSourceClientOffset() {
      return (0, _dragOffset.getSourceClientOffset)(this.store.getState().dragOffset);
    }
  }, {
    key: 'getDifferenceFromInitialOffset',
    value: function getDifferenceFromInitialOffset() {
      return (0, _dragOffset.getDifferenceFromInitialOffset)(this.store.getState().dragOffset);
    }
  }]);

  return DragDropMonitor;
}();

exports.default = DragDropMonitor;
},{"./HandlerRegistry":149,"./reducers/dirtyHandlerIds":154,"./reducers/dragOffset":155,"./utils/matchesType":161,"invariant":327,"lodash/isArray":234}],147:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DragSource = function () {
  function DragSource() {
    _classCallCheck(this, DragSource);
  }

  _createClass(DragSource, [{
    key: "canDrag",
    value: function canDrag() {
      return true;
    }
  }, {
    key: "isDragging",
    value: function isDragging(monitor, handle) {
      return handle === monitor.getSourceId();
    }
  }, {
    key: "endDrag",
    value: function endDrag() {}
  }]);

  return DragSource;
}();

exports.default = DragSource;
},{}],148:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DropTarget = function () {
  function DropTarget() {
    _classCallCheck(this, DropTarget);
  }

  _createClass(DropTarget, [{
    key: "canDrop",
    value: function canDrop() {
      return true;
    }
  }, {
    key: "hover",
    value: function hover() {}
  }, {
    key: "drop",
    value: function drop() {}
  }]);

  return DropTarget;
}();

exports.default = DropTarget;
},{}],149:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _asap = require('asap');

var _asap2 = _interopRequireDefault(_asap);

var _registry = require('./actions/registry');

var _getNextUniqueId = require('./utils/getNextUniqueId');

var _getNextUniqueId2 = _interopRequireDefault(_getNextUniqueId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HandlerRoles = {
  SOURCE: 'SOURCE',
  TARGET: 'TARGET'
};

function validateSourceContract(source) {
  (0, _invariant2.default)(typeof source.canDrag === 'function', 'Expected canDrag to be a function.');
  (0, _invariant2.default)(typeof source.beginDrag === 'function', 'Expected beginDrag to be a function.');
  (0, _invariant2.default)(typeof source.endDrag === 'function', 'Expected endDrag to be a function.');
}

function validateTargetContract(target) {
  (0, _invariant2.default)(typeof target.canDrop === 'function', 'Expected canDrop to be a function.');
  (0, _invariant2.default)(typeof target.hover === 'function', 'Expected hover to be a function.');
  (0, _invariant2.default)(typeof target.drop === 'function', 'Expected beginDrag to be a function.');
}

function validateType(type, allowArray) {
  if (allowArray && (0, _isArray2.default)(type)) {
    type.forEach(function (t) {
      return validateType(t, false);
    });
    return;
  }

  (0, _invariant2.default)(typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol', allowArray ? 'Type can only be a string, a symbol, or an array of either.' : 'Type can only be a string or a symbol.');
}

function getNextHandlerId(role) {
  var id = (0, _getNextUniqueId2.default)().toString();
  switch (role) {
    case HandlerRoles.SOURCE:
      return 'S' + id;
    case HandlerRoles.TARGET:
      return 'T' + id;
    default:
      (0, _invariant2.default)(false, 'Unknown role: ' + role);
  }
}

function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case 'S':
      return HandlerRoles.SOURCE;
    case 'T':
      return HandlerRoles.TARGET;
    default:
      (0, _invariant2.default)(false, 'Cannot parse handler ID: ' + handlerId);
  }
}

var HandlerRegistry = function () {
  function HandlerRegistry(store) {
    _classCallCheck(this, HandlerRegistry);

    this.store = store;

    this.types = {};
    this.handlers = {};

    this.pinnedSourceId = null;
    this.pinnedSource = null;
  }

  _createClass(HandlerRegistry, [{
    key: 'addSource',
    value: function addSource(type, source) {
      validateType(type);
      validateSourceContract(source);

      var sourceId = this.addHandler(HandlerRoles.SOURCE, type, source);
      this.store.dispatch((0, _registry.addSource)(sourceId));
      return sourceId;
    }
  }, {
    key: 'addTarget',
    value: function addTarget(type, target) {
      validateType(type, true);
      validateTargetContract(target);

      var targetId = this.addHandler(HandlerRoles.TARGET, type, target);
      this.store.dispatch((0, _registry.addTarget)(targetId));
      return targetId;
    }
  }, {
    key: 'addHandler',
    value: function addHandler(role, type, handler) {
      var id = getNextHandlerId(role);
      this.types[id] = type;
      this.handlers[id] = handler;

      return id;
    }
  }, {
    key: 'containsHandler',
    value: function containsHandler(handler) {
      var _this = this;

      return Object.keys(this.handlers).some(function (key) {
        return _this.handlers[key] === handler;
      });
    }
  }, {
    key: 'getSource',
    value: function getSource(sourceId, includePinned) {
      (0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');

      var isPinned = includePinned && sourceId === this.pinnedSourceId;
      var source = isPinned ? this.pinnedSource : this.handlers[sourceId];

      return source;
    }
  }, {
    key: 'getTarget',
    value: function getTarget(targetId) {
      (0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
      return this.handlers[targetId];
    }
  }, {
    key: 'getSourceType',
    value: function getSourceType(sourceId) {
      (0, _invariant2.default)(this.isSourceId(sourceId), 'Expected a valid source ID.');
      return this.types[sourceId];
    }
  }, {
    key: 'getTargetType',
    value: function getTargetType(targetId) {
      (0, _invariant2.default)(this.isTargetId(targetId), 'Expected a valid target ID.');
      return this.types[targetId];
    }
  }, {
    key: 'isSourceId',
    value: function isSourceId(handlerId) {
      var role = parseRoleFromHandlerId(handlerId);
      return role === HandlerRoles.SOURCE;
    }
  }, {
    key: 'isTargetId',
    value: function isTargetId(handlerId) {
      var role = parseRoleFromHandlerId(handlerId);
      return role === HandlerRoles.TARGET;
    }
  }, {
    key: 'removeSource',
    value: function removeSource(sourceId) {
      var _this2 = this;

      (0, _invariant2.default)(this.getSource(sourceId), 'Expected an existing source.');
      this.store.dispatch((0, _registry.removeSource)(sourceId));

      (0, _asap2.default)(function () {
        delete _this2.handlers[sourceId];
        delete _this2.types[sourceId];
      });
    }
  }, {
    key: 'removeTarget',
    value: function removeTarget(targetId) {
      var _this3 = this;

      (0, _invariant2.default)(this.getTarget(targetId), 'Expected an existing target.');
      this.store.dispatch((0, _registry.removeTarget)(targetId));

      (0, _asap2.default)(function () {
        delete _this3.handlers[targetId];
        delete _this3.types[targetId];
      });
    }
  }, {
    key: 'pinSource',
    value: function pinSource(sourceId) {
      var source = this.getSource(sourceId);
      (0, _invariant2.default)(source, 'Expected an existing source.');

      this.pinnedSourceId = sourceId;
      this.pinnedSource = source;
    }
  }, {
    key: 'unpinSource',
    value: function unpinSource() {
      (0, _invariant2.default)(this.pinnedSource, 'No source is pinned at the time.');

      this.pinnedSourceId = null;
      this.pinnedSource = null;
    }
  }]);

  return HandlerRegistry;
}();

exports.default = HandlerRegistry;
},{"./actions/registry":151,"./utils/getNextUniqueId":160,"asap":26,"invariant":327,"lodash/isArray":234}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.END_DRAG = exports.DROP = exports.HOVER = exports.PUBLISH_DRAG_SOURCE = exports.BEGIN_DRAG = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.beginDrag = beginDrag;
exports.publishDragSource = publishDragSource;
exports.hover = hover;
exports.drop = drop;
exports.endDrag = endDrag;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _matchesType = require('../utils/matchesType');

var _matchesType2 = _interopRequireDefault(_matchesType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BEGIN_DRAG = exports.BEGIN_DRAG = 'dnd-core/BEGIN_DRAG';
var PUBLISH_DRAG_SOURCE = exports.PUBLISH_DRAG_SOURCE = 'dnd-core/PUBLISH_DRAG_SOURCE';
var HOVER = exports.HOVER = 'dnd-core/HOVER';
var DROP = exports.DROP = 'dnd-core/DROP';
var END_DRAG = exports.END_DRAG = 'dnd-core/END_DRAG';

function beginDrag(sourceIds) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { publishSource: true, clientOffset: null };
  var publishSource = options.publishSource,
      clientOffset = options.clientOffset,
      getSourceClientOffset = options.getSourceClientOffset;

  (0, _invariant2.default)((0, _isArray2.default)(sourceIds), 'Expected sourceIds to be an array.');

  var monitor = this.getMonitor();
  var registry = this.getRegistry();
  (0, _invariant2.default)(!monitor.isDragging(), 'Cannot call beginDrag while dragging.');

  for (var i = 0; i < sourceIds.length; i++) {
    (0, _invariant2.default)(registry.getSource(sourceIds[i]), 'Expected sourceIds to be registered.');
  }

  var sourceId = null;
  for (var _i = sourceIds.length - 1; _i >= 0; _i--) {
    if (monitor.canDragSource(sourceIds[_i])) {
      sourceId = sourceIds[_i];
      break;
    }
  }
  if (sourceId === null) {
    return;
  }

  var sourceClientOffset = null;
  if (clientOffset) {
    (0, _invariant2.default)(typeof getSourceClientOffset === 'function', 'When clientOffset is provided, getSourceClientOffset must be a function.');
    sourceClientOffset = getSourceClientOffset(sourceId);
  }

  var source = registry.getSource(sourceId);
  var item = source.beginDrag(monitor, sourceId);
  (0, _invariant2.default)((0, _isObject2.default)(item), 'Item must be an object.');

  registry.pinSource(sourceId);

  var itemType = registry.getSourceType(sourceId);
  return {
    type: BEGIN_DRAG,
    itemType: itemType,
    item: item,
    sourceId: sourceId,
    clientOffset: clientOffset,
    sourceClientOffset: sourceClientOffset,
    isSourcePublic: publishSource
  };
}

function publishDragSource() {
  var monitor = this.getMonitor();
  if (!monitor.isDragging()) {
    return;
  }

  return { type: PUBLISH_DRAG_SOURCE };
}

function hover(targetIdsArg) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clientOffset = _ref.clientOffset,
      clientOffset = _ref$clientOffset === undefined ? null : _ref$clientOffset;

  (0, _invariant2.default)((0, _isArray2.default)(targetIdsArg), 'Expected targetIds to be an array.');
  var targetIds = targetIdsArg.slice(0);

  var monitor = this.getMonitor();
  var registry = this.getRegistry();
  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call hover while not dragging.');
  (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call hover after drop.');

  // First check invariants.
  for (var i = 0; i < targetIds.length; i++) {
    var targetId = targetIds[i];
    (0, _invariant2.default)(targetIds.lastIndexOf(targetId) === i, 'Expected targetIds to be unique in the passed array.');

    var target = registry.getTarget(targetId);
    (0, _invariant2.default)(target, 'Expected targetIds to be registered.');
  }

  var draggedItemType = monitor.getItemType();

  // Remove those targetIds that don't match the targetType.  This
  // fixes shallow isOver which would only be non-shallow because of
  // non-matching targets.
  for (var _i2 = targetIds.length - 1; _i2 >= 0; _i2--) {
    var _targetId = targetIds[_i2];
    var targetType = registry.getTargetType(_targetId);
    if (!(0, _matchesType2.default)(targetType, draggedItemType)) {
      targetIds.splice(_i2, 1);
    }
  }

  // Finally call hover on all matching targets.
  for (var _i3 = 0; _i3 < targetIds.length; _i3++) {
    var _targetId2 = targetIds[_i3];
    var _target = registry.getTarget(_targetId2);
    _target.hover(monitor, _targetId2);
  }

  return {
    type: HOVER,
    targetIds: targetIds,
    clientOffset: clientOffset
  };
}

function drop() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var monitor = this.getMonitor();
  var registry = this.getRegistry();
  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call drop while not dragging.');
  (0, _invariant2.default)(!monitor.didDrop(), 'Cannot call drop twice during one drag operation.');

  var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);

  targetIds.reverse();
  targetIds.forEach(function (targetId, index) {
    var target = registry.getTarget(targetId);

    var dropResult = target.drop(monitor, targetId);
    (0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isObject2.default)(dropResult), 'Drop result must either be an object or undefined.');
    if (typeof dropResult === 'undefined') {
      dropResult = index === 0 ? {} : monitor.getDropResult();
    }

    _this.store.dispatch({
      type: DROP,
      dropResult: _extends({}, options, dropResult)
    });
  });
}

function endDrag() {
  var monitor = this.getMonitor();
  var registry = this.getRegistry();
  (0, _invariant2.default)(monitor.isDragging(), 'Cannot call endDrag while not dragging.');

  var sourceId = monitor.getSourceId();
  var source = registry.getSource(sourceId, true);
  source.endDrag(monitor, sourceId);

  registry.unpinSource();

  return { type: END_DRAG };
}
},{"../utils/matchesType":161,"invariant":327,"lodash/isArray":234,"lodash/isObject":239}],151:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addSource = addSource;
exports.addTarget = addTarget;
exports.removeSource = removeSource;
exports.removeTarget = removeTarget;
var ADD_SOURCE = exports.ADD_SOURCE = 'dnd-core/ADD_SOURCE';
var ADD_TARGET = exports.ADD_TARGET = 'dnd-core/ADD_TARGET';
var REMOVE_SOURCE = exports.REMOVE_SOURCE = 'dnd-core/REMOVE_SOURCE';
var REMOVE_TARGET = exports.REMOVE_TARGET = 'dnd-core/REMOVE_TARGET';

function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    sourceId: sourceId
  };
}

function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    targetId: targetId
  };
}

function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    sourceId: sourceId
  };
}

function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    targetId: targetId
  };
}
},{}],152:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createBackend;

var _noop = require('lodash/noop');

var _noop2 = _interopRequireDefault(_noop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TestBackend = function () {
  function TestBackend(manager) {
    _classCallCheck(this, TestBackend);

    this.actions = manager.getActions();
  }

  _createClass(TestBackend, [{
    key: 'setup',
    value: function setup() {
      this.didCallSetup = true;
    }
  }, {
    key: 'teardown',
    value: function teardown() {
      this.didCallTeardown = true;
    }
  }, {
    key: 'connectDragSource',
    value: function connectDragSource() {
      return _noop2.default;
    }
  }, {
    key: 'connectDragPreview',
    value: function connectDragPreview() {
      return _noop2.default;
    }
  }, {
    key: 'connectDropTarget',
    value: function connectDropTarget() {
      return _noop2.default;
    }
  }, {
    key: 'simulateBeginDrag',
    value: function simulateBeginDrag(sourceIds, options) {
      this.actions.beginDrag(sourceIds, options);
    }
  }, {
    key: 'simulatePublishDragSource',
    value: function simulatePublishDragSource() {
      this.actions.publishDragSource();
    }
  }, {
    key: 'simulateHover',
    value: function simulateHover(targetIds, options) {
      this.actions.hover(targetIds, options);
    }
  }, {
    key: 'simulateDrop',
    value: function simulateDrop() {
      this.actions.drop();
    }
  }, {
    key: 'simulateEndDrag',
    value: function simulateEndDrag() {
      this.actions.endDrag();
    }
  }]);

  return TestBackend;
}();

function createBackend(manager) {
  return new TestBackend(manager);
}
},{"lodash/noop":241}],153:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _DragDropManager = require('./DragDropManager');

Object.defineProperty(exports, 'DragDropManager', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragDropManager).default;
  }
});

var _DragSource = require('./DragSource');

Object.defineProperty(exports, 'DragSource', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragSource).default;
  }
});

var _DropTarget = require('./DropTarget');

Object.defineProperty(exports, 'DropTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DropTarget).default;
  }
});

var _createTestBackend = require('./backends/createTestBackend');

Object.defineProperty(exports, 'createTestBackend', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_createTestBackend).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./DragDropManager":145,"./DragSource":147,"./DropTarget":148,"./backends/createTestBackend":152}],154:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = dirtyHandlerIds;
exports.areDirty = areDirty;

var _xor = require('lodash/xor');

var _xor2 = _interopRequireDefault(_xor);

var _intersection = require('lodash/intersection');

var _intersection2 = _interopRequireDefault(_intersection);

var _dragDrop = require('../actions/dragDrop');

var _registry = require('../actions/registry');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NONE = [];
var ALL = [];

function dirtyHandlerIds() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NONE;
  var action = arguments[1];
  var dragOperation = arguments[2];

  switch (action.type) {
    case _dragDrop.HOVER:
      break;
    case _registry.ADD_SOURCE:
    case _registry.ADD_TARGET:
    case _registry.REMOVE_TARGET:
    case _registry.REMOVE_SOURCE:
      return NONE;
    case _dragDrop.BEGIN_DRAG:
    case _dragDrop.PUBLISH_DRAG_SOURCE:
    case _dragDrop.END_DRAG:
    case _dragDrop.DROP:
    default:
      return ALL;
  }

  var targetIds = action.targetIds;
  var prevTargetIds = dragOperation.targetIds;

  var result = (0, _xor2.default)(targetIds, prevTargetIds);

  var didChange = false;
  if (result.length === 0) {
    for (var i = 0; i < targetIds.length; i++) {
      if (targetIds[i] !== prevTargetIds[i]) {
        didChange = true;
        break;
      }
    }
  } else {
    didChange = true;
  }

  if (!didChange) {
    return NONE;
  }

  var prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  var innermostTargetId = targetIds[targetIds.length - 1];

  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }

  return result;
}

function areDirty(state, handlerIds) {
  if (state === NONE) {
    return false;
  }

  if (state === ALL || typeof handlerIds === 'undefined') {
    return true;
  }

  return (0, _intersection2.default)(handlerIds, state).length > 0;
}
},{"../actions/dragDrop":150,"../actions/registry":151,"lodash/intersection":232,"lodash/xor":243}],155:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = dragOffset;
exports.getSourceClientOffset = getSourceClientOffset;
exports.getDifferenceFromInitialOffset = getDifferenceFromInitialOffset;

var _dragDrop = require('../actions/dragDrop');

var initialState = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};

function areOffsetsEqual(offsetA, offsetB) {
  if (offsetA === offsetB) {
    return true;
  }
  return offsetA && offsetB && offsetA.x === offsetB.x && offsetA.y === offsetB.y;
}

function dragOffset() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case _dragDrop.BEGIN_DRAG:
      return {
        initialSourceClientOffset: action.sourceClientOffset,
        initialClientOffset: action.clientOffset,
        clientOffset: action.clientOffset
      };
    case _dragDrop.HOVER:
      if (areOffsetsEqual(state.clientOffset, action.clientOffset)) {
        return state;
      }
      return _extends({}, state, {
        clientOffset: action.clientOffset
      });
    case _dragDrop.END_DRAG:
    case _dragDrop.DROP:
      return initialState;
    default:
      return state;
  }
}

function getSourceClientOffset(state) {
  var clientOffset = state.clientOffset,
      initialClientOffset = state.initialClientOffset,
      initialSourceClientOffset = state.initialSourceClientOffset;

  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return {
    x: clientOffset.x + initialSourceClientOffset.x - initialClientOffset.x,
    y: clientOffset.y + initialSourceClientOffset.y - initialClientOffset.y
  };
}

function getDifferenceFromInitialOffset(state) {
  var clientOffset = state.clientOffset,
      initialClientOffset = state.initialClientOffset;

  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return {
    x: clientOffset.x - initialClientOffset.x,
    y: clientOffset.y - initialClientOffset.y
  };
}
},{"../actions/dragDrop":150}],156:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = dragOperation;

var _without = require('lodash/without');

var _without2 = _interopRequireDefault(_without);

var _dragDrop = require('../actions/dragDrop');

var _registry = require('../actions/registry');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var initialState = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: false,
  isSourcePublic: null
};

function dragOperation() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;
  var action = arguments[1];

  switch (action.type) {
    case _dragDrop.BEGIN_DRAG:
      return _extends({}, state, {
        itemType: action.itemType,
        item: action.item,
        sourceId: action.sourceId,
        isSourcePublic: action.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case _dragDrop.PUBLISH_DRAG_SOURCE:
      return _extends({}, state, {
        isSourcePublic: true
      });
    case _dragDrop.HOVER:
      return _extends({}, state, {
        targetIds: action.targetIds
      });
    case _registry.REMOVE_TARGET:
      if (state.targetIds.indexOf(action.targetId) === -1) {
        return state;
      }
      return _extends({}, state, {
        targetIds: (0, _without2.default)(state.targetIds, action.targetId)
      });
    case _dragDrop.DROP:
      return _extends({}, state, {
        dropResult: action.dropResult,
        didDrop: true,
        targetIds: []
      });
    case _dragDrop.END_DRAG:
      return _extends({}, state, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
},{"../actions/dragDrop":150,"../actions/registry":151,"lodash/without":242}],157:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduce;

var _dragOffset = require('./dragOffset');

var _dragOffset2 = _interopRequireDefault(_dragOffset);

var _dragOperation = require('./dragOperation');

var _dragOperation2 = _interopRequireDefault(_dragOperation);

var _refCount = require('./refCount');

var _refCount2 = _interopRequireDefault(_refCount);

var _dirtyHandlerIds = require('./dirtyHandlerIds');

var _dirtyHandlerIds2 = _interopRequireDefault(_dirtyHandlerIds);

var _stateId = require('./stateId');

var _stateId2 = _interopRequireDefault(_stateId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function reduce() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var action = arguments[1];

  return {
    dirtyHandlerIds: (0, _dirtyHandlerIds2.default)(state.dirtyHandlerIds, action, state.dragOperation),
    dragOffset: (0, _dragOffset2.default)(state.dragOffset, action),
    refCount: (0, _refCount2.default)(state.refCount, action),
    dragOperation: (0, _dragOperation2.default)(state.dragOperation, action),
    stateId: (0, _stateId2.default)(state.stateId)
  };
}
},{"./dirtyHandlerIds":154,"./dragOffset":155,"./dragOperation":156,"./refCount":158,"./stateId":159}],158:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = refCount;

var _registry = require('../actions/registry');

function refCount() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var action = arguments[1];

  switch (action.type) {
    case _registry.ADD_SOURCE:
    case _registry.ADD_TARGET:
      return state + 1;
    case _registry.REMOVE_SOURCE:
    case _registry.REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
},{"../actions/registry":151}],159:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = stateId;
function stateId() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

  return state + 1;
}
},{}],160:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getNextUniqueId;
var nextUniqueId = 0;

function getNextUniqueId() {
  return nextUniqueId++;
}
},{}],161:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = matchesType;

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function matchesType(targetType, draggedItemType) {
  if ((0, _isArray2.default)(targetType)) {
    return targetType.some(function (t) {
      return t === draggedItemType;
    });
  } else {
    return targetType === draggedItemType;
  }
}
},{"lodash/isArray":234}],162:[function(require,module,exports){
var hashClear = require('./_hashClear'),
    hashDelete = require('./_hashDelete'),
    hashGet = require('./_hashGet'),
    hashHas = require('./_hashHas'),
    hashSet = require('./_hashSet');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;

},{"./_hashClear":200,"./_hashDelete":201,"./_hashGet":202,"./_hashHas":203,"./_hashSet":204}],163:[function(require,module,exports){
var listCacheClear = require('./_listCacheClear'),
    listCacheDelete = require('./_listCacheDelete'),
    listCacheGet = require('./_listCacheGet'),
    listCacheHas = require('./_listCacheHas'),
    listCacheSet = require('./_listCacheSet');

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;

},{"./_listCacheClear":208,"./_listCacheDelete":209,"./_listCacheGet":210,"./_listCacheHas":211,"./_listCacheSet":212}],164:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;

},{"./_getNative":197,"./_root":221}],165:[function(require,module,exports){
var mapCacheClear = require('./_mapCacheClear'),
    mapCacheDelete = require('./_mapCacheDelete'),
    mapCacheGet = require('./_mapCacheGet'),
    mapCacheHas = require('./_mapCacheHas'),
    mapCacheSet = require('./_mapCacheSet');

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;

},{"./_mapCacheClear":213,"./_mapCacheDelete":214,"./_mapCacheGet":215,"./_mapCacheHas":216,"./_mapCacheSet":217}],166:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;

},{"./_getNative":197,"./_root":221}],167:[function(require,module,exports){
var MapCache = require('./_MapCache'),
    setCacheAdd = require('./_setCacheAdd'),
    setCacheHas = require('./_setCacheHas');

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;

},{"./_MapCache":165,"./_setCacheAdd":222,"./_setCacheHas":223}],168:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":221}],169:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],170:[function(require,module,exports){
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;

},{}],171:[function(require,module,exports){
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

},{"./_baseIndexOf":180}],172:[function(require,module,exports){
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

},{}],173:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],174:[function(require,module,exports){
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;

},{}],175:[function(require,module,exports){
var eq = require('./eq');

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;

},{"./eq":230}],176:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

},{"./_SetCache":167,"./_arrayIncludes":171,"./_arrayIncludesWith":172,"./_arrayMap":173,"./_baseUnary":187,"./_cacheHas":190}],177:[function(require,module,exports){
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

},{}],178:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

},{"./_arrayPush":174,"./_isFlattenable":205}],179:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":168,"./_getRawTag":198,"./_objectToString":219}],180:[function(require,module,exports){
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

},{"./_baseFindIndex":177,"./_baseIsNaN":183,"./_strictIndexOf":227}],181:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;

},{"./_SetCache":167,"./_arrayIncludes":171,"./_arrayIncludesWith":172,"./_arrayMap":173,"./_baseUnary":187,"./_cacheHas":190}],182:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;

},{"./_baseGetTag":179,"./isObjectLike":240}],183:[function(require,module,exports){
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

},{}],184:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isMasked":207,"./_toSource":228,"./isFunction":237,"./isObject":239}],185:[function(require,module,exports){
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

},{"./_overRest":220,"./_setToString":225,"./identity":231}],186:[function(require,module,exports){
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

},{"./_defineProperty":194,"./constant":229,"./identity":231}],187:[function(require,module,exports){
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;

},{}],188:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

},{"./_SetCache":167,"./_arrayIncludes":171,"./_arrayIncludesWith":172,"./_cacheHas":190,"./_createSet":193,"./_setToArray":224}],189:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseUniq = require('./_baseUniq');

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : [];
  }
  var index = -1,
      result = Array(length);

  while (++index < length) {
    var array = arrays[index],
        othIndex = -1;

    while (++othIndex < length) {
      if (othIndex != index) {
        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
      }
    }
  }
  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
}

module.exports = baseXor;

},{"./_baseDifference":176,"./_baseFlatten":178,"./_baseUniq":188}],190:[function(require,module,exports){
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;

},{}],191:[function(require,module,exports){
var isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;

},{"./isArrayLikeObject":236}],192:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":221}],193:[function(require,module,exports){
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

},{"./_Set":166,"./_setToArray":224,"./noop":241}],194:[function(require,module,exports){
var getNative = require('./_getNative');

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;

},{"./_getNative":197}],195:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],196:[function(require,module,exports){
var isKeyable = require('./_isKeyable');

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;

},{"./_isKeyable":206}],197:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":184,"./_getValue":199}],198:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":168}],199:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],200:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;

},{"./_nativeCreate":218}],201:[function(require,module,exports){
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;

},{}],202:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;

},{"./_nativeCreate":218}],203:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;

},{"./_nativeCreate":218}],204:[function(require,module,exports){
var nativeCreate = require('./_nativeCreate');

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;

},{"./_nativeCreate":218}],205:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

},{"./_Symbol":168,"./isArguments":233,"./isArray":234}],206:[function(require,module,exports){
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;

},{}],207:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":192}],208:[function(require,module,exports){
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;

},{}],209:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;

},{"./_assocIndexOf":175}],210:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;

},{"./_assocIndexOf":175}],211:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;

},{"./_assocIndexOf":175}],212:[function(require,module,exports){
var assocIndexOf = require('./_assocIndexOf');

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;

},{"./_assocIndexOf":175}],213:[function(require,module,exports){
var Hash = require('./_Hash'),
    ListCache = require('./_ListCache'),
    Map = require('./_Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;

},{"./_Hash":162,"./_ListCache":163,"./_Map":164}],214:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;

},{"./_getMapData":196}],215:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;

},{"./_getMapData":196}],216:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;

},{"./_getMapData":196}],217:[function(require,module,exports){
var getMapData = require('./_getMapData');

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;

},{"./_getMapData":196}],218:[function(require,module,exports){
var getNative = require('./_getNative');

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;

},{"./_getNative":197}],219:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],220:[function(require,module,exports){
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

},{"./_apply":169}],221:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":195}],222:[function(require,module,exports){
/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;

},{}],223:[function(require,module,exports){
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;

},{}],224:[function(require,module,exports){
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;

},{}],225:[function(require,module,exports){
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

},{"./_baseSetToString":186,"./_shortOut":226}],226:[function(require,module,exports){
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

},{}],227:[function(require,module,exports){
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

},{}],228:[function(require,module,exports){
/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],229:[function(require,module,exports){
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

},{}],230:[function(require,module,exports){
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;

},{}],231:[function(require,module,exports){
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],232:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIntersection = require('./_baseIntersection'),
    baseRest = require('./_baseRest'),
    castArrayLikeObject = require('./_castArrayLikeObject');

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;

},{"./_arrayMap":173,"./_baseIntersection":181,"./_baseRest":185,"./_castArrayLikeObject":191}],233:[function(require,module,exports){
var baseIsArguments = require('./_baseIsArguments'),
    isObjectLike = require('./isObjectLike');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;

},{"./_baseIsArguments":182,"./isObjectLike":240}],234:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],235:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;

},{"./isFunction":237,"./isLength":238}],236:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

},{"./isArrayLike":235,"./isObjectLike":240}],237:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObject = require('./isObject');

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;

},{"./_baseGetTag":179,"./isObject":239}],238:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],239:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],240:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],241:[function(require,module,exports){
/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],242:[function(require,module,exports){
var baseDifference = require('./_baseDifference'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;

},{"./_baseDifference":176,"./_baseRest":185,"./isArrayLikeObject":236}],243:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    baseRest = require('./_baseRest'),
    baseXor = require('./_baseXor'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [2, 3]);
 * // => [1, 3]
 */
var xor = baseRest(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});

module.exports = xor;

},{"./_arrayFilter":170,"./_baseRest":185,"./_baseXor":189,"./isArrayLikeObject":236}],244:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = _utils2["default"].clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  }

  // Left edge inside and right edge outside viewport, try to resize it.
  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  }

  // Right edge outside viewport, try to move it.
  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 保证左边界和可视区域左边界对齐
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  }

  // Top edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  }

  // Top edge inside and bottom edge outside viewport, try to resize it.
  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  }

  // Bottom edge outside viewport, try to move it.
  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 保证上边界和可视区域上边界对齐
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return _utils2["default"].mix(pos, size);
}

exports["default"] = adjustForViewport;
module.exports = exports['default'];
},{"./utils":252}],245:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * 获取 node 上的 align 对齐点 相对于页面的坐标
 */

function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = void 0;
  var y = void 0;

  x = region.left;
  y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

exports["default"] = getAlignOffset;
module.exports = exports['default'];
},{}],246:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getAlignOffset = require('./getAlignOffset');

var _getAlignOffset2 = _interopRequireDefault(_getAlignOffset);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var xy = void 0;
  var diff = void 0;
  var p1 = void 0;
  var p2 = void 0;

  xy = {
    left: elRegion.left,
    top: elRegion.top
  };

  p1 = (0, _getAlignOffset2["default"])(refNodeRegion, points[1]);
  p2 = (0, _getAlignOffset2["default"])(elRegion, points[0]);

  diff = [p2.left - p1.left, p2.top - p1.top];

  return {
    left: xy.left - diff[0] + offset[0] - targetOffset[0],
    top: xy.top - diff[1] + offset[1] - targetOffset[1]
  };
}

exports["default"] = getElFuturePos;
module.exports = exports['default'];
},{"./getAlignOffset":245}],247:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * 得到会导致元素显示不全的祖先元素
 */

function getOffsetParent(element) {
  // ie 这个也不是完全可行
  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
   元素 6 高 100px 宽 50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  // 统一的 offsetParent 方法
  var doc = element.ownerDocument;
  var body = doc.body;
  var parent = void 0;
  var positionStyle = _utils2["default"].css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : element.parentNode;
  }

  for (parent = element.parentNode; parent && parent !== body; parent = parent.parentNode) {
    positionStyle = _utils2["default"].css(parent, 'position');
    if (positionStyle !== 'static') {
      return parent;
    }
  }
  return null;
}

exports["default"] = getOffsetParent;
module.exports = exports['default'];
},{"./utils":252}],248:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function getRegion(node) {
  var offset = void 0;
  var w = void 0;
  var h = void 0;
  if (!_utils2["default"].isWindow(node) && node.nodeType !== 9) {
    offset = _utils2["default"].offset(node);
    w = _utils2["default"].outerWidth(node);
    h = _utils2["default"].outerHeight(node);
  } else {
    var win = _utils2["default"].getWindow(node);
    offset = {
      left: _utils2["default"].getWindowScrollLeft(win),
      top: _utils2["default"].getWindowScrollTop(win)
    };
    w = _utils2["default"].viewportWidth(win);
    h = _utils2["default"].viewportHeight(win);
  }
  offset.width = w;
  offset.height = h;
  return offset;
}

exports["default"] = getRegion;
module.exports = exports['default'];
},{"./utils":252}],249:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

/**
 * 获得元素的显示部分的区域
 */
function getVisibleRectForElement(element) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = (0, _getOffsetParent2["default"])(element);
  var scrollX = void 0;
  var scrollY = void 0;
  var winSize = void 0;
  var doc = element.ownerDocument;
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement;

  // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.
  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) &&
    // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && _utils2["default"].css(el, 'overflow') !== 'visible') {
      var pos = _utils2["default"].offset(el);
      // add border
      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right,
      // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }
    el = (0, _getOffsetParent2["default"])(el);
  }

  // Clip by window's viewport.
  scrollX = _utils2["default"].getWindowScrollLeft(win);
  scrollY = _utils2["default"].getWindowScrollTop(win);
  visibleRect.left = Math.max(visibleRect.left, scrollX);
  visibleRect.top = Math.max(visibleRect.top, scrollY);
  winSize = {
    width: _utils2["default"].viewportWidth(win),
    height: _utils2["default"].viewportHeight(win)
  };
  visibleRect.right = Math.min(visibleRect.right, scrollX + winSize.width);
  visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + winSize.height);
  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

exports["default"] = getVisibleRectForElement;
module.exports = exports['default'];
},{"./getOffsetParent":247,"./utils":252}],250:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _getOffsetParent = require('./getOffsetParent');

var _getOffsetParent2 = _interopRequireDefault(_getOffsetParent);

var _getVisibleRectForElement = require('./getVisibleRectForElement');

var _getVisibleRectForElement2 = _interopRequireDefault(_getVisibleRectForElement);

var _adjustForViewport = require('./adjustForViewport');

var _adjustForViewport2 = _interopRequireDefault(_adjustForViewport);

var _getRegion = require('./getRegion');

var _getRegion2 = _interopRequireDefault(_getRegion);

var _getElFuturePos = require('./getElFuturePos');

var _getElFuturePos2 = _interopRequireDefault(_getElFuturePos);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// http://yiminghe.iteye.com/blog/1124720

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  _utils2["default"].each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n = void 0;
  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }
  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}

function domAlign(el, refNode, align) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var target = align.target || refNode;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};

  var fail = 0;
  // 当前节点可以被放置的显示区域
  var visibleRect = (0, _getVisibleRectForElement2["default"])(source);
  // 当前节点所占的区域, left/top/width/height
  var elRegion = (0, _getRegion2["default"])(source);
  // 参照节点所占的区域, left/top/width/height
  var refNodeRegion = (0, _getRegion2["default"])(target);
  // 将 offset 转换成数值，支持百分比
  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, refNodeRegion);
  // 当前节点将要被放置的位置
  var elFuturePos = (0, _getElFuturePos2["default"])(elRegion, refNodeRegion, points, offset, targetOffset);
  // 当前节点将要所处的区域
  var newElRegion = _utils2["default"].merge(elRegion, elFuturePos);

  // 如果可视区域不能完全放置当前节点时允许调整
  if (visibleRect && (overflow.adjustX || overflow.adjustY)) {
    if (overflow.adjustX) {
      // 如果横向不能放下
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var newPoints = flip(points, /[lr]/ig, {
          l: 'r',
          r: 'l'
        });
        // 偏移量也反下
        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = (0, _getElFuturePos2["default"])(elRegion, refNodeRegion, newPoints, newOffset, newTargetOffset);
        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 如果纵向不能放下
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 对齐位置反下
        var _newPoints = flip(points, /[tb]/ig, {
          t: 'b',
          b: 't'
        });
        // 偏移量也反下
        var _newOffset = flipOffset(offset, 1);
        var _newTargetOffset = flipOffset(targetOffset, 1);
        var _newElFuturePos = (0, _getElFuturePos2["default"])(elRegion, refNodeRegion, _newPoints, _newOffset, _newTargetOffset);
        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    }

    // 如果失败，重新计算当前节点将要被放置的位置
    if (fail) {
      elFuturePos = (0, _getElFuturePos2["default"])(elRegion, refNodeRegion, points, offset, targetOffset);
      _utils2["default"].mix(newElRegion, elFuturePos);
    }

    // 检查反下后的位置是否可以放下了
    // 如果仍然放不下只有指定了可以调整当前方向才调整
    newOverflowCfg.adjustX = overflow.adjustX && isFailX(elFuturePos, elRegion, visibleRect);

    newOverflowCfg.adjustY = overflow.adjustY && isFailY(elFuturePos, elRegion, visibleRect);

    // 确实要调整，甚至可能会调整高度宽度
    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = (0, _adjustForViewport2["default"])(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  }

  // need judge to in case set fixed with in css on height auto element
  if (newElRegion.width !== elRegion.width) {
    _utils2["default"].css(source, 'width', _utils2["default"].width(source) + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    _utils2["default"].css(source, 'height', _utils2["default"].height(source) + newElRegion.height - elRegion.height);
  }

  // https://github.com/kissyteam/kissy/issues/190
  // 相对于屏幕位置没变，而 left/top 变了
  // 例如 <div 'relative'><el absolute></div>
  _utils2["default"].offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform
  });

  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}

domAlign.__getOffsetParent = _getOffsetParent2["default"];

domAlign.__getVisibleRectForElement = _getVisibleRectForElement2["default"];

exports["default"] = domAlign;
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 优化智能对齐算法
 *   - 慎用 resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 增加智能对齐，以及大小调整选项
 **/

module.exports = exports['default'];
},{"./adjustForViewport":244,"./getElFuturePos":246,"./getOffsetParent":247,"./getRegion":248,"./getVisibleRectForElement":249,"./utils":252}],251:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransformName = getTransformName;
exports.setTransitionProperty = setTransitionProperty;
exports.getTransitionProperty = getTransitionProperty;
exports.getTransformXY = getTransformXY;
exports.setTransformXY = setTransformXY;
var vendorPrefix = void 0;

var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};

function getVendorPrefix() {
  if (vendorPrefix !== undefined) {
    return vendorPrefix;
  }
  vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';
  for (var key in jsCssMap) {
    if (key + testProp in style) {
      vendorPrefix = key;
    }
  }
  return vendorPrefix;
}

function getTransitionName() {
  return getVendorPrefix() ? getVendorPrefix() + 'TransitionProperty' : 'transitionProperty';
}

function getTransformName() {
  return getVendorPrefix() ? getVendorPrefix() + 'Transform' : 'transform';
}

function setTransitionProperty(node, value) {
  var name = getTransitionName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}

function setTransform(node, value) {
  var name = getTransformName();
  if (name) {
    node.style[name] = value;
    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}

function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[getTransitionName()];
}

function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return { x: parseFloat(matrix[12] || matrix[4], 0), y: parseFloat(matrix[13] || matrix[5], 0) };
  }
  return {
    x: 0,
    y: 0
  };
}

var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;

function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());
  if (transform && transform !== 'none') {
    var arr = void 0;
    var match2d = transform.match(matrix2d);
    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, 'matrix(' + arr.join(',') + ')');
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, 'matrix3d(' + arr.join(',') + ')');
    }
  } else {
    setTransform(node, 'translateX(' + xy.x + 'px) translateY(' + xy.y + 'px) translateZ(0)');
  }
}
},{}],252:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _propertyUtils = require('./propertyUtils');

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;

var getComputedStyleX = void 0;

function force(x, y) {
  return x + y;
}

function css(el, name, v) {
  var value = v;
  if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }
    return undefined;
  }
  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = value + 'px';
    }
    el.style[name] = value;
    return undefined;
  }
  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box = void 0;
  var x = void 0;
  var y = void 0;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement;
  // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式
  box = elem.getBoundingClientRect();

  // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
  // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
  // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

  x = box.left;
  y = box.top;

  // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.

  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.

  // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
  // 窗口边框标准是设 documentElement ,quirks 时设置 body
  // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
  // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
  // 标准 ie 下 docElem.clientTop 就是 border-top
  // ie7 html 即窗口边框改变不了。永远为 2
  // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;

  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w['page' + (top ? 'Y' : 'X') + 'Offset'];
  var method = 'scroll' + (top ? 'Top' : 'Left');
  if (typeof ret !== 'number') {
    var d = w.document;
    // ie6,7,8 standard mode
    ret = d.documentElement[method];
    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }
  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = elem.ownerDocument;
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null);

  // https://github.com/kissyteam/kissy/issues/61
  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i');
var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name];

  // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
  // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
  // 在 ie 下不对，需要直接用 offset 方式
  // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了

  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity
  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[LEFT];
    var rsLeft = elem[RUNTIME_STYLE][LEFT];

    // prevent flashing of content
    elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT];

    // Put in the new values to get a computed value out
    style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX;

    // Revert the changed values
    style[LEFT] = left;

    elem[RUNTIME_STYLE][LEFT] = rsLeft;
  }
  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }
  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
}

// 设置 elem 相对 elem.ownerDocument 的坐标
function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }
  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }
  var originalTransition = '';
  var originalOffset = getOffset(elem);
  if ('left' in offset || 'top' in offset) {
    originalTransition = (0, _propertyUtils.getTransitionProperty)(elem) || '';
    (0, _propertyUtils.setTransitionProperty)(elem, 'none');
  }
  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = presetH + 'px';
  }
  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = presetV + 'px';
  }
  var old = getOffset(elem);
  var originalStyle = {};
  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];
      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }
  css(elem, originalStyle);
  // force relayout
  force(elem.offsetTop, elem.offsetLeft);
  if ('left' in offset || 'top' in offset) {
    (0, _propertyUtils.setTransitionProperty)(elem, originalTransition);
  }
  var ret = {};
  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);
      var _off = offset[_key] - originalOffset[_key];
      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }
  css(elem, ret);
}

function setTransform(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = (0, _propertyUtils.getTransformXY)(elem);
  var resultXY = { x: originalXY.x, y: originalXY.y };
  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }
  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }
  (0, _propertyUtils.setTransformXY)(elem, resultXY);
}

function setOffset(elem, offset, option) {
  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && (0, _propertyUtils.getTransformName)() in document.body.style) {
    setTransform(elem, offset, option);
  } else {
    setLeftTop(elem, offset, option);
  }
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name = void 0;

  // Remember the old values, and insert the new ones
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem);

  // Revert the old values
  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop = void 0;
  var j = void 0;
  var i = void 0;
  for (j = 0; j < props.length; j++) {
    prop = props[j];
    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;
        if (prop === 'border') {
          cssProp = '' + prop + which[i] + 'Width';
        } else {
          cssProp = prop + which[i];
        }
        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }
  return value;
}

/**
 * A crude way of determining if an object is a window
 * @member util
 */
function isWindow(obj) {
  // must use == for ie8
  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

var domUtils = {};

each(['Width', 'Height'], function (name) {
  domUtils['doc' + name] = function (refWin) {
    var d = refWin.document;
    return Math.max(
    // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement['scroll' + name],
    // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
    d.body['scroll' + name], domUtils['viewport' + name](d));
  };

  domUtils['viewport' + name] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = 'client' + name;
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop];
    // 标准模式取 documentElement
    // backcompat 取 body
    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});

/*
 得到元素的大小信息
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */
function getWH(elem, name, ex) {
  var extra = ex;
  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? elem.offsetWidth : elem.offsetHeight;
  var computedStyle = getComputedStyleX(elem);
  var isBorderBox = isBorderBoxFn(elem, computedStyle);
  var cssBoxValue = 0;
  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined;
    // Fall back to computed then un computed css if necessary
    cssBoxValue = getComputedStyleX(elem, name);
    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    }
    // Normalize '', auto, and prepare for extra
    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }
  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }
  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;
  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which, computedStyle);
    }
    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }
    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
  }
  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
};

// fix #119 : https://github.com/kissyteam/kissy/issues/119
function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var val = void 0;
  var elem = args[0];
  // in case elem is window
  // elem.offsetWidth === undefined
  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }
  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);
  domUtils['outer' + first] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };
  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;
    if (val !== undefined) {
      if (elem) {
        var computedStyle = getComputedStyleX(elem);
        var isBorderBox = isBorderBoxFn(elem);
        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which, computedStyle);
        }
        return css(elem, name, val);
      }
      return undefined;
    }
    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }
  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }
    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },

  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i = void 0;
    var ret = {};
    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }
    var overflow = obj.overflow;
    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }
    return ret;
  },

  mix: mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var _len2 = arguments.length, args = Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }

    for (var i = 0; i < args.length; i++) {
      utils.mix(ret, args[i]);
    }
    return ret;
  },

  viewportWidth: 0,
  viewportHeight: 0
};

mix(utils, domUtils);

exports["default"] = utils;
module.exports = exports['default'];
},{"./propertyUtils":251}],253:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inDOM = require('../util/inDOM');

var _inDOM2 = _interopRequireDefault(_inDOM);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var off = function off() {};
if (_inDOM2.default) {
  off = function () {
    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.removeEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.detachEvent('on' + eventName, handler);
    };
  }();
}

exports.default = off;
module.exports = exports['default'];
},{"../util/inDOM":272}],254:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inDOM = require('../util/inDOM');

var _inDOM2 = _interopRequireDefault(_inDOM);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var on = function on() {};
if (_inDOM2.default) {
  on = function () {

    if (document.addEventListener) return function (node, eventName, handler, capture) {
      return node.addEventListener(eventName, handler, capture || false);
    };else if (document.attachEvent) return function (node, eventName, handler) {
      return node.attachEvent('on' + eventName, function (e) {
        e = e || window.event;
        e.target = e.target || e.srcElement;
        e.currentTarget = node;
        handler.call(node, e);
      });
    };
  }();
}

exports.default = on;
module.exports = exports['default'];
},{"../util/inDOM":272}],255:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ownerDocument;
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}
module.exports = exports["default"];
},{}],256:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _inDOM = require('../util/inDOM');

var _inDOM2 = _interopRequireDefault(_inDOM);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  // HTML DOM and SVG DOM may have different support levels,
  // so we need to check on context instead of a document root element.
  return _inDOM2.default ? function (context, node) {
    if (context.contains) {
      return context.contains(node);
    } else if (context.compareDocumentPosition) {
      return context === node || !!(context.compareDocumentPosition(node) & 16);
    } else {
      return fallback(context, node);
    }
  } : fallback;
}();

function fallback(context, node) {
  if (node) do {
    if (node === context) return true;
  } while (node = node.parentNode);

  return false;
}
module.exports = exports['default'];
},{"../util/inDOM":272}],257:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getWindow;
function getWindow(node) {
  return node === node.window ? node : node.nodeType === 9 ? node.defaultView || node.parentWindow : false;
}
module.exports = exports["default"];
},{}],258:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = offset;

var _contains = require('./contains');

var _contains2 = _interopRequireDefault(_contains);

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

var _ownerDocument = require('../ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function offset(node) {
  var doc = (0, _ownerDocument2.default)(node),
      win = (0, _isWindow2.default)(doc),
      docElem = doc && doc.documentElement,
      box = { top: 0, left: 0, height: 0, width: 0 };

  if (!doc) return;

  // Make sure it's not a disconnected DOM node
  if (!(0, _contains2.default)(docElem, node)) return box;

  if (node.getBoundingClientRect !== undefined) box = node.getBoundingClientRect();

  // IE8 getBoundingClientRect doesn't support width & height
  box = {
    top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
    left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0),
    width: (box.width == null ? node.offsetWidth : box.width) || 0,
    height: (box.height == null ? node.offsetHeight : box.height) || 0
  };

  return box;
}
module.exports = exports['default'];
},{"../ownerDocument":255,"./contains":256,"./isWindow":257}],259:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = offsetParent;

var _ownerDocument = require('../ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

var _style = require('../style');

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function nodeName(node) {
  return node.nodeName && node.nodeName.toLowerCase();
}

function offsetParent(node) {
  var doc = (0, _ownerDocument2.default)(node),
      offsetParent = node && node.offsetParent;

  while (offsetParent && nodeName(node) !== 'html' && (0, _style2.default)(offsetParent, 'position') === 'static') {
    offsetParent = offsetParent.offsetParent;
  }

  return offsetParent || doc.documentElement;
}
module.exports = exports['default'];
},{"../ownerDocument":255,"../style":264}],260:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.default = position;

var _offset = require('./offset');

var _offset2 = _interopRequireDefault(_offset);

var _offsetParent = require('./offsetParent');

var _offsetParent2 = _interopRequireDefault(_offsetParent);

var _scrollTop = require('./scrollTop');

var _scrollTop2 = _interopRequireDefault(_scrollTop);

var _scrollLeft = require('./scrollLeft');

var _scrollLeft2 = _interopRequireDefault(_scrollLeft);

var _style = require('../style');

var _style2 = _interopRequireDefault(_style);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function nodeName(node) {
  return node.nodeName && node.nodeName.toLowerCase();
}

function position(node, offsetParent) {
  var parentOffset = { top: 0, left: 0 },
      offset;

  // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
  // because it is its only offset parent
  if ((0, _style2.default)(node, 'position') === 'fixed') {
    offset = node.getBoundingClientRect();
  } else {
    offsetParent = offsetParent || (0, _offsetParent2.default)(node);
    offset = (0, _offset2.default)(node);

    if (nodeName(offsetParent) !== 'html') parentOffset = (0, _offset2.default)(offsetParent);

    parentOffset.top += parseInt((0, _style2.default)(offsetParent, 'borderTopWidth'), 10) - (0, _scrollTop2.default)(offsetParent) || 0;
    parentOffset.left += parseInt((0, _style2.default)(offsetParent, 'borderLeftWidth'), 10) - (0, _scrollLeft2.default)(offsetParent) || 0;
  }

  // Subtract parent offsets and node margins
  return _extends({}, offset, {
    top: offset.top - parentOffset.top - (parseInt((0, _style2.default)(node, 'marginTop'), 10) || 0),
    left: offset.left - parentOffset.left - (parseInt((0, _style2.default)(node, 'marginLeft'), 10) || 0)
  });
}
module.exports = exports['default'];
},{"../style":264,"./offset":258,"./offsetParent":259,"./scrollLeft":261,"./scrollTop":262}],261:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scrollTop;

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scrollTop(node, val) {
  var win = (0, _isWindow2.default)(node);

  if (val === undefined) return win ? 'pageXOffset' in win ? win.pageXOffset : win.document.documentElement.scrollLeft : node.scrollLeft;

  if (win) win.scrollTo(val, 'pageYOffset' in win ? win.pageYOffset : win.document.documentElement.scrollTop);else node.scrollLeft = val;
}
module.exports = exports['default'];
},{"./isWindow":257}],262:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = scrollTop;

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scrollTop(node, val) {
  var win = (0, _isWindow2.default)(node);

  if (val === undefined) return win ? 'pageYOffset' in win ? win.pageYOffset : win.document.documentElement.scrollTop : node.scrollTop;

  if (win) win.scrollTo('pageXOffset' in win ? win.pageXOffset : win.document.documentElement.scrollLeft, val);else node.scrollTop = val;
}
module.exports = exports['default'];
},{"./isWindow":257}],263:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _getComputedStyle;

var _camelizeStyle = require('../util/camelizeStyle');

var _camelizeStyle2 = _interopRequireDefault(_camelizeStyle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var rposition = /^(top|right|bottom|left)$/;
var rnumnonpx = /^([+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|))(?!px)[a-z%]+$/i;

function _getComputedStyle(node) {
  if (!node) throw new TypeError('No Element passed to `getComputedStyle()`');
  var doc = node.ownerDocument;

  return 'defaultView' in doc ? doc.defaultView.opener ? node.ownerDocument.defaultView.getComputedStyle(node, null) : window.getComputedStyle(node, null) : {
    //ie 8 "magic" from: https://github.com/jquery/jquery/blob/1.11-stable/src/css/curCSS.js#L72
    getPropertyValue: function getPropertyValue(prop) {
      var style = node.style;

      prop = (0, _camelizeStyle2.default)(prop);

      if (prop == 'float') prop = 'styleFloat';

      var current = node.currentStyle[prop] || null;

      if (current == null && style && style[prop]) current = style[prop];

      if (rnumnonpx.test(current) && !rposition.test(prop)) {
        // Remember the original values
        var left = style.left;
        var runStyle = node.runtimeStyle;
        var rsLeft = runStyle && runStyle.left;

        // Put in the new values to get a computed value out
        if (rsLeft) runStyle.left = node.currentStyle.left;

        style.left = prop === 'fontSize' ? '1em' : current;
        current = style.pixelLeft + 'px';

        // Revert the changed values
        style.left = left;
        if (rsLeft) runStyle.left = rsLeft;
      }

      return current;
    }
  };
}
module.exports = exports['default'];
},{"../util/camelizeStyle":269}],264:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = style;

var _camelizeStyle = require('../util/camelizeStyle');

var _camelizeStyle2 = _interopRequireDefault(_camelizeStyle);

var _hyphenateStyle = require('../util/hyphenateStyle');

var _hyphenateStyle2 = _interopRequireDefault(_hyphenateStyle);

var _getComputedStyle2 = require('./getComputedStyle');

var _getComputedStyle3 = _interopRequireDefault(_getComputedStyle2);

var _removeStyle = require('./removeStyle');

var _removeStyle2 = _interopRequireDefault(_removeStyle);

var _properties = require('../transition/properties');

var _isTransform = require('../transition/isTransform');

var _isTransform2 = _interopRequireDefault(_isTransform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function style(node, property, value) {
  var css = '';
  var transforms = '';
  var props = property;

  if (typeof property === 'string') {
    if (value === undefined) {
      return node.style[(0, _camelizeStyle2.default)(property)] || (0, _getComputedStyle3.default)(node).getPropertyValue((0, _hyphenateStyle2.default)(property));
    } else {
      (props = {})[property] = value;
    }
  }

  Object.keys(props).forEach(function (key) {
    var value = props[key];
    if (!value && value !== 0) {
      (0, _removeStyle2.default)(node, (0, _hyphenateStyle2.default)(key));
    } else if ((0, _isTransform2.default)(key)) {
      transforms += key + '(' + value + ') ';
    } else {
      css += (0, _hyphenateStyle2.default)(key) + ': ' + value + ';';
    }
  });

  if (transforms) {
    css += _properties.transform + ': ' + transforms + ';';
  }

  node.style.cssText += ';' + css;
}
module.exports = exports['default'];
},{"../transition/isTransform":266,"../transition/properties":267,"../util/camelizeStyle":269,"../util/hyphenateStyle":271,"./getComputedStyle":263,"./removeStyle":265}],265:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = removeStyle;
function removeStyle(node, key) {
  return 'removeProperty' in node.style ? node.style.removeProperty(key) : node.style.removeAttribute(key);
}
module.exports = exports['default'];
},{}],266:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = isTransform;
var supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i;

function isTransform(property) {
  return !!(property && supportedTransforms.test(property));
}
module.exports = exports["default"];
},{}],267:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.animationEnd = exports.animationDelay = exports.animationTiming = exports.animationDuration = exports.animationName = exports.transitionEnd = exports.transitionDuration = exports.transitionDelay = exports.transitionTiming = exports.transitionProperty = exports.transform = undefined;

var _inDOM = require('../util/inDOM');

var _inDOM2 = _interopRequireDefault(_inDOM);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transform = 'transform';
var prefix = void 0,
    transitionEnd = void 0,
    animationEnd = void 0;
var transitionProperty = void 0,
    transitionDuration = void 0,
    transitionTiming = void 0,
    transitionDelay = void 0;
var animationName = void 0,
    animationDuration = void 0,
    animationTiming = void 0,
    animationDelay = void 0;

if (_inDOM2.default) {
  var _getTransitionPropert = getTransitionProperties();

  prefix = _getTransitionPropert.prefix;
  exports.transitionEnd = transitionEnd = _getTransitionPropert.transitionEnd;
  exports.animationEnd = animationEnd = _getTransitionPropert.animationEnd;


  exports.transform = transform = prefix + '-' + transform;
  exports.transitionProperty = transitionProperty = prefix + '-transition-property';
  exports.transitionDuration = transitionDuration = prefix + '-transition-duration';
  exports.transitionDelay = transitionDelay = prefix + '-transition-delay';
  exports.transitionTiming = transitionTiming = prefix + '-transition-timing-function';

  exports.animationName = animationName = prefix + '-animation-name';
  exports.animationDuration = animationDuration = prefix + '-animation-duration';
  exports.animationTiming = animationTiming = prefix + '-animation-delay';
  exports.animationDelay = animationDelay = prefix + '-animation-timing-function';
}

exports.transform = transform;
exports.transitionProperty = transitionProperty;
exports.transitionTiming = transitionTiming;
exports.transitionDelay = transitionDelay;
exports.transitionDuration = transitionDuration;
exports.transitionEnd = transitionEnd;
exports.animationName = animationName;
exports.animationDuration = animationDuration;
exports.animationTiming = animationTiming;
exports.animationDelay = animationDelay;
exports.animationEnd = animationEnd;
exports.default = {
  transform: transform,
  end: transitionEnd,
  property: transitionProperty,
  timing: transitionTiming,
  delay: transitionDelay,
  duration: transitionDuration
};


function getTransitionProperties() {
  var style = document.createElement('div').style;

  var vendorMap = {
    O: function O(e) {
      return 'o' + e.toLowerCase();
    },
    Moz: function Moz(e) {
      return e.toLowerCase();
    },
    Webkit: function Webkit(e) {
      return 'webkit' + e;
    },
    ms: function ms(e) {
      return 'MS' + e;
    }
  };

  var vendors = Object.keys(vendorMap);

  var transitionEnd = void 0,
      animationEnd = void 0;
  var prefix = '';

  for (var i = 0; i < vendors.length; i++) {
    var vendor = vendors[i];

    if (vendor + 'TransitionProperty' in style) {
      prefix = '-' + vendor.toLowerCase();
      transitionEnd = vendorMap[vendor]('TransitionEnd');
      animationEnd = vendorMap[vendor]('AnimationEnd');
      break;
    }
  }

  if (!transitionEnd && 'transitionProperty' in style) transitionEnd = 'transitionend';

  if (!animationEnd && 'animationName' in style) animationEnd = 'animationend';

  style = null;

  return { animationEnd: animationEnd, transitionEnd: transitionEnd, prefix: prefix };
}
},{"../util/inDOM":272}],268:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = camelize;
var rHyphen = /-(.)/g;

function camelize(string) {
  return string.replace(rHyphen, function (_, chr) {
    return chr.toUpperCase();
  });
}
module.exports = exports["default"];
},{}],269:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = camelizeStyleName;

var _camelize = require('./camelize');

var _camelize2 = _interopRequireDefault(_camelize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var msPattern = /^-ms-/; /**
                          * Copyright 2014-2015, Facebook, Inc.
                          * All rights reserved.
                          * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/camelizeStyleName.js
                          */
function camelizeStyleName(string) {
  return (0, _camelize2.default)(string.replace(msPattern, 'ms-'));
}
module.exports = exports['default'];
},{"./camelize":268}],270:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hyphenate;

var rUpper = /([A-Z])/g;

function hyphenate(string) {
  return string.replace(rUpper, '-$1').toLowerCase();
}
module.exports = exports['default'];
},{}],271:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hyphenateStyleName;

var _hyphenate = require('./hyphenate');

var _hyphenate2 = _interopRequireDefault(_hyphenate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var msPattern = /^ms-/; /**
                         * Copyright 2013-2014, Facebook, Inc.
                         * All rights reserved.
                         * https://github.com/facebook/react/blob/2aeb8a2a6beb00617a4217f7f8284924fa2ad819/src/vendor/core/hyphenateStyleName.js
                         */

function hyphenateStyleName(string) {
  return (0, _hyphenate2.default)(string).replace(msPattern, '-ms-');
}
module.exports = exports['default'];
},{"./hyphenate":270}],272:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
module.exports = exports['default'];
},{}],273:[function(require,module,exports){
!function(a){"use strict";if("function"==typeof define&&define.amd)define(["jquery","moment"],a);else if("object"==typeof exports)module.exports=a(require("jquery"),require("moment"));else{if("undefined"==typeof jQuery)throw"bootstrap-datetimepicker requires jQuery to be loaded first";if("undefined"==typeof moment)throw"bootstrap-datetimepicker requires Moment.js to be loaded first";a(jQuery,moment)}}(function(a,b){"use strict";if(!b)throw new Error("bootstrap-datetimepicker requires Moment.js to be loaded first");var c=function(c,d){var e,f,g,h,i,j,k,l={},m=!0,n=!1,o=!1,p=0,q=[{clsName:"days",navFnc:"M",navStep:1},{clsName:"months",navFnc:"y",navStep:1},{clsName:"years",navFnc:"y",navStep:10},{clsName:"decades",navFnc:"y",navStep:100}],r=["days","months","years","decades"],s=["top","bottom","auto"],t=["left","right","auto"],u=["default","top","bottom"],v={up:38,38:"up",down:40,40:"down",left:37,37:"left",right:39,39:"right",tab:9,9:"tab",escape:27,27:"escape",enter:13,13:"enter",pageUp:33,33:"pageUp",pageDown:34,34:"pageDown",shift:16,16:"shift",control:17,17:"control",space:32,32:"space",t:84,84:"t",delete:46,46:"delete"},w={},x=function(){return void 0!==b.tz&&void 0!==d.timeZone&&null!==d.timeZone&&""!==d.timeZone},y=function(a){var c;return c=void 0===a||null===a?b():b.isDate(a)||b.isMoment(a)?b(a):x()?b.tz(a,j,d.useStrict,d.timeZone):b(a,j,d.useStrict),x()&&c.tz(d.timeZone),c},z=function(a){if("string"!=typeof a||a.length>1)throw new TypeError("isEnabled expects a single character string parameter");switch(a){case"y":return i.indexOf("Y")!==-1;case"M":return i.indexOf("M")!==-1;case"d":return i.toLowerCase().indexOf("d")!==-1;case"h":case"H":return i.toLowerCase().indexOf("h")!==-1;case"m":return i.indexOf("m")!==-1;case"s":return i.indexOf("s")!==-1;default:return!1}},A=function(){return z("h")||z("m")||z("s")},B=function(){return z("y")||z("M")||z("d")},C=function(){var b=a("<thead>").append(a("<tr>").append(a("<th>").addClass("prev").attr("data-action","previous").append(a("<span>").addClass(d.icons.previous))).append(a("<th>").addClass("picker-switch").attr("data-action","pickerSwitch").attr("colspan",d.calendarWeeks?"6":"5")).append(a("<th>").addClass("next").attr("data-action","next").append(a("<span>").addClass(d.icons.next)))),c=a("<tbody>").append(a("<tr>").append(a("<td>").attr("colspan",d.calendarWeeks?"8":"7")));return[a("<div>").addClass("datepicker-days").append(a("<table>").addClass("table-condensed").append(b).append(a("<tbody>"))),a("<div>").addClass("datepicker-months").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone())),a("<div>").addClass("datepicker-years").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone())),a("<div>").addClass("datepicker-decades").append(a("<table>").addClass("table-condensed").append(b.clone()).append(c.clone()))]},D=function(){var b=a("<tr>"),c=a("<tr>"),e=a("<tr>");return z("h")&&(b.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.incrementHour}).addClass("btn").attr("data-action","incrementHours").append(a("<span>").addClass(d.icons.up)))),c.append(a("<td>").append(a("<span>").addClass("timepicker-hour").attr({"data-time-component":"hours",title:d.tooltips.pickHour}).attr("data-action","showHours"))),e.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.decrementHour}).addClass("btn").attr("data-action","decrementHours").append(a("<span>").addClass(d.icons.down))))),z("m")&&(z("h")&&(b.append(a("<td>").addClass("separator")),c.append(a("<td>").addClass("separator").html(":")),e.append(a("<td>").addClass("separator"))),b.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.incrementMinute}).addClass("btn").attr("data-action","incrementMinutes").append(a("<span>").addClass(d.icons.up)))),c.append(a("<td>").append(a("<span>").addClass("timepicker-minute").attr({"data-time-component":"minutes",title:d.tooltips.pickMinute}).attr("data-action","showMinutes"))),e.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.decrementMinute}).addClass("btn").attr("data-action","decrementMinutes").append(a("<span>").addClass(d.icons.down))))),z("s")&&(z("m")&&(b.append(a("<td>").addClass("separator")),c.append(a("<td>").addClass("separator").html(":")),e.append(a("<td>").addClass("separator"))),b.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.incrementSecond}).addClass("btn").attr("data-action","incrementSeconds").append(a("<span>").addClass(d.icons.up)))),c.append(a("<td>").append(a("<span>").addClass("timepicker-second").attr({"data-time-component":"seconds",title:d.tooltips.pickSecond}).attr("data-action","showSeconds"))),e.append(a("<td>").append(a("<a>").attr({href:"#",tabindex:"-1",title:d.tooltips.decrementSecond}).addClass("btn").attr("data-action","decrementSeconds").append(a("<span>").addClass(d.icons.down))))),h||(b.append(a("<td>").addClass("separator")),c.append(a("<td>").append(a("<button>").addClass("btn btn-primary").attr({"data-action":"togglePeriod",tabindex:"-1",title:d.tooltips.togglePeriod}))),e.append(a("<td>").addClass("separator"))),a("<div>").addClass("timepicker-picker").append(a("<table>").addClass("table-condensed").append([b,c,e]))},E=function(){var b=a("<div>").addClass("timepicker-hours").append(a("<table>").addClass("table-condensed")),c=a("<div>").addClass("timepicker-minutes").append(a("<table>").addClass("table-condensed")),d=a("<div>").addClass("timepicker-seconds").append(a("<table>").addClass("table-condensed")),e=[D()];return z("h")&&e.push(b),z("m")&&e.push(c),z("s")&&e.push(d),e},F=function(){var b=[];return d.showTodayButton&&b.push(a("<td>").append(a("<a>").attr({"data-action":"today",title:d.tooltips.today}).append(a("<span>").addClass(d.icons.today)))),!d.sideBySide&&B()&&A()&&b.push(a("<td>").append(a("<a>").attr({"data-action":"togglePicker",title:d.tooltips.selectTime}).append(a("<span>").addClass(d.icons.time)))),d.showClear&&b.push(a("<td>").append(a("<a>").attr({"data-action":"clear",title:d.tooltips.clear}).append(a("<span>").addClass(d.icons.clear)))),d.showClose&&b.push(a("<td>").append(a("<a>").attr({"data-action":"close",title:d.tooltips.close}).append(a("<span>").addClass(d.icons.close)))),a("<table>").addClass("table-condensed").append(a("<tbody>").append(a("<tr>").append(b)))},G=function(){var b=a("<div>").addClass("bootstrap-datetimepicker-widget dropdown-menu"),c=a("<div>").addClass("datepicker").append(C()),e=a("<div>").addClass("timepicker").append(E()),f=a("<ul>").addClass("list-unstyled"),g=a("<li>").addClass("picker-switch"+(d.collapse?" accordion-toggle":"")).append(F());return d.inline&&b.removeClass("dropdown-menu"),h&&b.addClass("usetwentyfour"),z("s")&&!h&&b.addClass("wider"),d.sideBySide&&B()&&A()?(b.addClass("timepicker-sbs"),"top"===d.toolbarPlacement&&b.append(g),b.append(a("<div>").addClass("row").append(c.addClass("col-md-6")).append(e.addClass("col-md-6"))),"bottom"===d.toolbarPlacement&&b.append(g),b):("top"===d.toolbarPlacement&&f.append(g),B()&&f.append(a("<li>").addClass(d.collapse&&A()?"collapse in":"").append(c)),"default"===d.toolbarPlacement&&f.append(g),A()&&f.append(a("<li>").addClass(d.collapse&&B()?"collapse":"").append(e)),"bottom"===d.toolbarPlacement&&f.append(g),b.append(f))},H=function(){var b,e={};return b=c.is("input")||d.inline?c.data():c.find("input").data(),b.dateOptions&&b.dateOptions instanceof Object&&(e=a.extend(!0,e,b.dateOptions)),a.each(d,function(a){var c="date"+a.charAt(0).toUpperCase()+a.slice(1);void 0!==b[c]&&(e[a]=b[c])}),e},I=function(){var b,e=(n||c).position(),f=(n||c).offset(),g=d.widgetPositioning.vertical,h=d.widgetPositioning.horizontal;if(d.widgetParent)b=d.widgetParent.append(o);else if(c.is("input"))b=c.after(o).parent();else{if(d.inline)return void(b=c.append(o));b=c,c.children().first().after(o)}if("auto"===g&&(g=f.top+1.5*o.height()>=a(window).height()+a(window).scrollTop()&&o.height()+c.outerHeight()<f.top?"top":"bottom"),"auto"===h&&(h=b.width()<f.left+o.outerWidth()/2&&f.left+o.outerWidth()>a(window).width()?"right":"left"),"top"===g?o.addClass("top").removeClass("bottom"):o.addClass("bottom").removeClass("top"),"right"===h?o.addClass("pull-right"):o.removeClass("pull-right"),"static"===b.css("position")&&(b=b.parents().filter(function(){return"static"!==a(this).css("position")}).first()),0===b.length)throw new Error("datetimepicker component should be placed within a non-static positioned container");o.css({top:"top"===g?"auto":e.top+c.outerHeight(),bottom:"top"===g?b.outerHeight()-(b===c?0:e.top):"auto",left:"left"===h?b===c?0:e.left:"auto",right:"left"===h?"auto":b.outerWidth()-c.outerWidth()-(b===c?0:e.left)})},J=function(a){"dp.change"===a.type&&(a.date&&a.date.isSame(a.oldDate)||!a.date&&!a.oldDate)||c.trigger(a)},K=function(a){"y"===a&&(a="YYYY"),J({type:"dp.update",change:a,viewDate:f.clone()})},L=function(a){o&&(a&&(k=Math.max(p,Math.min(3,k+a))),o.find(".datepicker > div").hide().filter(".datepicker-"+q[k].clsName).show())},M=function(){var b=a("<tr>"),c=f.clone().startOf("w").startOf("d");for(d.calendarWeeks===!0&&b.append(a("<th>").addClass("cw").text("#"));c.isBefore(f.clone().endOf("w"));)b.append(a("<th>").addClass("dow").text(c.format("dd"))),c.add(1,"d");o.find(".datepicker-days thead").append(b)},N=function(a){return d.disabledDates[a.format("YYYY-MM-DD")]===!0},O=function(a){return d.enabledDates[a.format("YYYY-MM-DD")]===!0},P=function(a){return d.disabledHours[a.format("H")]===!0},Q=function(a){return d.enabledHours[a.format("H")]===!0},R=function(b,c){if(!b.isValid())return!1;if(d.disabledDates&&"d"===c&&N(b))return!1;if(d.enabledDates&&"d"===c&&!O(b))return!1;if(d.minDate&&b.isBefore(d.minDate,c))return!1;if(d.maxDate&&b.isAfter(d.maxDate,c))return!1;if(d.daysOfWeekDisabled&&"d"===c&&d.daysOfWeekDisabled.indexOf(b.day())!==-1)return!1;if(d.disabledHours&&("h"===c||"m"===c||"s"===c)&&P(b))return!1;if(d.enabledHours&&("h"===c||"m"===c||"s"===c)&&!Q(b))return!1;if(d.disabledTimeIntervals&&("h"===c||"m"===c||"s"===c)){var e=!1;if(a.each(d.disabledTimeIntervals,function(){if(b.isBetween(this[0],this[1]))return e=!0,!1}),e)return!1}return!0},S=function(){for(var b=[],c=f.clone().startOf("y").startOf("d");c.isSame(f,"y");)b.push(a("<span>").attr("data-action","selectMonth").addClass("month").text(c.format("MMM"))),c.add(1,"M");o.find(".datepicker-months td").empty().append(b)},T=function(){var b=o.find(".datepicker-months"),c=b.find("th"),g=b.find("tbody").find("span");c.eq(0).find("span").attr("title",d.tooltips.prevYear),c.eq(1).attr("title",d.tooltips.selectYear),c.eq(2).find("span").attr("title",d.tooltips.nextYear),b.find(".disabled").removeClass("disabled"),R(f.clone().subtract(1,"y"),"y")||c.eq(0).addClass("disabled"),c.eq(1).text(f.year()),R(f.clone().add(1,"y"),"y")||c.eq(2).addClass("disabled"),g.removeClass("active"),e.isSame(f,"y")&&!m&&g.eq(e.month()).addClass("active"),g.each(function(b){R(f.clone().month(b),"M")||a(this).addClass("disabled")})},U=function(){var a=o.find(".datepicker-years"),b=a.find("th"),c=f.clone().subtract(5,"y"),g=f.clone().add(6,"y"),h="";for(b.eq(0).find("span").attr("title",d.tooltips.prevDecade),b.eq(1).attr("title",d.tooltips.selectDecade),b.eq(2).find("span").attr("title",d.tooltips.nextDecade),a.find(".disabled").removeClass("disabled"),d.minDate&&d.minDate.isAfter(c,"y")&&b.eq(0).addClass("disabled"),b.eq(1).text(c.year()+"-"+g.year()),d.maxDate&&d.maxDate.isBefore(g,"y")&&b.eq(2).addClass("disabled");!c.isAfter(g,"y");)h+='<span data-action="selectYear" class="year'+(c.isSame(e,"y")&&!m?" active":"")+(R(c,"y")?"":" disabled")+'">'+c.year()+"</span>",c.add(1,"y");a.find("td").html(h)},V=function(){var a,c=o.find(".datepicker-decades"),g=c.find("th"),h=b({y:f.year()-f.year()%100-1}),i=h.clone().add(100,"y"),j=h.clone(),k=!1,l=!1,m="";for(g.eq(0).find("span").attr("title",d.tooltips.prevCentury),g.eq(2).find("span").attr("title",d.tooltips.nextCentury),c.find(".disabled").removeClass("disabled"),(h.isSame(b({y:1900}))||d.minDate&&d.minDate.isAfter(h,"y"))&&g.eq(0).addClass("disabled"),g.eq(1).text(h.year()+"-"+i.year()),(h.isSame(b({y:2e3}))||d.maxDate&&d.maxDate.isBefore(i,"y"))&&g.eq(2).addClass("disabled");!h.isAfter(i,"y");)a=h.year()+12,k=d.minDate&&d.minDate.isAfter(h,"y")&&d.minDate.year()<=a,l=d.maxDate&&d.maxDate.isAfter(h,"y")&&d.maxDate.year()<=a,m+='<span data-action="selectDecade" class="decade'+(e.isAfter(h)&&e.year()<=a?" active":"")+(R(h,"y")||k||l?"":" disabled")+'" data-selection="'+(h.year()+6)+'">'+(h.year()+1)+" - "+(h.year()+12)+"</span>",h.add(12,"y");m+="<span></span><span></span><span></span>",c.find("td").html(m),g.eq(1).text(j.year()+1+"-"+h.year())},W=function(){var b,c,g,h=o.find(".datepicker-days"),i=h.find("th"),j=[],k=[];if(B()){for(i.eq(0).find("span").attr("title",d.tooltips.prevMonth),i.eq(1).attr("title",d.tooltips.selectMonth),i.eq(2).find("span").attr("title",d.tooltips.nextMonth),h.find(".disabled").removeClass("disabled"),i.eq(1).text(f.format(d.dayViewHeaderFormat)),R(f.clone().subtract(1,"M"),"M")||i.eq(0).addClass("disabled"),R(f.clone().add(1,"M"),"M")||i.eq(2).addClass("disabled"),b=f.clone().startOf("M").startOf("w").startOf("d"),g=0;g<42;g++)0===b.weekday()&&(c=a("<tr>"),d.calendarWeeks&&c.append('<td class="cw">'+b.week()+"</td>"),j.push(c)),k=["day"],b.isBefore(f,"M")&&k.push("old"),b.isAfter(f,"M")&&k.push("new"),b.isSame(e,"d")&&!m&&k.push("active"),R(b,"d")||k.push("disabled"),b.isSame(y(),"d")&&k.push("today"),0!==b.day()&&6!==b.day()||k.push("weekend"),J({type:"dp.classify",date:b,classNames:k}),c.append('<td data-action="selectDay" data-day="'+b.format("L")+'" class="'+k.join(" ")+'">'+b.date()+"</td>"),b.add(1,"d");h.find("tbody").empty().append(j),T(),U(),V()}},X=function(){var b=o.find(".timepicker-hours table"),c=f.clone().startOf("d"),d=[],e=a("<tr>");for(f.hour()>11&&!h&&c.hour(12);c.isSame(f,"d")&&(h||f.hour()<12&&c.hour()<12||f.hour()>11);)c.hour()%4===0&&(e=a("<tr>"),d.push(e)),e.append('<td data-action="selectHour" class="hour'+(R(c,"h")?"":" disabled")+'">'+c.format(h?"HH":"hh")+"</td>"),c.add(1,"h");b.empty().append(d)},Y=function(){for(var b=o.find(".timepicker-minutes table"),c=f.clone().startOf("h"),e=[],g=a("<tr>"),h=1===d.stepping?5:d.stepping;f.isSame(c,"h");)c.minute()%(4*h)===0&&(g=a("<tr>"),e.push(g)),g.append('<td data-action="selectMinute" class="minute'+(R(c,"m")?"":" disabled")+'">'+c.format("mm")+"</td>"),c.add(h,"m");b.empty().append(e)},Z=function(){for(var b=o.find(".timepicker-seconds table"),c=f.clone().startOf("m"),d=[],e=a("<tr>");f.isSame(c,"m");)c.second()%20===0&&(e=a("<tr>"),d.push(e)),e.append('<td data-action="selectSecond" class="second'+(R(c,"s")?"":" disabled")+'">'+c.format("ss")+"</td>"),c.add(5,"s");b.empty().append(d)},$=function(){var a,b,c=o.find(".timepicker span[data-time-component]");h||(a=o.find(".timepicker [data-action=togglePeriod]"),b=e.clone().add(e.hours()>=12?-12:12,"h"),a.text(e.format("A")),R(b,"h")?a.removeClass("disabled"):a.addClass("disabled")),c.filter("[data-time-component=hours]").text(e.format(h?"HH":"hh")),c.filter("[data-time-component=minutes]").text(e.format("mm")),c.filter("[data-time-component=seconds]").text(e.format("ss")),X(),Y(),Z()},_=function(){o&&(W(),$())},aa=function(a){var b=m?null:e;if(!a)return m=!0,g.val(""),c.data("date",""),J({type:"dp.change",date:!1,oldDate:b}),void _();if(a=a.clone().locale(d.locale),x()&&a.tz(d.timeZone),1!==d.stepping)for(a.minutes(Math.round(a.minutes()/d.stepping)*d.stepping).seconds(0);d.minDate&&a.isBefore(d.minDate);)a.add(d.stepping,"minutes");R(a)?(e=a,f=e.clone(),g.val(e.format(i)),c.data("date",e.format(i)),m=!1,_(),J({type:"dp.change",date:e.clone(),oldDate:b})):(d.keepInvalid?J({type:"dp.change",date:a,oldDate:b}):g.val(m?"":e.format(i)),J({type:"dp.error",date:a,oldDate:b}))},ba=function(){var b=!1;return o?(o.find(".collapse").each(function(){var c=a(this).data("collapse");return!c||!c.transitioning||(b=!0,!1)}),b?l:(n&&n.hasClass("btn")&&n.toggleClass("active"),o.hide(),a(window).off("resize",I),o.off("click","[data-action]"),o.off("mousedown",!1),o.remove(),o=!1,J({type:"dp.hide",date:e.clone()}),g.blur(),f=e.clone(),l)):l},ca=function(){aa(null)},da=function(a){return void 0===d.parseInputDate?(!b.isMoment(a)||a instanceof Date)&&(a=y(a)):a=d.parseInputDate(a),a},ea={next:function(){var a=q[k].navFnc;f.add(q[k].navStep,a),W(),K(a)},previous:function(){var a=q[k].navFnc;f.subtract(q[k].navStep,a),W(),K(a)},pickerSwitch:function(){L(1)},selectMonth:function(b){var c=a(b.target).closest("tbody").find("span").index(a(b.target));f.month(c),k===p?(aa(e.clone().year(f.year()).month(f.month())),d.inline||ba()):(L(-1),W()),K("M")},selectYear:function(b){var c=parseInt(a(b.target).text(),10)||0;f.year(c),k===p?(aa(e.clone().year(f.year())),d.inline||ba()):(L(-1),W()),K("YYYY")},selectDecade:function(b){var c=parseInt(a(b.target).data("selection"),10)||0;f.year(c),k===p?(aa(e.clone().year(f.year())),d.inline||ba()):(L(-1),W()),K("YYYY")},selectDay:function(b){var c=f.clone();a(b.target).is(".old")&&c.subtract(1,"M"),a(b.target).is(".new")&&c.add(1,"M"),aa(c.date(parseInt(a(b.target).text(),10))),A()||d.keepOpen||d.inline||ba()},incrementHours:function(){var a=e.clone().add(1,"h");R(a,"h")&&aa(a)},incrementMinutes:function(){var a=e.clone().add(d.stepping,"m");R(a,"m")&&aa(a)},incrementSeconds:function(){var a=e.clone().add(1,"s");R(a,"s")&&aa(a)},decrementHours:function(){var a=e.clone().subtract(1,"h");R(a,"h")&&aa(a)},decrementMinutes:function(){var a=e.clone().subtract(d.stepping,"m");R(a,"m")&&aa(a)},decrementSeconds:function(){var a=e.clone().subtract(1,"s");R(a,"s")&&aa(a)},togglePeriod:function(){aa(e.clone().add(e.hours()>=12?-12:12,"h"))},togglePicker:function(b){var c,e=a(b.target),f=e.closest("ul"),g=f.find(".in"),h=f.find(".collapse:not(.in)");if(g&&g.length){if(c=g.data("collapse"),c&&c.transitioning)return;g.collapse?(g.collapse("hide"),h.collapse("show")):(g.removeClass("in"),h.addClass("in")),e.is("span")?e.toggleClass(d.icons.time+" "+d.icons.date):e.find("span").toggleClass(d.icons.time+" "+d.icons.date)}},showPicker:function(){o.find(".timepicker > div:not(.timepicker-picker)").hide(),o.find(".timepicker .timepicker-picker").show()},showHours:function(){o.find(".timepicker .timepicker-picker").hide(),o.find(".timepicker .timepicker-hours").show()},showMinutes:function(){o.find(".timepicker .timepicker-picker").hide(),o.find(".timepicker .timepicker-minutes").show()},showSeconds:function(){o.find(".timepicker .timepicker-picker").hide(),o.find(".timepicker .timepicker-seconds").show()},selectHour:function(b){var c=parseInt(a(b.target).text(),10);h||(e.hours()>=12?12!==c&&(c+=12):12===c&&(c=0)),aa(e.clone().hours(c)),ea.showPicker.call(l)},selectMinute:function(b){aa(e.clone().minutes(parseInt(a(b.target).text(),10))),ea.showPicker.call(l)},selectSecond:function(b){aa(e.clone().seconds(parseInt(a(b.target).text(),10))),ea.showPicker.call(l)},clear:ca,today:function(){var a=y();R(a,"d")&&aa(a)},close:ba},fa=function(b){return!a(b.currentTarget).is(".disabled")&&(ea[a(b.currentTarget).data("action")].apply(l,arguments),!1)},ga=function(){var b,c={year:function(a){return a.month(0).date(1).hours(0).seconds(0).minutes(0)},month:function(a){return a.date(1).hours(0).seconds(0).minutes(0)},day:function(a){return a.hours(0).seconds(0).minutes(0)},hour:function(a){return a.seconds(0).minutes(0)},minute:function(a){return a.seconds(0)}};return g.prop("disabled")||!d.ignoreReadonly&&g.prop("readonly")||o?l:(void 0!==g.val()&&0!==g.val().trim().length?aa(da(g.val().trim())):m&&d.useCurrent&&(d.inline||g.is("input")&&0===g.val().trim().length)&&(b=y(),"string"==typeof d.useCurrent&&(b=c[d.useCurrent](b)),aa(b)),o=G(),M(),S(),o.find(".timepicker-hours").hide(),o.find(".timepicker-minutes").hide(),o.find(".timepicker-seconds").hide(),_(),L(),a(window).on("resize",I),o.on("click","[data-action]",fa),o.on("mousedown",!1),n&&n.hasClass("btn")&&n.toggleClass("active"),I(),o.show(),d.focusOnShow&&!g.is(":focus")&&g.focus(),J({type:"dp.show"}),l)},ha=function(){return o?ba():ga()},ia=function(a){var b,c,e,f,g=null,h=[],i={},j=a.which,k="p";w[j]=k;for(b in w)w.hasOwnProperty(b)&&w[b]===k&&(h.push(b),parseInt(b,10)!==j&&(i[b]=!0));for(b in d.keyBinds)if(d.keyBinds.hasOwnProperty(b)&&"function"==typeof d.keyBinds[b]&&(e=b.split(" "),e.length===h.length&&v[j]===e[e.length-1])){for(f=!0,c=e.length-2;c>=0;c--)if(!(v[e[c]]in i)){f=!1;break}if(f){g=d.keyBinds[b];break}}g&&(g.call(l,o),a.stopPropagation(),a.preventDefault())},ja=function(a){w[a.which]="r",a.stopPropagation(),a.preventDefault()},ka=function(b){var c=a(b.target).val().trim(),d=c?da(c):null;return aa(d),b.stopImmediatePropagation(),!1},la=function(){g.on({change:ka,blur:d.debug?"":ba,keydown:ia,keyup:ja,focus:d.allowInputToggle?ga:""}),c.is("input")?g.on({focus:ga}):n&&(n.on("click",ha),n.on("mousedown",!1))},ma=function(){g.off({change:ka,blur:blur,keydown:ia,keyup:ja,focus:d.allowInputToggle?ba:""}),c.is("input")?g.off({focus:ga}):n&&(n.off("click",ha),n.off("mousedown",!1))},na=function(b){var c={};return a.each(b,function(){var a=da(this);a.isValid()&&(c[a.format("YYYY-MM-DD")]=!0)}),!!Object.keys(c).length&&c},oa=function(b){var c={};return a.each(b,function(){c[this]=!0}),!!Object.keys(c).length&&c},pa=function(){var a=d.format||"L LT";i=a.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,function(a){var b=e.localeData().longDateFormat(a)||a;return b.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,function(a){return e.localeData().longDateFormat(a)||a})}),j=d.extraFormats?d.extraFormats.slice():[],j.indexOf(a)<0&&j.indexOf(i)<0&&j.push(i),h=i.toLowerCase().indexOf("a")<1&&i.replace(/\[.*?\]/g,"").indexOf("h")<1,z("y")&&(p=2),z("M")&&(p=1),z("d")&&(p=0),k=Math.max(p,k),m||aa(e)};if(l.destroy=function(){ba(),ma(),c.removeData("DateTimePicker"),c.removeData("date")},l.toggle=ha,l.show=ga,l.hide=ba,l.disable=function(){return ba(),n&&n.hasClass("btn")&&n.addClass("disabled"),g.prop("disabled",!0),l},l.enable=function(){return n&&n.hasClass("btn")&&n.removeClass("disabled"),g.prop("disabled",!1),l},l.ignoreReadonly=function(a){if(0===arguments.length)return d.ignoreReadonly;if("boolean"!=typeof a)throw new TypeError("ignoreReadonly () expects a boolean parameter");return d.ignoreReadonly=a,l},l.options=function(b){if(0===arguments.length)return a.extend(!0,{},d);if(!(b instanceof Object))throw new TypeError("options() options parameter should be an object");return a.extend(!0,d,b),a.each(d,function(a,b){if(void 0===l[a])throw new TypeError("option "+a+" is not recognized!");l[a](b)}),l},l.date=function(a){if(0===arguments.length)return m?null:e.clone();if(!(null===a||"string"==typeof a||b.isMoment(a)||a instanceof Date))throw new TypeError("date() parameter must be one of [null, string, moment or Date]");return aa(null===a?null:da(a)),l},l.format=function(a){if(0===arguments.length)return d.format;if("string"!=typeof a&&("boolean"!=typeof a||a!==!1))throw new TypeError("format() expects a string or boolean:false parameter "+a);return d.format=a,i&&pa(),l},l.timeZone=function(a){if(0===arguments.length)return d.timeZone;if("string"!=typeof a)throw new TypeError("newZone() expects a string parameter");return d.timeZone=a,l},l.dayViewHeaderFormat=function(a){if(0===arguments.length)return d.dayViewHeaderFormat;if("string"!=typeof a)throw new TypeError("dayViewHeaderFormat() expects a string parameter");return d.dayViewHeaderFormat=a,l},l.extraFormats=function(a){if(0===arguments.length)return d.extraFormats;if(a!==!1&&!(a instanceof Array))throw new TypeError("extraFormats() expects an array or false parameter");return d.extraFormats=a,j&&pa(),l},l.disabledDates=function(b){if(0===arguments.length)return d.disabledDates?a.extend({},d.disabledDates):d.disabledDates;if(!b)return d.disabledDates=!1,_(),l;if(!(b instanceof Array))throw new TypeError("disabledDates() expects an array parameter");return d.disabledDates=na(b),d.enabledDates=!1,_(),l},l.enabledDates=function(b){if(0===arguments.length)return d.enabledDates?a.extend({},d.enabledDates):d.enabledDates;if(!b)return d.enabledDates=!1,_(),l;if(!(b instanceof Array))throw new TypeError("enabledDates() expects an array parameter");return d.enabledDates=na(b),d.disabledDates=!1,_(),l},l.daysOfWeekDisabled=function(a){if(0===arguments.length)return d.daysOfWeekDisabled.splice(0);if("boolean"==typeof a&&!a)return d.daysOfWeekDisabled=!1,_(),l;if(!(a instanceof Array))throw new TypeError("daysOfWeekDisabled() expects an array parameter");if(d.daysOfWeekDisabled=a.reduce(function(a,b){return b=parseInt(b,10),b>6||b<0||isNaN(b)?a:(a.indexOf(b)===-1&&a.push(b),a)},[]).sort(),d.useCurrent&&!d.keepInvalid){for(var b=0;!R(e,"d");){if(e.add(1,"d"),31===b)throw"Tried 31 times to find a valid date";b++}aa(e)}return _(),l},l.maxDate=function(a){if(0===arguments.length)return d.maxDate?d.maxDate.clone():d.maxDate;if("boolean"==typeof a&&a===!1)return d.maxDate=!1,_(),l;"string"==typeof a&&("now"!==a&&"moment"!==a||(a=y()));var b=da(a);if(!b.isValid())throw new TypeError("maxDate() Could not parse date parameter: "+a);if(d.minDate&&b.isBefore(d.minDate))throw new TypeError("maxDate() date parameter is before options.minDate: "+b.format(i));return d.maxDate=b,d.useCurrent&&!d.keepInvalid&&e.isAfter(a)&&aa(d.maxDate),f.isAfter(b)&&(f=b.clone().subtract(d.stepping,"m")),_(),l},l.minDate=function(a){if(0===arguments.length)return d.minDate?d.minDate.clone():d.minDate;if("boolean"==typeof a&&a===!1)return d.minDate=!1,_(),l;"string"==typeof a&&("now"!==a&&"moment"!==a||(a=y()));var b=da(a);if(!b.isValid())throw new TypeError("minDate() Could not parse date parameter: "+a);if(d.maxDate&&b.isAfter(d.maxDate))throw new TypeError("minDate() date parameter is after options.maxDate: "+b.format(i));return d.minDate=b,d.useCurrent&&!d.keepInvalid&&e.isBefore(a)&&aa(d.minDate),f.isBefore(b)&&(f=b.clone().add(d.stepping,"m")),_(),l},l.defaultDate=function(a){if(0===arguments.length)return d.defaultDate?d.defaultDate.clone():d.defaultDate;if(!a)return d.defaultDate=!1,l;"string"==typeof a&&(a="now"===a||"moment"===a?y():y(a));var b=da(a);if(!b.isValid())throw new TypeError("defaultDate() Could not parse date parameter: "+a);if(!R(b))throw new TypeError("defaultDate() date passed is invalid according to component setup validations");return d.defaultDate=b,(d.defaultDate&&d.inline||""===g.val().trim())&&aa(d.defaultDate),l},l.locale=function(a){if(0===arguments.length)return d.locale;if(!b.localeData(a))throw new TypeError("locale() locale "+a+" is not loaded from moment locales!");return d.locale=a,e.locale(d.locale),f.locale(d.locale),i&&pa(),o&&(ba(),ga()),l},l.stepping=function(a){return 0===arguments.length?d.stepping:(a=parseInt(a,10),(isNaN(a)||a<1)&&(a=1),d.stepping=a,l)},l.useCurrent=function(a){var b=["year","month","day","hour","minute"];if(0===arguments.length)return d.useCurrent;if("boolean"!=typeof a&&"string"!=typeof a)throw new TypeError("useCurrent() expects a boolean or string parameter");if("string"==typeof a&&b.indexOf(a.toLowerCase())===-1)throw new TypeError("useCurrent() expects a string parameter of "+b.join(", "));return d.useCurrent=a,l},l.collapse=function(a){if(0===arguments.length)return d.collapse;if("boolean"!=typeof a)throw new TypeError("collapse() expects a boolean parameter");return d.collapse===a?l:(d.collapse=a,o&&(ba(),ga()),l)},l.icons=function(b){if(0===arguments.length)return a.extend({},d.icons);if(!(b instanceof Object))throw new TypeError("icons() expects parameter to be an Object");return a.extend(d.icons,b),o&&(ba(),ga()),l},l.tooltips=function(b){if(0===arguments.length)return a.extend({},d.tooltips);if(!(b instanceof Object))throw new TypeError("tooltips() expects parameter to be an Object");return a.extend(d.tooltips,b),o&&(ba(),ga()),l},l.useStrict=function(a){if(0===arguments.length)return d.useStrict;if("boolean"!=typeof a)throw new TypeError("useStrict() expects a boolean parameter");return d.useStrict=a,l},l.sideBySide=function(a){if(0===arguments.length)return d.sideBySide;if("boolean"!=typeof a)throw new TypeError("sideBySide() expects a boolean parameter");return d.sideBySide=a,o&&(ba(),ga()),l},l.viewMode=function(a){if(0===arguments.length)return d.viewMode;if("string"!=typeof a)throw new TypeError("viewMode() expects a string parameter");if(r.indexOf(a)===-1)throw new TypeError("viewMode() parameter must be one of ("+r.join(", ")+") value");return d.viewMode=a,k=Math.max(r.indexOf(a),p),L(),l},l.toolbarPlacement=function(a){if(0===arguments.length)return d.toolbarPlacement;if("string"!=typeof a)throw new TypeError("toolbarPlacement() expects a string parameter");if(u.indexOf(a)===-1)throw new TypeError("toolbarPlacement() parameter must be one of ("+u.join(", ")+") value");return d.toolbarPlacement=a,o&&(ba(),ga()),l},l.widgetPositioning=function(b){if(0===arguments.length)return a.extend({},d.widgetPositioning);if("[object Object]"!=={}.toString.call(b))throw new TypeError("widgetPositioning() expects an object variable");if(b.horizontal){if("string"!=typeof b.horizontal)throw new TypeError("widgetPositioning() horizontal variable must be a string");if(b.horizontal=b.horizontal.toLowerCase(),t.indexOf(b.horizontal)===-1)throw new TypeError("widgetPositioning() expects horizontal parameter to be one of ("+t.join(", ")+")");d.widgetPositioning.horizontal=b.horizontal}if(b.vertical){if("string"!=typeof b.vertical)throw new TypeError("widgetPositioning() vertical variable must be a string");if(b.vertical=b.vertical.toLowerCase(),s.indexOf(b.vertical)===-1)throw new TypeError("widgetPositioning() expects vertical parameter to be one of ("+s.join(", ")+")");d.widgetPositioning.vertical=b.vertical}return _(),l},l.calendarWeeks=function(a){if(0===arguments.length)return d.calendarWeeks;if("boolean"!=typeof a)throw new TypeError("calendarWeeks() expects parameter to be a boolean value");return d.calendarWeeks=a,_(),l},l.showTodayButton=function(a){if(0===arguments.length)return d.showTodayButton;if("boolean"!=typeof a)throw new TypeError("showTodayButton() expects a boolean parameter");return d.showTodayButton=a,o&&(ba(),ga()),l},l.showClear=function(a){if(0===arguments.length)return d.showClear;if("boolean"!=typeof a)throw new TypeError("showClear() expects a boolean parameter");return d.showClear=a,o&&(ba(),ga()),l},l.widgetParent=function(b){if(0===arguments.length)return d.widgetParent;if("string"==typeof b&&(b=a(b)),null!==b&&"string"!=typeof b&&!(b instanceof a))throw new TypeError("widgetParent() expects a string or a jQuery object parameter");return d.widgetParent=b,o&&(ba(),ga()),l},l.keepOpen=function(a){if(0===arguments.length)return d.keepOpen;if("boolean"!=typeof a)throw new TypeError("keepOpen() expects a boolean parameter");return d.keepOpen=a,l},l.focusOnShow=function(a){if(0===arguments.length)return d.focusOnShow;if("boolean"!=typeof a)throw new TypeError("focusOnShow() expects a boolean parameter");return d.focusOnShow=a,l},l.inline=function(a){if(0===arguments.length)return d.inline;if("boolean"!=typeof a)throw new TypeError("inline() expects a boolean parameter");return d.inline=a,l},l.clear=function(){return ca(),l},l.keyBinds=function(a){return 0===arguments.length?d.keyBinds:(d.keyBinds=a,l)},l.getMoment=function(a){return y(a)},l.debug=function(a){if("boolean"!=typeof a)throw new TypeError("debug() expects a boolean parameter");return d.debug=a,l},l.allowInputToggle=function(a){if(0===arguments.length)return d.allowInputToggle;if("boolean"!=typeof a)throw new TypeError("allowInputToggle() expects a boolean parameter");return d.allowInputToggle=a,l},l.showClose=function(a){if(0===arguments.length)return d.showClose;if("boolean"!=typeof a)throw new TypeError("showClose() expects a boolean parameter");return d.showClose=a,l},l.keepInvalid=function(a){if(0===arguments.length)return d.keepInvalid;if("boolean"!=typeof a)throw new TypeError("keepInvalid() expects a boolean parameter");
return d.keepInvalid=a,l},l.datepickerInput=function(a){if(0===arguments.length)return d.datepickerInput;if("string"!=typeof a)throw new TypeError("datepickerInput() expects a string parameter");return d.datepickerInput=a,l},l.parseInputDate=function(a){if(0===arguments.length)return d.parseInputDate;if("function"!=typeof a)throw new TypeError("parseInputDate() sholud be as function");return d.parseInputDate=a,l},l.disabledTimeIntervals=function(b){if(0===arguments.length)return d.disabledTimeIntervals?a.extend({},d.disabledTimeIntervals):d.disabledTimeIntervals;if(!b)return d.disabledTimeIntervals=!1,_(),l;if(!(b instanceof Array))throw new TypeError("disabledTimeIntervals() expects an array parameter");return d.disabledTimeIntervals=b,_(),l},l.disabledHours=function(b){if(0===arguments.length)return d.disabledHours?a.extend({},d.disabledHours):d.disabledHours;if(!b)return d.disabledHours=!1,_(),l;if(!(b instanceof Array))throw new TypeError("disabledHours() expects an array parameter");if(d.disabledHours=oa(b),d.enabledHours=!1,d.useCurrent&&!d.keepInvalid){for(var c=0;!R(e,"h");){if(e.add(1,"h"),24===c)throw"Tried 24 times to find a valid date";c++}aa(e)}return _(),l},l.enabledHours=function(b){if(0===arguments.length)return d.enabledHours?a.extend({},d.enabledHours):d.enabledHours;if(!b)return d.enabledHours=!1,_(),l;if(!(b instanceof Array))throw new TypeError("enabledHours() expects an array parameter");if(d.enabledHours=oa(b),d.disabledHours=!1,d.useCurrent&&!d.keepInvalid){for(var c=0;!R(e,"h");){if(e.add(1,"h"),24===c)throw"Tried 24 times to find a valid date";c++}aa(e)}return _(),l},l.viewDate=function(a){if(0===arguments.length)return f.clone();if(!a)return f=e.clone(),l;if(!("string"==typeof a||b.isMoment(a)||a instanceof Date))throw new TypeError("viewDate() parameter must be one of [string, moment or Date]");return f=da(a),K(),l},c.is("input"))g=c;else if(g=c.find(d.datepickerInput),0===g.length)g=c.find("input");else if(!g.is("input"))throw new Error('CSS class "'+d.datepickerInput+'" cannot be applied to non input element');if(c.hasClass("input-group")&&(n=0===c.find(".datepickerbutton").length?c.find(".input-group-addon"):c.find(".datepickerbutton")),!d.inline&&!g.is("input"))throw new Error("Could not initialize DateTimePicker without an input element");return e=y(),f=e.clone(),a.extend(!0,d,H()),l.options(d),pa(),la(),g.prop("disabled")&&l.disable(),g.is("input")&&0!==g.val().trim().length?aa(da(g.val().trim())):d.defaultDate&&void 0===g.attr("placeholder")&&aa(d.defaultDate),d.inline&&ga(),l};return a.fn.datetimepicker=function(b){b=b||{};var d,e=Array.prototype.slice.call(arguments,1),f=!0,g=["destroy","hide","show","toggle"];if("object"==typeof b)return this.each(function(){var d,e=a(this);e.data("DateTimePicker")||(d=a.extend(!0,{},a.fn.datetimepicker.defaults,b),e.data("DateTimePicker",c(e,d)))});if("string"==typeof b)return this.each(function(){var c=a(this),g=c.data("DateTimePicker");if(!g)throw new Error('bootstrap-datetimepicker("'+b+'") method was called on an element that is not using DateTimePicker');d=g[b].apply(g,e),f=d===g}),f||a.inArray(b,g)>-1?this:d;throw new TypeError("Invalid arguments for DateTimePicker: "+b)},a.fn.datetimepicker.defaults={timeZone:"",format:!1,dayViewHeaderFormat:"MMMM YYYY",extraFormats:!1,stepping:1,minDate:!1,maxDate:!1,useCurrent:!0,collapse:!0,locale:b.locale(),defaultDate:!1,disabledDates:!1,enabledDates:!1,icons:{time:"glyphicon glyphicon-time",date:"glyphicon glyphicon-calendar",up:"glyphicon glyphicon-chevron-up",down:"glyphicon glyphicon-chevron-down",previous:"glyphicon glyphicon-chevron-left",next:"glyphicon glyphicon-chevron-right",today:"glyphicon glyphicon-screenshot",clear:"glyphicon glyphicon-trash",close:"glyphicon glyphicon-remove"},tooltips:{today:"Go to today",clear:"Clear selection",close:"Close the picker",selectMonth:"Select Month",prevMonth:"Previous Month",nextMonth:"Next Month",selectYear:"Select Year",prevYear:"Previous Year",nextYear:"Next Year",selectDecade:"Select Decade",prevDecade:"Previous Decade",nextDecade:"Next Decade",prevCentury:"Previous Century",nextCentury:"Next Century",pickHour:"Pick Hour",incrementHour:"Increment Hour",decrementHour:"Decrement Hour",pickMinute:"Pick Minute",incrementMinute:"Increment Minute",decrementMinute:"Decrement Minute",pickSecond:"Pick Second",incrementSecond:"Increment Second",decrementSecond:"Decrement Second",togglePeriod:"Toggle Period",selectTime:"Select Time"},useStrict:!1,sideBySide:!1,daysOfWeekDisabled:!1,calendarWeeks:!1,viewMode:"days",toolbarPlacement:"default",showTodayButton:!1,showClear:!1,showClose:!1,widgetPositioning:{horizontal:"auto",vertical:"auto"},widgetParent:null,ignoreReadonly:!1,keepOpen:!1,focusOnShow:!0,inline:!1,keepInvalid:!1,datepickerInput:".datepickerinput",keyBinds:{up:function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")?this.date(b.clone().subtract(7,"d")):this.date(b.clone().add(this.stepping(),"m"))}},down:function(a){if(!a)return void this.show();var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")?this.date(b.clone().add(7,"d")):this.date(b.clone().subtract(this.stepping(),"m"))},"control up":function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")?this.date(b.clone().subtract(1,"y")):this.date(b.clone().add(1,"h"))}},"control down":function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")?this.date(b.clone().add(1,"y")):this.date(b.clone().subtract(1,"h"))}},left:function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")&&this.date(b.clone().subtract(1,"d"))}},right:function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")&&this.date(b.clone().add(1,"d"))}},pageUp:function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")&&this.date(b.clone().subtract(1,"M"))}},pageDown:function(a){if(a){var b=this.date()||this.getMoment();a.find(".datepicker").is(":visible")&&this.date(b.clone().add(1,"M"))}},enter:function(){this.hide()},escape:function(){this.hide()},"control space":function(a){a&&a.find(".timepicker").is(":visible")&&a.find('.btn[data-action="togglePeriod"]').click()},t:function(){this.date(this.getMoment())},delete:function(){this.clear()}},debug:!1,allowInputToggle:!1,disabledTimeIntervals:!1,disabledHours:!1,enabledHours:!1,viewDate:!1},a.fn.datetimepicker});
},{"jquery":"jquery","moment":337}],274:[function(require,module,exports){
(function(root,factory){
    if (typeof define === 'function' && define.amd) {
        define(factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        root.eventListener = factory();
  }
}(this, function () {
	function wrap(standard, fallback) {
		return function (el, evtName, listener, useCapture) {
			if (el[standard]) {
				el[standard](evtName, listener, useCapture);
			} else if (el[fallback]) {
				el[fallback]('on' + evtName, listener);
			}
		}
	}

    return {
		add: wrap('addEventListener', 'attachEvent'),
		remove: wrap('removeEventListener', 'detachEvent')
	};
}));
},{}],275:[function(require,module,exports){
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2014-12-17
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  // IE 10+ (native saveAs)
  || (typeof navigator !== "undefined" &&
      navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  // Everyone else
  || (function(view) {
	"use strict";
	// IE <10 is explicitly unsupported
	if (typeof navigator !== "undefined" &&
	    /MSIE [1-9]\./.test(navigator.userAgent)) {
		return;
	}
	var
		  doc = view.document
		  // only get URL when necessary in case Blob.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function(ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047
		// for the reasoning behind the timeout and revocation flow
		, arbitrary_revoke_timeout = 500 // in ms
		, revoke = function(file) {
			var revoker = function() {
				if (typeof file === "string") { // file is an object URL
					get_URL().revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			};
			if (view.chrome) {
				revoker();
			} else {
				setTimeout(revoker, arbitrary_revoke_timeout);
			}
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_URL().createObjectURL(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					} else {
						var new_tab = view.open(object_url, "_blank");
						if (new_tab == undefined && typeof safari !== "undefined") {
							//Apple do not allow window.open, see http://bit.ly/1kZffRI
							view.location.href = object_url
						}
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
					revoke(object_url);
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_URL().createObjectURL(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				revoke(object_url);
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			// Update: Google errantly closed 91158, I submitted it again:
			// https://code.google.com/p/chromium/issues/detail?id=389642
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
									revoke(file);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;

	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;

	return saveAs;
}(
	   typeof self !== "undefined" && self
	|| typeof window !== "undefined" && window
	|| this.content
));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module.exports) {
  module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
  define([], function() {
    return saveAs;
  });
}

},{}],276:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule BrowserSupportCore
 */

'use strict';

var getVendorPrefixedName = require('./getVendorPrefixedName');

var BrowserSupportCore = {
  /**
   * @return {bool} True if browser supports css animations.
   */
  hasCSSAnimations: function hasCSSAnimations() {
    return !!getVendorPrefixedName('animationName');
  },

  /**
   * @return {bool} True if browser supports css transforms.
   */
  hasCSSTransforms: function hasCSSTransforms() {
    return !!getVendorPrefixedName('transform');
  },

  /**
   * @return {bool} True if browser supports css 3d transforms.
   */
  hasCSS3DTransforms: function hasCSS3DTransforms() {
    return !!getVendorPrefixedName('perspective');
  },

  /**
   * @return {bool} True if browser supports css transitions.
   */
  hasCSSTransitions: function hasCSSTransitions() {
    return !!getVendorPrefixedName('transition');
  }
};

module.exports = BrowserSupportCore;
},{"./getVendorPrefixedName":316}],277:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * This class listens to events on the document and then updates a react
 * component through callbacks.
 * Please note that captureMouseMove must be called in
 * order to initialize listeners on mousemove and mouseup.
 * releaseMouseMove must be called to remove them. It is important to
 * call releaseMouseMoves since mousemove is expensive to listen to.
 *
 * @providesModule DOMMouseMoveTracker
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var EventListener = require('./EventListener');

var cancelAnimationFramePolyfill = require('./cancelAnimationFramePolyfill');
var requestAnimationFramePolyfill = require('./requestAnimationFramePolyfill');

var DOMMouseMoveTracker = (function () {
  /**
   * onMove is the callback that will be called on every mouse move.
   * onMoveEnd is called on mouse up when movement has ended.
   */

  function DOMMouseMoveTracker(
  /*function*/onMove,
  /*function*/onMoveEnd,
  /*DOMElement*/domNode) {
    _classCallCheck(this, DOMMouseMoveTracker);

    this._isDragging = false;
    this._animationFrameID = null;
    this._domNode = domNode;
    this._onMove = onMove;
    this._onMoveEnd = onMoveEnd;
    this._onMouseMove = this._onMouseMove.bind(this);
    this._onMouseUp = this._onMouseUp.bind(this);
    this._didMouseMove = this._didMouseMove.bind(this);
  }

  /**
   * This is to set up the listeners for listening to mouse move
   * and mouse up signaling the movement has ended. Please note that these
   * listeners are added at the document.body level. It takes in an event
   * in order to grab inital state.
   */

  _createClass(DOMMouseMoveTracker, [{
    key: 'captureMouseMoves',
    value: function captureMouseMoves( /*object*/event) {
      if (!this._eventMoveToken && !this._eventUpToken) {
        this._eventMoveToken = EventListener.listen(this._domNode, 'mousemove', this._onMouseMove);
        this._eventUpToken = EventListener.listen(this._domNode, 'mouseup', this._onMouseUp);
      }

      if (!this._isDragging) {
        this._deltaX = 0;
        this._deltaY = 0;
        this._isDragging = true;
        this._x = event.clientX;
        this._y = event.clientY;
      }
      event.preventDefault();
    }

    /**
     * These releases all of the listeners on document.body.
     */
  }, {
    key: 'releaseMouseMoves',
    value: function releaseMouseMoves() {
      if (this._eventMoveToken && this._eventUpToken) {
        this._eventMoveToken.remove();
        this._eventMoveToken = null;
        this._eventUpToken.remove();
        this._eventUpToken = null;
      }

      if (this._animationFrameID !== null) {
        cancelAnimationFramePolyfill(this._animationFrameID);
        this._animationFrameID = null;
      }

      if (this._isDragging) {
        this._isDragging = false;
        this._x = null;
        this._y = null;
      }
    }

    /**
     * Returns whether or not if the mouse movement is being tracked.
     */
  }, {
    key: 'isDragging',
    value: function isDragging() /*boolean*/{
      return this._isDragging;
    }

    /**
     * Calls onMove passed into constructor and updates internal state.
     */
  }, {
    key: '_onMouseMove',
    value: function _onMouseMove( /*object*/event) {
      var x = event.clientX;
      var y = event.clientY;

      this._deltaX += x - this._x;
      this._deltaY += y - this._y;

      if (this._animationFrameID === null) {
        // The mouse may move faster then the animation frame does.
        // Use `requestAnimationFramePolyfill` to avoid over-updating.
        this._animationFrameID = requestAnimationFramePolyfill(this._didMouseMove);
      }

      this._x = x;
      this._y = y;
      event.preventDefault();
    }
  }, {
    key: '_didMouseMove',
    value: function _didMouseMove() {
      this._animationFrameID = null;
      this._onMove(this._deltaX, this._deltaY);
      this._deltaX = 0;
      this._deltaY = 0;
    }

    /**
     * Calls onMoveEnd passed into constructor and updates internal state.
     */
  }, {
    key: '_onMouseUp',
    value: function _onMouseUp() {
      if (this._animationFrameID) {
        this._didMouseMove();
      }
      this._onMoveEnd();
    }
  }]);

  return DOMMouseMoveTracker;
})();

module.exports = DOMMouseMoveTracker;
},{"./EventListener":278,"./cancelAnimationFramePolyfill":310,"./requestAnimationFramePolyfill":322}],278:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule EventListener
 * @typechecks
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
}).call(this,require('_process'))
},{"./emptyFunction":315,"_process":395}],279:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

/*jslint evil: true */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],280:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTable.react
 */

/**
 * TRANSITION SHIM
 * This acts to provide an intermediate mapping from the old API to the new API
 *
 * Remove this entire file and replace the two lines in FixedDataTableRoot
 * when ready to continue to the new API.
 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('./React');

var ReactChildren = React.Children;

var PropTypes = React.PropTypes;

// New Table API
var Table = require('./FixedDataTableNew.react');
var Column = require('./FixedDataTableColumnNew.react');
var ColumnGroup = require('./FixedDataTableColumnGroupNew.react');

// Transition Cell
var TransitionCell = require('./FixedDataTableCellTransition.react');

var NEXT_VERSION = '0.7.0';
var DOCUMENTATION_URL = 'https://fburl.com/FixedDataTable-v0.6';

var EMPTY_OBJECT = {};

/**
 * Notify in console that some prop has been deprecated.
 */
var notified = {};
function notifyDeprecated(prop, reason) {
  if (process.env.NODE_ENV !== 'production') {
    if (!notified[prop]) {
      console.warn('`' + prop + '` will be DEPRECATED in version ' + NEXT_VERSION + ' of FixedDataTable and beyond. \n' + reason + '\n' + 'Read the docs at: ' + DOCUMENTATION_URL);
      notified[prop] = true;
    }
  }
}

/**
 * Data grid component with fixed or scrollable header and columns.
 *
 * This is currently in a transition mode, as the new API is used.
 * DEPRECATED endpoints work, but will not be supported in later versions.
 *
 * The layout of the data table is as follows:
 *
 * ```
 * +---------------------------------------------------+
 * | Fixed Column Group    | Scrollable Column Group   |
 * | Header                | Header                    |
 * |                       |                           |
 * +---------------------------------------------------+
 * |                       |                           |
 * | Fixed Header Columns  | Scrollable Header Columns |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * |                       |                           |
 * | Fixed Body Columns    | Scrollable Body Columns   |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * |                       |                           |
 * | Fixed Footer Columns  | Scrollable Footer Columns |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * ```
 *
 * - Fixed Column Group Header: These are the headers for a group
 *   of columns if included in the table that do not scroll
 *   vertically or horizontally.
 *
 * - Scrollable Column Group Header: The header for a group of columns
 *   that do not move while scrolling vertically, but move horizontally
 *   with the horizontal scrolling.
 *
 * - Fixed Header Columns: The header columns that do not move while scrolling
 *   vertically or horizontally.
 *
 * - Scrollable Header Columns: The header columns that do not move
 *   while scrolling vertically, but move horizontally with the horizontal
 *   scrolling.
 *
 * - Fixed Body Columns: The body columns that do not move while scrolling
 *   horizontally, but move vertically with the vertical scrolling.
 *
 * - Scrollable Body Columns: The body columns that move while scrolling
 *   vertically or horizontally.
 */
var TransitionTable = React.createClass({
  displayName: 'TransitionTable',

  propTypes: {
    /**
     * Pixel width of table. If all columns do not fit,
     * a horizontal scrollbar will appear.
     */
    width: PropTypes.number.isRequired,

    /**
     * Pixel height of table. If all rows do not fit,
     * a vertical scrollbar will appear.
     *
     * Either `height` or `maxHeight` must be specified.
     */
    height: PropTypes.number,

    /**
     * Maximum pixel height of table. If all rows do not fit,
     * a vertical scrollbar will appear.
     *
     * Either `height` or `maxHeight` must be specified.
     */
    maxHeight: PropTypes.number,

    /**
     * Pixel height of table's owner, this is used in a managed scrolling
     * situation when you want to slide the table up from below the fold
     * without having to constantly update the height on every scroll tick.
     * Instead, vary this property on scroll. By using `ownerHeight`, we
     * over-render the table while making sure the footer and horizontal
     * scrollbar of the table are visible when the current space for the table
     * in view is smaller than the final, over-flowing height of table. It
     * allows us to avoid resizing and reflowing table when it is moving in the
     * view.
     *
     * This is used if `ownerHeight < height` (or `maxHeight`).
     */
    ownerHeight: PropTypes.number,

    overflowX: PropTypes.oneOf(['hidden', 'auto']),
    overflowY: PropTypes.oneOf(['hidden', 'auto']),

    /**
     * Number of rows in the table.
     */
    rowsCount: PropTypes.number.isRequired,

    /**
     * Pixel height of rows unless `rowHeightGetter` is specified and returns
     * different value.
     */
    rowHeight: PropTypes.number.isRequired,

    /**
     * If specified, `rowHeightGetter(index)` is called for each row and the
     * returned value overrides `rowHeight` for particular row.
     */
    rowHeightGetter: PropTypes.func,

    /**
     * DEPRECATED
     *
     * To get rows to display in table, `rowGetter(index)`
     * is called. `rowGetter` should be smart enough to handle async
     * fetching of data and return temporary objects
     * while data is being fetched.
     */
    rowGetter: PropTypes.func,

    /**
     * To get any additional CSS classes that should be added to a row,
     * `rowClassNameGetter(index)` is called.
     */
    rowClassNameGetter: PropTypes.func,

    /**
     * Pixel height of the column group header.
     */
    groupHeaderHeight: PropTypes.number,

    /**
     * Pixel height of header.
     */
    headerHeight: PropTypes.number.isRequired,

    /**
     * DEPRECATED
     *
     * Function that is called to get the data for the header row.
     * If the function returns null, the header will be set to the
     * Column's label property.
     */
    headerDataGetter: PropTypes.func,

    /**
     * Pixel height of footer.
     */
    footerHeight: PropTypes.number,

    /**
     * DEPRECATED - use footerDataGetter instead.
     * Data that will be passed to footer cell renderers.
     */
    footerData: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),

    /**
     * DEPRECATED
     *
     * Function that is called to get the data for the footer row.
     */
    footerDataGetter: PropTypes.func,

    /**
     * Value of horizontal scroll.
     */
    scrollLeft: PropTypes.number,

    /**
     * Index of column to scroll to.
     */
    scrollToColumn: PropTypes.number,

    /**
     * Value of vertical scroll.
     */
    scrollTop: PropTypes.number,

    /**
     * Index of row to scroll to.
     */
    scrollToRow: PropTypes.number,

    /**
     * Callback that is called when scrolling starts with current horizontal
     * and vertical scroll values.
     */
    onScrollStart: PropTypes.func,

    /**
     * Callback that is called when scrolling ends or stops with new horizontal
     * and vertical scroll values.
     */
    onScrollEnd: PropTypes.func,

    /**
     * Callback that is called when `rowHeightGetter` returns a different height
     * for a row than the `rowHeight` prop. This is necessary because initially
     * table estimates heights of some parts of the content.
     */
    onContentHeightChange: PropTypes.func,

    /**
     * Callback that is called when a row is clicked.
     */
    onRowClick: PropTypes.func,

    /**
     * Callback that is called when a row is double clicked.
     */
    onRowDoubleClick: PropTypes.func,

    /**
     * Callback that is called when a mouse-down event happens on a row.
     */
    onRowMouseDown: PropTypes.func,

    /**
     * Callback that is called when a mouse-enter event happens on a row.
     */
    onRowMouseEnter: PropTypes.func,

    /**
     * Callback that is called when a mouse-leave event happens on a row.
     */
    onRowMouseLeave: PropTypes.func,

    /**
     * Callback that is called when resizer has been released
     * and column needs to be updated.
     *
     * Required if the isResizable property is true on any column.
     *
     * ```
     * function(
     *   newColumnWidth: number,
     *   dataKey: string,
     * )
     * ```
     */
    onColumnResizeEndCallback: PropTypes.func,

    /**
     * Whether a column is currently being resized.
     */
    isColumnResizing: PropTypes.bool
  },

  getInitialState: function getInitialState() {
    // Throw warnings on deprecated props.
    var state = {};
    state.needsMigration = this._checkDeprecations();

    return state;
  },

  _checkDeprecations: function _checkDeprecations() {
    var needsMigration = false;

    if (this.props.rowGetter) {
      notifyDeprecated('rowGetter', 'Please use the cell API in Column to fetch data for your cells.');

      // ROWGETTER??? You need to migrate.
      needsMigration = true;
    }

    if (this.props.headerDataGetter) {
      notifyDeprecated('headerDataGetter', 'Please use the header API in Column to ' + 'fetch data for your header cells.');
    }

    if (this.props.footerData) {
      notifyDeprecated('footerData', 'Please use the footer API in Column to ' + 'fetch data for your footer cells.');
    }

    if (this.props.footerDataGetter) {
      notifyDeprecated('footerDataGetter', 'Please use the footer API in Column to ' + 'fetch data for your footer cells.');
    }

    ReactChildren.forEach(this.props.children, function (child) {
      if (!child || !child.props) {
        return;
      }

      var props = child.props;

      if (props.label) {
        notifyDeprecated('label', 'Please use `header` instead.');
      }

      if (props.dataKey) {
        notifyDeprecated('dataKey', 'Please use the `cell` API to pass in a dataKey');
      }

      if (props.cellRenderer) {
        notifyDeprecated('cellRenderer', 'Please use the `cell` API to pass in a React Element instead.');
      }

      if (props.headerRenderer) {
        notifyDeprecated('headerRenderer', 'Please use the `header` API to pass in a React Element instead.');
      }

      if (props.columnData) {
        notifyDeprecated('columnData', 'Please pass data in through props to your header, cell or footer.');
      }

      if (props.groupHeaderRenderer) {
        notifyDeprecated('groupHeaderRenderer', 'Please use the `header` API in ColumnGroup to ' + 'pass in a React Element instead of a function that creates one.');
      }

      if (props.groupHeaderData) {
        notifyDeprecated('groupHeaderData', 'Please pass in any data through props to your header.');
      }
    });

    return needsMigration;
  },

  // Wrapper for onRow callbacks, since we don't have rowData at that level.
  _onRowAction: function _onRowAction(props, callback) {
    if (!callback) {
      return undefined;
    }

    return function (e, rowIndex) {
      callback(e, rowIndex, props.rowGetter && props.rowGetter(rowIndex) || EMPTY_OBJECT);
    };
  },

  _transformColumn: function _transformColumn(column, tableProps, key) {

    var props = column.props;

    if (column.type.__TableColumn__) {
      // Constuct the cell to be used using the rowGetter
      return React.createElement(Column, _extends({
        key: 'column_' + key
      }, props, {
        header: React.createElement(TransitionCell, {
          isHeaderCell: true,
          label: props.label,
          width: props.width,
          dataKey: props.dataKey,
          className: props.headerClassName,
          columnData: props.columnData || EMPTY_OBJECT,
          cellRenderer: props.headerRenderer,
          headerDataGetter: tableProps.headerDataGetter
        }),
        columnKey: props.dataKey,
        cell: React.createElement(TransitionCell, {
          dataKey: props.dataKey,
          className: props.cellClassName,
          rowGetter: tableProps.rowGetter,
          width: props.width,
          columnData: props.columnData || EMPTY_OBJECT,
          cellDataGetter: props.cellDataGetter,
          cellRenderer: props.cellRenderer
        }),
        footer: React.createElement(TransitionCell, {
          isFooterCell: true,
          className: props.footerClassName,
          dataKey: props.dataKey,
          cellRenderer: props.footerRenderer,
          footerDataGetter: tableProps.footerDataGetter,
          footerData: tableProps.footerData || EMPTY_OBJECT
        })
      }));
    }
  },

  _transformColumnGroup: function _transformColumnGroup(group, tableProps, key, labels) {
    var _this = this;

    var props = group.props;

    var j = 0;
    var columns = ReactChildren.map(props.children, function (child) {
      j++;
      return _this._transformColumn(child, tableProps, key + '_' + j);
    });

    return React.createElement(
      ColumnGroup,
      _extends({}, props, {
        key: 'group_' + key,
        header: React.createElement(TransitionCell, {
          isHeaderCell: true,
          label: group.props.label,
          dataKey: key,
          groupHeaderRenderer: props.groupHeaderRenderer,
          groupHeaderLabels: labels,
          groupHeaderData: props.columnGroupData || EMPTY_OBJECT
        }) }),
      columns
    );
  },

  _convertedColumns: function _convertedColumns(needsMigration) {
    var _this2 = this;

    // If we don't need to migrate, map directly to the new API.
    if (!needsMigration) {
      return ReactChildren.map(this.props.children, function (child) {

        if (!child) {
          return null;
        }

        if (child.type.__TableColumn__) {
          return React.createElement(Column, child.props);
        }

        if (child.type.__TableColumnGroup__) {
          return React.createElement(ColumnGroup, child.props);
        }
      });
    }

    var tableProps = this.props;

    // Otherwise, if a migration is needed, we need to transform each Column
    // or ColumnGroup.
    var i = 0;
    return ReactChildren.map(this.props.children, function (child) {

      if (!child) {
        return null;
      }

      if (child.type.__TableColumn__) {
        child = _this2._transformColumn(child, tableProps, i);
      }

      if (child.type.__TableColumnGroup__) {
        // Since we apparently give an array of labels to groupHeaderRenderer
        var labels = [];
        ReactChildren.forEach(_this2.props.children, function (child) {
          labels.push(child.props.label);
        });

        child = _this2._transformColumnGroup(child, tableProps, i, labels);
      }

      i++;
      return child;
    });
  },

  render: function render() {
    var props = this.props;
    return React.createElement(
      Table,
      _extends({}, props, {
        onRowMouseDown: this._onRowAction(props, props.onRowMouseDown),
        onRowClick: this._onRowAction(props, props.onRowClick),
        onRowDoubleClick: this._onRowAction(props, props.onRowDoubleClick),
        onRowMouseEnter: this._onRowAction(props, props.onRowMouseEnter),
        onRowMouseLeave: this._onRowAction(props, props.onRowMouseLeave)
      }),
      this._convertedColumns(this.state.needsMigration)
    );
  }
});

module.exports = TransitionTable;
}).call(this,require('_process'))
},{"./FixedDataTableCellTransition.react":285,"./FixedDataTableColumnGroupNew.react":288,"./FixedDataTableColumnNew.react":289,"./FixedDataTableNew.react":292,"./React":303,"_process":395}],281:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableBufferedRows.react
 * @typechecks
 */

'use strict';

var React = require('./React');
var FixedDataTableRowBuffer = require('./FixedDataTableRowBuffer');
var FixedDataTableRow = require('./FixedDataTableRow.react');

var cx = require('./cx');
var emptyFunction = require('./emptyFunction');
var joinClasses = require('./joinClasses');
var translateDOMPositionXY = require('./translateDOMPositionXY');

var PropTypes = React.PropTypes;

var FixedDataTableBufferedRows = React.createClass({
  displayName: 'FixedDataTableBufferedRows',

  propTypes: {
    isScrolling: PropTypes.bool,
    defaultRowHeight: PropTypes.number.isRequired,
    firstRowIndex: PropTypes.number.isRequired,
    firstRowOffset: PropTypes.number.isRequired,
    fixedColumns: PropTypes.array.isRequired,
    height: PropTypes.number.isRequired,
    offsetTop: PropTypes.number.isRequired,
    onRowClick: PropTypes.func,
    onRowDoubleClick: PropTypes.func,
    onRowMouseDown: PropTypes.func,
    onRowMouseEnter: PropTypes.func,
    onRowMouseLeave: PropTypes.func,
    rowClassNameGetter: PropTypes.func,
    rowsCount: PropTypes.number.isRequired,
    rowHeightGetter: PropTypes.func,
    rowPositionGetter: PropTypes.func.isRequired,
    scrollLeft: PropTypes.number.isRequired,
    scrollableColumns: PropTypes.array.isRequired,
    showLastRowBorder: PropTypes.bool,
    width: PropTypes.number.isRequired
  },

  getInitialState: function getInitialState() /*object*/{
    this._rowBuffer = new FixedDataTableRowBuffer(this.props.rowsCount, this.props.defaultRowHeight, this.props.height, this._getRowHeight);
    return {
      rowsToRender: this._rowBuffer.getRows(this.props.firstRowIndex, this.props.firstRowOffset)
    };
  },

  componentWillMount: function componentWillMount() {
    this._staticRowArray = [];
  },

  componentDidMount: function componentDidMount() {
    setTimeout(this._updateBuffer, 1000);
  },

  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
    if (nextProps.rowsCount !== this.props.rowsCount || nextProps.defaultRowHeight !== this.props.defaultRowHeight || nextProps.height !== this.props.height) {
      this._rowBuffer = new FixedDataTableRowBuffer(nextProps.rowsCount, nextProps.defaultRowHeight, nextProps.height, this._getRowHeight);
    }
    if (this.props.isScrolling && !nextProps.isScrolling) {
      this._updateBuffer();
    } else {
      this.setState({
        rowsToRender: this._rowBuffer.getRows(nextProps.firstRowIndex, nextProps.firstRowOffset)
      });
    }
  },

  _updateBuffer: function _updateBuffer() {
    if (this.isMounted()) {
      this.setState({
        rowsToRender: this._rowBuffer.getRowsWithUpdatedBuffer()
      });
    }
  },

  shouldComponentUpdate: function shouldComponentUpdate() /*boolean*/{
    // Don't add PureRenderMixin to this component please.
    return true;
  },

  componentWillUnmount: function componentWillUnmount() {
    this._staticRowArray.length = 0;
  },

  render: function render() /*object*/{
    var props = this.props;
    var rowClassNameGetter = props.rowClassNameGetter || emptyFunction;
    var rowPositionGetter = props.rowPositionGetter;

    var rowsToRender = this.state.rowsToRender;
    this._staticRowArray.length = rowsToRender.length;

    for (var i = 0; i < rowsToRender.length; ++i) {
      var rowIndex = rowsToRender[i];
      var currentRowHeight = this._getRowHeight(rowIndex);
      var rowOffsetTop = rowPositionGetter(rowIndex);

      var hasBottomBorder = rowIndex === props.rowsCount - 1 && props.showLastRowBorder;

      this._staticRowArray[i] = React.createElement(FixedDataTableRow, {
        key: i,
        isScrolling: props.isScrolling,
        index: rowIndex,
        width: props.width,
        height: currentRowHeight,
        scrollLeft: Math.round(props.scrollLeft),
        offsetTop: Math.round(rowOffsetTop),
        fixedColumns: props.fixedColumns,
        scrollableColumns: props.scrollableColumns,
        onClick: props.onRowClick,
        onDoubleClick: props.onRowDoubleClick,
        onMouseDown: props.onRowMouseDown,
        onMouseEnter: props.onRowMouseEnter,
        onMouseLeave: props.onRowMouseLeave,
        className: joinClasses(rowClassNameGetter(rowIndex), cx('public/fixedDataTable/bodyRow'), cx({
          'fixedDataTableLayout/hasBottomBorder': hasBottomBorder,
          'public/fixedDataTable/hasBottomBorder': hasBottomBorder
        }))
      });
    }

    var firstRowPosition = props.rowPositionGetter(props.firstRowIndex);

    var style = {
      position: 'absolute',
      pointerEvents: props.isScrolling ? 'none' : 'auto'
    };

    translateDOMPositionXY(style, 0, props.firstRowOffset - firstRowPosition + props.offsetTop);

    return React.createElement(
      'div',
      { style: style },
      this._staticRowArray
    );
  },

  _getRowHeight: function _getRowHeight( /*number*/index) /*number*/{
    return this.props.rowHeightGetter ? this.props.rowHeightGetter(index) : this.props.defaultRowHeight;
  }
});

module.exports = FixedDataTableBufferedRows;
},{"./FixedDataTableRow.react":294,"./FixedDataTableRowBuffer":295,"./React":303,"./cx":313,"./emptyFunction":315,"./joinClasses":319,"./translateDOMPositionXY":324}],282:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableCell.react
 * @typechecks
 */

'use strict';

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var FixedDataTableCellDefault = require('./FixedDataTableCellDefault.react');
var FixedDataTableHelper = require('./FixedDataTableHelper');
var React = require('./React');
var cx = require('./cx');
var joinClasses = require('./joinClasses');

var DIR_SIGN = FixedDataTableHelper.DIR_SIGN;

var PropTypes = React.PropTypes;

var DEFAULT_PROPS = {
  align: 'left',
  highlighted: false
};

var FixedDataTableCell = React.createClass({
  displayName: 'FixedDataTableCell',

  /**
   * PropTypes are disabled in this component, because having them on slows
   * down the FixedDataTable hugely in DEV mode. You can enable them back for
   * development, but please don't commit this component with enabled propTypes.
   */
  propTypes_DISABLED_FOR_PERFORMANCE: {
    isScrolling: PropTypes.bool,
    align: PropTypes.oneOf(['left', 'center', 'right']),
    className: PropTypes.string,
    highlighted: PropTypes.bool,
    width: PropTypes.number.isRequired,
    minWidth: PropTypes.number,
    maxWidth: PropTypes.number,
    height: PropTypes.number.isRequired,

    cell: PropTypes.oneOfType([PropTypes.string, PropTypes.element, PropTypes.func]),

    columnKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * The row index that will be passed to `cellRenderer` to render.
     */
    rowIndex: PropTypes.number.isRequired,

    /**
     * Callback for when resizer knob (in FixedDataTableCell) is clicked
     * to initialize resizing. Please note this is only on the cells
     * in the header.
     * @param number combinedWidth
     * @param number left
     * @param number width
     * @param number minWidth
     * @param number maxWidth
     * @param number|string columnKey
     * @param object event
     */
    onColumnResize: PropTypes.func,

    /**
     * The left offset in pixels of the cell.
     */
    left: PropTypes.number
  },

  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return !nextProps.isScrolling || this.props.rowIndex !== nextProps.rowIndex;
  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return DEFAULT_PROPS;
  },

  render: function render() /*object*/{
    var _props = this.props;
    var height = _props.height;
    var width = _props.width;
    var columnKey = _props.columnKey;

    var props = _objectWithoutProperties(_props, ['height', 'width', 'columnKey']);

    var style = {
      height: height,
      width: width
    };

    if (DIR_SIGN === 1) {
      style.left = props.left;
    } else {
      style.right = props.left;
    }

    var className = joinClasses(cx({
      'fixedDataTableCellLayout/main': true,
      'fixedDataTableCellLayout/lastChild': props.lastChild,
      'fixedDataTableCellLayout/alignRight': props.align === 'right',
      'fixedDataTableCellLayout/alignCenter': props.align === 'center',
      'public/fixedDataTableCell/alignRight': props.align === 'right',
      'public/fixedDataTableCell/highlighted': props.highlighted,
      'public/fixedDataTableCell/main': true
    }), props.className);

    var columnResizerComponent;
    if (props.onColumnResize) {
      var columnResizerStyle = {
        height: height
      };
      columnResizerComponent = React.createElement(
        'div',
        {
          className: cx('fixedDataTableCellLayout/columnResizerContainer'),
          style: columnResizerStyle,
          onMouseDown: this._onColumnResizerMouseDown },
        React.createElement('div', {
          className: joinClasses(cx('fixedDataTableCellLayout/columnResizerKnob'), cx('public/fixedDataTableCell/columnResizerKnob')),
          style: columnResizerStyle
        })
      );
    }

    var cellProps = {
      columnKey: columnKey,
      height: height,
      width: width
    };

    if (props.rowIndex >= 0) {
      cellProps.rowIndex = props.rowIndex;
    }

    var content;
    if (React.isValidElement(props.cell)) {
      content = React.cloneElement(props.cell, cellProps);
    } else if (typeof props.cell === 'function') {
      content = props.cell(cellProps);
    } else {
      content = React.createElement(
        FixedDataTableCellDefault,
        cellProps,
        props.cell
      );
    }

    return React.createElement(
      'div',
      { className: className, style: style },
      columnResizerComponent,
      content
    );
  },

  _onColumnResizerMouseDown: function _onColumnResizerMouseDown( /*object*/event) {
    this.props.onColumnResize(this.props.left, this.props.width, this.props.minWidth, this.props.maxWidth, this.props.columnKey, event);
  }
});

module.exports = FixedDataTableCell;
},{"./FixedDataTableCellDefault.react":283,"./FixedDataTableHelper":291,"./React":303,"./cx":313,"./joinClasses":319}],283:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableCellDefault.react
 * @typechecks
 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var React = require('./React');

var cx = require('./cx');
var joinClasses = require('./joinClasses');

var PropTypes = React.PropTypes;

/**
 * Component that handles default cell layout and styling.
 *
 * All props unless specified below will be set onto the top level `div`
 * rendered by the cell.
 *
 * Example usage via from a `Column`:
 * ```
 * const MyColumn = (
 *   <Column
 *     cell={({rowIndex, width, height}) => (
 *       <Cell
 *         width={width}
 *         height={height}
 *         className="my-class">
 *         Cell number: <span>{rowIndex}</span>
*        </Cell>
 *     )}
 *     width={100}
 *   />
 * );
 * ```
 */
var FixedDataTableCellDefault = React.createClass({
  displayName: 'FixedDataTableCellDefault',

  propTypes: {

    /**
     * Outer height of the cell.
     */
    height: PropTypes.number,

    /**
     * Outer width of the cell.
     */
    width: PropTypes.number,

    /**
     * Optional prop that if specified on the `Column` will be passed to the
     * cell. It can be used to uniquely identify which column is the cell is in.
     */
    columnKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  },

  render: function render() {
    var _props = this.props;
    var height = _props.height;
    var width = _props.width;
    var style = _props.style;
    var className = _props.className;
    var children = _props.children;
    var columnKey = _props.columnKey;
    var // Unused but should not be passed through
    rowIndex = _props.rowIndex;

    var props = _objectWithoutProperties(_props, ['height', 'width', 'style', 'className', 'children', 'columnKey', 'rowIndex']);

    var innerStyle = _extends({
      height: height,
      width: width
    }, style);

    return React.createElement(
      'div',
      _extends({}, props, {
        className: joinClasses(cx('fixedDataTableCellLayout/wrap1'), cx('public/fixedDataTableCell/wrap1'), className),
        style: innerStyle }),
      React.createElement(
        'div',
        {
          className: joinClasses(cx('fixedDataTableCellLayout/wrap2'), cx('public/fixedDataTableCell/wrap2')) },
        React.createElement(
          'div',
          {
            className: joinClasses(cx('fixedDataTableCellLayout/wrap3'), cx('public/fixedDataTableCell/wrap3')) },
          React.createElement(
            'div',
            { className: cx('public/fixedDataTableCell/cellContent') },
            children
          )
        )
      )
    );
  }
});

module.exports = FixedDataTableCellDefault;
// Unused but should not be passed through
},{"./React":303,"./cx":313,"./joinClasses":319}],284:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableCellGroup.react
 * @typechecks
 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var FixedDataTableHelper = require('./FixedDataTableHelper');
var React = require('./React');
var FixedDataTableCell = require('./FixedDataTableCell.react');

var cx = require('./cx');
var translateDOMPositionXY = require('./translateDOMPositionXY');

var PropTypes = React.PropTypes;

var DIR_SIGN = FixedDataTableHelper.DIR_SIGN;

var FixedDataTableCellGroupImpl = React.createClass({
  displayName: 'FixedDataTableCellGroupImpl',

  /**
   * PropTypes are disabled in this component, because having them on slows
   * down the FixedDataTable hugely in DEV mode. You can enable them back for
   * development, but please don't commit this component with enabled propTypes.
   */
  propTypes_DISABLED_FOR_PERFORMANCE: {

    /**
     * Array of <FixedDataTableColumn />.
     */
    columns: PropTypes.array.isRequired,

    isScrolling: PropTypes.bool,

    left: PropTypes.number,

    onColumnResize: PropTypes.func,

    rowHeight: PropTypes.number.isRequired,

    rowIndex: PropTypes.number.isRequired,

    width: PropTypes.number.isRequired,

    zIndex: PropTypes.number.isRequired
  },

  render: function render() /*object*/{
    var props = this.props;
    var columns = props.columns;
    var cells = new Array(columns.length);

    var currentPosition = 0;
    for (var i = 0, j = columns.length; i < j; i++) {
      var columnProps = columns[i].props;
      if (!columnProps.allowCellsRecycling || currentPosition - props.left <= props.width && currentPosition - props.left + columnProps.width >= 0) {
        var key = 'cell_' + i;
        cells[i] = this._renderCell(props.rowIndex, props.rowHeight, columnProps, currentPosition, key);
      }
      currentPosition += columnProps.width;
    }

    var contentWidth = this._getColumnsWidth(columns);

    var style = {
      height: props.height,
      position: 'absolute',
      width: contentWidth,
      zIndex: props.zIndex
    };
    translateDOMPositionXY(style, -1 * DIR_SIGN * props.left, 0);

    return React.createElement(
      'div',
      {
        className: cx('fixedDataTableCellGroupLayout/cellGroup'),
        style: style },
      cells
    );
  },

  _renderCell: function _renderCell(
  /*number*/rowIndex,
  /*number*/height,
  /*object*/columnProps,
  /*number*/left,
  /*string*/key) /*object*/{

    var cellIsResizable = columnProps.isResizable && this.props.onColumnResize;
    var onColumnResize = cellIsResizable ? this.props.onColumnResize : null;

    var className = columnProps.cellClassName;

    return React.createElement(FixedDataTableCell, {
      isScrolling: this.props.isScrolling,
      align: columnProps.align,
      className: className,
      height: height,
      key: key,
      maxWidth: columnProps.maxWidth,
      minWidth: columnProps.minWidth,
      onColumnResize: onColumnResize,
      rowIndex: rowIndex,
      columnKey: columnProps.columnKey,
      width: columnProps.width,
      left: left,
      cell: columnProps.cell
    });
  },

  _getColumnsWidth: function _getColumnsWidth( /*array*/columns) /*number*/{
    var width = 0;
    for (var i = 0; i < columns.length; ++i) {
      width += columns[i].props.width;
    }
    return width;
  }
});

var FixedDataTableCellGroup = React.createClass({
  displayName: 'FixedDataTableCellGroup',

  /**
   * PropTypes are disabled in this component, because having them on slows
   * down the FixedDataTable hugely in DEV mode. You can enable them back for
   * development, but please don't commit this component with enabled propTypes.
   */
  propTypes_DISABLED_FOR_PERFORMANCE: {
    isScrolling: PropTypes.bool,
    /**
     * Height of the row.
     */
    height: PropTypes.number.isRequired,

    offsetLeft: PropTypes.number,

    left: PropTypes.number,
    /**
     * Z-index on which the row will be displayed. Used e.g. for keeping
     * header and footer in front of other rows.
     */
    zIndex: PropTypes.number.isRequired
  },

  shouldComponentUpdate: function shouldComponentUpdate( /*object*/nextProps) /*boolean*/{
    return !nextProps.isScrolling || this.props.rowIndex !== nextProps.rowIndex || this.props.left !== nextProps.left;
  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return {
      offsetLeft: 0
    };
  },

  render: function render() /*object*/{
    var _props = this.props;
    var offsetLeft = _props.offsetLeft;

    var props = _objectWithoutProperties(_props, ['offsetLeft']);

    var style = {
      height: props.height
    };

    if (DIR_SIGN === 1) {
      style.left = offsetLeft;
    } else {
      style.right = offsetLeft;
    }

    var onColumnResize = props.onColumnResize ? this._onColumnResize : null;

    return React.createElement(
      'div',
      {
        style: style,
        className: cx('fixedDataTableCellGroupLayout/cellGroupWrapper') },
      React.createElement(FixedDataTableCellGroupImpl, _extends({}, props, {
        onColumnResize: onColumnResize
      }))
    );
  },

  _onColumnResize: function _onColumnResize(
  /*number*/left,
  /*number*/width,
  /*?number*/minWidth,
  /*?number*/maxWidth,
  /*string|number*/columnKey,
  /*object*/event) {
    this.props.onColumnResize && this.props.onColumnResize(this.props.offsetLeft, left - this.props.left + width, width, minWidth, maxWidth, columnKey, event);
  }
});

module.exports = FixedDataTableCellGroup;
},{"./FixedDataTableCell.react":282,"./FixedDataTableHelper":291,"./React":303,"./cx":313,"./translateDOMPositionXY":324}],285:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableCellTransition.react
 */

/**
 * TRANSITION SHIM
 * This acts to provide an intermediate mapping from the old API to the new API.
 *
 * When ready, remove this file and rename the providesModule in
 * FixedDataTableCellNew.react and dependency in FixedDataTableCellGroup.react
 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('./React');
var PropTypes = React.PropTypes;

var cx = require('./cx');
var joinClasses = require('./joinClasses');
var shallowEqual = require('./shallowEqual');

var CellDefault = require('./FixedDataTableCellDefault.react');

var TransitionCell = React.createClass({
  displayName: 'TransitionCell',

  propTypes: {
    label: PropTypes.string, // header, footer
    className: PropTypes.string,
    rowIndex: PropTypes.number,
    rowGetter: PropTypes.func, // cell
    dataKey: PropTypes.oneOfType([// cell, footer
    PropTypes.string, PropTypes.number]),
    cellRenderer: PropTypes.func,
    cellDataGetter: PropTypes.func,
    footerDataGetter: PropTypes.func, // footer
    footerData: PropTypes.any, // footer
    columnData: PropTypes.any, // cell, header
    width: PropTypes.number,
    height: PropTypes.number,
    isHeaderCell: PropTypes.bool, // header
    isFooterCell: PropTypes.bool },

  // footer
  shouldComponentUpdate: function shouldComponentUpdate( /*object*/nextProps) {
    var update = false;
    var rowData;
    if (nextProps.rowGetter) {
      rowData = nextProps.rowGetter(nextProps.rowIndex);
      if (this._rowData !== rowData) {
        update = true;
      }
    }

    var cellData;
    if (nextProps.dataKey != null) {
      if (nextProps.cellDataGetter) {
        cellData = nextProps.cellDataGetter(nextProps.dataKey, rowData);
      }
      if (!cellData && rowData) {
        cellData = rowData[nextProps.dataKey];
      }
    }
    if (this._cellData !== cellData) {
      update = true;
    }
    this._rowData = rowData;
    this._cellData = cellData;

    return update || !shallowEqual(nextProps, this.props);
  },

  _getCellData: function _getCellData(props) {
    var dataKey = props.dataKey;
    if (dataKey == null) {
      return null;
    }

    var rowData;
    if (props.rowGetter) {
      rowData = props.rowGetter(props.rowIndex);
    }

    if (props.cellDataGetter) {
      return props.cellDataGetter(dataKey, rowData);
    }

    if (rowData) {
      return rowData[dataKey];
    }

    if (props.footerDataGetter) {
      return props.footerDataGetter()[dataKey];
    }

    if (props.footerData) {
      return props.footerData[dataKey];
    }

    if (props.headerDataGetter) {
      return props.headerDataGetter[dataKey];
    }
  },

  _getRowData: function _getRowData(props) {
    if (props.rowGetter) {
      return props.rowGetter(props.rowIndex) || {};
    }

    if (props.footerDataGetter) {
      return props.footerDataGetter() || {};
    }

    if (props.footerData) {
      return props.footerData || {};
    }

    return {};
  },

  render: function render() {
    var props = this.props;

    var cellData = this._getCellData(props);
    var content = cellData;
    var rowData = this._getRowData(props);
    var usingRenderer = !!(props.cellRenderer || props.groupHeaderRenderer);

    if (props.isHeaderCell || props.isFooterCell) {
      content = content || props.label;
    }

    if (props.cellRenderer) {
      if (props.isHeaderCell || props.isFooterCell) {
        content = props.cellRenderer(props.label, props.dataKey, props.columnData, rowData, props.width) || props.label;
      } else {
        content = props.cellRenderer(cellData, props.dataKey, rowData, props.rowIndex, props.columnData, props.width);
      }
    }

    if (props.groupHeaderRenderer) {
      content = props.groupHeaderRenderer(props.label, props.dataKey, // index in children
      props.groupHeaderData, props.groupHeaderLabels, props.width) || content;
    }

    var contentClass = cx('public/fixedDataTableCell/cellContent');

    if (React.isValidElement(content) && usingRenderer) {
      content = React.cloneElement(content, {
        className: joinClasses(content.props.className, contentClass)
      });
    } else {
      return React.createElement(
        CellDefault,
        props,
        content
      );
    }

    var innerStyle = _extends({
      height: props.height,
      width: props.width
    }, props.style);

    return React.createElement(
      'div',
      _extends({}, this.props, {
        className: joinClasses(cx('fixedDataTableCellLayout/wrap1'), cx('public/fixedDataTableCell/wrap1'), this.props.className),
        style: innerStyle }),
      React.createElement(
        'div',
        {
          className: joinClasses(cx('fixedDataTableCellLayout/wrap2'), cx('public/fixedDataTableCell/wrap2')) },
        React.createElement(
          'div',
          {
            className: joinClasses(cx('fixedDataTableCellLayout/wrap3'), cx('public/fixedDataTableCell/wrap3')) },
          content
        )
      )
    );
  }
});

module.exports = TransitionCell;
},{"./FixedDataTableCellDefault.react":283,"./React":303,"./cx":313,"./joinClasses":319,"./shallowEqual":323}],286:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableColumn.react
 */

/**
 * TRANSITION SHIM
 * This acts to provide an intermediate mapping from the old API to the new API.
 *
 * When ready, remove this file and rename the providesModule in
 * FixedDataTableColumnNew.react
 */

'use strict';

var React = require('./React');

var TransitionColumn = React.createClass({
  displayName: 'TransitionColumn',

  statics: {
    __TableColumn__: true
  },

  render: function render() {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error('Component <TransitionColumn /> should never render');
    }
    return null;
  }
});

module.exports = TransitionColumn;
}).call(this,require('_process'))
},{"./React":303,"_process":395}],287:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableColumnGroup.react
 */

/**
 * TRANSITION SHIM
 * This provides an intermediate mapping from the old API to the new API.
 *
 * When ready, remove this file and rename the providesModule in
 * FixedDataTableColumnNew.react
 */

'use strict';

var React = require('./React');

var TransitionColumnGroup = React.createClass({
  displayName: 'TransitionColumnGroup',

  statics: {
    __TableColumnGroup__: true
  },

  render: function render() {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error('Component <TransitionColumnGroup /> should never render');
    }
    return null;
  }
});

module.exports = TransitionColumnGroup;
}).call(this,require('_process'))
},{"./React":303,"_process":395}],288:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableColumnGroupNew.react
 * @typechecks
 */

'use strict';

var React = require('./React');

var PropTypes = React.PropTypes;

/**
 * Component that defines the attributes of a table column group.
 */
var FixedDataTableColumnGroup = React.createClass({
  displayName: 'FixedDataTableColumnGroup',

  statics: {
    __TableColumnGroup__: true
  },

  propTypes: {
    /**
     * The horizontal alignment of the table cell content.
     */
    align: PropTypes.oneOf(['left', 'center', 'right']),

    /**
     * Controls if the column group is fixed when scrolling in the X axis.
     */
    fixed: PropTypes.bool,

    /**
     * This is the header cell for this column group.
     * This can either be a string or a React element. Passing in a string
     * will render a default footer cell with that string. By default, the React
     * element passed in can expect to receive the following props:
     *
     * ```
     * props: {
     *   height: number // (supplied from the groupHeaderHeight)
     *   width: number // (supplied from the Column)
     * }
     * ```
     *
     * Because you are passing in your own React element, you can feel free to
     * pass in whatever props you may want or need.
     *
     * You can also pass in a function that returns a react elemnt, with the
     * props object above passed in as the first parameter.
     */
    header: PropTypes.oneOfType([PropTypes.node, PropTypes.func])

  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return {
      fixed: false
    };
  },

  render: function render() {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error('Component <FixedDataTableColumnGroup /> should never render');
    }
    return null;
  }
});

module.exports = FixedDataTableColumnGroup;
}).call(this,require('_process'))
},{"./React":303,"_process":395}],289:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableColumnNew.react
 * @typechecks
 */

'use strict';

var React = require('./React');

var PropTypes = React.PropTypes;

/**
 * Component that defines the attributes of table column.
 */
var FixedDataTableColumn = React.createClass({
  displayName: 'FixedDataTableColumn',

  statics: {
    __TableColumn__: true
  },

  propTypes: {
    /**
     * The horizontal alignment of the table cell content.
     */
    align: PropTypes.oneOf(['left', 'center', 'right']),

    /**
     * Controls if the column is fixed when scrolling in the X axis.
     */
    fixed: PropTypes.bool,

    /**
     * The header cell for this column.
     * This can either be a string a React element, or a function that generates
     * a React Element. Passing in a string will render a default header cell
     * with that string. By default, the React element passed in can expect to
     * receive the following props:
     *
     * ```
     * props: {
     *   columnKey: string // (of the column, if given)
     *   height: number // (supplied from the Table or rowHeightGetter)
     *   width: number // (supplied from the Column)
     * }
     * ```
     *
     * Because you are passing in your own React element, you can feel free to
     * pass in whatever props you may want or need.
     *
     * If you pass in a function, you will receive the same props object as the
     * first argument.
     */
    header: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

    /**
     * This is the body cell that will be cloned for this column.
     * This can either be a string a React element, or a function that generates
     * a React Element. Passing in a string will render a default header cell
     * with that string. By default, the React element passed in can expect to
     * receive the following props:
     *
     * ```
     * props: {
     *   rowIndex; number // (the row index of the cell)
     *   columnKey: string // (of the column, if given)
     *   height: number // (supplied from the Table or rowHeightGetter)
     *   width: number // (supplied from the Column)
     * }
     * ```
     *
     * Because you are passing in your own React element, you can feel free to
     * pass in whatever props you may want or need.
     *
     * If you pass in a function, you will receive the same props object as the
     * first argument.
     */
    cell: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

    /**
     * This is the footer cell for this column.
     * This can either be a string a React element, or a function that generates
     * a React Element. Passing in a string will render a default header cell
     * with that string. By default, the React element passed in can expect to
     * receive the following props:
     *
     * ```
     * props: {
     *   columnKey: string // (of the column, if given)
     *   height: number // (supplied from the Table or rowHeightGetter)
     *   width: number // (supplied from the Column)
     * }
     * ```
     *
     * Because you are passing in your own React element, you can feel free to
     * pass in whatever props you may want or need.
     *
     * If you pass in a function, you will receive the same props object as the
     * first argument.
     */
    footer: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),

    /**
     * This is used to uniquely identify the column, and is not required unless
     * you a resizing columns. This will be the key given in the
     * `onColumnResizeEndCallback` on the Table.
     */
    columnKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),

    /**
     * The pixel width of the column.
     */
    width: PropTypes.number.isRequired,

    /**
     * If this is a resizable column this is its minimum pixel width.
     */
    minWidth: PropTypes.number,

    /**
     * If this is a resizable column this is its maximum pixel width.
     */
    maxWidth: PropTypes.number,

    /**
     * The grow factor relative to other columns. Same as the flex-grow API
     * from http://www.w3.org/TR/css3-flexbox/. Basically, take any available
     * extra width and distribute it proportionally according to all columns'
     * flexGrow values. Defaults to zero (no-flexing).
     */
    flexGrow: PropTypes.number,

    /**
     * Whether the column can be resized with the
     * FixedDataTableColumnResizeHandle. Please note that if a column
     * has a flex grow, once you resize the column this will be set to 0.
     *
     * This property only provides the UI for the column resizing. If this
     * is set to true, you will need to set the onColumnResizeEndCallback table
     * property and render your columns appropriately.
     */
    isResizable: PropTypes.bool,

    /**
     * Whether cells in this column can be removed from document when outside
     * of viewport as a result of horizontal scrolling.
     * Setting this property to true allows the table to not render cells in
     * particular column that are outside of viewport for visible rows. This
     * allows to create table with many columns and not have vertical scrolling
     * performance drop.
     * Setting the property to false will keep previous behaviour and keep
     * cell rendered if the row it belongs to is visible.
     */
    allowCellsRecycling: PropTypes.bool
  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return {
      allowCellsRecycling: false,
      fixed: false
    };
  },

  render: function render() {
    if (process.env.NODE_ENV !== 'production') {
      throw new Error('Component <FixedDataTableColumn /> should never render');
    }
    return null;
  }
});

module.exports = FixedDataTableColumn;
}).call(this,require('_process'))
},{"./React":303,"_process":395}],290:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * This is to be used with the FixedDataTable. It is a read line
 * that when you click on a column that is resizable appears and allows
 * you to resize the corresponding column.
 *
 * @providesModule FixedDataTableColumnResizeHandle.react
 * @typechecks
 */

'use strict';

var DOMMouseMoveTracker = require('./DOMMouseMoveTracker');
var Locale = require('./Locale');
var React = require('./React');
var ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');

var clamp = require('./clamp');
var cx = require('./cx');

var PropTypes = React.PropTypes;

var FixedDataTableColumnResizeHandle = React.createClass({
  displayName: 'FixedDataTableColumnResizeHandle',

  mixins: [ReactComponentWithPureRenderMixin],

  propTypes: {
    visible: PropTypes.bool.isRequired,

    /**
     * This is the height of the line
     */
    height: PropTypes.number.isRequired,

    /**
     * Offset from left border of the table, please note
     * that the line is a border on diff. So this is really the
     * offset of the column itself.
     */
    leftOffset: PropTypes.number.isRequired,

    /**
     * Height of the clickable region of the line.
     * This is assumed to be at the top of the line.
     */
    knobHeight: PropTypes.number.isRequired,

    /**
     * The line is a border on a diff, so this is essentially
     * the width of column.
     */
    initialWidth: PropTypes.number,

    /**
     * The minimum width this dragger will collapse to
     */
    minWidth: PropTypes.number,

    /**
     * The maximum width this dragger will collapse to
     */
    maxWidth: PropTypes.number,

    /**
     * Initial click event on the header cell.
     */
    initialEvent: PropTypes.object,

    /**
     * When resizing is complete this is called.
     */
    onColumnResizeEnd: PropTypes.func,

    /**
     * Column key for the column being resized.
     */
    columnKey: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
  },

  getInitialState: function getInitialState() /*object*/{
    return {
      width: 0,
      cursorDelta: 0
    };
  },

  componentWillReceiveProps: function componentWillReceiveProps( /*object*/newProps) {
    if (newProps.initialEvent && !this._mouseMoveTracker.isDragging()) {
      this._mouseMoveTracker.captureMouseMoves(newProps.initialEvent);
      this.setState({
        width: newProps.initialWidth,
        cursorDelta: newProps.initialWidth
      });
    }
  },

  componentDidMount: function componentDidMount() {
    this._mouseMoveTracker = new DOMMouseMoveTracker(this._onMove, this._onColumnResizeEnd, document.body);
  },

  componentWillUnmount: function componentWillUnmount() {
    this._mouseMoveTracker.releaseMouseMoves();
    this._mouseMoveTracker = null;
  },

  render: function render() /*object*/{
    var style = {
      width: this.state.width,
      height: this.props.height
    };
    if (Locale.isRTL()) {
      style.right = this.props.leftOffset;
    } else {
      style.left = this.props.leftOffset;
    }
    return React.createElement(
      'div',
      {
        className: cx({
          'fixedDataTableColumnResizerLineLayout/main': true,
          'fixedDataTableColumnResizerLineLayout/hiddenElem': !this.props.visible,
          'public/fixedDataTableColumnResizerLine/main': true
        }),
        style: style },
      React.createElement('div', {
        className: cx('fixedDataTableColumnResizerLineLayout/mouseArea'),
        style: { height: this.props.height }
      })
    );
  },

  _onMove: function _onMove( /*number*/deltaX) {
    if (Locale.isRTL()) {
      deltaX = -deltaX;
    }
    var newWidth = this.state.cursorDelta + deltaX;
    var newColumnWidth = clamp(newWidth, this.props.minWidth, this.props.maxWidth);

    // Please note cursor delta is the different between the currently width
    // and the new width.
    this.setState({
      width: newColumnWidth,
      cursorDelta: newWidth
    });
  },

  _onColumnResizeEnd: function _onColumnResizeEnd() {
    this._mouseMoveTracker.releaseMouseMoves();
    this.props.onColumnResizeEnd(this.state.width, this.props.columnKey);
  }
});

module.exports = FixedDataTableColumnResizeHandle;
},{"./DOMMouseMoveTracker":277,"./Locale":301,"./React":303,"./ReactComponentWithPureRenderMixin":304,"./clamp":311,"./cx":313}],291:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableHelper
 * @typechecks
 */

'use strict';

var Locale = require('./Locale');
var React = require('./React');
var FixedDataTableColumnGroup = require('./FixedDataTableColumnGroup.react');
var FixedDataTableColumn = require('./FixedDataTableColumn.react');

var DIR_SIGN = Locale.isRTL() ? -1 : +1;
// A cell up to 5px outside of the visible area will still be considered visible
var CELL_VISIBILITY_TOLERANCE = 5; // used for flyouts

function renderToString(value) /*string*/{
  if (value === null || value === undefined) {
    return '';
  } else {
    return String(value);
  }
}

/**
 * Helper method to execute a callback against all columns given the children
 * of a table.
 * @param {?object|array} children
 *    Children of a table.
 * @param {function} callback
 *    Function to excecute for each column. It is passed the column.
 */
function forEachColumn(children, callback) {
  React.Children.forEach(children, function (child) {
    if (child.type === FixedDataTableColumnGroup) {
      forEachColumn(child.props.children, callback);
    } else if (child.type === FixedDataTableColumn) {
      callback(child);
    }
  });
}

/**
 * Helper method to map columns to new columns. This takes into account column
 * groups and will generate a new column group if its columns change.
 * @param {?object|array} children
 *    Children of a table.
 * @param {function} callback
 *    Function to excecute for each column. It is passed the column and should
 *    return a result column.
 */
function mapColumns(children, callback) {
  var newChildren = [];
  React.Children.forEach(children, function (originalChild) {
    var newChild = originalChild;

    // The child is either a column group or a column. If it is a column group
    // we need to iterate over its columns and then potentially generate a
    // new column group
    if (originalChild.type === FixedDataTableColumnGroup) {
      var haveColumnsChanged = false;
      var newColumns = [];

      forEachColumn(originalChild.props.children, function (originalcolumn) {
        var newColumn = callback(originalcolumn);
        if (newColumn !== originalcolumn) {
          haveColumnsChanged = true;
        }
        newColumns.push(newColumn);
      });

      // If the column groups columns have changed clone the group and supply
      // new children
      if (haveColumnsChanged) {
        newChild = React.cloneElement(originalChild, {
          children: newColumns
        });
      }
    } else if (originalChild.type === FixedDataTableColumn) {
      newChild = callback(originalChild);
    }

    newChildren.push(newChild);
  });

  return newChildren;
}

var FixedDataTableHelper = {
  DIR_SIGN: DIR_SIGN,
  CELL_VISIBILITY_TOLERANCE: CELL_VISIBILITY_TOLERANCE,
  renderToString: renderToString,
  forEachColumn: forEachColumn,
  mapColumns: mapColumns
};

module.exports = FixedDataTableHelper;
},{"./FixedDataTableColumn.react":286,"./FixedDataTableColumnGroup.react":287,"./Locale":301,"./React":303}],292:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableNew.react
 * @typechecks
 * @noflow
 */

/*eslint no-bitwise:1*/

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('./React');
var ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');
var ReactWheelHandler = require('./ReactWheelHandler');
var Scrollbar = require('./Scrollbar.react');
var FixedDataTableBufferedRows = require('./FixedDataTableBufferedRows.react');
var FixedDataTableColumnResizeHandle = require('./FixedDataTableColumnResizeHandle.react');
var FixedDataTableRow = require('./FixedDataTableRow.react');
var FixedDataTableScrollHelper = require('./FixedDataTableScrollHelper');
var FixedDataTableWidthHelper = require('./FixedDataTableWidthHelper');

var cx = require('./cx');
var debounceCore = require('./debounceCore');
var emptyFunction = require('./emptyFunction');
var invariant = require('./invariant');
var joinClasses = require('./joinClasses');
var shallowEqual = require('./shallowEqual');
var translateDOMPositionXY = require('./translateDOMPositionXY');

var PropTypes = React.PropTypes;

var ReactChildren = React.Children;

var EMPTY_OBJECT = {};
var BORDER_HEIGHT = 1;
var HEADER = 'header';
var FOOTER = 'footer';
var CELL = 'cell';

/**
 * Data grid component with fixed or scrollable header and columns.
 *
 * The layout of the data table is as follows:
 *
 * ```
 * +---------------------------------------------------+
 * | Fixed Column Group    | Scrollable Column Group   |
 * | Header                | Header                    |
 * |                       |                           |
 * +---------------------------------------------------+
 * |                       |                           |
 * | Fixed Header Columns  | Scrollable Header Columns |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * |                       |                           |
 * | Fixed Body Columns    | Scrollable Body Columns   |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * |                       |                           |
 * | Fixed Footer Columns  | Scrollable Footer Columns |
 * |                       |                           |
 * +-----------------------+---------------------------+
 * ```
 *
 * - Fixed Column Group Header: These are the headers for a group
 *   of columns if included in the table that do not scroll
 *   vertically or horizontally.
 *
 * - Scrollable Column Group Header: The header for a group of columns
 *   that do not move while scrolling vertically, but move horizontally
 *   with the horizontal scrolling.
 *
 * - Fixed Header Columns: The header columns that do not move while scrolling
 *   vertically or horizontally.
 *
 * - Scrollable Header Columns: The header columns that do not move
 *   while scrolling vertically, but move horizontally with the horizontal
 *   scrolling.
 *
 * - Fixed Body Columns: The body columns that do not move while scrolling
 *   horizontally, but move vertically with the vertical scrolling.
 *
 * - Scrollable Body Columns: The body columns that move while scrolling
 *   vertically or horizontally.
 */
var FixedDataTable = React.createClass({
  displayName: 'FixedDataTable',

  propTypes: {

    /**
     * Pixel width of table. If all columns do not fit,
     * a horizontal scrollbar will appear.
     */
    width: PropTypes.number.isRequired,

    /**
     * Pixel height of table. If all rows do not fit,
     * a vertical scrollbar will appear.
     *
     * Either `height` or `maxHeight` must be specified.
     */
    height: PropTypes.number,

    /**
     * Maximum pixel height of table. If all rows do not fit,
     * a vertical scrollbar will appear.
     *
     * Either `height` or `maxHeight` must be specified.
     */
    maxHeight: PropTypes.number,

    /**
     * Pixel height of table's owner, this is used in a managed scrolling
     * situation when you want to slide the table up from below the fold
     * without having to constantly update the height on every scroll tick.
     * Instead, vary this property on scroll. By using `ownerHeight`, we
     * over-render the table while making sure the footer and horizontal
     * scrollbar of the table are visible when the current space for the table
     * in view is smaller than the final, over-flowing height of table. It
     * allows us to avoid resizing and reflowing table when it is moving in the
     * view.
     *
     * This is used if `ownerHeight < height` (or `maxHeight`).
     */
    ownerHeight: PropTypes.number,

    overflowX: PropTypes.oneOf(['hidden', 'auto']),
    overflowY: PropTypes.oneOf(['hidden', 'auto']),

    /**
     * Number of rows in the table.
     */
    rowsCount: PropTypes.number.isRequired,

    /**
     * Pixel height of rows unless `rowHeightGetter` is specified and returns
     * different value.
     */
    rowHeight: PropTypes.number.isRequired,

    /**
     * If specified, `rowHeightGetter(index)` is called for each row and the
     * returned value overrides `rowHeight` for particular row.
     */
    rowHeightGetter: PropTypes.func,

    /**
     * To get any additional CSS classes that should be added to a row,
     * `rowClassNameGetter(index)` is called.
     */
    rowClassNameGetter: PropTypes.func,

    /**
     * Pixel height of the column group header.
     */
    groupHeaderHeight: PropTypes.number,

    /**
     * Pixel height of header.
     */
    headerHeight: PropTypes.number.isRequired,

    /**
     * Pixel height of footer.
     */
    footerHeight: PropTypes.number,

    /**
     * Value of horizontal scroll.
     */
    scrollLeft: PropTypes.number,

    /**
     * Index of column to scroll to.
     */
    scrollToColumn: PropTypes.number,

    /**
     * Value of vertical scroll.
     */
    scrollTop: PropTypes.number,

    /**
     * Index of row to scroll to.
     */
    scrollToRow: PropTypes.number,

    /**
     * Callback that is called when scrolling starts with current horizontal
     * and vertical scroll values.
     */
    onScrollStart: PropTypes.func,

    /**
     * Callback that is called when scrolling ends or stops with new horizontal
     * and vertical scroll values.
     */
    onScrollEnd: PropTypes.func,

    /**
     * Callback that is called when `rowHeightGetter` returns a different height
     * for a row than the `rowHeight` prop. This is necessary because initially
     * table estimates heights of some parts of the content.
     */
    onContentHeightChange: PropTypes.func,

    /**
     * Callback that is called when a row is clicked.
     */
    onRowClick: PropTypes.func,

    /**
     * Callback that is called when a row is double clicked.
     */
    onRowDoubleClick: PropTypes.func,

    /**
     * Callback that is called when a mouse-down event happens on a row.
     */
    onRowMouseDown: PropTypes.func,

    /**
     * Callback that is called when a mouse-enter event happens on a row.
     */
    onRowMouseEnter: PropTypes.func,

    /**
     * Callback that is called when a mouse-leave event happens on a row.
     */
    onRowMouseLeave: PropTypes.func,

    /**
     * Callback that is called when resizer has been released
     * and column needs to be updated.
     *
     * Required if the isResizable property is true on any column.
     *
     * ```
     * function(
     *   newColumnWidth: number,
     *   columnKey: string,
     * )
     * ```
     */
    onColumnResizeEndCallback: PropTypes.func,

    /**
     * Whether a column is currently being resized.
     */
    isColumnResizing: PropTypes.bool
  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return {
      footerHeight: 0,
      groupHeaderHeight: 0,
      headerHeight: 0,
      scrollLeft: 0,
      scrollTop: 0
    };
  },

  getInitialState: function getInitialState() /*object*/{
    var props = this.props;
    var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);
    this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);
    if (props.scrollTop) {
      this._scrollHelper.scrollTo(props.scrollTop);
    }
    this._didScrollStop = debounceCore(this._didScrollStop, 200, this);

    return this._calculateState(this.props);
  },

  componentWillMount: function componentWillMount() {
    var scrollToRow = this.props.scrollToRow;
    if (scrollToRow !== undefined && scrollToRow !== null) {
      this._rowToScrollTo = scrollToRow;
    }
    var scrollToColumn = this.props.scrollToColumn;
    if (scrollToColumn !== undefined && scrollToColumn !== null) {
      this._columnToScrollTo = scrollToColumn;
    }
    this._wheelHandler = new ReactWheelHandler(this._onWheel, this._shouldHandleWheelX, this._shouldHandleWheelY);
  },

  _shouldHandleWheelX: function _shouldHandleWheelX( /*number*/delta) /*boolean*/{
    if (this.props.overflowX === 'hidden') {
      return false;
    }

    delta = Math.round(delta);
    if (delta === 0) {
      return false;
    }

    return delta < 0 && this.state.scrollX > 0 || delta >= 0 && this.state.scrollX < this.state.maxScrollX;
  },

  _shouldHandleWheelY: function _shouldHandleWheelY( /*number*/delta) /*boolean*/{
    if (this.props.overflowY === 'hidden' || delta === 0) {
      return false;
    }

    delta = Math.round(delta);
    if (delta === 0) {
      return false;
    }

    return delta < 0 && this.state.scrollY > 0 || delta >= 0 && this.state.scrollY < this.state.maxScrollY;
  },

  _reportContentHeight: function _reportContentHeight() {
    var scrollContentHeight = this.state.scrollContentHeight;
    var reservedHeight = this.state.reservedHeight;
    var requiredHeight = scrollContentHeight + reservedHeight;
    var contentHeight;
    var useMaxHeight = this.props.height === undefined;
    if (useMaxHeight && this.props.maxHeight > requiredHeight) {
      contentHeight = requiredHeight;
    } else if (this.state.height > requiredHeight && this.props.ownerHeight) {
      contentHeight = Math.max(requiredHeight, this.props.ownerHeight);
    } else {
      contentHeight = this.state.height + this.state.maxScrollY;
    }
    if (contentHeight !== this._contentHeight && this.props.onContentHeightChange) {
      this.props.onContentHeightChange(contentHeight);
    }
    this._contentHeight = contentHeight;
  },

  componentDidMount: function componentDidMount() {
    this._reportContentHeight();
  },

  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
    var scrollToRow = nextProps.scrollToRow;
    if (scrollToRow !== undefined && scrollToRow !== null) {
      this._rowToScrollTo = scrollToRow;
    }
    var scrollToColumn = nextProps.scrollToColumn;
    if (scrollToColumn !== undefined && scrollToColumn !== null) {
      this._columnToScrollTo = scrollToColumn;
    }

    var newOverflowX = nextProps.overflowX;
    var newOverflowY = nextProps.overflowY;
    if (newOverflowX !== this.props.overflowX || newOverflowY !== this.props.overflowY) {
      this._wheelHandler = new ReactWheelHandler(this._onWheel, newOverflowX !== 'hidden', // Should handle horizontal scroll
      newOverflowY !== 'hidden' // Should handle vertical scroll
      );
    }

    // In the case of controlled scrolling, notify.
    if (this.props.ownerHeight !== nextProps.ownerHeight || this.props.scrollTop !== nextProps.scrollTop) {
      this._didScrollStart();
    }
    this._didScrollStop();

    this.setState(this._calculateState(nextProps, this.state));
  },

  componentDidUpdate: function componentDidUpdate() {
    this._reportContentHeight();
  },

  render: function render() /*object*/{
    var state = this.state;
    var props = this.props;

    var groupHeader;
    if (state.useGroupHeader) {
      groupHeader = React.createElement(FixedDataTableRow, {
        key: 'group_header',
        isScrolling: this._isScrolling,
        className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),
        width: state.width,
        height: state.groupHeaderHeight,
        index: 0,
        zIndex: 1,
        offsetTop: 0,
        scrollLeft: state.scrollX,
        fixedColumns: state.groupHeaderFixedColumns,
        scrollableColumns: state.groupHeaderScrollableColumns,
        onColumnResize: this._onColumnResize
      });
    }

    var maxScrollY = this.state.maxScrollY;
    var showScrollbarX = state.maxScrollX > 0 && state.overflowX !== 'hidden';
    var showScrollbarY = maxScrollY > 0 && state.overflowY !== 'hidden';
    var scrollbarXHeight = showScrollbarX ? Scrollbar.SIZE : 0;
    var scrollbarYHeight = state.height - scrollbarXHeight - 2 * BORDER_HEIGHT - state.footerHeight;

    var headerOffsetTop = state.useGroupHeader ? state.groupHeaderHeight : 0;
    var bodyOffsetTop = headerOffsetTop + state.headerHeight;
    scrollbarYHeight -= bodyOffsetTop;
    var bottomSectionOffset = 0;
    var footOffsetTop = props.maxHeight != null ? bodyOffsetTop + state.bodyHeight : bodyOffsetTop + scrollbarYHeight;
    var rowsContainerHeight = footOffsetTop + state.footerHeight;

    if (props.ownerHeight !== undefined && props.ownerHeight < state.height) {
      bottomSectionOffset = props.ownerHeight - state.height;

      footOffsetTop = Math.min(footOffsetTop, props.ownerHeight - state.footerHeight - scrollbarXHeight);

      scrollbarYHeight = Math.max(0, footOffsetTop - bodyOffsetTop);
    }

    var verticalScrollbar;
    if (showScrollbarY) {
      verticalScrollbar = React.createElement(Scrollbar, {
        size: scrollbarYHeight,
        contentSize: scrollbarYHeight + maxScrollY,
        onScroll: this._onVerticalScroll,
        verticalTop: bodyOffsetTop,
        position: state.scrollY
      });
    }

    var horizontalScrollbar;
    if (showScrollbarX) {
      var scrollbarXWidth = state.width;
      horizontalScrollbar = React.createElement(HorizontalScrollbar, {
        contentSize: scrollbarXWidth + state.maxScrollX,
        offset: bottomSectionOffset,
        onScroll: this._onHorizontalScroll,
        position: state.scrollX,
        size: scrollbarXWidth
      });
    }

    var dragKnob = React.createElement(FixedDataTableColumnResizeHandle, {
      height: state.height,
      initialWidth: state.columnResizingData.width || 0,
      minWidth: state.columnResizingData.minWidth || 0,
      maxWidth: state.columnResizingData.maxWidth || Number.MAX_VALUE,
      visible: !!state.isColumnResizing,
      leftOffset: state.columnResizingData.left || 0,
      knobHeight: state.headerHeight,
      initialEvent: state.columnResizingData.initialEvent,
      onColumnResizeEnd: props.onColumnResizeEndCallback,
      columnKey: state.columnResizingData.key
    });

    var footer = null;
    if (state.footerHeight) {
      footer = React.createElement(FixedDataTableRow, {
        key: 'footer',
        isScrolling: this._isScrolling,
        className: joinClasses(cx('fixedDataTableLayout/footer'), cx('public/fixedDataTable/footer')),
        width: state.width,
        height: state.footerHeight,
        index: -1,
        zIndex: 1,
        offsetTop: footOffsetTop,
        fixedColumns: state.footFixedColumns,
        scrollableColumns: state.footScrollableColumns,
        scrollLeft: state.scrollX
      });
    }

    var rows = this._renderRows(bodyOffsetTop);

    var header = React.createElement(FixedDataTableRow, {
      key: 'header',
      isScrolling: this._isScrolling,
      className: joinClasses(cx('fixedDataTableLayout/header'), cx('public/fixedDataTable/header')),
      width: state.width,
      height: state.headerHeight,
      index: -1,
      zIndex: 1,
      offsetTop: headerOffsetTop,
      scrollLeft: state.scrollX,
      fixedColumns: state.headFixedColumns,
      scrollableColumns: state.headScrollableColumns,
      onColumnResize: this._onColumnResize
    });

    var topShadow;
    var bottomShadow;
    if (state.scrollY) {
      topShadow = React.createElement('div', {
        className: joinClasses(cx('fixedDataTableLayout/topShadow'), cx('public/fixedDataTable/topShadow')),
        style: { top: bodyOffsetTop }
      });
    }

    if (state.ownerHeight != null && state.ownerHeight < state.height && state.scrollContentHeight + state.reservedHeight > state.ownerHeight || state.scrollY < maxScrollY) {
      bottomShadow = React.createElement('div', {
        className: joinClasses(cx('fixedDataTableLayout/bottomShadow'), cx('public/fixedDataTable/bottomShadow')),
        style: { top: footOffsetTop }
      });
    }

    return React.createElement(
      'div',
      {
        className: joinClasses(cx('fixedDataTableLayout/main'), cx('public/fixedDataTable/main')),
        onWheel: this._wheelHandler.onWheel,
        style: { height: state.height, width: state.width } },
      React.createElement(
        'div',
        {
          className: cx('fixedDataTableLayout/rowsContainer'),
          style: { height: rowsContainerHeight, width: state.width } },
        dragKnob,
        groupHeader,
        header,
        rows,
        footer,
        topShadow,
        bottomShadow
      ),
      verticalScrollbar,
      horizontalScrollbar
    );
  },

  _renderRows: function _renderRows( /*number*/offsetTop) /*object*/{
    var state = this.state;

    return React.createElement(FixedDataTableBufferedRows, {
      isScrolling: this._isScrolling,
      defaultRowHeight: state.rowHeight,
      firstRowIndex: state.firstRowIndex,
      firstRowOffset: state.firstRowOffset,
      fixedColumns: state.bodyFixedColumns,
      height: state.bodyHeight,
      offsetTop: offsetTop,
      onRowClick: state.onRowClick,
      onRowDoubleClick: state.onRowDoubleClick,
      onRowMouseDown: state.onRowMouseDown,
      onRowMouseEnter: state.onRowMouseEnter,
      onRowMouseLeave: state.onRowMouseLeave,
      rowClassNameGetter: state.rowClassNameGetter,
      rowsCount: state.rowsCount,
      rowGetter: state.rowGetter,
      rowHeightGetter: state.rowHeightGetter,
      scrollLeft: state.scrollX,
      scrollableColumns: state.bodyScrollableColumns,
      showLastRowBorder: true,
      width: state.width,
      rowPositionGetter: this._scrollHelper.getRowPosition
    });
  },

  /**
   * This is called when a cell that is in the header of a column has its
   * resizer knob clicked on. It displays the resizer and puts in the correct
   * location on the table.
   */
  _onColumnResize: function _onColumnResize(
  /*number*/combinedWidth,
  /*number*/leftOffset,
  /*number*/cellWidth,
  /*?number*/cellMinWidth,
  /*?number*/cellMaxWidth,
  /*number|string*/columnKey,
  /*object*/event) {
    this.setState({
      isColumnResizing: true,
      columnResizingData: {
        left: leftOffset + combinedWidth - cellWidth,
        width: cellWidth,
        minWidth: cellMinWidth,
        maxWidth: cellMaxWidth,
        initialEvent: {
          clientX: event.clientX,
          clientY: event.clientY,
          preventDefault: emptyFunction
        },
        key: columnKey
      }
    });
  },

  _areColumnSettingsIdentical: function _areColumnSettingsIdentical(oldColumns, newColumns) {
    if (oldColumns.length !== newColumns.length) {
      return false;
    }
    for (var index = 0; index < oldColumns.length; ++index) {
      if (!shallowEqual(oldColumns[index].props, newColumns[index].props)) {
        return false;
      }
    }
    return true;
  },

  _populateColumnsAndColumnData: function _populateColumnsAndColumnData(columns, columnGroups, oldState) {
    var canReuseColumnSettings = false;
    var canReuseColumnGroupSettings = false;

    if (oldState && oldState.columns) {
      canReuseColumnSettings = this._areColumnSettingsIdentical(columns, oldState.columns);
    }
    if (oldState && oldState.columnGroups && columnGroups) {
      canReuseColumnGroupSettings = this._areColumnSettingsIdentical(columnGroups, oldState.columnGroups);
    }

    var columnInfo = {};
    if (canReuseColumnSettings) {
      columnInfo.bodyFixedColumns = oldState.bodyFixedColumns;
      columnInfo.bodyScrollableColumns = oldState.bodyScrollableColumns;
      columnInfo.headFixedColumns = oldState.headFixedColumns;
      columnInfo.headScrollableColumns = oldState.headScrollableColumns;
      columnInfo.footFixedColumns = oldState.footFixedColumns;
      columnInfo.footScrollableColumns = oldState.footScrollableColumns;
    } else {
      var bodyColumnTypes = this._splitColumnTypes(columns);
      columnInfo.bodyFixedColumns = bodyColumnTypes.fixed;
      columnInfo.bodyScrollableColumns = bodyColumnTypes.scrollable;

      var headColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columns));
      columnInfo.headFixedColumns = headColumnTypes.fixed;
      columnInfo.headScrollableColumns = headColumnTypes.scrollable;

      var footColumnTypes = this._splitColumnTypes(this._selectColumnElement(FOOTER, columns));
      columnInfo.footFixedColumns = footColumnTypes.fixed;
      columnInfo.footScrollableColumns = footColumnTypes.scrollable;
    }

    if (canReuseColumnGroupSettings) {
      columnInfo.groupHeaderFixedColumns = oldState.groupHeaderFixedColumns;
      columnInfo.groupHeaderScrollableColumns = oldState.groupHeaderScrollableColumns;
    } else {
      if (columnGroups) {
        var groupHeaderColumnTypes = this._splitColumnTypes(this._selectColumnElement(HEADER, columnGroups));
        columnInfo.groupHeaderFixedColumns = groupHeaderColumnTypes.fixed;
        columnInfo.groupHeaderScrollableColumns = groupHeaderColumnTypes.scrollable;
      }
    }

    return columnInfo;
  },

  _calculateState: function _calculateState( /*object*/props, /*?object*/oldState) /*object*/{
    invariant(props.height !== undefined || props.maxHeight !== undefined, 'You must set either a height or a maxHeight');

    var children = [];
    ReactChildren.forEach(props.children, function (child, index) {
      if (child == null) {
        return;
      }
      invariant(child.type.__TableColumnGroup__ || child.type.__TableColumn__, 'child type should be <FixedDataTableColumn /> or ' + '<FixedDataTableColumnGroup />');
      children.push(child);
    });

    var useGroupHeader = false;
    if (children.length && children[0].type.__TableColumnGroup__) {
      useGroupHeader = true;
    }

    var firstRowIndex = oldState && oldState.firstRowIndex || 0;
    var firstRowOffset = oldState && oldState.firstRowOffset || 0;
    var scrollX, scrollY;
    if (oldState && props.overflowX !== 'hidden') {
      scrollX = oldState.scrollX;
    } else {
      scrollX = props.scrollLeft;
    }
    if (oldState && props.overflowY !== 'hidden') {
      scrollY = oldState.scrollY;
    } else {
      scrollState = this._scrollHelper.scrollTo(props.scrollTop);
      firstRowIndex = scrollState.index;
      firstRowOffset = scrollState.offset;
      scrollY = scrollState.position;
    }

    if (this._rowToScrollTo !== undefined) {
      scrollState = this._scrollHelper.scrollRowIntoView(this._rowToScrollTo);
      firstRowIndex = scrollState.index;
      firstRowOffset = scrollState.offset;
      scrollY = scrollState.position;
      delete this._rowToScrollTo;
    }

    var groupHeaderHeight = useGroupHeader ? props.groupHeaderHeight : 0;

    if (oldState && props.rowsCount !== oldState.rowsCount) {
      // Number of rows changed, try to scroll to the row from before the
      // change
      var viewportHeight = (props.height === undefined ? props.maxHeight : props.height) - (props.headerHeight || 0) - (props.footerHeight || 0) - (props.groupHeaderHeight || 0);
      this._scrollHelper = new FixedDataTableScrollHelper(props.rowsCount, props.rowHeight, viewportHeight, props.rowHeightGetter);
      var scrollState = this._scrollHelper.scrollToRow(firstRowIndex, firstRowOffset);
      firstRowIndex = scrollState.index;
      firstRowOffset = scrollState.offset;
      scrollY = scrollState.position;
    } else if (oldState && props.rowHeightGetter !== oldState.rowHeightGetter) {
      this._scrollHelper.setRowHeightGetter(props.rowHeightGetter);
    }

    var columnResizingData;
    if (props.isColumnResizing) {
      columnResizingData = oldState && oldState.columnResizingData;
    } else {
      columnResizingData = EMPTY_OBJECT;
    }

    var columns;
    var columnGroups;

    if (useGroupHeader) {
      var columnGroupSettings = FixedDataTableWidthHelper.adjustColumnGroupWidths(children, props.width);
      columns = columnGroupSettings.columns;
      columnGroups = columnGroupSettings.columnGroups;
    } else {
      columns = FixedDataTableWidthHelper.adjustColumnWidths(children, props.width);
    }

    var columnInfo = this._populateColumnsAndColumnData(columns, columnGroups, oldState);

    if (this._columnToScrollTo !== undefined) {
      // If selected column is a fixed column, don't scroll
      var fixedColumnsCount = columnInfo.bodyFixedColumns.length;
      if (this._columnToScrollTo >= fixedColumnsCount) {
        var totalFixedColumnsWidth = 0;
        var i, column;
        for (i = 0; i < columnInfo.bodyFixedColumns.length; ++i) {
          column = columnInfo.bodyFixedColumns[i];
          totalFixedColumnsWidth += column.props.width;
        }

        var scrollableColumnIndex = Math.min(this._columnToScrollTo - fixedColumnsCount, columnInfo.bodyScrollableColumns.length - 1);

        var previousColumnsWidth = 0;
        for (i = 0; i < scrollableColumnIndex; ++i) {
          column = columnInfo.bodyScrollableColumns[i];
          previousColumnsWidth += column.props.width;
        }

        var availableScrollWidth = props.width - totalFixedColumnsWidth;
        var selectedColumnWidth = columnInfo.bodyScrollableColumns[scrollableColumnIndex].props.width;
        var minAcceptableScrollPosition = previousColumnsWidth + selectedColumnWidth - availableScrollWidth;

        if (scrollX < minAcceptableScrollPosition) {
          scrollX = minAcceptableScrollPosition;
        }

        if (scrollX > previousColumnsWidth) {
          scrollX = previousColumnsWidth;
        }
      }
      delete this._columnToScrollTo;
    }

    var useMaxHeight = props.height === undefined;
    var height = Math.round(useMaxHeight ? props.maxHeight : props.height);
    var totalHeightReserved = props.footerHeight + props.headerHeight + groupHeaderHeight + 2 * BORDER_HEIGHT;
    var bodyHeight = height - totalHeightReserved;
    var scrollContentHeight = this._scrollHelper.getContentHeight();
    var totalHeightNeeded = scrollContentHeight + totalHeightReserved;
    var scrollContentWidth = FixedDataTableWidthHelper.getTotalWidth(columns);

    var horizontalScrollbarVisible = scrollContentWidth > props.width && props.overflowX !== 'hidden';

    if (horizontalScrollbarVisible) {
      bodyHeight -= Scrollbar.SIZE;
      totalHeightNeeded += Scrollbar.SIZE;
      totalHeightReserved += Scrollbar.SIZE;
    }

    var maxScrollX = Math.max(0, scrollContentWidth - props.width);
    var maxScrollY = Math.max(0, scrollContentHeight - bodyHeight);
    scrollX = Math.min(scrollX, maxScrollX);
    scrollY = Math.min(scrollY, maxScrollY);

    if (!maxScrollY) {
      // no vertical scrollbar necessary, use the totals we tracked so we
      // can shrink-to-fit vertically
      if (useMaxHeight) {
        height = totalHeightNeeded;
      }
      bodyHeight = totalHeightNeeded - totalHeightReserved;
    }

    this._scrollHelper.setViewportHeight(bodyHeight);

    // The order of elements in this object metters and bringing bodyHeight,
    // height or useGroupHeader to the top can break various features
    var newState = _extends({
      isColumnResizing: oldState && oldState.isColumnResizing
    }, columnInfo, props, {

      columns: columns,
      columnGroups: columnGroups,
      columnResizingData: columnResizingData,
      firstRowIndex: firstRowIndex,
      firstRowOffset: firstRowOffset,
      horizontalScrollbarVisible: horizontalScrollbarVisible,
      maxScrollX: maxScrollX,
      maxScrollY: maxScrollY,
      reservedHeight: totalHeightReserved,
      scrollContentHeight: scrollContentHeight,
      scrollX: scrollX,
      scrollY: scrollY,

      // These properties may overwrite properties defined in
      // columnInfo and props
      bodyHeight: bodyHeight,
      height: height,
      groupHeaderHeight: groupHeaderHeight,
      useGroupHeader: useGroupHeader
    });

    return newState;
  },

  _selectColumnElement: function _selectColumnElement( /*string*/type, /*array*/columns) /*array*/{
    var newColumns = [];
    for (var i = 0; i < columns.length; ++i) {
      var column = columns[i];
      newColumns.push(React.cloneElement(column, {
        cell: type ? column.props[type] : column.props[CELL]
      }));
    }
    return newColumns;
  },

  _splitColumnTypes: function _splitColumnTypes( /*array*/columns) /*object*/{
    var fixedColumns = [];
    var scrollableColumns = [];
    for (var i = 0; i < columns.length; ++i) {
      if (columns[i].props.fixed) {
        fixedColumns.push(columns[i]);
      } else {
        scrollableColumns.push(columns[i]);
      }
    }
    return {
      fixed: fixedColumns,
      scrollable: scrollableColumns
    };
  },

  _onWheel: function _onWheel( /*number*/deltaX, /*number*/deltaY) {
    if (this.isMounted()) {
      if (!this._isScrolling) {
        this._didScrollStart();
      }
      var x = this.state.scrollX;
      if (Math.abs(deltaY) > Math.abs(deltaX) && this.props.overflowY !== 'hidden') {
        var scrollState = this._scrollHelper.scrollBy(Math.round(deltaY));
        var maxScrollY = Math.max(0, scrollState.contentHeight - this.state.bodyHeight);
        this.setState({
          firstRowIndex: scrollState.index,
          firstRowOffset: scrollState.offset,
          scrollY: scrollState.position,
          scrollContentHeight: scrollState.contentHeight,
          maxScrollY: maxScrollY
        });
      } else if (deltaX && this.props.overflowX !== 'hidden') {
        x += deltaX;
        x = x < 0 ? 0 : x;
        x = x > this.state.maxScrollX ? this.state.maxScrollX : x;
        this.setState({
          scrollX: x
        });
      }

      this._didScrollStop();
    }
  },

  _onHorizontalScroll: function _onHorizontalScroll( /*number*/scrollPos) {
    if (this.isMounted() && scrollPos !== this.state.scrollX) {
      if (!this._isScrolling) {
        this._didScrollStart();
      }
      this.setState({
        scrollX: scrollPos
      });
      this._didScrollStop();
    }
  },

  _onVerticalScroll: function _onVerticalScroll( /*number*/scrollPos) {
    if (this.isMounted() && scrollPos !== this.state.scrollY) {
      if (!this._isScrolling) {
        this._didScrollStart();
      }
      var scrollState = this._scrollHelper.scrollTo(Math.round(scrollPos));
      this.setState({
        firstRowIndex: scrollState.index,
        firstRowOffset: scrollState.offset,
        scrollY: scrollState.position,
        scrollContentHeight: scrollState.contentHeight
      });
      this._didScrollStop();
    }
  },

  _didScrollStart: function _didScrollStart() {
    if (this.isMounted() && !this._isScrolling) {
      this._isScrolling = true;
      if (this.props.onScrollStart) {
        this.props.onScrollStart(this.state.scrollX, this.state.scrollY);
      }
    }
  },

  _didScrollStop: function _didScrollStop() {
    if (this.isMounted() && this._isScrolling) {
      this._isScrolling = false;
      this.setState({ redraw: true });
      if (this.props.onScrollEnd) {
        this.props.onScrollEnd(this.state.scrollX, this.state.scrollY);
      }
    }
  }
});

var HorizontalScrollbar = React.createClass({
  displayName: 'HorizontalScrollbar',

  mixins: [ReactComponentWithPureRenderMixin],
  propTypes: {
    contentSize: PropTypes.number.isRequired,
    offset: PropTypes.number.isRequired,
    onScroll: PropTypes.func.isRequired,
    position: PropTypes.number.isRequired,
    size: PropTypes.number.isRequired
  },

  render: function render() /*object*/{
    var outerContainerStyle = {
      height: Scrollbar.SIZE,
      width: this.props.size
    };
    var innerContainerStyle = {
      height: Scrollbar.SIZE,
      position: 'absolute',
      overflow: 'hidden',
      width: this.props.size
    };
    translateDOMPositionXY(innerContainerStyle, 0, this.props.offset);

    return React.createElement(
      'div',
      {
        className: joinClasses(cx('fixedDataTableLayout/horizontalScrollbar'), cx('public/fixedDataTable/horizontalScrollbar')),
        style: outerContainerStyle },
      React.createElement(
        'div',
        { style: innerContainerStyle },
        React.createElement(Scrollbar, _extends({}, this.props, {
          isOpaque: true,
          orientation: 'horizontal',
          offset: undefined
        }))
      )
    );
  }
});

module.exports = FixedDataTable;
// isColumnResizing should be overwritten by value from props if
// avaialble
},{"./FixedDataTableBufferedRows.react":281,"./FixedDataTableColumnResizeHandle.react":290,"./FixedDataTableRow.react":294,"./FixedDataTableScrollHelper":296,"./FixedDataTableWidthHelper":297,"./React":303,"./ReactComponentWithPureRenderMixin":304,"./ReactWheelHandler":306,"./Scrollbar.react":307,"./cx":313,"./debounceCore":314,"./emptyFunction":315,"./invariant":317,"./joinClasses":319,"./shallowEqual":323,"./translateDOMPositionXY":324}],293:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableRoot
 */

'use strict';

var FixedDataTable = require('./FixedDataTable.react');
var FixedDataTableCellDefault = require('./FixedDataTableCellDefault.react');
var FixedDataTableColumn = require('./FixedDataTableColumn.react');
var FixedDataTableColumnGroup = require('./FixedDataTableColumnGroup.react');

var FixedDataTableRoot = {
  Cell: FixedDataTableCellDefault,
  Column: FixedDataTableColumn,
  ColumnGroup: FixedDataTableColumnGroup,
  Table: FixedDataTable
};

FixedDataTableRoot.version = '0.6.3';
module.exports = FixedDataTableRoot;
},{"./FixedDataTable.react":280,"./FixedDataTableCellDefault.react":283,"./FixedDataTableColumn.react":286,"./FixedDataTableColumnGroup.react":287}],294:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableRow.react
 * @typechecks
 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('./React');
var FixedDataTableCellGroup = require('./FixedDataTableCellGroup.react');

var cx = require('./cx');
var joinClasses = require('./joinClasses');
var translateDOMPositionXY = require('./translateDOMPositionXY');

var PropTypes = React.PropTypes;

/**
 * Component that renders the row for <FixedDataTable />.
 * This component should not be used directly by developer. Instead,
 * only <FixedDataTable /> should use the component internally.
 */
var FixedDataTableRowImpl = React.createClass({
  displayName: 'FixedDataTableRowImpl',

  propTypes: {

    isScrolling: PropTypes.bool,

    /**
     * Array of <FixedDataTableColumn /> for the fixed columns.
     */
    fixedColumns: PropTypes.array.isRequired,

    /**
     * Height of the row.
     */
    height: PropTypes.number.isRequired,

    /**
     * The row index.
     */
    index: PropTypes.number.isRequired,

    /**
     * Array of <FixedDataTableColumn /> for the scrollable columns.
     */
    scrollableColumns: PropTypes.array.isRequired,

    /**
     * The distance between the left edge of the table and the leftmost portion
     * of the row currently visible in the table.
     */
    scrollLeft: PropTypes.number.isRequired,

    /**
     * Width of the row.
     */
    width: PropTypes.number.isRequired,

    /**
     * Fire when a row is clicked.
     */
    onClick: PropTypes.func,

    /**
     * Fire when a row is double clicked.
     */
    onDoubleClick: PropTypes.func,

    /**
     * Callback for when resizer knob (in FixedDataTableCell) is clicked
     * to initialize resizing. Please note this is only on the cells
     * in the header.
     * @param number combinedWidth
     * @param number leftOffset
     * @param number cellWidth
     * @param number|string columnKey
     * @param object event
     */
    onColumnResize: PropTypes.func
  },

  render: function render() /*object*/{
    var style = {
      width: this.props.width,
      height: this.props.height
    };

    var className = cx({
      'fixedDataTableRowLayout/main': true,
      'public/fixedDataTableRow/main': true,
      'public/fixedDataTableRow/highlighted': this.props.index % 2 === 1,
      'public/fixedDataTableRow/odd': this.props.index % 2 === 1,
      'public/fixedDataTableRow/even': this.props.index % 2 === 0
    });

    var fixedColumnsWidth = this._getColumnsWidth(this.props.fixedColumns);
    var fixedColumns = React.createElement(FixedDataTableCellGroup, {
      key: 'fixed_cells',
      isScrolling: this.props.isScrolling,
      height: this.props.height,
      left: 0,
      width: fixedColumnsWidth,
      zIndex: 2,
      columns: this.props.fixedColumns,
      onColumnResize: this.props.onColumnResize,
      rowHeight: this.props.height,
      rowIndex: this.props.index
    });
    var columnsShadow = this._renderColumnsShadow(fixedColumnsWidth);
    var scrollableColumns = React.createElement(FixedDataTableCellGroup, {
      key: 'scrollable_cells',
      isScrolling: this.props.isScrolling,
      height: this.props.height,
      left: this.props.scrollLeft,
      offsetLeft: fixedColumnsWidth,
      width: this.props.width - fixedColumnsWidth,
      zIndex: 0,
      columns: this.props.scrollableColumns,
      onColumnResize: this.props.onColumnResize,
      rowHeight: this.props.height,
      rowIndex: this.props.index
    });

    return React.createElement(
      'div',
      {
        className: joinClasses(className, this.props.className),
        onClick: this.props.onClick ? this._onClick : null,
        onDoubleClick: this.props.onDoubleClick ? this._onDoubleClick : null,
        onMouseDown: this.props.onMouseDown ? this._onMouseDown : null,
        onMouseEnter: this.props.onMouseEnter ? this._onMouseEnter : null,
        onMouseLeave: this.props.onMouseLeave ? this._onMouseLeave : null,
        style: style },
      React.createElement(
        'div',
        { className: cx('fixedDataTableRowLayout/body') },
        fixedColumns,
        scrollableColumns,
        columnsShadow
      )
    );
  },

  _getColumnsWidth: function _getColumnsWidth( /*array*/columns) /*number*/{
    var width = 0;
    for (var i = 0; i < columns.length; ++i) {
      width += columns[i].props.width;
    }
    return width;
  },

  _renderColumnsShadow: function _renderColumnsShadow( /*number*/left) /*?object*/{
    if (left > 0) {
      var className = cx({
        'fixedDataTableRowLayout/fixedColumnsDivider': true,
        'fixedDataTableRowLayout/columnsShadow': this.props.scrollLeft > 0,
        'public/fixedDataTableRow/fixedColumnsDivider': true,
        'public/fixedDataTableRow/columnsShadow': this.props.scrollLeft > 0
      });
      var style = {
        left: left,
        height: this.props.height
      };
      return React.createElement('div', { className: className, style: style });
    }
  },

  _onClick: function _onClick( /*object*/event) {
    this.props.onClick(event, this.props.index);
  },

  _onDoubleClick: function _onDoubleClick( /*object*/event) {
    this.props.onDoubleClick(event, this.props.index);
  },

  _onMouseDown: function _onMouseDown( /*object*/event) {
    this.props.onMouseDown(event, this.props.index);
  },

  _onMouseEnter: function _onMouseEnter( /*object*/event) {
    this.props.onMouseEnter(event, this.props.index);
  },

  _onMouseLeave: function _onMouseLeave( /*object*/event) {
    this.props.onMouseLeave(event, this.props.index);
  }
});

var FixedDataTableRow = React.createClass({
  displayName: 'FixedDataTableRow',

  propTypes: {

    isScrolling: PropTypes.bool,

    /**
     * Height of the row.
     */
    height: PropTypes.number.isRequired,

    /**
     * Z-index on which the row will be displayed. Used e.g. for keeping
     * header and footer in front of other rows.
     */
    zIndex: PropTypes.number,

    /**
     * The vertical position where the row should render itself
     */
    offsetTop: PropTypes.number.isRequired,

    /**
     * Width of the row.
     */
    width: PropTypes.number.isRequired
  },

  render: function render() /*object*/{
    var style = {
      width: this.props.width,
      height: this.props.height,
      zIndex: this.props.zIndex ? this.props.zIndex : 0
    };
    translateDOMPositionXY(style, 0, this.props.offsetTop);

    return React.createElement(
      'div',
      {
        style: style,
        className: cx('fixedDataTableRowLayout/rowWrapper') },
      React.createElement(FixedDataTableRowImpl, _extends({}, this.props, {
        offsetTop: undefined,
        zIndex: undefined
      }))
    );
  }
});

module.exports = FixedDataTableRow;
},{"./FixedDataTableCellGroup.react":284,"./React":303,"./cx":313,"./joinClasses":319,"./translateDOMPositionXY":324}],295:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableRowBuffer
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var IntegerBufferSet = require('./IntegerBufferSet');

var clamp = require('./clamp');
var invariant = require('./invariant');
var MIN_BUFFER_ROWS = 3;
var MAX_BUFFER_ROWS = 6;

// FixedDataTableRowBuffer is a helper class that executes row buffering
// logic for FixedDataTable. It figures out which rows should be rendered
// and in which positions.

var FixedDataTableRowBuffer = (function () {
  function FixedDataTableRowBuffer(
  /*number*/rowsCount,
  /*number*/defaultRowHeight,
  /*number*/viewportHeight,
  /*?function*/rowHeightGetter) {
    _classCallCheck(this, FixedDataTableRowBuffer);

    invariant(defaultRowHeight !== 0, "defaultRowHeight musn't be equal 0 in FixedDataTableRowBuffer");

    this._bufferSet = new IntegerBufferSet();
    this._defaultRowHeight = defaultRowHeight;
    this._viewportRowsBegin = 0;
    this._viewportRowsEnd = 0;
    this._maxVisibleRowCount = Math.ceil(viewportHeight / defaultRowHeight) + 1;
    this._bufferRowsCount = clamp(Math.floor(this._maxVisibleRowCount / 2), MIN_BUFFER_ROWS, MAX_BUFFER_ROWS);
    this._rowsCount = rowsCount;
    this._rowHeightGetter = rowHeightGetter;
    this._rows = [];
    this._viewportHeight = viewportHeight;

    this.getRows = this.getRows.bind(this);
    this.getRowsWithUpdatedBuffer = this.getRowsWithUpdatedBuffer.bind(this);
  }

  _createClass(FixedDataTableRowBuffer, [{
    key: 'getRowsWithUpdatedBuffer',
    value: function getRowsWithUpdatedBuffer() /*array*/{
      var remainingBufferRows = 2 * this._bufferRowsCount;
      var bufferRowIndex = Math.max(this._viewportRowsBegin - this._bufferRowsCount, 0);
      while (bufferRowIndex < this._viewportRowsBegin) {
        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);
        bufferRowIndex++;
        remainingBufferRows--;
      }
      bufferRowIndex = this._viewportRowsEnd;
      while (bufferRowIndex < this._rowsCount && remainingBufferRows > 0) {
        this._addRowToBuffer(bufferRowIndex, this._viewportRowsBegin, this._viewportRowsEnd - 1);
        bufferRowIndex++;
        remainingBufferRows--;
      }
      return this._rows;
    }
  }, {
    key: 'getRows',
    value: function getRows(
    /*number*/firstRowIndex,
    /*number*/firstRowOffset) /*array*/{
      var top = firstRowOffset;
      var totalHeight = top;
      var rowIndex = firstRowIndex;
      var endIndex = Math.min(firstRowIndex + this._maxVisibleRowCount, this._rowsCount);

      this._viewportRowsBegin = firstRowIndex;
      while (rowIndex < endIndex || totalHeight < this._viewportHeight && rowIndex < this._rowsCount) {
        this._addRowToBuffer(rowIndex, firstRowIndex, endIndex - 1);
        totalHeight += this._rowHeightGetter(rowIndex);
        ++rowIndex;
        // Store index after the last viewport row as end, to be able to
        // distinguish when there are no rows rendered in viewport
        this._viewportRowsEnd = rowIndex;
      }

      return this._rows;
    }
  }, {
    key: '_addRowToBuffer',
    value: function _addRowToBuffer(
    /*number*/rowIndex,
    /*number*/firstViewportRowIndex,
    /*number*/lastViewportRowIndex) {
      var rowPosition = this._bufferSet.getValuePosition(rowIndex);
      var viewportRowsCount = lastViewportRowIndex - firstViewportRowIndex + 1;
      var allowedRowsCount = viewportRowsCount + this._bufferRowsCount * 2;
      if (rowPosition === null && this._bufferSet.getSize() >= allowedRowsCount) {
        rowPosition = this._bufferSet.replaceFurthestValuePosition(firstViewportRowIndex, lastViewportRowIndex, rowIndex);
      }
      if (rowPosition === null) {
        // We can't reuse any of existing positions for this row. We have to
        // create new position
        rowPosition = this._bufferSet.getNewPositionForValue(rowIndex);
        this._rows[rowPosition] = rowIndex;
      } else {
        // This row already is in the table with rowPosition position or it
        // can replace row that is in that position
        this._rows[rowPosition] = rowIndex;
      }
    }
  }]);

  return FixedDataTableRowBuffer;
})();

module.exports = FixedDataTableRowBuffer;
},{"./IntegerBufferSet":299,"./clamp":311,"./invariant":317}],296:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableScrollHelper
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var PrefixIntervalTree = require('./PrefixIntervalTree');
var clamp = require('./clamp');

var BUFFER_ROWS = 5;
var NO_ROWS_SCROLL_RESULT = {
  index: 0,
  offset: 0,
  position: 0,
  contentHeight: 0
};

var FixedDataTableScrollHelper = (function () {
  function FixedDataTableScrollHelper(
  /*number*/rowCount,
  /*number*/defaultRowHeight,
  /*number*/viewportHeight,
  /*?function*/rowHeightGetter) {
    _classCallCheck(this, FixedDataTableScrollHelper);

    this._rowOffsets = PrefixIntervalTree.uniform(rowCount, defaultRowHeight);
    this._storedHeights = new Array(rowCount);
    for (var i = 0; i < rowCount; ++i) {
      this._storedHeights[i] = defaultRowHeight;
    }
    this._rowCount = rowCount;
    this._position = 0;
    this._contentHeight = rowCount * defaultRowHeight;
    this._defaultRowHeight = defaultRowHeight;
    this._rowHeightGetter = rowHeightGetter ? rowHeightGetter : function () {
      return defaultRowHeight;
    };
    this._viewportHeight = viewportHeight;
    this.scrollRowIntoView = this.scrollRowIntoView.bind(this);
    this.setViewportHeight = this.setViewportHeight.bind(this);
    this.scrollBy = this.scrollBy.bind(this);
    this.scrollTo = this.scrollTo.bind(this);
    this.scrollToRow = this.scrollToRow.bind(this);
    this.setRowHeightGetter = this.setRowHeightGetter.bind(this);
    this.getContentHeight = this.getContentHeight.bind(this);
    this.getRowPosition = this.getRowPosition.bind(this);

    this._updateHeightsInViewport(0, 0);
  }

  _createClass(FixedDataTableScrollHelper, [{
    key: 'setRowHeightGetter',
    value: function setRowHeightGetter( /*function*/rowHeightGetter) {
      this._rowHeightGetter = rowHeightGetter;
    }
  }, {
    key: 'setViewportHeight',
    value: function setViewportHeight( /*number*/viewportHeight) {
      this._viewportHeight = viewportHeight;
    }
  }, {
    key: 'getContentHeight',
    value: function getContentHeight() /*number*/{
      return this._contentHeight;
    }
  }, {
    key: '_updateHeightsInViewport',
    value: function _updateHeightsInViewport(
    /*number*/firstRowIndex,
    /*number*/firstRowOffset) {
      var top = firstRowOffset;
      var index = firstRowIndex;
      while (top <= this._viewportHeight && index < this._rowCount) {
        this._updateRowHeight(index);
        top += this._storedHeights[index];
        index++;
      }
    }
  }, {
    key: '_updateHeightsAboveViewport',
    value: function _updateHeightsAboveViewport( /*number*/firstRowIndex) {
      var index = firstRowIndex - 1;
      while (index >= 0 && index >= firstRowIndex - BUFFER_ROWS) {
        var delta = this._updateRowHeight(index);
        this._position += delta;
        index--;
      }
    }
  }, {
    key: '_updateRowHeight',
    value: function _updateRowHeight( /*number*/rowIndex) /*number*/{
      if (rowIndex < 0 || rowIndex >= this._rowCount) {
        return 0;
      }
      var newHeight = this._rowHeightGetter(rowIndex);
      if (newHeight !== this._storedHeights[rowIndex]) {
        var change = newHeight - this._storedHeights[rowIndex];
        this._rowOffsets.set(rowIndex, newHeight);
        this._storedHeights[rowIndex] = newHeight;
        this._contentHeight += change;
        return change;
      }
      return 0;
    }
  }, {
    key: 'getRowPosition',
    value: function getRowPosition( /*number*/rowIndex) /*number*/{
      this._updateRowHeight(rowIndex);
      return this._rowOffsets.sumUntil(rowIndex);
    }
  }, {
    key: 'scrollBy',
    value: function scrollBy( /*number*/delta) /*object*/{
      if (this._rowCount === 0) {
        return NO_ROWS_SCROLL_RESULT;
      }
      var firstRow = this._rowOffsets.greatestLowerBound(this._position);
      firstRow = clamp(firstRow, 0, Math.max(this._rowCount - 1, 0));
      var firstRowPosition = this._rowOffsets.sumUntil(firstRow);
      var rowIndex = firstRow;
      var position = this._position;

      var rowHeightChange = this._updateRowHeight(rowIndex);
      if (firstRowPosition !== 0) {
        position += rowHeightChange;
      }
      var visibleRowHeight = this._storedHeights[rowIndex] - (position - firstRowPosition);

      if (delta >= 0) {

        while (delta > 0 && rowIndex < this._rowCount) {
          if (delta < visibleRowHeight) {
            position += delta;
            delta = 0;
          } else {
            delta -= visibleRowHeight;
            position += visibleRowHeight;
            rowIndex++;
          }
          if (rowIndex < this._rowCount) {
            this._updateRowHeight(rowIndex);
            visibleRowHeight = this._storedHeights[rowIndex];
          }
        }
      } else if (delta < 0) {
        delta = -delta;
        var invisibleRowHeight = this._storedHeights[rowIndex] - visibleRowHeight;

        while (delta > 0 && rowIndex >= 0) {
          if (delta < invisibleRowHeight) {
            position -= delta;
            delta = 0;
          } else {
            position -= invisibleRowHeight;
            delta -= invisibleRowHeight;
            rowIndex--;
          }
          if (rowIndex >= 0) {
            var change = this._updateRowHeight(rowIndex);
            invisibleRowHeight = this._storedHeights[rowIndex];
            position += change;
          }
        }
      }

      var maxPosition = this._contentHeight - this._viewportHeight;
      position = clamp(position, 0, maxPosition);
      this._position = position;
      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);
      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));
      firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);
      var firstRowOffset = firstRowPosition - position;

      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);
      this._updateHeightsAboveViewport(firstRowIndex);

      return {
        index: firstRowIndex,
        offset: firstRowOffset,
        position: this._position,
        contentHeight: this._contentHeight
      };
    }
  }, {
    key: '_getRowAtEndPosition',
    value: function _getRowAtEndPosition( /*number*/rowIndex) /*number*/{
      // We need to update enough rows above the selected one to be sure that when
      // we scroll to selected position all rows between first shown and selected
      // one have most recent heights computed and will not resize
      this._updateRowHeight(rowIndex);
      var currentRowIndex = rowIndex;
      var top = this._storedHeights[currentRowIndex];
      while (top < this._viewportHeight && currentRowIndex >= 0) {
        currentRowIndex--;
        if (currentRowIndex >= 0) {
          this._updateRowHeight(currentRowIndex);
          top += this._storedHeights[currentRowIndex];
        }
      }
      var position = this._rowOffsets.sumTo(rowIndex) - this._viewportHeight;
      if (position < 0) {
        position = 0;
      }
      return position;
    }
  }, {
    key: 'scrollTo',
    value: function scrollTo( /*number*/position) /*object*/{
      if (this._rowCount === 0) {
        return NO_ROWS_SCROLL_RESULT;
      }
      if (position <= 0) {
        // If position less than or equal to 0 first row should be fully visible
        // on top
        this._position = 0;
        this._updateHeightsInViewport(0, 0);

        return {
          index: 0,
          offset: 0,
          position: this._position,
          contentHeight: this._contentHeight
        };
      } else if (position >= this._contentHeight - this._viewportHeight) {
        // If position is equal to or greater than max scroll value, we need
        // to make sure to have bottom border of last row visible.
        var rowIndex = this._rowCount - 1;
        position = this._getRowAtEndPosition(rowIndex);
      }
      this._position = position;

      var firstRowIndex = this._rowOffsets.greatestLowerBound(position);
      firstRowIndex = clamp(firstRowIndex, 0, Math.max(this._rowCount - 1, 0));
      var firstRowPosition = this._rowOffsets.sumUntil(firstRowIndex);
      var firstRowOffset = firstRowPosition - position;

      this._updateHeightsInViewport(firstRowIndex, firstRowOffset);
      this._updateHeightsAboveViewport(firstRowIndex);

      return {
        index: firstRowIndex,
        offset: firstRowOffset,
        position: this._position,
        contentHeight: this._contentHeight
      };
    }

    /**
     * Allows to scroll to selected row with specified offset. It always
     * brings that row to top of viewport with that offset
     */
  }, {
    key: 'scrollToRow',
    value: function scrollToRow( /*number*/rowIndex, /*number*/offset) /*object*/{
      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));
      offset = clamp(offset, -this._storedHeights[rowIndex], 0);
      var firstRow = this._rowOffsets.sumUntil(rowIndex);
      return this.scrollTo(firstRow - offset);
    }

    /**
     * Allows to scroll to selected row by bringing it to viewport with minimal
     * scrolling. This that if row is fully visible, scroll will not be changed.
     * If top border of row is above top of viewport it will be scrolled to be
     * fully visible on the top of viewport. If the bottom border of row is
     * below end of viewport, it will be scrolled up to be fully visible on the
     * bottom of viewport.
     */
  }, {
    key: 'scrollRowIntoView',
    value: function scrollRowIntoView( /*number*/rowIndex) /*object*/{
      rowIndex = clamp(rowIndex, 0, Math.max(this._rowCount - 1, 0));
      var rowBegin = this._rowOffsets.sumUntil(rowIndex);
      var rowEnd = rowBegin + this._storedHeights[rowIndex];
      if (rowBegin < this._position) {
        return this.scrollTo(rowBegin);
      } else if (this._position + this._viewportHeight < rowEnd) {
        var position = this._getRowAtEndPosition(rowIndex);
        return this.scrollTo(position);
      }
      return this.scrollTo(this._position);
    }
  }]);

  return FixedDataTableScrollHelper;
})();

module.exports = FixedDataTableScrollHelper;
},{"./PrefixIntervalTree":302,"./clamp":311}],297:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule FixedDataTableWidthHelper
 * @typechecks
 */

'use strict';

var React = require('./React');

function getTotalWidth( /*array*/columns) /*number*/{
  var totalWidth = 0;
  for (var i = 0; i < columns.length; ++i) {
    totalWidth += columns[i].props.width;
  }
  return totalWidth;
}

function getTotalFlexGrow( /*array*/columns) /*number*/{
  var totalFlexGrow = 0;
  for (var i = 0; i < columns.length; ++i) {
    totalFlexGrow += columns[i].props.flexGrow || 0;
  }
  return totalFlexGrow;
}

function distributeFlexWidth(
/*array*/columns,
/*number*/flexWidth) /*object*/{
  if (flexWidth <= 0) {
    return {
      columns: columns,
      width: getTotalWidth(columns)
    };
  }
  var remainingFlexGrow = getTotalFlexGrow(columns);
  var remainingFlexWidth = flexWidth;
  var newColumns = [];
  var totalWidth = 0;
  for (var i = 0; i < columns.length; ++i) {
    var column = columns[i];
    if (!column.props.flexGrow) {
      totalWidth += column.props.width;
      newColumns.push(column);
      continue;
    }
    var columnFlexWidth = Math.floor(column.props.flexGrow / remainingFlexGrow * remainingFlexWidth);
    var newColumnWidth = Math.floor(column.props.width + columnFlexWidth);
    totalWidth += newColumnWidth;

    remainingFlexGrow -= column.props.flexGrow;
    remainingFlexWidth -= columnFlexWidth;

    newColumns.push(React.cloneElement(column, { width: newColumnWidth }));
  }

  return {
    columns: newColumns,
    width: totalWidth
  };
}

function adjustColumnGroupWidths(
/*array*/columnGroups,
/*number*/expectedWidth) /*object*/{
  var allColumns = [];
  var i;
  for (i = 0; i < columnGroups.length; ++i) {
    React.Children.forEach(columnGroups[i].props.children, function (column) {
      allColumns.push(column);
    });
  }
  var columnsWidth = getTotalWidth(allColumns);
  var remainingFlexGrow = getTotalFlexGrow(allColumns);
  var remainingFlexWidth = Math.max(expectedWidth - columnsWidth, 0);

  var newAllColumns = [];
  var newColumnGroups = [];

  for (i = 0; i < columnGroups.length; ++i) {
    var columnGroup = columnGroups[i];
    var currentColumns = [];

    React.Children.forEach(columnGroup.props.children, function (column) {
      currentColumns.push(column);
    });

    var columnGroupFlexGrow = getTotalFlexGrow(currentColumns);
    var columnGroupFlexWidth = Math.floor(columnGroupFlexGrow / remainingFlexGrow * remainingFlexWidth);

    var newColumnSettings = distributeFlexWidth(currentColumns, columnGroupFlexWidth);

    remainingFlexGrow -= columnGroupFlexGrow;
    remainingFlexWidth -= columnGroupFlexWidth;

    for (var j = 0; j < newColumnSettings.columns.length; ++j) {
      newAllColumns.push(newColumnSettings.columns[j]);
    }

    newColumnGroups.push(React.cloneElement(columnGroup, { width: newColumnSettings.width }));
  }

  return {
    columns: newAllColumns,
    columnGroups: newColumnGroups
  };
}

function adjustColumnWidths(
/*array*/columns,
/*number*/expectedWidth) /*array*/{
  var columnsWidth = getTotalWidth(columns);
  if (columnsWidth < expectedWidth) {
    return distributeFlexWidth(columns, expectedWidth - columnsWidth).columns;
  }
  return columns;
}

var FixedDataTableWidthHelper = {
  getTotalWidth: getTotalWidth,
  getTotalFlexGrow: getTotalFlexGrow,
  distributeFlexWidth: distributeFlexWidth,
  adjustColumnWidths: adjustColumnWidths,
  adjustColumnGroupWidths: adjustColumnGroupWidths
};

module.exports = FixedDataTableWidthHelper;
},{"./React":303}],298:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Heap
 * @typechecks
 * @preventMunge
 */

'use strict';

/*
 * @param {*} a
 * @param {*} b
 * @return {boolean}
 */

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function defaultComparator(a, b) {
  return a < b;
}

var Heap = (function () {
  function Heap(items, comparator) {
    _classCallCheck(this, Heap);

    this._items = items || [];
    this._size = this._items.length;
    this._comparator = comparator || defaultComparator;
    this._heapify();
  }

  /*
   * @return {boolean}
   */

  _createClass(Heap, [{
    key: 'empty',
    value: function empty() {
      return this._size === 0;
    }

    /*
     * @return {*}
     */
  }, {
    key: 'pop',
    value: function pop() {
      if (this._size === 0) {
        return;
      }

      var elt = this._items[0];

      var lastElt = this._items.pop();
      this._size--;

      if (this._size > 0) {
        this._items[0] = lastElt;
        this._sinkDown(0);
      }

      return elt;
    }

    /*
     * @param {*} item
     */
  }, {
    key: 'push',
    value: function push(item) {
      this._items[this._size++] = item;
      this._bubbleUp(this._size - 1);
    }

    /*
     * @return {number}
     */
  }, {
    key: 'size',
    value: function size() {
      return this._size;
    }

    /*
     * @return {*}
     */
  }, {
    key: 'peek',
    value: function peek() {
      if (this._size === 0) {
        return;
      }

      return this._items[0];
    }
  }, {
    key: '_heapify',
    value: function _heapify() {
      for (var index = Math.floor((this._size + 1) / 2); index >= 0; index--) {
        this._sinkDown(index);
      }
    }

    /*
     * @parent {number} index
     */
  }, {
    key: '_bubbleUp',
    value: function _bubbleUp(index) {
      var elt = this._items[index];
      while (index > 0) {
        var parentIndex = Math.floor((index + 1) / 2) - 1;
        var parentElt = this._items[parentIndex];

        // if parentElt < elt, stop
        if (this._comparator(parentElt, elt)) {
          return;
        }

        // swap
        this._items[parentIndex] = elt;
        this._items[index] = parentElt;
        index = parentIndex;
      }
    }

    /*
     * @parent {number} index
     */
  }, {
    key: '_sinkDown',
    value: function _sinkDown(index) {
      var elt = this._items[index];

      while (true) {
        var leftChildIndex = 2 * (index + 1) - 1;
        var rightChildIndex = 2 * (index + 1);
        var swapIndex = -1;

        if (leftChildIndex < this._size) {
          var leftChild = this._items[leftChildIndex];
          if (this._comparator(leftChild, elt)) {
            swapIndex = leftChildIndex;
          }
        }

        if (rightChildIndex < this._size) {
          var rightChild = this._items[rightChildIndex];
          if (this._comparator(rightChild, elt)) {
            if (swapIndex === -1 || this._comparator(rightChild, this._items[swapIndex])) {
              swapIndex = rightChildIndex;
            }
          }
        }

        // if we don't have a swap, stop
        if (swapIndex === -1) {
          return;
        }

        this._items[index] = this._items[swapIndex];
        this._items[swapIndex] = elt;
        index = swapIndex;
      }
    }
  }]);

  return Heap;
})();

module.exports = Heap;
},{}],299:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule IntegerBufferSet
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var Heap = require('./Heap');

var invariant = require('./invariant');

// Data structure that allows to store values and assign positions to them
// in a way to minimize changing positions of stored values when new ones are
// added or when some values are replaced. Stored elements are alwasy assigned
// a consecutive set of positoins startin from 0 up to count of elements less 1
// Following actions can be executed
// * get position assigned to given value (null if value is not stored)
// * create new entry for new value and get assigned position back
// * replace value that is furthest from specified value range with new value
//   and get it's position back
// All operations take amortized log(n) time where n is number of elements in
// the set.

var IntegerBufferSet = (function () {
  function IntegerBufferSet() {
    _classCallCheck(this, IntegerBufferSet);

    this._valueToPositionMap = {};
    this._size = 0;
    this._smallValues = new Heap([], // Initial data in the heap
    this._smallerComparator);
    this._largeValues = new Heap([], // Initial data in the heap
    this._greaterComparator);

    this.getNewPositionForValue = this.getNewPositionForValue.bind(this);
    this.getValuePosition = this.getValuePosition.bind(this);
    this.getSize = this.getSize.bind(this);
    this.replaceFurthestValuePosition = this.replaceFurthestValuePosition.bind(this);
  }

  _createClass(IntegerBufferSet, [{
    key: 'getSize',
    value: function getSize() /*number*/{
      return this._size;
    }
  }, {
    key: 'getValuePosition',
    value: function getValuePosition( /*number*/value) /*?number*/{
      if (this._valueToPositionMap[value] === undefined) {
        return null;
      }
      return this._valueToPositionMap[value];
    }
  }, {
    key: 'getNewPositionForValue',
    value: function getNewPositionForValue( /*number*/value) /*number*/{
      invariant(this._valueToPositionMap[value] === undefined, "Shouldn't try to find new position for value already stored in BufferSet");
      var newPosition = this._size;
      this._size++;
      this._pushToHeaps(newPosition, value);
      this._valueToPositionMap[value] = newPosition;
      return newPosition;
    }
  }, {
    key: 'replaceFurthestValuePosition',
    value: function replaceFurthestValuePosition(
    /*number*/lowValue,
    /*number*/highValue,
    /*number*/newValue) /*?number*/{
      invariant(this._valueToPositionMap[newValue] === undefined, "Shouldn't try to replace values with value already stored value in " + "BufferSet");

      this._cleanHeaps();
      if (this._smallValues.empty() || this._largeValues.empty()) {
        // Threre are currently no values stored. We will have to create new
        // position for this value.
        return null;
      }

      var minValue = this._smallValues.peek().value;
      var maxValue = this._largeValues.peek().value;
      if (minValue >= lowValue && maxValue <= highValue) {
        // All values currently stored are necessary, we can't reuse any of them.
        return null;
      }

      var valueToReplace;
      if (lowValue - minValue > maxValue - highValue) {
        // minValue is further from provided range. We will reuse it's position.
        valueToReplace = minValue;
        this._smallValues.pop();
      } else {
        valueToReplace = maxValue;
        this._largeValues.pop();
      }
      var position = this._valueToPositionMap[valueToReplace];
      delete this._valueToPositionMap[valueToReplace];
      this._valueToPositionMap[newValue] = position;
      this._pushToHeaps(position, newValue);

      return position;
    }
  }, {
    key: '_pushToHeaps',
    value: function _pushToHeaps( /*number*/position, /*number*/value) {
      var element = {
        position: position,
        value: value
      };
      // We can reuse the same object in both heaps, because we don't mutate them
      this._smallValues.push(element);
      this._largeValues.push(element);
    }
  }, {
    key: '_cleanHeaps',
    value: function _cleanHeaps() {
      // We not usually only remove object from one heap while moving value.
      // Here we make sure that there is no stale data on top of heaps.
      this._cleanHeap(this._smallValues);
      this._cleanHeap(this._largeValues);
      var minHeapSize = Math.min(this._smallValues.size(), this._largeValues.size());
      var maxHeapSize = Math.max(this._smallValues.size(), this._largeValues.size());
      if (maxHeapSize > 10 * minHeapSize) {
        // There are many old values in one of heaps. We nned to get rid of them
        // to not use too avoid memory leaks
        this._recreateHeaps();
      }
    }
  }, {
    key: '_recreateHeaps',
    value: function _recreateHeaps() {
      var sourceHeap = this._smallValues.size() < this._largeValues.size() ? this._smallValues : this._largeValues;
      var newSmallValues = new Heap([], // Initial data in the heap
      this._smallerComparator);
      var newLargeValues = new Heap([], // Initial datat in the heap
      this._greaterComparator);
      while (!sourceHeap.empty()) {
        var element = sourceHeap.pop();
        // Push all stil valid elements to new heaps
        if (this._valueToPositionMap[element.value] !== undefined) {
          newSmallValues.push(element);
          newLargeValues.push(element);
        }
      }
      this._smallValues = newSmallValues;
      this._largeValues = newLargeValues;
    }
  }, {
    key: '_cleanHeap',
    value: function _cleanHeap( /*object*/heap) {
      while (!heap.empty() && this._valueToPositionMap[heap.peek().value] === undefined) {
        heap.pop();
      }
    }
  }, {
    key: '_smallerComparator',
    value: function _smallerComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{
      return lhs.value < rhs.value;
    }
  }, {
    key: '_greaterComparator',
    value: function _greaterComparator( /*object*/lhs, /*object*/rhs) /*boolean*/{
      return lhs.value > rhs.value;
    }
  }]);

  return IntegerBufferSet;
})();

module.exports = IntegerBufferSet;
},{"./Heap":298,"./invariant":317}],300:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Keys
 */

"use strict";

module.exports = {
  BACKSPACE: 8,
  TAB: 9,
  RETURN: 13,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  PAGE_UP: 33,
  PAGE_DOWN: 34,
  END: 35,
  HOME: 36,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  DELETE: 46,
  COMMA: 188,
  PERIOD: 190,
  A: 65,
  Z: 90,
  ZERO: 48,
  NUMPAD_0: 96,
  NUMPAD_9: 105
};
},{}],301:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Locale
 */

"use strict";

// Hard code this for now.
var Locale = {
  isRTL: function isRTL() {
    return false;
  },
  getDirection: function getDirection() {
    return 'LTR';
  }
};

module.exports = Locale;
},{}],302:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule PrefixIntervalTree
 * 
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('./invariant');

var parent = function parent(node) {
  return Math.floor(node / 2);
};

var Int32Array = global.Int32Array || function (size) {
  var xs = [];
  for (var i = size - 1; i >= 0; --i) {
    xs[i] = 0;
  }
  return xs;
};

/**
 * Computes the next power of 2 after or equal to x.
 */
function ceilLog2(x) {
  var y = 1;
  while (y < x) {
    y *= 2;
  }
  return y;
}

/**
 * A prefix interval tree stores an numeric array and the partial sums of that
 * array. It is optimized for updating the values of the array without
 * recomputing all of the partial sums.
 *
 *   - O(ln n) update
 *   - O(1) lookup
 *   - O(ln n) compute a partial sum
 *   - O(n) space
 *
 * Note that the sequence of partial sums is one longer than the array, so that
 * the first partial sum is always 0, and the last partial sum is the sum of the
 * entire array.
 */

var PrefixIntervalTree = (function () {
  function PrefixIntervalTree(xs) {
    _classCallCheck(this, PrefixIntervalTree);

    this._size = xs.length;
    this._half = ceilLog2(this._size);
    this._heap = new Int32Array(2 * this._half);

    var i;
    for (i = 0; i < this._size; ++i) {
      this._heap[this._half + i] = xs[i];
    }

    for (i = this._half - 1; i > 0; --i) {
      this._heap[i] = this._heap[2 * i] + this._heap[2 * i + 1];
    }
  }

  _createClass(PrefixIntervalTree, [{
    key: 'set',
    value: function set(index, value) {
      invariant(0 <= index && index < this._size, 'Index out of range %s', index);

      var node = this._half + index;
      this._heap[node] = value;

      node = parent(node);
      for (; node !== 0; node = parent(node)) {
        this._heap[node] = this._heap[2 * node] + this._heap[2 * node + 1];
      }
    }
  }, {
    key: 'get',
    value: function get(index) {
      invariant(0 <= index && index < this._size, 'Index out of range %s', index);

      var node = this._half + index;
      return this._heap[node];
    }
  }, {
    key: 'getSize',
    value: function getSize() {
      return this._size;
    }

    /**
     * Returns the sum get(0) + get(1) + ... + get(end - 1).
     */
  }, {
    key: 'sumUntil',
    value: function sumUntil(end) {
      invariant(0 <= end && end < this._size + 1, 'Index out of range %s', end);

      if (end === 0) {
        return 0;
      }

      var node = this._half + end - 1;
      var sum = this._heap[node];
      for (; node !== 1; node = parent(node)) {
        if (node % 2 === 1) {
          sum += this._heap[node - 1];
        }
      }

      return sum;
    }

    /**
     * Returns the sum get(0) + get(1) + ... + get(inclusiveEnd).
     */
  }, {
    key: 'sumTo',
    value: function sumTo(inclusiveEnd) {
      invariant(0 <= inclusiveEnd && inclusiveEnd < this._size, 'Index out of range %s', inclusiveEnd);
      return this.sumUntil(inclusiveEnd + 1);
    }

    /**
     * Returns the sum get(begin) + get(begin + 1) + ... + get(end - 1).
     */
  }, {
    key: 'sum',
    value: function sum(begin, end) {
      invariant(begin <= end, 'Begin must precede end');
      return this.sumUntil(end) - this.sumUntil(begin);
    }

    /**
     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) <= t, or
     * -1 if no such i exists.
     */
  }, {
    key: 'greatestLowerBound',
    value: function greatestLowerBound(t) {
      if (t < 0) {
        return -1;
      }

      var node = 1;
      if (this._heap[node] <= t) {
        return this._size;
      }

      while (node < this._half) {
        var leftSum = this._heap[2 * node];
        if (t < leftSum) {
          node = 2 * node;
        } else {
          node = 2 * node + 1;
          t -= leftSum;
        }
      }

      return node - this._half;
    }

    /**
     * Returns the smallest i such that 0 <= i <= size and sumUntil(i) < t, or
     * -1 if no such i exists.
     */
  }, {
    key: 'greatestStrictLowerBound',
    value: function greatestStrictLowerBound(t) {
      if (t <= 0) {
        return -1;
      }

      var node = 1;
      if (this._heap[node] < t) {
        return this._size;
      }

      while (node < this._half) {
        var leftSum = this._heap[2 * node];
        if (t <= leftSum) {
          node = 2 * node;
        } else {
          node = 2 * node + 1;
          t -= leftSum;
        }
      }

      return node - this._half;
    }

    /**
     * Returns the smallest i such that 0 <= i <= size and t <= sumUntil(i), or
     * size + 1 if no such i exists.
     */
  }, {
    key: 'leastUpperBound',
    value: function leastUpperBound(t) {
      return this.greatestStrictLowerBound(t) + 1;
    }

    /**
     * Returns the smallest i such that 0 <= i <= size and t < sumUntil(i), or
     * size + 1 if no such i exists.
     */
  }, {
    key: 'leastStrictUpperBound',
    value: function leastStrictUpperBound(t) {
      return this.greatestLowerBound(t) + 1;
    }
  }], [{
    key: 'uniform',
    value: function uniform(size, initialValue) {
      var xs = [];
      for (var i = size - 1; i >= 0; --i) {
        xs[i] = initialValue;
      }

      return new PrefixIntervalTree(xs);
    }
  }, {
    key: 'empty',
    value: function empty(size) {
      return PrefixIntervalTree.uniform(size, 0);
    }
  }]);

  return PrefixIntervalTree;
})();

module.exports = PrefixIntervalTree;

/**
 * Number of elements in the array
 */

/**
 * Half the size of the heap. It is also the number of non-leaf nodes, and the
 * index of the first element in the heap. Always a power of 2.
 */

/**
 * Binary heap
 */
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./invariant":317}],303:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule React
 */

'use strict';

module.exports = require('react');
},{"react":"react"}],304:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactComponentWithPureRenderMixin
 */

'use strict';

/**
 * Performs equality by iterating through keys on an object and returning
 * false when any key has values which are not strictly equal between
 * objA and objB. Returns true when the values of all keys are strictly equal.
 *
 * @return {boolean}
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }
  var key;
  // Test for A's keys different from B.
  for (key in objA) {
    if (objA.hasOwnProperty(key) && (!objB.hasOwnProperty(key) || objA[key] !== objB[key])) {
      return false;
    }
  }
  // Test for B's keys missing from A.
  for (key in objB) {
    if (objB.hasOwnProperty(key) && !objA.hasOwnProperty(key)) {
      return false;
    }
  }
  return true;
}

/**
 * If your React component's render function is "pure", e.g. it will render the
 * same result given the same props and state, provide this Mixin for a
 * considerable performance boost.
 *
 * Most React components have pure render functions.
 *
 * Example:
 *
 *   var ReactComponentWithPureRenderMixin =
 *     require('ReactComponentWithPureRenderMixin');
 *   React.createClass({
 *     mixins: [ReactComponentWithPureRenderMixin],
 *
 *     render: function() {
 *       return <div className={this.props.className}>foo</div>;
 *     }
 *   });
 *
 * Note: This only checks shallow equality for props and state. If these contain
 * complex data structures this mixin may have false-negatives for deeper
 * differences. Only mixin to components which have simple props and state, or
 * use `forceUpdate()` when you know deep data structures have changed.
 */
var ReactComponentWithPureRenderMixin = {
  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
    return !shallowEqual(this.props, nextProps) || !shallowEqual(this.state, nextState);
  }
};

module.exports = ReactComponentWithPureRenderMixin;
},{}],305:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ReactDOM
 */

'use strict';

module.exports = require('react-dom');
},{"react-dom":"react-dom"}],306:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * This is utility that hanlds onWheel events and calls provided wheel
 * callback with correct frame rate.
 *
 * @providesModule ReactWheelHandler
 * @typechecks
 */

'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var emptyFunction = require('./emptyFunction');
var normalizeWheel = require('./normalizeWheel');
var requestAnimationFramePolyfill = require('./requestAnimationFramePolyfill');

var ReactWheelHandler = (function () {
  /**
   * onWheel is the callback that will be called with right frame rate if
   * any wheel events happened
   * onWheel should is to be called with two arguments: deltaX and deltaY in
   * this order
   */

  function ReactWheelHandler(
  /*function*/onWheel,
  /*boolean|function*/handleScrollX,
  /*boolean|function*/handleScrollY,
  /*?boolean|?function*/stopPropagation) {
    _classCallCheck(this, ReactWheelHandler);

    this._animationFrameID = null;
    this._deltaX = 0;
    this._deltaY = 0;
    this._didWheel = this._didWheel.bind(this);
    if (typeof handleScrollX !== 'function') {
      handleScrollX = handleScrollX ? emptyFunction.thatReturnsTrue : emptyFunction.thatReturnsFalse;
    }

    if (typeof handleScrollY !== 'function') {
      handleScrollY = handleScrollY ? emptyFunction.thatReturnsTrue : emptyFunction.thatReturnsFalse;
    }

    if (typeof stopPropagation !== 'function') {
      stopPropagation = stopPropagation ? emptyFunction.thatReturnsTrue : emptyFunction.thatReturnsFalse;
    }

    this._handleScrollX = handleScrollX;
    this._handleScrollY = handleScrollY;
    this._stopPropagation = stopPropagation;
    this._onWheelCallback = onWheel;
    this.onWheel = this.onWheel.bind(this);
  }

  _createClass(ReactWheelHandler, [{
    key: 'onWheel',
    value: function onWheel( /*object*/event) {
      var normalizedEvent = normalizeWheel(event);
      var deltaX = this._deltaX + normalizedEvent.pixelX;
      var deltaY = this._deltaY + normalizedEvent.pixelY;
      var handleScrollX = this._handleScrollX(deltaX, deltaY);
      var handleScrollY = this._handleScrollY(deltaY, deltaX);
      if (!handleScrollX && !handleScrollY) {
        return;
      }

      this._deltaX += handleScrollX ? normalizedEvent.pixelX : 0;
      this._deltaY += handleScrollY ? normalizedEvent.pixelY : 0;
      event.preventDefault();

      var changed;
      if (this._deltaX !== 0 || this._deltaY !== 0) {
        if (this._stopPropagation()) {
          event.stopPropagation();
        }
        changed = true;
      }

      if (changed === true && this._animationFrameID === null) {
        this._animationFrameID = requestAnimationFramePolyfill(this._didWheel);
      }
    }
  }, {
    key: '_didWheel',
    value: function _didWheel() {
      this._animationFrameID = null;
      this._onWheelCallback(this._deltaX, this._deltaY);
      this._deltaX = 0;
      this._deltaY = 0;
    }
  }]);

  return ReactWheelHandler;
})();

module.exports = ReactWheelHandler;
},{"./emptyFunction":315,"./normalizeWheel":321,"./requestAnimationFramePolyfill":322}],307:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Scrollbar.react
 * @typechecks
 */

'use strict';

var DOMMouseMoveTracker = require('./DOMMouseMoveTracker');
var Keys = require('./Keys');
var React = require('./React');
var ReactDOM = require('./ReactDOM');
var ReactComponentWithPureRenderMixin = require('./ReactComponentWithPureRenderMixin');
var ReactWheelHandler = require('./ReactWheelHandler');

var cssVar = require('./cssVar');
var cx = require('./cx');
var emptyFunction = require('./emptyFunction');
var translateDOMPositionXY = require('./translateDOMPositionXY');

var PropTypes = React.PropTypes;

var UNSCROLLABLE_STATE = {
  position: 0,
  scrollable: false
};

var FACE_MARGIN = parseInt(cssVar('scrollbar-face-margin'), 10);
var FACE_MARGIN_2 = FACE_MARGIN * 2;
var FACE_SIZE_MIN = 30;
var KEYBOARD_SCROLL_AMOUNT = 40;

var _lastScrolledScrollbar = null;

var Scrollbar = React.createClass({
  displayName: 'Scrollbar',

  mixins: [ReactComponentWithPureRenderMixin],

  propTypes: {
    contentSize: PropTypes.number.isRequired,
    defaultPosition: PropTypes.number,
    isOpaque: PropTypes.bool,
    orientation: PropTypes.oneOf(['vertical', 'horizontal']),
    onScroll: PropTypes.func,
    position: PropTypes.number,
    size: PropTypes.number.isRequired,
    trackColor: PropTypes.oneOf(['gray']),
    zIndex: PropTypes.number,
    verticalTop: PropTypes.number
  },

  getInitialState: function getInitialState() /*object*/{
    var props = this.props;
    return this._calculateState(props.position || props.defaultPosition || 0, props.size, props.contentSize, props.orientation);
  },

  componentWillReceiveProps: function componentWillReceiveProps( /*object*/nextProps) {
    var controlledPosition = nextProps.position;
    if (controlledPosition === undefined) {
      this._setNextState(this._calculateState(this.state.position, nextProps.size, nextProps.contentSize, nextProps.orientation));
    } else {
      this._setNextState(this._calculateState(controlledPosition, nextProps.size, nextProps.contentSize, nextProps.orientation), nextProps);
    }
  },

  getDefaultProps: function getDefaultProps() /*object*/{
    return {
      defaultPosition: 0,
      isOpaque: false,
      onScroll: emptyFunction,
      orientation: 'vertical',
      zIndex: 99
    };
  },

  render: function render() /*?object*/{
    if (!this.state.scrollable) {
      return null;
    }

    var size = this.props.size;
    var mainStyle;
    var faceStyle;
    var isHorizontal = this.state.isHorizontal;
    var isVertical = !isHorizontal;
    var isActive = this.state.focused || this.state.isDragging;
    var faceSize = this.state.faceSize;
    var isOpaque = this.props.isOpaque;
    var verticalTop = this.props.verticalTop || 0;

    var mainClassName = cx({
      'ScrollbarLayout/main': true,
      'ScrollbarLayout/mainVertical': isVertical,
      'ScrollbarLayout/mainHorizontal': isHorizontal,
      'public/Scrollbar/main': true,
      'public/Scrollbar/mainOpaque': isOpaque,
      'public/Scrollbar/mainActive': isActive
    });

    var faceClassName = cx({
      'ScrollbarLayout/face': true,
      'ScrollbarLayout/faceHorizontal': isHorizontal,
      'ScrollbarLayout/faceVertical': isVertical,
      'public/Scrollbar/faceActive': isActive,
      'public/Scrollbar/face': true
    });

    var position = this.state.position * this.state.scale + FACE_MARGIN;

    if (isHorizontal) {
      mainStyle = {
        width: size
      };
      faceStyle = {
        width: faceSize - FACE_MARGIN_2
      };
      translateDOMPositionXY(faceStyle, position, 0);
    } else {
      mainStyle = {
        top: verticalTop,
        height: size
      };
      faceStyle = {
        height: faceSize - FACE_MARGIN_2
      };
      translateDOMPositionXY(faceStyle, 0, position);
    }

    mainStyle.zIndex = this.props.zIndex;

    if (this.props.trackColor === 'gray') {
      mainStyle.backgroundColor = cssVar('fbui-desktop-background-light');
    }

    return React.createElement(
      'div',
      {
        onFocus: this._onFocus,
        onBlur: this._onBlur,
        onKeyDown: this._onKeyDown,
        onMouseDown: this._onMouseDown,
        onWheel: this._wheelHandler.onWheel,
        className: mainClassName,
        style: mainStyle,
        tabIndex: 0 },
      React.createElement('div', {
        ref: 'face',
        className: faceClassName,
        style: faceStyle
      })
    );
  },

  componentWillMount: function componentWillMount() {
    var isHorizontal = this.props.orientation === 'horizontal';
    var onWheel = isHorizontal ? this._onWheelX : this._onWheelY;

    this._wheelHandler = new ReactWheelHandler(onWheel, this._shouldHandleX, // Should hanlde horizontal scroll
    this._shouldHandleY // Should handle vertical scroll
    );
  },

  componentDidMount: function componentDidMount() {
    this._mouseMoveTracker = new DOMMouseMoveTracker(this._onMouseMove, this._onMouseMoveEnd, document.documentElement);

    if (this.props.position !== undefined && this.state.position !== this.props.position) {
      this._didScroll();
    }
  },

  componentWillUnmount: function componentWillUnmount() {
    this._nextState = null;
    this._mouseMoveTracker.releaseMouseMoves();
    if (_lastScrolledScrollbar === this) {
      _lastScrolledScrollbar = null;
    }
    delete this._mouseMoveTracker;
  },

  scrollBy: function scrollBy( /*number*/delta) {
    this._onWheel(delta);
  },

  _shouldHandleX: function _shouldHandleX( /*number*/delta) /*boolean*/{
    return this.props.orientation === 'horizontal' ? this._shouldHandleChange(delta) : false;
  },

  _shouldHandleY: function _shouldHandleY( /*number*/delta) /*boolean*/{
    return this.props.orientation !== 'horizontal' ? this._shouldHandleChange(delta) : false;
  },

  _shouldHandleChange: function _shouldHandleChange( /*number*/delta) /*boolean*/{
    var nextState = this._calculateState(this.state.position + delta, this.props.size, this.props.contentSize, this.props.orientation);
    return nextState.position !== this.state.position;
  },

  _calculateState: function _calculateState(
  /*number*/position,
  /*number*/size,
  /*number*/contentSize,
  /*string*/orientation) /*object*/{
    if (size < 1 || contentSize <= size) {
      return UNSCROLLABLE_STATE;
    }

    var stateKey = position + '_' + size + '_' + contentSize + '_' + orientation;
    if (this._stateKey === stateKey) {
      return this._stateForKey;
    }

    // There are two types of positions here.
    // 1) Phisical position: changed by mouse / keyboard
    // 2) Logical position: changed by props.
    // The logical position will be kept as as internal state and the `render()`
    // function will translate it into physical position to render.

    var isHorizontal = orientation === 'horizontal';
    var scale = size / contentSize;
    var faceSize = size * scale;

    if (faceSize < FACE_SIZE_MIN) {
      scale = (size - FACE_SIZE_MIN) / (contentSize - size);
      faceSize = FACE_SIZE_MIN;
    }

    var scrollable = true;
    var maxPosition = contentSize - size;

    if (position < 0) {
      position = 0;
    } else if (position > maxPosition) {
      position = maxPosition;
    }

    var isDragging = this._mouseMoveTracker ? this._mouseMoveTracker.isDragging() : false;

    // This function should only return flat values that can be compared quiclky
    // by `ReactComponentWithPureRenderMixin`.
    var state = {
      faceSize: faceSize,
      isDragging: isDragging,
      isHorizontal: isHorizontal,
      position: position,
      scale: scale,
      scrollable: scrollable
    };

    // cache the state for later use.
    this._stateKey = stateKey;
    this._stateForKey = state;
    return state;
  },

  _onWheelY: function _onWheelY( /*number*/deltaX, /*number*/deltaY) {
    this._onWheel(deltaY);
  },

  _onWheelX: function _onWheelX( /*number*/deltaX, /*number*/deltaY) {
    this._onWheel(deltaX);
  },

  _onWheel: function _onWheel( /*number*/delta) {
    var props = this.props;

    // The mouse may move faster then the animation frame does.
    // Use `requestAnimationFrame` to avoid over-updating.
    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));
  },

  _onMouseDown: function _onMouseDown( /*object*/event) {
    var nextState;

    if (event.target !== ReactDOM.findDOMNode(this.refs.face)) {
      // Both `offsetX` and `layerX` are non-standard DOM property but they are
      // magically available for browsers somehow.
      var nativeEvent = event.nativeEvent;
      var position = this.state.isHorizontal ? nativeEvent.offsetX || nativeEvent.layerX : nativeEvent.offsetY || nativeEvent.layerY;

      // MouseDown on the scroll-track directly, move the center of the
      // scroll-face to the mouse position.
      var props = this.props;
      position /= this.state.scale;
      nextState = this._calculateState(position - this.state.faceSize * 0.5 / this.state.scale, props.size, props.contentSize, props.orientation);
    } else {
      nextState = {};
    }

    nextState.focused = true;
    this._setNextState(nextState);

    this._mouseMoveTracker.captureMouseMoves(event);
    // Focus the node so it may receive keyboard event.
    ReactDOM.findDOMNode(this).focus();
  },

  _onMouseMove: function _onMouseMove( /*number*/deltaX, /*number*/deltaY) {
    var props = this.props;
    var delta = this.state.isHorizontal ? deltaX : deltaY;
    delta /= this.state.scale;

    this._setNextState(this._calculateState(this.state.position + delta, props.size, props.contentSize, props.orientation));
  },

  _onMouseMoveEnd: function _onMouseMoveEnd() {
    this._nextState = null;
    this._mouseMoveTracker.releaseMouseMoves();
    this.setState({ isDragging: false });
  },

  _onKeyDown: function _onKeyDown( /*object*/event) {
    var keyCode = event.keyCode;

    if (keyCode === Keys.TAB) {
      // Let focus move off the scrollbar.
      return;
    }

    var distance = KEYBOARD_SCROLL_AMOUNT;
    var direction = 0;

    if (this.state.isHorizontal) {
      switch (keyCode) {
        case Keys.HOME:
          direction = -1;
          distance = this.props.contentSize;
          break;

        case Keys.LEFT:
          direction = -1;
          break;

        case Keys.RIGHT:
          direction = 1;
          break;

        default:
          return;
      }
    }

    if (!this.state.isHorizontal) {
      switch (keyCode) {
        case Keys.SPACE:
          if (event.shiftKey) {
            direction = -1;
          } else {
            direction = 1;
          }
          break;

        case Keys.HOME:
          direction = -1;
          distance = this.props.contentSize;
          break;

        case Keys.UP:
          direction = -1;
          break;

        case Keys.DOWN:
          direction = 1;
          break;

        case Keys.PAGE_UP:
          direction = -1;
          distance = this.props.size;
          break;

        case Keys.PAGE_DOWN:
          direction = 1;
          distance = this.props.size;
          break;

        default:
          return;
      }
    }

    event.preventDefault();

    var props = this.props;
    this._setNextState(this._calculateState(this.state.position + distance * direction, props.size, props.contentSize, props.orientation));
  },

  _onFocus: function _onFocus() {
    this.setState({
      focused: true
    });
  },

  _onBlur: function _onBlur() {
    this.setState({
      focused: false
    });
  },

  _blur: function _blur() {
    if (this.isMounted()) {
      try {
        this._onBlur();
        ReactDOM.findDOMNode(this).blur();
      } catch (oops) {
        // pass
      }
    }
  },

  _setNextState: function _setNextState( /*object*/nextState, /*?object*/props) {
    props = props || this.props;
    var controlledPosition = props.position;
    var willScroll = this.state.position !== nextState.position;
    if (controlledPosition === undefined) {
      var callback = willScroll ? this._didScroll : undefined;
      this.setState(nextState, callback);
    } else if (controlledPosition === nextState.position) {
      this.setState(nextState);
    } else {
      // Scrolling is controlled. Don't update the state and let the owner
      // to update the scrollbar instead.
      if (nextState.position !== undefined && nextState.position !== this.state.position) {
        this.props.onScroll(nextState.position);
      }
      return;
    }

    if (willScroll && _lastScrolledScrollbar !== this) {
      _lastScrolledScrollbar && _lastScrolledScrollbar._blur();
      _lastScrolledScrollbar = this;
    }
  },

  _didScroll: function _didScroll() {
    this.props.onScroll(this.state.position);
  }
});

Scrollbar.KEYBOARD_SCROLL_AMOUNT = KEYBOARD_SCROLL_AMOUNT;
Scrollbar.SIZE = parseInt(cssVar('scrollbar-size'), 10);

module.exports = Scrollbar;
},{"./DOMMouseMoveTracker":277,"./Keys":300,"./React":303,"./ReactComponentWithPureRenderMixin":304,"./ReactDOM":305,"./ReactWheelHandler":306,"./cssVar":312,"./cx":313,"./emptyFunction":315,"./translateDOMPositionXY":324}],308:[function(require,module,exports){
/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */

'use strict';

var _populated = false;

// Browsers
var _ie, _firefox, _opera, _webkit, _chrome;

// Actual IE browser for compatibility mode
var _ie_real_version;

// Platforms
var _osx, _windows, _linux, _android;

// Architectures
var _win64;

// Devices
var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true;

  // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10
  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);

  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas);

  // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.
  _win64 = !!/Win64/.exec(uas);

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN;
    // IE compatibility mode
    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    }
    // grab the "true" ie version from the trident token if available
    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;

    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;
    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);

      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }
    _windows = !!os[2];
    _linux = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {

  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function ie() {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function ieCompatibilityMode() {
    return _populate() || _ie_real_version > _ie;
  },

  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function ie64() {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function firefox() {
    return _populate() || _firefox;
  },

  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function opera() {
    return _populate() || _opera;
  },

  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function webkit() {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function safari() {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome: function chrome() {
    return _populate() || _chrome;
  },

  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function windows() {
    return _populate() || _windows;
  },

  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function osx() {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function linux() {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function iphone() {
    return _populate() || _iphone;
  },

  mobile: function mobile() {
    return _populate() || _iphone || _ipad || _android || _mobile;
  },

  nativeApp: function nativeApp() {
    // webviews inside of the native apps
    return _populate() || _native;
  },

  android: function android() {
    return _populate() || _android;
  },

  ipad: function ipad() {
    return _populate() || _ipad;
  }
};

module.exports = UserAgent_DEPRECATED;
},{}],309:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule camelize
 * @typechecks
 */

"use strict";

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],310:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule cancelAnimationFramePolyfill
 */

/**
 * Here is the native and polyfill version of cancelAnimationFrame.
 * Please don't use it directly and use cancelAnimationFrame module instead.
 */
"use strict";

var cancelAnimationFrame = global.cancelAnimationFrame || global.webkitCancelAnimationFrame || global.mozCancelAnimationFrame || global.oCancelAnimationFrame || global.msCancelAnimationFrame || global.clearTimeout;

module.exports = cancelAnimationFrame;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],311:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule clamp
 * @typechecks
 */

/**
 * Clamps (or clips or confines) the value to be between min and max.
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @return {number}
 */
"use strict";

function clamp(value, min, max) {
  if (value < min) {
    return min;
  }
  if (value > max) {
    return max;
  }
  return value;
}

module.exports = clamp;
},{}],312:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule cssVar
 * @typechecks
 */

"use strict";

var CSS_VARS = {
  'scrollbar-face-active-color': '#7d7d7d',
  'scrollbar-face-color': '#c2c2c2',
  'scrollbar-face-margin': '4px',
  'scrollbar-face-radius': '6px',
  'scrollbar-size': '15px',
  'scrollbar-size-large': '17px',
  'scrollbar-track-color': 'rgba(255, 255, 255, 0.8)',
  'fbui-white': '#fff',
  'fbui-desktop-background-light': '#f6f7f8'
};

/**
 * @param {string} name
 */
function cssVar(name) {
  if (CSS_VARS.hasOwnProperty(name)) {
    return CSS_VARS[name];
  }

  throw new Error('cssVar' + '("' + name + '"): Unexpected class transformation.');
}

cssVar.CSS_VARS = CSS_VARS;

module.exports = cssVar;
},{}],313:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule cx
 */

'use strict';

var slashReplaceRegex = /\//g;
var cache = {};

function getClassName(className) {
  if (cache[className]) {
    return cache[className];
  }

  cache[className] = className.replace(slashReplaceRegex, '_');
  return cache[className];
}

/**
 * This function is used to mark string literals representing CSS class names
 * so that they can be transformed statically. This allows for modularization
 * and minification of CSS class names.
 *
 * In static_upstream, this function is actually implemented, but it should
 * eventually be replaced with something more descriptive, and the transform
 * that is used in the main stack should be ported for use elsewhere.
 *
 * @param string|object className to modularize, or an object of key/values.
 *                      In the object case, the values are conditions that
 *                      determine if the className keys should be included.
 * @param [string ...]  Variable list of classNames in the string case.
 * @return string       Renderable space-separated CSS className.
 */
function cx(classNames) {
  var classNamesArray;
  if (typeof classNames == 'object') {
    classNamesArray = Object.keys(classNames).filter(function (className) {
      return classNames[className];
    });
  } else {
    classNamesArray = Array.prototype.slice.call(arguments);
  }

  return classNamesArray.map(getClassName).join(' ');
}

module.exports = cx;
},{}],314:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule debounceCore
 * @typechecks
 */

/**
 * Invokes the given callback after a specified number of milliseconds have
 * elapsed, ignoring subsequent calls.
 *
 * For example, if you wanted to update a preview after the user stops typing
 * you could do the following:
 *
 *   elem.addEventListener('keyup', debounce(this.updatePreview, 250), false);
 *
 * The returned function has a reset method which can be called to cancel a
 * pending invocation.
 *
 *   var debouncedUpdatePreview = debounce(this.updatePreview, 250);
 *   elem.addEventListener('keyup', debouncedUpdatePreview, false);
 *
 *   // later, to cancel pending calls
 *   debouncedUpdatePreview.reset();
 *
 * @param {function} func - the function to debounce
 * @param {number} wait - how long to wait in milliseconds
 * @param {*} context - optional context to invoke the function in
 * @param {?function} setTimeoutFunc - an implementation of setTimeout
 *  if nothing is passed in the default setTimeout function is used
  * @param {?function} clearTimeoutFunc - an implementation of clearTimeout
 *  if nothing is passed in the default clearTimeout function is used
 */
"use strict";

function debounce(func, wait, context, setTimeoutFunc, clearTimeoutFunc) {
  setTimeoutFunc = setTimeoutFunc || setTimeout;
  clearTimeoutFunc = clearTimeoutFunc || clearTimeout;
  var timeout;

  function debouncer() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    debouncer.reset();

    var callback = function callback() {
      func.apply(context, args);
    };
    callback.__SMmeta = func.__SMmeta;
    timeout = setTimeoutFunc(callback, wait);
  }

  debouncer.reset = function () {
    clearTimeoutFunc(timeout);
  };

  return debouncer;
}

module.exports = debounce;
},{}],315:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule emptyFunction
 */

"use strict";

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
function emptyFunction() {}

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],316:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule getVendorPrefixedName
 * @typechecks
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var camelize = require('./camelize');
var invariant = require('./invariant');

var memoized = {};
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
var prefixRegex = new RegExp('^(' + prefixes.join('|') + ')');
var testStyle = ExecutionEnvironment.canUseDOM ? document.createElement('div').style : {};

function getWithPrefix(name) {
  for (var i = 0; i < prefixes.length; i++) {
    var prefixedName = prefixes[i] + name;
    if (prefixedName in testStyle) {
      return prefixedName;
    }
  }
  return null;
}

/**
 * @param {string} property Name of a css property to check for.
 * @return {?string} property name supported in the browser, or null if not
 * supported.
 */
function getVendorPrefixedName(property) {
  var name = camelize(property);
  if (memoized[name] === undefined) {
    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
    if (prefixRegex.test(capitalizedName)) {
      invariant(false, 'getVendorPrefixedName must only be called with unprefixed' + 'CSS property names. It was called with %s', property);
    }
    memoized[name] = name in testStyle ? name : getWithPrefix(capitalizedName);
  }
  return memoized[name];
}

module.exports = getVendorPrefixedName;
},{"./ExecutionEnvironment":279,"./camelize":309,"./invariant":317}],317:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule invariant
 */

"use strict";

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function invariant(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error('Invariant Violation: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;
}).call(this,require('_process'))
},{"_process":395}],318:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule isEventSupported
 */

'use strict';

var ExecutionEnvironment = require('./ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"./ExecutionEnvironment":279}],319:[function(require,module,exports){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule joinClasses
 * @typechecks static-only
 */

'use strict';

/**
 * Combines multiple className strings into one.
 * http://jsperf.com/joinclasses-args-vs-array
 *
 * @param {...?string} className
 * @return {string}
 */
function joinClasses(className /*, ... */) {
  if (!className) {
    className = '';
  }
  var nextClass;
  var argLength = arguments.length;
  if (argLength > 1) {
    for (var ii = 1; ii < argLength; ii++) {
      nextClass = arguments[ii];
      if (nextClass) {
        className = (className ? className + ' ' : '') + nextClass;
      }
    }
  }
  return className;
}

module.exports = joinClasses;
},{}],320:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule nativeRequestAnimationFrame
 */

"use strict";

var nativeRequestAnimationFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame;

module.exports = nativeRequestAnimationFrame;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],321:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule normalizeWheel
 * @typechecks
 */

'use strict';

var UserAgent_DEPRECATED = require('./UserAgent_DEPRECATED');

var isEventSupported = require('./isEventSupported');

// Reasonable defaults
var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */
function normalizeWheel( /*object*/event) /*object*/{
  var sX = 0,
      sY = 0,
      // spinX, spinY
  pX = 0,
      pY = 0; // pixelX, pixelY

  // Legacy
  if ('detail' in event) {
    sY = event.detail;
  }
  if ('wheelDelta' in event) {
    sY = -event.wheelDelta / 120;
  }
  if ('wheelDeltaY' in event) {
    sY = -event.wheelDeltaY / 120;
  }
  if ('wheelDeltaX' in event) {
    sX = -event.wheelDeltaX / 120;
  }

  // side scrolling on FF with DOMMouseScroll
  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) {
    pY = event.deltaY;
  }
  if ('deltaX' in event) {
    pX = event.deltaX;
  }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }
  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }

  return { spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY };
}

/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */
normalizeWheel.getEventType = function () /*string*/{
  return UserAgent_DEPRECATED.firefox() ? 'DOMMouseScroll' : isEventSupported('wheel') ? 'wheel' : 'mousewheel';
};

module.exports = normalizeWheel;
},{"./UserAgent_DEPRECATED":308,"./isEventSupported":318}],322:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule requestAnimationFramePolyfill
 */

'use strict';

var emptyFunction = require('./emptyFunction');
var nativeRequestAnimationFrame = require('./nativeRequestAnimationFrame');

var lastTime = 0;

/**
 * Here is the native and polyfill version of requestAnimationFrame.
 * Please don't use it directly and use requestAnimationFrame module instead.
 */
var requestAnimationFrame = nativeRequestAnimationFrame || function (callback) {
  var currTime = Date.now();
  var timeDelay = Math.max(0, 16 - (currTime - lastTime));
  lastTime = currTime + timeDelay;
  return global.setTimeout(function () {
    callback(Date.now());
  }, timeDelay);
};

// Works around a rare bug in Safari 6 where the first request is never invoked.
requestAnimationFrame(emptyFunction);

module.exports = requestAnimationFrame;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./emptyFunction":315,"./nativeRequestAnimationFrame":320}],323:[function(require,module,exports){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule shallowEqual
 * @typechecks
 * 
 */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var bHasOwnProperty = hasOwnProperty.bind(objB);
  for (var i = 0; i < keysA.length; i++) {
    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],324:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule translateDOMPositionXY
 * @typechecks
 */

'use strict';

var BrowserSupportCore = require('./BrowserSupportCore');

var getVendorPrefixedName = require('./getVendorPrefixedName');

var TRANSFORM = getVendorPrefixedName('transform');
var BACKFACE_VISIBILITY = getVendorPrefixedName('backfaceVisibility');

var translateDOMPositionXY = (function () {
  if (BrowserSupportCore.hasCSSTransforms()) {
    var ua = global.window ? global.window.navigator.userAgent : 'UNKNOWN';
    var isSafari = /Safari\//.test(ua) && !/Chrome\//.test(ua);
    // It appears that Safari messes up the composition order
    // of GPU-accelerated layers
    // (see bug https://bugs.webkit.org/show_bug.cgi?id=61824).
    // Use 2D translation instead.
    if (!isSafari && BrowserSupportCore.hasCSS3DTransforms()) {
      return function ( /*object*/style, /*number*/x, /*number*/y) {
        style[TRANSFORM] = 'translate3d(' + x + 'px,' + y + 'px,0)';
        style[BACKFACE_VISIBILITY] = 'hidden';
      };
    } else {
      return function ( /*object*/style, /*number*/x, /*number*/y) {
        style[TRANSFORM] = 'translate(' + x + 'px,' + y + 'px)';
      };
    }
  } else {
    return function ( /*object*/style, /*number*/x, /*number*/y) {
      style.left = x + 'px';
      style.top = y + 'px';
    };
  }
})();

module.exports = translateDOMPositionXY;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./BrowserSupportCore":276,"./getVendorPrefixedName":316}],325:[function(require,module,exports){
module.exports = require('./internal/FixedDataTableRoot');

},{"./internal/FixedDataTableRoot":293}],326:[function(require,module,exports){
/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
};

},{}],327:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if (process.env.NODE_ENV !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

}).call(this,require('_process'))
},{"_process":395}],328:[function(require,module,exports){
//from https://github.com/joker-x/languages.js
(function(exports){var langs={attribute:{name:0,nativeName:1},rtl:{ar:1,dv:1,fa:1,ha:1,he:1,ks:1,ku:1,ps:1,ur:1,yi:1},lang:{aa:["Afar","Afar"],ab:["Abkhazian","Аҧсуа"],af:["Afrikaans","Afrikaans"],ak:["Akan","Akana"],am:["Amharic","አማርኛ"],an:["Aragonese","Aragonés"],ar:["Arabic","العربية"],as:["Assamese","অসমীয়া"],av:["Avar","Авар"],ay:["Aymara","Aymar"],az:["Azerbaijani","Azərbaycanca / آذربايجان"],ba:["Bashkir","Башҡорт"],be:["Belarusian","Беларуская"],bg:["Bulgarian","Български"],bh:["Bihari","भोजपुरी"],bi:["Bislama","Bislama"],bm:["Bambara","Bamanankan"],bn:["Bengali","বাংলা"],bo:["Tibetan","བོད་ཡིག / Bod skad"],br:["Breton","Brezhoneg"],bs:["Bosnian","Bosanski"],ca:["Catalan","Català"],ce:["Chechen","Нохчийн"],ch:["Chamorro","Chamoru"],co:["Corsican","Corsu"],cr:["Cree","Nehiyaw"],cs:["Czech","Česky"],cu:["Old Church Slavonic / Old Bulgarian","словѣньскъ / slověnĭskŭ"],cv:["Chuvash","Чăваш"],cy:["Welsh","Cymraeg"],da:["Danish","Dansk"],de:["German","Deutsch"],dv:["Divehi","ދިވެހިބަސް"],dz:["Dzongkha","ཇོང་ཁ"],ee:["Ewe","Ɛʋɛ"],el:["Greek","Ελληνικά"],en:["English","English"],eo:["Esperanto","Esperanto"],es:["Spanish","Español"],et:["Estonian","Eesti"],eu:["Basque","Euskara"],fa:["Persian","فارسی"],ff:["Peul","Fulfulde"],fi:["Finnish","Suomi"],fj:["Fijian","Na Vosa Vakaviti"],fo:["Faroese","Føroyskt"],fr:["French","Français"],fy:["West Frisian","Frysk"],ga:["Irish","Gaeilge"],gd:["Scottish Gaelic","Gàidhlig"],gl:["Galician","Galego"],gn:["Guarani","Avañe'ẽ"],gu:["Gujarati","ગુજરાતી"],gv:["Manx","Gaelg"],ha:["Hausa","هَوُسَ"],he:["Hebrew","עברית"],hi:["Hindi","हिन्दी"],ho:["Hiri Motu","Hiri Motu"],hr:["Croatian","Hrvatski"],ht:["Haitian","Krèyol ayisyen"],hu:["Hungarian","Magyar"],hy:["Armenian","Հայերեն"],hz:["Herero","Otsiherero"],ia:["Interlingua","Interlingua"],id:["Indonesian","Bahasa Indonesia"],ie:["Interlingue","Interlingue"],ig:["Igbo","Igbo"],ii:["Sichuan Yi","ꆇꉙ / 四川彝语"],ik:["Inupiak","Iñupiak"],io:["Ido","Ido"],is:["Icelandic","Íslenska"],it:["Italian","Italiano"],iu:["Inuktitut","ᐃᓄᒃᑎᑐᑦ"],ja:["Japanese","日本語"],jv:["Javanese","Basa Jawa"],ka:["Georgian","ქართული"],kg:["Kongo","KiKongo"],ki:["Kikuyu","Gĩkũyũ"],kj:["Kuanyama","Kuanyama"],kk:["Kazakh","Қазақша"],kl:["Greenlandic","Kalaallisut"],km:["Cambodian","ភាសាខ្មែរ"],kn:["Kannada","ಕನ್ನಡ"],ko:["Korean","한국어"],kr:["Kanuri","Kanuri"],ks:["Kashmiri","कश्मीरी / كشميري"],ku:["Kurdish","Kurdî / كوردی"],kv:["Komi","Коми"],kw:["Cornish","Kernewek"],ky:["Kirghiz","Kırgızca / Кыргызча"],la:["Latin","Latina"],lb:["Luxembourgish","Lëtzebuergesch"],lg:["Ganda","Luganda"],li:["Limburgian","Limburgs"],ln:["Lingala","Lingála"],lo:["Laotian","ລາວ / Pha xa lao"],lt:["Lithuanian","Lietuvių"],lv:["Latvian","Latviešu"],mg:["Malagasy","Malagasy"],mh:["Marshallese","Kajin Majel / Ebon"],mi:["Maori","Māori"],mk:["Macedonian","Македонски"],ml:["Malayalam","മലയാളം"],mn:["Mongolian","Монгол"],mo:["Moldovan","Moldovenească"],mr:["Marathi","मराठी"],ms:["Malay","Bahasa Melayu"],mt:["Maltese","bil-Malti"],my:["Burmese","Myanmasa"],na:["Nauruan","Dorerin Naoero"],nd:["North Ndebele","Sindebele"],ne:["Nepali","नेपाली"],ng:["Ndonga","Oshiwambo"],nl:["Dutch","Nederlands"],nn:["Norwegian Nynorsk","Norsk (nynorsk)"],no:["Norwegian","Norsk (bokmål / riksmål)"],nr:["South Ndebele","isiNdebele"],nv:["Navajo","Diné bizaad"],ny:["Chichewa","Chi-Chewa"],oc:["Occitan","Occitan"],oj:["Ojibwa","ᐊᓂᔑᓈᐯᒧᐎᓐ / Anishinaabemowin"],om:["Oromo","Oromoo"],or:["Oriya","ଓଡ଼ିଆ"],os:["Ossetian / Ossetic","Иронау"],pa:["Panjabi / Punjabi","ਪੰਜਾਬੀ / पंजाबी / پنجابي"],pi:["Pali","Pāli / पाऴि"],pl:["Polish","Polski"],ps:["Pashto","پښتو"],pt:["Portuguese","Português"],qu:["Quechua","Runa Simi"],rm:["Raeto Romance","Rumantsch"],rn:["Kirundi","Kirundi"],ro:["Romanian","Română"],ru:["Russian","Русский"],rw:["Rwandi","Kinyarwandi"],sa:["Sanskrit","संस्कृतम्"],sc:["Sardinian","Sardu"],sd:["Sindhi","सिनधि"],se:["Northern Sami","Sámegiella"],sg:["Sango","Sängö"],sh:["Serbo-Croatian","Srpskohrvatski / Српскохрватски"],si:["Sinhalese","සිංහල"],sk:["Slovak","Slovenčina"],sl:["Slovenian","Slovenščina"],sm:["Samoan","Gagana Samoa"],sn:["Shona","chiShona"],so:["Somalia","Soomaaliga"],sq:["Albanian","Shqip"],sr:["Serbian","Српски"],ss:["Swati","SiSwati"],st:["Southern Sotho","Sesotho"],su:["Sundanese","Basa Sunda"],sv:["Swedish","Svenska"],sw:["Swahili","Kiswahili"],ta:["Tamil","தமிழ்"],te:["Telugu","తెలుగు"],tg:["Tajik","Тоҷикӣ"],th:["Thai","ไทย / Phasa Thai"],ti:["Tigrinya","ትግርኛ"],tk:["Turkmen","Туркмен / تركمن"],tl:["Tagalog / Filipino","Tagalog"],tn:["Tswana","Setswana"],to:["Tonga","Lea Faka-Tonga"],tr:["Turkish","Türkçe"],ts:["Tsonga","Xitsonga"],tt:["Tatar","Tatarça"],tw:["Twi","Twi"],ty:["Tahitian","Reo Mā`ohi"],ug:["Uyghur","Uyƣurqə / ئۇيغۇرچە"],uk:["Ukrainian","Українська"],ur:["Urdu","اردو"],uz:["Uzbek","Ўзбек"],ve:["Venda","Tshivenḓa"],vi:["Vietnamese","Tiếng Việt"],vo:["Volapük","Volapük"],wa:["Walloon","Walon"],wo:["Wolof","Wollof"],xh:["Xhosa","isiXhosa"],yi:["Yiddish","ייִדיש"],yo:["Yoruba","Yorùbá"],za:["Zhuang","Cuengh / Tôô / 壮语"],zh:["Chinese","中文"],zu:["Zulu","isiZulu"]}};var getLangDirection=function(langcode){return langs.rtl[langcode]?"rtl":"ltr"};exports.isValid=function(langcode){return langs.lang.hasOwnProperty(langcode)};exports.getAllLanguageCode=function(){var result=[];for(langcode in langs.lang){result.push(langcode)}return result};exports.getLanguageInfo=function(langcode){var result={};if(exports.isValid(langcode)){var lang=langs.lang[langcode];result["name"]=lang[0];result["nativeName"]=lang[1];result["direction"]=getLangDirection(langcode)}return result}})(typeof exports==="undefined"?this["languages"]={}:exports);

},{}],329:[function(require,module,exports){
/*
 * L.Control.Loading is a control that shows a loading indicator when tiles are
 * loading or when map-related AJAX requests are taking place.
 */

(function () {

    var console = window.console || {
        error: function () {},
        warn: function () {}
    };

    function defineLeafletLoading(L) {
        L.Control.Loading = L.Control.extend({
            options: {
                delayIndicator: null,
                position: 'topleft',
                separate: false,
                zoomControl: null,
                spinjs: false,
                spin: { 
                    lines: 7, 
                    length: 3, 
                    width: 3, 
                    radius: 5, 
                    rotate: 13, 
                    top: "83%"
                }
            },

            initialize: function(options) {
                L.setOptions(this, options);
                this._dataLoaders = {};

                // Try to set the zoom control this control is attached to from the 
                // options
                if (this.options.zoomControl !== null) {
                    this.zoomControl = this.options.zoomControl;
                }
            },

            onAdd: function(map) {
                if (this.options.spinjs && (typeof Spinner !== 'function')) {
                    return console.error("Leaflet.loading cannot load because you didn't load spin.js (http://fgnass.github.io/spin.js/), even though you set it in options.");
                }
                this._addLayerListeners(map);
                this._addMapListeners(map);

                // Try to set the zoom control this control is attached to from the map
                // the control is being added to
                if (!this.options.separate && !this.zoomControl) {
                    if (map.zoomControl) {
                        this.zoomControl = map.zoomControl;
                    } else if (map.zoomsliderControl) {
                        this.zoomControl = map.zoomsliderControl;
                    }
                }

                // Create the loading indicator
                var classes = 'leaflet-control-loading';
                var container;
                if (this.zoomControl && !this.options.separate) {
                    // If there is a zoom control, hook into the bottom of it
                    container = this.zoomControl._container;
                    // These classes are no longer used as of Leaflet 0.6
                    classes += ' leaflet-bar-part-bottom leaflet-bar-part last';

                    // Loading control will be added to the zoom control. So the visible last element is not the
                    // last dom element anymore. So add the part-bottom class.
                    L.DomUtil.addClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
                }
                else {
                    // Otherwise, create a container for the indicator
                    container = L.DomUtil.create('div', 'leaflet-control-zoom leaflet-bar');
                }
                this._indicator = L.DomUtil.create('a', classes, container);
                if (this.options.spinjs) {
                    this._spinner = new Spinner(this.options.spin).spin();
                    this._indicator.appendChild(this._spinner.el);
                }
                return container;
            },

            onRemove: function(map) {
                this._removeLayerListeners(map);
                this._removeMapListeners(map);
            },

            removeFrom: function (map) {
                if (this.zoomControl && !this.options.separate) {
                    // Override Control.removeFrom() to avoid clobbering the entire
                    // _container, which is the same as zoomControl's
                    this._container.removeChild(this._indicator);
                    this._map = null;
                    this.onRemove(map);
                    return this;
                }
                else {
                    // If this control is separate from the zoomControl, call the
                    // parent method so we don't leave behind an empty container
                    // REMOVED AS THIS METHOD DOESN'T EXIST
                    // return L.Control.prototype.removeFrom.call(this, map);
                }
            },

            addLoader: function(id) {
                this._dataLoaders[id] = true;
                if (this.options.delayIndicator && !this.delayIndicatorTimeout) {
                    // If we are delaying showing the indicator and we're not
                    // already waiting for that delay, set up a timeout.
                    var that = this;
                    this.delayIndicatorTimeout = setTimeout(function () {
                        that.updateIndicator();
                        that.delayIndicatorTimeout = null;
                    }, this.options.delayIndicator);
                }
                else {
                    // Otherwise show the indicator immediately
                    this.updateIndicator();
                }
            },

            removeLoader: function(id) {
                delete this._dataLoaders[id];
                this.updateIndicator();

                // If removing this loader means we're in no danger of loading,
                // clear the timeout. This prevents old delays from instantly 
                // triggering the indicator.
                if (this.options.delayIndicator && this.delayIndicatorTimeout && !this.isLoading()) {
                    clearTimeout(this.delayIndicatorTimeout);
                    this.delayIndicatorTimeout = null;
                }
            },

            updateIndicator: function() {
                if (this.isLoading()) {
                    this._showIndicator();
                }
                else {
                    this._hideIndicator();
                }
            },

            isLoading: function() {
                return this._countLoaders() > 0;
            },

            _countLoaders: function() {
                var size = 0, key;
                for (key in this._dataLoaders) {
                    if (this._dataLoaders.hasOwnProperty(key)) size++;
                }
                return size;
            },

            _showIndicator: function() {
                // Show loading indicator
                L.DomUtil.addClass(this._indicator, 'is-loading');

                // If zoomControl exists, make the zoom-out button not last
                if (!this.options.separate) {
                    if (this.zoomControl instanceof L.Control.Zoom) {
                        L.DomUtil.removeClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
                    }
                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
                        L.DomUtil.removeClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
                    }
                }
            },

            _hideIndicator: function() {
                // Hide loading indicator
                L.DomUtil.removeClass(this._indicator, 'is-loading');

                // If zoomControl exists, make the zoom-out button last
                if (!this.options.separate) {
                    if (this.zoomControl instanceof L.Control.Zoom) {
                        L.DomUtil.addClass(this._getLastControlButton(), 'leaflet-bar-part-bottom');
                    }
                    else if (typeof L.Control.Zoomslider === 'function' && this.zoomControl instanceof L.Control.Zoomslider) {
                        L.DomUtil.addClass(this.zoomControl._ui.zoomOut, 'leaflet-bar-part-bottom');
                    }
                }
            },

            _getLastControlButton: function() {
                var container = this.zoomControl._container,
                    index = container.children.length - 1;

                // Find the last visible control button that is not our loading
                // indicator
                while (index > 0) {
                    var button = container.children[index];
                    if (!(this._indicator === button || button.offsetWidth === 0 || button.offsetHeight === 0)) {
                        break;
                    }
                    index--;
                }

                return container.children[index];
            },

            _handleLoading: function(e) {
                this.addLoader(this.getEventId(e));
            },

            _handleBaseLayerChange: function (e) {
                var that = this;

                // Check for a target 'layer' that contains multiple layers, such as
                // L.LayerGroup. This will happen if you have an L.LayerGroup in an
                // L.Control.Layers.
                if (e.layer && e.layer.eachLayer && typeof e.layer.eachLayer === 'function') {
                    e.layer.eachLayer(function (layer) {
                        that._handleBaseLayerChange({ layer: layer });
                    });
                }
                else {
                    // If we're changing to a canvas layer, don't handle loading
                    // as canvas layers will not fire load events.
                    if (!(L.TileLayer.Canvas && e.layer instanceof L.TileLayer.Canvas)) {
                        that._handleLoading(e);
                    }
                }
            },

            _handleLoad: function(e) {
                this.removeLoader(this.getEventId(e));
            },

            getEventId: function(e) {
                if (e.id) {
                    return e.id;
                }
                else if (e.layer) {
                    return e.layer._leaflet_id;
                }
                return e.target._leaflet_id;
            },

            _layerAdd: function(e) {
                if (!e.layer || !e.layer.on) return
                try {
                    e.layer.on({
                        loading: this._handleLoading,
                        load: this._handleLoad
                    }, this);
                }
                catch (exception) {
                    console.warn('L.Control.Loading: Tried and failed to add ' +
                                 ' event handlers to layer', e.layer);
                    console.warn('L.Control.Loading: Full details', exception);
                }
                if (e.layer._loading)
                  this._handleLoading({type: 'loading', target: e.layer});
            },

            _layerRemove: function(e) {
                if (!e.layer || !e.layer.off) return;
                try {
                    e.layer.off({
                        loading: this._handleLoading,
                        load: this._handleLoad
                    }, this);
                }
                catch (exception) {
                    console.warn('L.Control.Loading: Tried and failed to remove ' +
                                 'event handlers from layer', e.layer);
                    console.warn('L.Control.Loading: Full details', exception);
                }
            },

            _addLayerListeners: function(map) {
                // Add listeners for begin and end of load to any layers already on the 
                // map
                map.eachLayer(function(layer) {
                    if (!layer.on) return;
                    layer.on({
                        loading: this._handleLoading,
                        load: this._handleLoad
                    }, this);
                }, this);

                // When a layer is added to the map, add listeners for begin and end
                // of load
                map.on('layeradd', this._layerAdd, this);
                map.on('layerremove', this._layerRemove, this);
            },

            _removeLayerListeners: function(map) {
                // Remove listeners for begin and end of load from all layers
                map.eachLayer(function(layer) {
                    if (!layer.off) return;
                    layer.off({
                        loading: this._handleLoading,
                        load: this._handleLoad
                    }, this);
                }, this);

                // Remove layeradd/layerremove listener from map
                map.off('layeradd', this._layerAdd, this);
                map.off('layerremove', this._layerRemove, this);
            },

            _addMapListeners: function(map) {
                // Add listeners to the map for (custom) dataloading and dataload
                // events, eg, for AJAX calls that affect the map but will not be
                // reflected in the above layer events.
                map.on({
                    baselayerchange: this._handleBaseLayerChange,
                    dataloading: this._handleLoading,
                    dataload: this._handleLoad,
                    layerremove: this._handleLoad
                }, this);
            },

            _removeMapListeners: function(map) {
                map.off({
                    baselayerchange: this._handleBaseLayerChange,
                    dataloading: this._handleLoading,
                    dataload: this._handleLoad,
                    layerremove: this._handleLoad
                }, this);
            }
        });

        L.Map.addInitHook(function () {
            if (this.options.loadingControl) {
                this.loadingControl = new L.Control.Loading();
                this.addControl(this.loadingControl);
            }
        });

        L.Control.loading = function(options) {
            return new L.Control.Loading(options);
        };
    }

    if (typeof define === 'function' && define.amd) {
        // Try to add leaflet.loading to Leaflet using AMD
        define(['leaflet'], function (L) {
            defineLeafletLoading(L);
        });
    }
    else {
        // Else use the global L
        defineLeafletLoading(L);
    }

})();

},{}],330:[function(require,module,exports){
/*
 Leaflet 1.0.3, a JS library for interactive maps. http://leafletjs.com
 (c) 2010-2016 Vladimir Agafonkin, (c) 2010-2011 CloudMade
*/
(function (window, document, undefined) {
var L = {
	version: "1.0.3"
};

function expose() {
	var oldL = window.L;

	L.noConflict = function () {
		window.L = oldL;
		return this;
	};

	window.L = L;
}

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed
if (typeof window !== 'undefined') {
	expose();
}



/*
 * @namespace Util
 *
 * Various utility functions, used by Leaflet internally.
 */

L.Util = {

	// @function extend(dest: Object, src?: Object): Object
	// Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
	extend: function (dest) {
		var i, j, len, src;

		for (j = 1, len = arguments.length; j < len; j++) {
			src = arguments[j];
			for (i in src) {
				dest[i] = src[i];
			}
		}
		return dest;
	},

	// @function create(proto: Object, properties?: Object): Object
	// Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
	create: Object.create || (function () {
		function F() {}
		return function (proto) {
			F.prototype = proto;
			return new F();
		};
	})(),

	// @function bind(fn: Function, …): Function
	// Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
	// Has a `L.bind()` shortcut.
	bind: function (fn, obj) {
		var slice = Array.prototype.slice;

		if (fn.bind) {
			return fn.bind.apply(fn, slice.call(arguments, 1));
		}

		var args = slice.call(arguments, 2);

		return function () {
			return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
		};
	},

	// @function stamp(obj: Object): Number
	// Returns the unique ID of an object, assiging it one if it doesn't have it.
	stamp: function (obj) {
		/*eslint-disable */
		obj._leaflet_id = obj._leaflet_id || ++L.Util.lastId;
		return obj._leaflet_id;
		/*eslint-enable */
	},

	// @property lastId: Number
	// Last unique ID used by [`stamp()`](#util-stamp)
	lastId: 0,

	// @function throttle(fn: Function, time: Number, context: Object): Function
	// Returns a function which executes function `fn` with the given scope `context`
	// (so that the `this` keyword refers to `context` inside `fn`'s code). The function
	// `fn` will be called no more than one time per given amount of `time`. The arguments
	// received by the bound function will be any arguments passed when binding the
	// function, followed by any arguments passed when invoking the bound function.
	// Has an `L.bind` shortcut.
	throttle: function (fn, time, context) {
		var lock, args, wrapperFn, later;

		later = function () {
			// reset lock and call if queued
			lock = false;
			if (args) {
				wrapperFn.apply(context, args);
				args = false;
			}
		};

		wrapperFn = function () {
			if (lock) {
				// called too soon, queue to call later
				args = arguments;

			} else {
				// call and lock until later
				fn.apply(context, arguments);
				setTimeout(later, time);
				lock = true;
			}
		};

		return wrapperFn;
	},

	// @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
	// Returns the number `num` modulo `range` in such a way so it lies within
	// `range[0]` and `range[1]`. The returned value will be always smaller than
	// `range[1]` unless `includeMax` is set to `true`.
	wrapNum: function (x, range, includeMax) {
		var max = range[1],
		    min = range[0],
		    d = max - min;
		return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
	},

	// @function falseFn(): Function
	// Returns a function which always returns `false`.
	falseFn: function () { return false; },

	// @function formatNum(num: Number, digits?: Number): Number
	// Returns the number `num` rounded to `digits` decimals, or to 5 decimals by default.
	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	// @function trim(str: String): String
	// Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	// @function splitWords(str: String): String[]
	// Trims and splits the string on whitespace and returns the array of parts.
	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	// @function setOptions(obj: Object, options: Object): Object
	// Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `Class options`. Has an `L.setOptions` shortcut.
	setOptions: function (obj, options) {
		if (!obj.hasOwnProperty('options')) {
			obj.options = obj.options ? L.Util.create(obj.options) : {};
		}
		for (var i in options) {
			obj.options[i] = options[i];
		}
		return obj.options;
	},

	// @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
	// Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
	// translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
	// be appended at the end. If `uppercase` is `true`, the parameter names will
	// be uppercased (e.g. `'?A=foo&B=bar'`)
	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},

	// @function template(str: String, data: Object): String
	// Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
	// and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
	// `('Hello foo, bar')`. You can also specify functions instead of strings for
	// data values — they will be evaluated passing `data` as an argument.
	template: function (str, data) {
		return str.replace(L.Util.templateRe, function (str, key) {
			var value = data[key];

			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);

			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	templateRe: /\{ *([\w_\-]+) *\}/g,

	// @function isArray(obj): Boolean
	// Compatibility polyfill for [Array.isArray](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray)
	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	// @function indexOf(array: Array, el: Object): Number
	// Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
	indexOf: function (array, el) {
		for (var i = 0; i < array.length; i++) {
			if (array[i] === el) { return i; }
		}
		return -1;
	},

	// @property emptyImageUrl: String
	// Data URI string containing a base64-encoded empty GIF image.
	// Used as a hack to free memory from unused images on WebKit-powered
	// mobile devices (by setting image `src` to this string).
	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {
	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		return window['webkit' + name] || window['moz' + name] || window['ms' + name];
	}

	var lastTime = 0;

	// fallback for IE 7-8
	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer,
	    cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') ||
	               getPrefixed('CancelRequestAnimationFrame') || function (id) { window.clearTimeout(id); };


	// @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
	// Schedules `fn` to be executed when the browser repaints. `fn` is bound to
	// `context` if given. When `immediate` is set, `fn` is called immediately if
	// the browser doesn't have native support for
	// [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
	// otherwise it's delayed. Returns a request ID that can be used to cancel the request.
	L.Util.requestAnimFrame = function (fn, context, immediate) {
		if (immediate && requestFn === timeoutDefer) {
			fn.call(context);
		} else {
			return requestFn.call(window, L.bind(fn, context));
		}
	};

	// @function cancelAnimFrame(id: Number): undefined
	// Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};
})();

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;




// @class Class
// @aka L.Class

// @section
// @uninheritable

// Thanks to John Resig and Dean Edwards for inspiration!

L.Class = function () {};

L.Class.extend = function (props) {

	// @function extend(props: Object): Function
	// [Extends the current class](#class-inheritance) given the properties to be included.
	// Returns a Javascript function that is a class constructor (to be called with `new`).
	var NewClass = function () {

		// call the constructor
		if (this.initialize) {
			this.initialize.apply(this, arguments);
		}

		// call all constructor hooks
		this.callInitHooks();
	};

	var parentProto = NewClass.__super__ = this.prototype;

	var proto = L.Util.create(parentProto);
	proto.constructor = NewClass;

	NewClass.prototype = proto;

	// inherit parent's statics
	for (var i in this) {
		if (this.hasOwnProperty(i) && i !== 'prototype') {
			NewClass[i] = this[i];
		}
	}

	// mix static properties into the class
	if (props.statics) {
		L.extend(NewClass, props.statics);
		delete props.statics;
	}

	// mix includes into the prototype
	if (props.includes) {
		L.Util.extend.apply(null, [proto].concat(props.includes));
		delete props.includes;
	}

	// merge options
	if (proto.options) {
		props.options = L.Util.extend(L.Util.create(proto.options), props.options);
	}

	// mix given properties into the prototype
	L.extend(proto, props);

	proto._initHooks = [];

	// add method for calling all hooks
	proto.callInitHooks = function () {

		if (this._initHooksCalled) { return; }

		if (parentProto.callInitHooks) {
			parentProto.callInitHooks.call(this);
		}

		this._initHooksCalled = true;

		for (var i = 0, len = proto._initHooks.length; i < len; i++) {
			proto._initHooks[i].call(this);
		}
	};

	return NewClass;
};


// @function include(properties: Object): this
// [Includes a mixin](#class-includes) into the current class.
L.Class.include = function (props) {
	L.extend(this.prototype, props);
	return this;
};

// @function mergeOptions(options: Object): this
// [Merges `options`](#class-options) into the defaults of the class.
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
	return this;
};

// @function addInitHook(fn: Function): this
// Adds a [constructor hook](#class-constructor-hooks) to the class.
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
	return this;
};



/*
 * @class Evented
 * @aka L.Evented
 * @inherits Class
 *
 * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
 *
 * @example
 *
 * ```js
 * map.on('click', function(e) {
 * 	alert(e.latlng);
 * } );
 * ```
 *
 * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
 *
 * ```js
 * function onClick(e) { ... }
 *
 * map.on('click', onClick);
 * map.off('click', onClick);
 * ```
 */


L.Evented = L.Class.extend({

	/* @method on(type: String, fn: Function, context?: Object): this
	 * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
	 *
	 * @alternative
	 * @method on(eventMap: Object): this
	 * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	 */
	on: function (types, fn, context) {

		// types can be a map of types/handlers
		if (typeof types === 'object') {
			for (var type in types) {
				// we don't process space-separated events here for performance;
				// it's a hot path since Layer uses the on(obj) syntax
				this._on(type, types[type], fn);
			}

		} else {
			// types can be a string of space-separated words
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(types[i], fn, context);
			}
		}

		return this;
	},

	/* @method off(type: String, fn?: Function, context?: Object): this
	 * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
	 *
	 * @alternative
	 * @method off(eventMap: Object): this
	 * Removes a set of type/listener pairs.
	 *
	 * @alternative
	 * @method off: this
	 * Removes all listeners to all events on the object.
	 */
	off: function (types, fn, context) {

		if (!types) {
			// clear all listeners if called without arguments
			delete this._events;

		} else if (typeof types === 'object') {
			for (var type in types) {
				this._off(type, types[type], fn);
			}

		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(types[i], fn, context);
			}
		}

		return this;
	},

	// attach listener (without syntactic sugar now)
	_on: function (type, fn, context) {
		this._events = this._events || {};

		/* get/init listeners for type */
		var typeListeners = this._events[type];
		if (!typeListeners) {
			typeListeners = [];
			this._events[type] = typeListeners;
		}

		if (context === this) {
			// Less memory footprint.
			context = undefined;
		}
		var newListener = {fn: fn, ctx: context},
		    listeners = typeListeners;

		// check if fn already there
		for (var i = 0, len = listeners.length; i < len; i++) {
			if (listeners[i].fn === fn && listeners[i].ctx === context) {
				return;
			}
		}

		listeners.push(newListener);
	},

	_off: function (type, fn, context) {
		var listeners,
		    i,
		    len;

		if (!this._events) { return; }

		listeners = this._events[type];

		if (!listeners) {
			return;
		}

		if (!fn) {
			// Set all removed listeners to noop so they are not called if remove happens in fire
			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].fn = L.Util.falseFn;
			}
			// clear all listeners for a type if function isn't specified
			delete this._events[type];
			return;
		}

		if (context === this) {
			context = undefined;
		}

		if (listeners) {

			// find fn and remove it
			for (i = 0, len = listeners.length; i < len; i++) {
				var l = listeners[i];
				if (l.ctx !== context) { continue; }
				if (l.fn === fn) {

					// set the removed listener to noop so that's not called if remove happens in fire
					l.fn = L.Util.falseFn;

					if (this._firingCount) {
						/* copy array in case events are being fired */
						this._events[type] = listeners = listeners.slice();
					}
					listeners.splice(i, 1);

					return;
				}
			}
		}
	},

	// @method fire(type: String, data?: Object, propagate?: Boolean): this
	// Fires an event of the specified type. You can optionally provide an data
	// object — the first argument of the listener function will contain its
	// properties. The event can optionally be propagated to event parents.
	fire: function (type, data, propagate) {
		if (!this.listens(type, propagate)) { return this; }

		var event = L.Util.extend({}, data, {type: type, target: this});

		if (this._events) {
			var listeners = this._events[type];

			if (listeners) {
				this._firingCount = (this._firingCount + 1) || 1;
				for (var i = 0, len = listeners.length; i < len; i++) {
					var l = listeners[i];
					l.fn.call(l.ctx || this, event);
				}

				this._firingCount--;
			}
		}

		if (propagate) {
			// propagate the event to parents (set with addEventParent)
			this._propagateEvent(event);
		}

		return this;
	},

	// @method listens(type: String): Boolean
	// Returns `true` if a particular event type has any listeners attached to it.
	listens: function (type, propagate) {
		var listeners = this._events && this._events[type];
		if (listeners && listeners.length) { return true; }

		if (propagate) {
			// also check parents for listeners if event propagates
			for (var id in this._eventParents) {
				if (this._eventParents[id].listens(type, propagate)) { return true; }
			}
		}
		return false;
	},

	// @method once(…): this
	// Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
	once: function (types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this.once(type, types[type], fn);
			}
			return this;
		}

		var handler = L.bind(function () {
			this
			    .off(types, fn, context)
			    .off(types, handler, context);
		}, this);

		// add a listener that's executed once and removed after that
		return this
		    .on(types, fn, context)
		    .on(types, handler, context);
	},

	// @method addEventParent(obj: Evented): this
	// Adds an event parent - an `Evented` that will receive propagated events
	addEventParent: function (obj) {
		this._eventParents = this._eventParents || {};
		this._eventParents[L.stamp(obj)] = obj;
		return this;
	},

	// @method removeEventParent(obj: Evented): this
	// Removes an event parent, so it will stop receiving propagated events
	removeEventParent: function (obj) {
		if (this._eventParents) {
			delete this._eventParents[L.stamp(obj)];
		}
		return this;
	},

	_propagateEvent: function (e) {
		for (var id in this._eventParents) {
			this._eventParents[id].fire(e.type, L.extend({layer: e.target}, e), true);
		}
	}
});

var proto = L.Evented.prototype;

// aliases; we should ditch those eventually

// @method addEventListener(…): this
// Alias to [`on(…)`](#evented-on)
proto.addEventListener = proto.on;

// @method removeEventListener(…): this
// Alias to [`off(…)`](#evented-off)

// @method clearAllEventListeners(…): this
// Alias to [`off()`](#evented-off)
proto.removeEventListener = proto.clearAllEventListeners = proto.off;

// @method addOneTimeEventListener(…): this
// Alias to [`once(…)`](#evented-once)
proto.addOneTimeEventListener = proto.once;

// @method fireEvent(…): this
// Alias to [`fire(…)`](#evented-fire)
proto.fireEvent = proto.fire;

// @method hasEventListeners(…): Boolean
// Alias to [`listens(…)`](#evented-listens)
proto.hasEventListeners = proto.listens;

L.Mixin = {Events: proto};



/*
 * @namespace Browser
 * @aka L.Browser
 *
 * A namespace with static properties for browser/feature detection used by Leaflet internally.
 *
 * @example
 *
 * ```js
 * if (L.Browser.ielt9) {
 *   alert('Upgrade your browser, dude!');
 * }
 * ```
 */

(function () {

	var ua = navigator.userAgent.toLowerCase(),
	    doc = document.documentElement,

	    ie = 'ActiveXObject' in window,

	    webkit    = ua.indexOf('webkit') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android23 = ua.search('android [23]') !== -1,
	    chrome    = ua.indexOf('chrome') !== -1,
	    gecko     = ua.indexOf('gecko') !== -1  && !webkit && !window.opera && !ie,

	    win = navigator.platform.indexOf('Win') === 0,

	    mobile = typeof orientation !== 'undefined' || ua.indexOf('mobile') !== -1,
	    msPointer = !window.PointerEvent && window.MSPointerEvent,
	    pointer = window.PointerEvent || msPointer,

	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera12 = 'OTransition' in doc.style;


	var touch = !window.L_NO_TOUCH && (pointer || 'ontouchstart' in window ||
			(window.DocumentTouch && document instanceof window.DocumentTouch));

	L.Browser = {

		// @property ie: Boolean
		// `true` for all Internet Explorer versions (not Edge).
		ie: ie,

		// @property ielt9: Boolean
		// `true` for Internet Explorer versions less than 9.
		ielt9: ie && !document.addEventListener,

		// @property edge: Boolean
		// `true` for the Edge web browser.
		edge: 'msLaunchUri' in navigator && !('documentMode' in document),

		// @property webkit: Boolean
		// `true` for webkit-based browsers like Chrome and Safari (including mobile versions).
		webkit: webkit,

		// @property gecko: Boolean
		// `true` for gecko-based browsers like Firefox.
		gecko: gecko,

		// @property android: Boolean
		// `true` for any browser running on an Android platform.
		android: ua.indexOf('android') !== -1,

		// @property android23: Boolean
		// `true` for browsers running on Android 2 or Android 3.
		android23: android23,

		// @property chrome: Boolean
		// `true` for the Chrome browser.
		chrome: chrome,

		// @property safari: Boolean
		// `true` for the Safari browser.
		safari: !chrome && ua.indexOf('safari') !== -1,


		// @property win: Boolean
		// `true` when the browser is running in a Windows platform
		win: win,


		// @property ie3d: Boolean
		// `true` for all Internet Explorer versions supporting CSS transforms.
		ie3d: ie3d,

		// @property webkit3d: Boolean
		// `true` for webkit-based browsers supporting CSS transforms.
		webkit3d: webkit3d,

		// @property gecko3d: Boolean
		// `true` for gecko-based browsers supporting CSS transforms.
		gecko3d: gecko3d,

		// @property opera12: Boolean
		// `true` for the Opera browser supporting CSS transforms (version 12 or later).
		opera12: opera12,

		// @property any3d: Boolean
		// `true` for all browsers supporting CSS transforms.
		any3d: !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d) && !opera12 && !phantomjs,


		// @property mobile: Boolean
		// `true` for all browsers running in a mobile device.
		mobile: mobile,

		// @property mobileWebkit: Boolean
		// `true` for all webkit-based browsers in a mobile device.
		mobileWebkit: mobile && webkit,

		// @property mobileWebkit3d: Boolean
		// `true` for all webkit-based browsers in a mobile device supporting CSS transforms.
		mobileWebkit3d: mobile && webkit3d,

		// @property mobileOpera: Boolean
		// `true` for the Opera browser in a mobile device.
		mobileOpera: mobile && window.opera,

		// @property mobileGecko: Boolean
		// `true` for gecko-based browsers running in a mobile device.
		mobileGecko: mobile && gecko,


		// @property touch: Boolean
		// `true` for all browsers supporting [touch events](https://developer.mozilla.org/docs/Web/API/Touch_events).
		// This does not necessarily mean that the browser is running in a computer with
		// a touchscreen, it only means that the browser is capable of understanding
		// touch events.
		touch: !!touch,

		// @property msPointer: Boolean
		// `true` for browsers implementing the Microsoft touch events model (notably IE10).
		msPointer: !!msPointer,

		// @property pointer: Boolean
		// `true` for all browsers supporting [pointer events](https://msdn.microsoft.com/en-us/library/dn433244%28v=vs.85%29.aspx).
		pointer: !!pointer,


		// @property retina: Boolean
		// `true` for browsers on a high-resolution "retina" screen.
		retina: (window.devicePixelRatio || (window.screen.deviceXDPI / window.screen.logicalXDPI)) > 1
	};

}());



/*
 * @class Point
 * @aka L.Point
 *
 * Represents a point with `x` and `y` coordinates in pixels.
 *
 * @example
 *
 * ```js
 * var point = L.point(200, 300);
 * ```
 *
 * All Leaflet methods and options that accept `Point` objects also accept them in a simple Array form (unless noted otherwise), so these lines are equivalent:
 *
 * ```js
 * map.panBy([200, 300]);
 * map.panBy(L.point(200, 300));
 * ```
 */

L.Point = function (x, y, round) {
	// @property x: Number; The `x` coordinate of the point
	this.x = (round ? Math.round(x) : x);
	// @property y: Number; The `y` coordinate of the point
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	// @method clone(): Point
	// Returns a copy of the current point.
	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// @method add(otherPoint: Point): Point
	// Returns the result of addition of the current and the given points.
	add: function (point) {
		// non-destructive, returns a new point
		return this.clone()._add(L.point(point));
	},

	_add: function (point) {
		// destructive, used directly for performance in situations where it's safe to modify existing point
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	// @method subtract(otherPoint: Point): Point
	// Returns the result of subtraction of the given point from the current.
	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	// @method divideBy(num: Number): Point
	// Returns the result of division of the current point by the given number.
	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	// @method multiplyBy(num: Number): Point
	// Returns the result of multiplication of the current point by the given number.
	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	// @method scaleBy(scale: Point): Point
	// Multiply each coordinate of the current point by each coordinate of
	// `scale`. In linear algebra terms, multiply the point by the
	// [scaling matrix](https://en.wikipedia.org/wiki/Scaling_%28geometry%29#Matrix_representation)
	// defined by `scale`.
	scaleBy: function (point) {
		return new L.Point(this.x * point.x, this.y * point.y);
	},

	// @method unscaleBy(scale: Point): Point
	// Inverse of `scaleBy`. Divide each coordinate of the current point by
	// each coordinate of `scale`.
	unscaleBy: function (point) {
		return new L.Point(this.x / point.x, this.y / point.y);
	},

	// @method round(): Point
	// Returns a copy of the current point with rounded coordinates.
	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	// @method floor(): Point
	// Returns a copy of the current point with floored coordinates (rounded down).
	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	// @method ceil(): Point
	// Returns a copy of the current point with ceiled coordinates (rounded up).
	ceil: function () {
		return this.clone()._ceil();
	},

	_ceil: function () {
		this.x = Math.ceil(this.x);
		this.y = Math.ceil(this.y);
		return this;
	},

	// @method distanceTo(otherPoint: Point): Number
	// Returns the cartesian distance between the current and the given points.
	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	// @method equals(otherPoint: Point): Boolean
	// Returns `true` if the given point has the same coordinates.
	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	// @method contains(otherPoint: Point): Boolean
	// Returns `true` if both coordinates of the given point are less than the corresponding current point coordinates (in absolute values).
	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	// @method toString(): String
	// Returns a string representation of the point for debugging purposes.
	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

// @factory L.point(x: Number, y: Number, round?: Boolean)
// Creates a Point object with the given `x` and `y` coordinates. If optional `round` is set to true, rounds the `x` and `y` values.

// @alternative
// @factory L.point(coords: Number[])
// Expects an array of the form `[x, y]` instead.

// @alternative
// @factory L.point(coords: Object)
// Expects a plain object of the form `{x: Number, y: Number}` instead.
L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	if (typeof x === 'object' && 'x' in x && 'y' in x) {
		return new L.Point(x.x, x.y);
	}
	return new L.Point(x, y, round);
};



/*
 * @class Bounds
 * @aka L.Bounds
 *
 * Represents a rectangular area in pixel coordinates.
 *
 * @example
 *
 * ```js
 * var p1 = L.point(10, 10),
 * p2 = L.point(40, 60),
 * bounds = L.bounds(p1, p2);
 * ```
 *
 * All Leaflet methods that accept `Bounds` objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * otherBounds.intersects([[10, 10], [40, 60]]);
 * ```
 */

L.Bounds = function (a, b) {
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// @method extend(point: Point): this
	// Extends the bounds to contain the given point.
	extend: function (point) { // (Point)
		point = L.point(point);

		// @property min: Point
		// The top left corner of the rectangle.
		// @property max: Point
		// The bottom right corner of the rectangle.
		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	// @method getCenter(round?: Boolean): Point
	// Returns the center point of the bounds.
	getCenter: function (round) {
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	// @method getBottomLeft(): Point
	// Returns the bottom-left point of the bounds.
	getBottomLeft: function () {
		return new L.Point(this.min.x, this.max.y);
	},

	// @method getTopRight(): Point
	// Returns the top-right point of the bounds.
	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	// @method getSize(): Point
	// Returns the size of the given bounds
	getSize: function () {
		return this.max.subtract(this.min);
	},

	// @method contains(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle contains the given one.
	// @alternative
	// @method contains(point: Point): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) {
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	// @method intersects(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds
	// intersect if they have at least one point in common.
	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds
	// overlap if their intersection is an area.
	overlaps: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xOverlaps = (max2.x > min.x) && (min2.x < max.x),
		    yOverlaps = (max2.y > min.y) && (min2.y < max.y);

		return xOverlaps && yOverlaps;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};


// @factory L.bounds(topLeft: Point, bottomRight: Point)
// Creates a Bounds object from two coordinates (usually top-left and bottom-right corners).
// @alternative
// @factory L.bounds(points: Point[])
// Creates a Bounds object from the points it contains
L.bounds = function (a, b) {
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};



/*
 * @class Transformation
 * @aka L.Transformation
 *
 * Represents an affine transformation: a set of coefficients `a`, `b`, `c`, `d`
 * for transforming a point of a form `(x, y)` into `(a*x + b, c*y + d)` and doing
 * the reverse. Used by Leaflet in its projections code.
 *
 * @example
 *
 * ```js
 * var transformation = new L.Transformation(2, 5, -1, 10),
 * 	p = L.point(1, 2),
 * 	p2 = transformation.transform(p), //  L.point(7, 8)
 * 	p3 = transformation.untransform(p2); //  L.point(1, 2)
 * ```
 */


// factory new L.Transformation(a: Number, b: Number, c: Number, d: Number)
// Creates a `Transformation` object with the given coefficients.
L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	// @method transform(point: Point, scale?: Number): Point
	// Returns a transformed point, optionally multiplied by the given scale.
	// Only accepts actual `L.Point` instances, not arrays.
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	// @method untransform(point: Point, scale?: Number): Point
	// Returns the reverse transformation of the given point, optionally divided
	// by the given scale. Only accepts actual `L.Point` instances, not arrays.
	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};



/*
 * @namespace DomUtil
 *
 * Utility functions to work with the [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model)
 * tree, used by Leaflet internally.
 *
 * Most functions expecting or returning a `HTMLElement` also work for
 * SVG elements. The only difference is that classes refer to CSS classes
 * in HTML and SVG classes in SVG.
 */

L.DomUtil = {

	// @function get(id: String|HTMLElement): HTMLElement
	// Returns an element given its DOM id, or returns the element itself
	// if it was passed directly.
	get: function (id) {
		return typeof id === 'string' ? document.getElementById(id) : id;
	},

	// @function getStyle(el: HTMLElement, styleAttrib: String): String
	// Returns the value for a certain style attribute on an element,
	// including computed values or values set through CSS.
	getStyle: function (el, style) {

		var value = el.style[style] || (el.currentStyle && el.currentStyle[style]);

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	// @function create(tagName: String, className?: String, container?: HTMLElement): HTMLElement
	// Creates an HTML element with `tagName`, sets its class to `className`, and optionally appends it to `container` element.
	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className || '';

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	// @function remove(el: HTMLElement)
	// Removes `el` from its parent element
	remove: function (el) {
		var parent = el.parentNode;
		if (parent) {
			parent.removeChild(el);
		}
	},

	// @function empty(el: HTMLElement)
	// Removes all of `el`'s children elements from `el`
	empty: function (el) {
		while (el.firstChild) {
			el.removeChild(el.firstChild);
		}
	},

	// @function toFront(el: HTMLElement)
	// Makes `el` the last children of its parent, so it renders in front of the other children.
	toFront: function (el) {
		el.parentNode.appendChild(el);
	},

	// @function toBack(el: HTMLElement)
	// Makes `el` the first children of its parent, so it renders back from the other children.
	toBack: function (el) {
		var parent = el.parentNode;
		parent.insertBefore(el, parent.firstChild);
	},

	// @function hasClass(el: HTMLElement, name: String): Boolean
	// Returns `true` if the element's class attribute contains `name`.
	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil.getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	// @function addClass(el: HTMLElement, name: String)
	// Adds `name` to the element's class attribute.
	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil.getClass(el);
			L.DomUtil.setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	// @function removeClass(el: HTMLElement, name: String)
	// Removes `name` from the element's class attribute.
	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil.setClass(el, L.Util.trim((' ' + L.DomUtil.getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	// @function setClass(el: HTMLElement, name: String)
	// Sets the element's class.
	setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	// @function getClass(el: HTMLElement): String
	// Returns the element's class.
	getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	// @function setOpacity(el: HTMLElement, opacity: Number)
	// Set the opacity of an element (including old IE support).
	// `opacity` must be a number from `0` to `1`.
	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {
			L.DomUtil._setOpacityIE(el, value);
		}
	},

	_setOpacityIE: function (el, value) {
		var filter = false,
		    filterName = 'DXImageTransform.Microsoft.Alpha';

		// filters collection throws an error if we try to retrieve a filter that doesn't exist
		try {
			filter = el.filters.item(filterName);
		} catch (e) {
			// don't set opacity to 1 if we haven't already set an opacity,
			// it isn't needed and breaks transparent pngs.
			if (value === 1) { return; }
		}

		value = Math.round(value * 100);

		if (filter) {
			filter.Enabled = (value !== 100);
			filter.Opacity = value;
		} else {
			el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
		}
	},

	// @function testProp(props: String[]): String|false
	// Goes through the array of style names and returns the first name
	// that is a valid style name for an element. If no such name is found,
	// it returns false. Useful for vendor-prefixed styles like `transform`.
	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	// @function setTransform(el: HTMLElement, offset: Point, scale?: Number)
	// Resets the 3D CSS transform of `el` so it is translated by `offset` pixels
	// and optionally scaled by `scale`. Does not have an effect if the
	// browser doesn't support 3D CSS transforms.
	setTransform: function (el, offset, scale) {
		var pos = offset || new L.Point(0, 0);

		el.style[L.DomUtil.TRANSFORM] =
			(L.Browser.ie3d ?
				'translate(' + pos.x + 'px,' + pos.y + 'px)' :
				'translate3d(' + pos.x + 'px,' + pos.y + 'px,0)') +
			(scale ? ' scale(' + scale + ')' : '');
	},

	// @function setPosition(el: HTMLElement, position: Point)
	// Sets the position of `el` to coordinates specified by `position`,
	// using CSS translate or top/left positioning depending on the browser
	// (used by Leaflet internally to position its layers).
	setPosition: function (el, point) { // (HTMLElement, Point[, Boolean])

		/*eslint-disable */
		el._leaflet_pos = point;
		/*eslint-enable */

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(el, point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	// @function getPosition(el: HTMLElement): Point
	// Returns the coordinates of an element previously positioned with setPosition.
	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		return el._leaflet_pos || new L.Point(0, 0);
	}
};


(function () {
	// prefix style property names

	// @property TRANSFORM: String
	// Vendor-prefixed fransform style name (e.g. `'webkitTransform'` for WebKit).
	L.DomUtil.TRANSFORM = L.DomUtil.testProp(
			['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);


	// webkitTransition comes first because some browser versions that drop vendor prefix don't do
	// the same for the transitionend event, in particular the Android 4.1 stock browser

	// @property TRANSITION: String
	// Vendor-prefixed transform style name.
	var transition = L.DomUtil.TRANSITION = L.DomUtil.testProp(
			['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

	L.DomUtil.TRANSITION_END =
			transition === 'webkitTransition' || transition === 'OTransition' ? transition + 'End' : 'transitionend';

	// @function disableTextSelection()
	// Prevents the user from generating `selectstart` DOM events, usually generated
	// when the user drags the mouse through a page with text. Used internally
	// by Leaflet to override the behaviour of any click-and-drag interaction on
	// the map. Affects drag interactions on the whole document.

	// @function enableTextSelection()
	// Cancels the effects of a previous [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection).
	if ('onselectstart' in document) {
		L.DomUtil.disableTextSelection = function () {
			L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
		};
		L.DomUtil.enableTextSelection = function () {
			L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
		};

	} else {
		var userSelectProperty = L.DomUtil.testProp(
			['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

		L.DomUtil.disableTextSelection = function () {
			if (userSelectProperty) {
				var style = document.documentElement.style;
				this._userSelect = style[userSelectProperty];
				style[userSelectProperty] = 'none';
			}
		};
		L.DomUtil.enableTextSelection = function () {
			if (userSelectProperty) {
				document.documentElement.style[userSelectProperty] = this._userSelect;
				delete this._userSelect;
			}
		};
	}

	// @function disableImageDrag()
	// As [`L.DomUtil.disableTextSelection`](#domutil-disabletextselection), but
	// for `dragstart` DOM events, usually generated when the user drags an image.
	L.DomUtil.disableImageDrag = function () {
		L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function enableImageDrag()
	// Cancels the effects of a previous [`L.DomUtil.disableImageDrag`](#domutil-disabletextselection).
	L.DomUtil.enableImageDrag = function () {
		L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
	};

	// @function preventOutline(el: HTMLElement)
	// Makes the [outline](https://developer.mozilla.org/docs/Web/CSS/outline)
	// of the element `el` invisible. Used internally by Leaflet to prevent
	// focusable elements from displaying an outline when the user performs a
	// drag interaction on them.
	L.DomUtil.preventOutline = function (element) {
		while (element.tabIndex === -1) {
			element = element.parentNode;
		}
		if (!element || !element.style) { return; }
		L.DomUtil.restoreOutline();
		this._outlineElement = element;
		this._outlineStyle = element.style.outline;
		element.style.outline = 'none';
		L.DomEvent.on(window, 'keydown', L.DomUtil.restoreOutline, this);
	};

	// @function restoreOutline()
	// Cancels the effects of a previous [`L.DomUtil.preventOutline`]().
	L.DomUtil.restoreOutline = function () {
		if (!this._outlineElement) { return; }
		this._outlineElement.style.outline = this._outlineStyle;
		delete this._outlineElement;
		delete this._outlineStyle;
		L.DomEvent.off(window, 'keydown', L.DomUtil.restoreOutline, this);
	};
})();



/* @class LatLng
 * @aka L.LatLng
 *
 * Represents a geographical point with a certain latitude and longitude.
 *
 * @example
 *
 * ```
 * var latlng = L.latLng(50.5, 30.5);
 * ```
 *
 * All Leaflet methods that accept LatLng objects also accept them in a simple Array form and simple object form (unless noted otherwise), so these lines are equivalent:
 *
 * ```
 * map.panTo([50, 30]);
 * map.panTo({lon: 30, lat: 50});
 * map.panTo({lat: 50, lng: 30});
 * map.panTo(L.latLng(50, 30));
 * ```
 */

L.LatLng = function (lat, lng, alt) {
	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	// @property lat: Number
	// Latitude in degrees
	this.lat = +lat;

	// @property lng: Number
	// Longitude in degrees
	this.lng = +lng;

	// @property alt: Number
	// Altitude in meters (optional)
	if (alt !== undefined) {
		this.alt = +alt;
	}
};

L.LatLng.prototype = {
	// @method equals(otherLatLng: LatLng, maxMargin?: Number): Boolean
	// Returns `true` if the given `LatLng` point is at the same position (within a small margin of error). The margin of error can be overriden by setting `maxMargin` to a small number.
	equals: function (obj, maxMargin) {
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= (maxMargin === undefined ? 1.0E-9 : maxMargin);
	},

	// @method toString(): String
	// Returns a string representation of the point (for debugging purposes).
	toString: function (precision) {
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// @method distanceTo(otherLatLng: LatLng): Number
	// Returns the distance (in meters) to the given `LatLng` calculated using the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula).
	distanceTo: function (other) {
		return L.CRS.Earth.distance(this, L.latLng(other));
	},

	// @method wrap(): LatLng
	// Returns a new `LatLng` object with the longitude wrapped so it's always between -180 and +180 degrees.
	wrap: function () {
		return L.CRS.Earth.wrapLatLng(this);
	},

	// @method toBounds(sizeInMeters: Number): LatLngBounds
	// Returns a new `LatLngBounds` object in which each boundary is `sizeInMeters/2` meters apart from the `LatLng`.
	toBounds: function (sizeInMeters) {
		var latAccuracy = 180 * sizeInMeters / 40075017,
		    lngAccuracy = latAccuracy / Math.cos((Math.PI / 180) * this.lat);

		return L.latLngBounds(
		        [this.lat - latAccuracy, this.lng - lngAccuracy],
		        [this.lat + latAccuracy, this.lng + lngAccuracy]);
	},

	clone: function () {
		return new L.LatLng(this.lat, this.lng, this.alt);
	}
};



// @factory L.latLng(latitude: Number, longitude: Number, altitude?: Number): LatLng
// Creates an object representing a geographical point with the given latitude and longitude (and optionally altitude).

// @alternative
// @factory L.latLng(coords: Array): LatLng
// Expects an array of the form `[Number, Number]` or `[Number, Number, Number]` instead.

// @alternative
// @factory L.latLng(coords: Object): LatLng
// Expects an plain object of the form `{lat: Number, lng: Number}` or `{lat: Number, lng: Number, alt: Number}` instead.

L.latLng = function (a, b, c) {
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a) && typeof a[0] !== 'object') {
		if (a.length === 3) {
			return new L.LatLng(a[0], a[1], a[2]);
		}
		if (a.length === 2) {
			return new L.LatLng(a[0], a[1]);
		}
		return null;
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon, a.alt);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b, c);
};



/*
 * @class LatLngBounds
 * @aka L.LatLngBounds
 *
 * Represents a rectangular geographical area on a map.
 *
 * @example
 *
 * ```js
 * var corner1 = L.latLng(40.712, -74.227),
 * corner2 = L.latLng(40.774, -74.125),
 * bounds = L.latLngBounds(corner1, corner2);
 * ```
 *
 * All Leaflet methods that accept LatLngBounds objects also accept them in a simple Array form (unless noted otherwise), so the bounds example above can be passed like this:
 *
 * ```js
 * map.fitBounds([
 * 	[40.712, -74.227],
 * 	[40.774, -74.125]
 * ]);
 * ```
 *
 * Caution: if the area crosses the antimeridian (often confused with the International Date Line), you must specify corners _outside_ the [-180, 180] degrees longitude range.
 */

L.LatLngBounds = function (corner1, corner2) { // (LatLng, LatLng) or (LatLng[])
	if (!corner1) { return; }

	var latlngs = corner2 ? [corner1, corner2] : corner1;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {

	// @method extend(latlng: LatLng): this
	// Extend the bounds to contain the given point

	// @alternative
	// @method extend(otherBounds: LatLngBounds): this
	// Extend the bounds to contain the given bounds
	extend: function (obj) {
		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLng) {
			sw2 = obj;
			ne2 = obj;

		} else if (obj instanceof L.LatLngBounds) {
			sw2 = obj._southWest;
			ne2 = obj._northEast;

			if (!sw2 || !ne2) { return this; }

		} else {
			return obj ? this.extend(L.latLng(obj) || L.latLngBounds(obj)) : this;
		}

		if (!sw && !ne) {
			this._southWest = new L.LatLng(sw2.lat, sw2.lng);
			this._northEast = new L.LatLng(ne2.lat, ne2.lng);
		} else {
			sw.lat = Math.min(sw2.lat, sw.lat);
			sw.lng = Math.min(sw2.lng, sw.lng);
			ne.lat = Math.max(ne2.lat, ne.lat);
			ne.lng = Math.max(ne2.lng, ne.lng);
		}

		return this;
	},

	// @method pad(bufferRatio: Number): LatLngBounds
	// Returns bigger bounds created by extending the current bounds by a given percentage in each direction.
	pad: function (bufferRatio) {
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	// @method getCenter(): LatLng
	// Returns the center point of the bounds.
	getCenter: function () {
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	// @method getSouthWest(): LatLng
	// Returns the south-west point of the bounds.
	getSouthWest: function () {
		return this._southWest;
	},

	// @method getNorthEast(): LatLng
	// Returns the north-east point of the bounds.
	getNorthEast: function () {
		return this._northEast;
	},

	// @method getNorthWest(): LatLng
	// Returns the north-west point of the bounds.
	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	// @method getSouthEast(): LatLng
	// Returns the south-east point of the bounds.
	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	// @method getWest(): Number
	// Returns the west longitude of the bounds
	getWest: function () {
		return this._southWest.lng;
	},

	// @method getSouth(): Number
	// Returns the south latitude of the bounds
	getSouth: function () {
		return this._southWest.lat;
	},

	// @method getEast(): Number
	// Returns the east longitude of the bounds
	getEast: function () {
		return this._northEast.lng;
	},

	// @method getNorth(): Number
	// Returns the north latitude of the bounds
	getNorth: function () {
		return this._northEast.lat;
	},

	// @method contains(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle contains the given one.

	// @alternative
	// @method contains (latlng: LatLng): Boolean
	// Returns `true` if the rectangle contains the given point.
	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng || 'lat' in obj) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	// @method intersects(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle intersects the given bounds. Two bounds intersect if they have at least one point in common.
	intersects: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	// @method overlaps(otherBounds: Bounds): Boolean
	// Returns `true` if the rectangle overlaps the given bounds. Two bounds overlap if their intersection is an area.
	overlaps: function (bounds) {
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latOverlaps = (ne2.lat > sw.lat) && (sw2.lat < ne.lat),
		    lngOverlaps = (ne2.lng > sw.lng) && (sw2.lng < ne.lng);

		return latOverlaps && lngOverlaps;
	},

	// @method toBBoxString(): String
	// Returns a string with bounding box coordinates in a 'southwest_lng,southwest_lat,northeast_lng,northeast_lat' format. Useful for sending requests to web services that return geo data.
	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	// @method equals(otherBounds: LatLngBounds): Boolean
	// Returns `true` if the rectangle is equivalent (within a small margin of error) to the given bounds.
	equals: function (bounds) {
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	// @method isValid(): Boolean
	// Returns `true` if the bounds are properly initialized.
	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

// TODO International date line?

// @factory L.latLngBounds(corner1: LatLng, corner2: LatLng)
// Creates a `LatLngBounds` object by defining two diagonally opposite corners of the rectangle.

// @alternative
// @factory L.latLngBounds(latlngs: LatLng[])
// Creates a `LatLngBounds` object defined by the geographical points it contains. Very useful for zooming the map to fit a particular set of locations with [`fitBounds`](#map-fitbounds).
L.latLngBounds = function (a, b) {
	if (a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};



/*
 * @namespace Projection
 * @section
 * Leaflet comes with a set of already defined Projections out of the box:
 *
 * @projection L.Projection.LonLat
 *
 * Equirectangular, or Plate Carree projection — the most simple projection,
 * mostly used by GIS enthusiasts. Directly maps `x` as longitude, and `y` as
 * latitude. Also suitable for flat worlds, e.g. game maps. Used by the
 * `EPSG:3395` and `Simple` CRS.
 */

L.Projection = {};

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	},

	bounds: L.bounds([-180, -90], [180, 90])
};



/*
 * @namespace Projection
 * @projection L.Projection.SphericalMercator
 *
 * Spherical Mercator projection — the most common projection for online maps,
 * used by almost all free and commercial tile providers. Assumes that Earth is
 * a sphere. Used by the `EPSG:3857` CRS.
 */

L.Projection.SphericalMercator = {

	R: 6378137,
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) {
		var d = Math.PI / 180,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    sin = Math.sin(lat * d);

		return new L.Point(
				this.R * latlng.lng * d,
				this.R * Math.log((1 + sin) / (1 - sin)) / 2);
	},

	unproject: function (point) {
		var d = 180 / Math.PI;

		return new L.LatLng(
			(2 * Math.atan(Math.exp(point.y / this.R)) - (Math.PI / 2)) * d,
			point.x * d / this.R);
	},

	bounds: (function () {
		var d = 6378137 * Math.PI;
		return L.bounds([-d, -d], [d, d]);
	})()
};



/*
 * @class CRS
 * @aka L.CRS
 * Abstract class that defines coordinate reference systems for projecting
 * geographical points into pixel (screen) coordinates and back (and to
 * coordinates in other units for [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services). See
 * [spatial reference system](http://en.wikipedia.org/wiki/Coordinate_reference_system).
 *
 * Leaflet defines the most usual CRSs by default. If you want to use a
 * CRS not defined by default, take a look at the
 * [Proj4Leaflet](https://github.com/kartena/Proj4Leaflet) plugin.
 */

L.CRS = {
	// @method latLngToPoint(latlng: LatLng, zoom: Number): Point
	// Projects geographical coordinates into pixel coordinates for a given zoom.
	latLngToPoint: function (latlng, zoom) {
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	// @method pointToLatLng(point: Point, zoom: Number): LatLng
	// The inverse of `latLngToPoint`. Projects pixel coordinates on a given
	// zoom into geographical coordinates.
	pointToLatLng: function (point, zoom) {
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	// @method project(latlng: LatLng): Point
	// Projects geographical coordinates into coordinates in units accepted for
	// this CRS (e.g. meters for EPSG:3857, for passing it to WMS services).
	project: function (latlng) {
		return this.projection.project(latlng);
	},

	// @method unproject(point: Point): LatLng
	// Given a projected coordinate returns the corresponding LatLng.
	// The inverse of `project`.
	unproject: function (point) {
		return this.projection.unproject(point);
	},

	// @method scale(zoom: Number): Number
	// Returns the scale used when transforming projected coordinates into
	// pixel coordinates for a particular zoom. For example, it returns
	// `256 * 2^zoom` for Mercator-based CRS.
	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	// @method zoom(scale: Number): Number
	// Inverse of `scale()`, returns the zoom level corresponding to a scale
	// factor of `scale`.
	zoom: function (scale) {
		return Math.log(scale / 256) / Math.LN2;
	},

	// @method getProjectedBounds(zoom: Number): Bounds
	// Returns the projection's bounds scaled and transformed for the provided `zoom`.
	getProjectedBounds: function (zoom) {
		if (this.infinite) { return null; }

		var b = this.projection.bounds,
		    s = this.scale(zoom),
		    min = this.transformation.transform(b.min, s),
		    max = this.transformation.transform(b.max, s);

		return L.bounds(min, max);
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates.

	// @property code: String
	// Standard code name of the CRS passed into WMS services (e.g. `'EPSG:3857'`)
	//
	// @property wrapLng: Number[]
	// An array of two numbers defining whether the longitude (horizontal) coordinate
	// axis wraps around a given range and how. Defaults to `[-180, 180]` in most
	// geographical CRSs. If `undefined`, the longitude axis does not wrap around.
	//
	// @property wrapLat: Number[]
	// Like `wrapLng`, but for the latitude (vertical) axis.

	// wrapLng: [min, max],
	// wrapLat: [min, max],

	// @property infinite: Boolean
	// If true, the coordinate space will be unbounded (infinite in both axes)
	infinite: false,

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where lat and lng has been wrapped according to the
	// CRS's `wrapLat` and `wrapLng` properties, if they are outside the CRS's bounds.
	// Only accepts actual `L.LatLng` instances, not arrays.
	wrapLatLng: function (latlng) {
		var lng = this.wrapLng ? L.Util.wrapNum(latlng.lng, this.wrapLng, true) : latlng.lng,
		    lat = this.wrapLat ? L.Util.wrapNum(latlng.lat, this.wrapLat, true) : latlng.lat,
		    alt = latlng.alt;

		return L.latLng(lat, lng, alt);
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring
	// that its center is within the CRS's bounds.
	// Only accepts actual `L.LatLngBounds` instances, not arrays.
	wrapLatLngBounds: function (bounds) {
		var center = bounds.getCenter(),
		    newCenter = this.wrapLatLng(center),
		    latShift = center.lat - newCenter.lat,
		    lngShift = center.lng - newCenter.lng;

		if (latShift === 0 && lngShift === 0) {
			return bounds;
		}

		var sw = bounds.getSouthWest(),
		    ne = bounds.getNorthEast(),
		    newSw = L.latLng({lat: sw.lat - latShift, lng: sw.lng - lngShift}),
		    newNe = L.latLng({lat: ne.lat - latShift, lng: ne.lng - lngShift});

		return new L.LatLngBounds(newSw, newNe);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.Simple
 *
 * A simple CRS that maps longitude and latitude into `x` and `y` directly.
 * May be used for maps of flat surfaces (e.g. game maps). Note that the `y`
 * axis should still be inverted (going from bottom to top). `distance()` returns
 * simple euclidean distance.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	},

	zoom: function (scale) {
		return Math.log(scale) / Math.LN2;
	},

	distance: function (latlng1, latlng2) {
		var dx = latlng2.lng - latlng1.lng,
		    dy = latlng2.lat - latlng1.lat;

		return Math.sqrt(dx * dx + dy * dy);
	},

	infinite: true
});



/*
 * @namespace CRS
 * @crs L.CRS.Earth
 *
 * Serves as the base for CRS that are global such that they cover the earth.
 * Can only be used as the base for other CRS and cannot be used directly,
 * since it does not have a `code`, `projection` or `transformation`. `distance()` returns
 * meters.
 */

L.CRS.Earth = L.extend({}, L.CRS, {
	wrapLng: [-180, 180],

	// Mean Earth Radius, as recommended for use by
	// the International Union of Geodesy and Geophysics,
	// see http://rosettacode.org/wiki/Haversine_formula
	R: 6371000,

	// distance between two geographical points using spherical law of cosines approximation
	distance: function (latlng1, latlng2) {
		var rad = Math.PI / 180,
		    lat1 = latlng1.lat * rad,
		    lat2 = latlng2.lat * rad,
		    a = Math.sin(lat1) * Math.sin(lat2) +
		        Math.cos(lat1) * Math.cos(lat2) * Math.cos((latlng2.lng - latlng1.lng) * rad);

		return this.R * Math.acos(Math.min(a, 1));
	}
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3857
 *
 * The most common CRS for online maps, used by almost all free and commercial
 * tile providers. Uses Spherical Mercator projection. Set in by default in
 * Map's `crs` option.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3857',
	projection: L.Projection.SphericalMercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.SphericalMercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});



/*
 * @namespace CRS
 * @crs L.CRS.EPSG4326
 *
 * A common CRS among GIS enthusiasts. Uses simple Equirectangular projection.
 *
 * Leaflet 1.0.x complies with the [TMS coordinate scheme for EPSG:4326](https://wiki.osgeo.org/wiki/Tile_Map_Service_Specification#global-geodetic),
 * which is a breaking change from 0.7.x behaviour.  If you are using a `TileLayer`
 * with this CRS, ensure that there are two 256x256 pixel tiles covering the
 * whole earth at zoom level zero, and that the tile coordinate origin is (-180,+90),
 * or (-180,-90) for `TileLayer`s with [the `tms` option](#tilelayer-tms) set.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:4326',
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 180, 1, -1 / 180, 0.5)
});



/*
 * @class Map
 * @aka L.Map
 * @inherits Evented
 *
 * The central class of the API — it is used to create a map on a page and manipulate it.
 *
 * @example
 *
 * ```js
 * // initialize the map on the "map" div with a given center and zoom
 * var map = L.map('map', {
 * 	center: [51.505, -0.09],
 * 	zoom: 13
 * });
 * ```
 *
 */

L.Map = L.Evented.extend({

	options: {
		// @section Map State Options
		// @option crs: CRS = L.CRS.EPSG3857
		// The [Coordinate Reference System](#crs) to use. Don't change this if you're not
		// sure what it means.
		crs: L.CRS.EPSG3857,

		// @option center: LatLng = undefined
		// Initial geographic center of the map
		center: undefined,

		// @option zoom: Number = undefined
		// Initial map zoom level
		zoom: undefined,

		// @option minZoom: Number = undefined
		// Minimum zoom level of the map. Overrides any `minZoom` option set on map layers.
		minZoom: undefined,

		// @option maxZoom: Number = undefined
		// Maximum zoom level of the map. Overrides any `maxZoom` option set on map layers.
		maxZoom: undefined,

		// @option layers: Layer[] = []
		// Array of layers that will be added to the map initially
		layers: [],

		// @option maxBounds: LatLngBounds = null
		// When this option is set, the map restricts the view to the given
		// geographical bounds, bouncing the user back if the user tries to pan
		// outside the view. To set the restriction dynamically, use
		// [`setMaxBounds`](#map-setmaxbounds) method.
		maxBounds: undefined,

		// @option renderer: Renderer = *
		// The default method for drawing vector layers on the map. `L.SVG`
		// or `L.Canvas` by default depending on browser support.
		renderer: undefined,


		// @section Animation Options
		// @option zoomAnimation: Boolean = true
		// Whether the map zoom animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		zoomAnimation: true,

		// @option zoomAnimationThreshold: Number = 4
		// Won't animate zoom if the zoom difference exceeds this value.
		zoomAnimationThreshold: 4,

		// @option fadeAnimation: Boolean = true
		// Whether the tile fade animation is enabled. By default it's enabled
		// in all browsers that support CSS3 Transitions except Android.
		fadeAnimation: true,

		// @option markerZoomAnimation: Boolean = true
		// Whether markers animate their zoom with the zoom animation, if disabled
		// they will disappear for the length of the animation. By default it's
		// enabled in all browsers that support CSS3 Transitions except Android.
		markerZoomAnimation: true,

		// @option transform3DLimit: Number = 2^23
		// Defines the maximum size of a CSS translation transform. The default
		// value should not be changed unless a web browser positions layers in
		// the wrong place after doing a large `panBy`.
		transform3DLimit: 8388608, // Precision limit of a 32-bit float

		// @section Interaction Options
		// @option zoomSnap: Number = 1
		// Forces the map's zoom level to always be a multiple of this, particularly
		// right after a [`fitBounds()`](#map-fitbounds) or a pinch-zoom.
		// By default, the zoom level snaps to the nearest integer; lower values
		// (e.g. `0.5` or `0.1`) allow for greater granularity. A value of `0`
		// means the zoom level will not be snapped after `fitBounds` or a pinch-zoom.
		zoomSnap: 1,

		// @option zoomDelta: Number = 1
		// Controls how much the map's zoom level will change after a
		// [`zoomIn()`](#map-zoomin), [`zoomOut()`](#map-zoomout), pressing `+`
		// or `-` on the keyboard, or using the [zoom controls](#control-zoom).
		// Values smaller than `1` (e.g. `0.5`) allow for greater granularity.
		zoomDelta: 1,

		// @option trackResize: Boolean = true
		// Whether the map automatically handles browser window resize to update itself.
		trackResize: true
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);

		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.zoom !== undefined) {
			this._zoom = this._limitZoom(options.zoom);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];
		this._layers = {};
		this._zoomBoundLayers = {};
		this._sizeChanged = true;

		this.callInitHooks();

		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = L.DomUtil.TRANSITION && L.Browser.any3d && !L.Browser.mobileOpera &&
				this.options.zoomAnimation;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			this._createAnimProxy();
			L.DomEvent.on(this._proxy, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}

		this._addLayers(this.options.layers);
	},


	// @section Methods for modifying map state

	// @method setView(center: LatLng, zoom: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) with the given
	// animation options.
	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		this._stop();

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate, duration: options.duration}, options.pan);
			}

			// try animating pan or zoom
			var moved = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (moved) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	// @method setZoom(zoom: Number, options: Zoom/pan options): this
	// Sets the zoom of the map.
	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = zoom;
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	// @method zoomIn(delta?: Number, options?: Zoom options): this
	// Increases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomIn: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom + delta, options);
	},

	// @method zoomOut(delta?: Number, options?: Zoom options): this
	// Decreases the zoom of the map by `delta` ([`zoomDelta`](#map-zoomdelta) by default).
	zoomOut: function (delta, options) {
		delta = delta || (L.Browser.any3d ? this.options.zoomDelta : 1);
		return this.setZoom(this._zoom - delta, options);
	},

	// @method setZoomAround(latlng: LatLng, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified geographical point on the map
	// stationary (e.g. used internally for scroll zoom and double-click zoom).
	// @alternative
	// @method setZoomAround(offset: Point, zoom: Number, options: Zoom options): this
	// Zooms the map while keeping a specified pixel on the map (relative to the top-left corner) stationary.
	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	_getBoundsCenterZoom: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR));

		zoom = (typeof options.maxZoom === 'number') ? Math.min(options.maxZoom, zoom) : zoom;

		var paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		return {
			center: center,
			zoom: zoom
		};
	},

	// @method fitBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets a map view that contains the given geographical bounds with the
	// maximum zoom level possible.
	fitBounds: function (bounds, options) {

		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			throw new Error('Bounds are not valid.');
		}

		var target = this._getBoundsCenterZoom(bounds, options);
		return this.setView(target.center, target.zoom, options);
	},

	// @method fitWorld(options?: fitBounds options): this
	// Sets a map view that mostly contains the whole world with the maximum
	// zoom level possible.
	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	// @method panTo(latlng: LatLng, options?: Pan options): this
	// Pans the map to a given center.
	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	// @method panBy(offset: Point): this
	// Pans the map by a given number of pixels (animated).
	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this.fire('moveend');
		}
		// If we pan too far, Chrome gets issues with tiles
		// and makes them disappear or appear in the wrong place (slightly offset) #2602
		if (options.animate !== true && !this.getSize().contains(offset)) {
			this._resetView(this.unproject(this.project(this.getCenter()).add(offset)), this.getZoom());
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset).round();
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	// @method flyTo(latlng: LatLng, zoom?: Number, options?: Zoom/pan options): this
	// Sets the view of the map (geographical center and zoom) performing a smooth
	// pan-zoom animation.
	flyTo: function (targetCenter, targetZoom, options) {

		options = options || {};
		if (options.animate === false || !L.Browser.any3d) {
			return this.setView(targetCenter, targetZoom, options);
		}

		this._stop();

		var from = this.project(this.getCenter()),
		    to = this.project(targetCenter),
		    size = this.getSize(),
		    startZoom = this._zoom;

		targetCenter = L.latLng(targetCenter);
		targetZoom = targetZoom === undefined ? startZoom : targetZoom;

		var w0 = Math.max(size.x, size.y),
		    w1 = w0 * this.getZoomScale(startZoom, targetZoom),
		    u1 = (to.distanceTo(from)) || 1,
		    rho = 1.42,
		    rho2 = rho * rho;

		function r(i) {
			var s1 = i ? -1 : 1,
			    s2 = i ? w1 : w0,
			    t1 = w1 * w1 - w0 * w0 + s1 * rho2 * rho2 * u1 * u1,
			    b1 = 2 * s2 * rho2 * u1,
			    b = t1 / b1,
			    sq = Math.sqrt(b * b + 1) - b;

			    // workaround for floating point precision bug when sq = 0, log = -Infinite,
			    // thus triggering an infinite loop in flyTo
			    var log = sq < 0.000000001 ? -18 : Math.log(sq);

			return log;
		}

		function sinh(n) { return (Math.exp(n) - Math.exp(-n)) / 2; }
		function cosh(n) { return (Math.exp(n) + Math.exp(-n)) / 2; }
		function tanh(n) { return sinh(n) / cosh(n); }

		var r0 = r(0);

		function w(s) { return w0 * (cosh(r0) / cosh(r0 + rho * s)); }
		function u(s) { return w0 * (cosh(r0) * tanh(r0 + rho * s) - sinh(r0)) / rho2; }

		function easeOut(t) { return 1 - Math.pow(1 - t, 1.5); }

		var start = Date.now(),
		    S = (r(1) - r0) / rho,
		    duration = options.duration ? 1000 * options.duration : 1000 * S * 0.8;

		function frame() {
			var t = (Date.now() - start) / duration,
			    s = easeOut(t) * S;

			if (t <= 1) {
				this._flyToFrame = L.Util.requestAnimFrame(frame, this);

				this._move(
					this.unproject(from.add(to.subtract(from).multiplyBy(u(s) / u1)), startZoom),
					this.getScaleZoom(w0 / w(s), startZoom),
					{flyTo: true});

			} else {
				this
					._move(targetCenter, targetZoom)
					._moveEnd(true);
			}
		}

		this._moveStart(true);

		frame.call(this);
		return this;
	},

	// @method flyToBounds(bounds: LatLngBounds, options?: fitBounds options): this
	// Sets the view of the map with a smooth animation like [`flyTo`](#map-flyto),
	// but takes a bounds parameter like [`fitBounds`](#map-fitbounds).
	flyToBounds: function (bounds, options) {
		var target = this._getBoundsCenterZoom(bounds, options);
		return this.flyTo(target.center, target.zoom, options);
	},

	// @method setMaxBounds(bounds: Bounds): this
	// Restricts the map view to the given bounds (see the [maxBounds](#map-maxbounds) option).
	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		if (!bounds.isValid()) {
			this.options.maxBounds = null;
			return this.off('moveend', this._panInsideMaxBounds);
		} else if (this.options.maxBounds) {
			this.off('moveend', this._panInsideMaxBounds);
		}

		this.options.maxBounds = bounds;

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds);
	},

	// @method setMinZoom(zoom: Number): this
	// Sets the lower limit for the available zoom levels (see the [minZoom](#map-minzoom) option).
	setMinZoom: function (zoom) {
		this.options.minZoom = zoom;

		if (this._loaded && this.getZoom() < this.options.minZoom) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method setMaxZoom(zoom: Number): this
	// Sets the upper limit for the available zoom levels (see the [maxZoom](#map-maxzoom) option).
	setMaxZoom: function (zoom) {
		this.options.maxZoom = zoom;

		if (this._loaded && (this.getZoom() > this.options.maxZoom)) {
			return this.setZoom(zoom);
		}

		return this;
	},

	// @method panInsideBounds(bounds: LatLngBounds, options?: Pan options): this
	// Pans the map to the closest view that would lie inside the given bounds (if it's not already), controlling the animation using the options specific, if any.
	panInsideBounds: function (bounds, options) {
		this._enforcingBounds = true;
		var center = this.getCenter(),
		    newCenter = this._limitCenter(center, this._zoom, L.latLngBounds(bounds));

		if (!center.equals(newCenter)) {
			this.panTo(newCenter, options);
		}

		this._enforcingBounds = false;
		return this;
	},

	// @method invalidateSize(options: Zoom/Pan options): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default. If `options.pan` is `false`, panning will not occur.
	// If `options.debounceMoveend` is `true`, it will delay `moveend` event so
	// that it doesn't happen often even if the method is called many
	// times in a row.

	// @alternative
	// @method invalidateSize(animate: Boolean): this
	// Checks if the map container size changed and updates the map if so —
	// call it after you've changed the map size dynamically, also animating
	// pan by default.
	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._lastCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		// @section Map state change events
		// @event resize: ResizeEvent
		// Fired when the map is resized.
		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// @section Methods for modifying map state
	// @method stop(): this
	// Stops the currently running `panTo` or `flyTo` animation, if any.
	stop: function () {
		this.setZoom(this._limitZoom(this._zoom));
		if (!this.options.zoomSnap) {
			this.fire('viewreset');
		}
		return this._stop();
	},

	// @section Geolocation methods
	// @method locate(options?: Locate options): this
	// Tries to locate the user using the Geolocation API, firing a [`locationfound`](#map-locationfound)
	// event with location data on success or a [`locationerror`](#map-locationerror) event on failure,
	// and optionally sets the map view to the user's location with respect to
	// detection accuracy (or to the world view if geolocation failed).
	// Note that, if your page doesn't use HTTPS, this method will fail in
	// modern browsers ([Chrome 50 and newer](https://sites.google.com/a/chromium.org/dev/Home/chromium-security/deprecating-powerful-features-on-insecure-origins))
	// See `Locate options` for more details.
	locate: function (options) {

		options = this._locateOptions = L.extend({
			timeout: 10000,
			watch: false
			// setView: false
			// maxZoom: <Number>
			// maximumAge: 0
			// enableHighAccuracy: false
		}, options);

		if (!('geolocation' in navigator)) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
		    onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	// @method stopLocate(): this
	// Stops watching location previously initiated by `map.locate({watch: true})`
	// and aborts resetting the map view if map.locate was called with
	// `{setView: true}`.
	stopLocate: function () {
		if (navigator.geolocation && navigator.geolocation.clearWatch) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		// @section Location events
		// @event locationerror: ErrorEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method) failed.
		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),
		    bounds = latlng.toBounds(pos.coords.accuracy),
		    options = this._locateOptions;

		if (options.setView) {
			var zoom = this.getBoundsZoom(bounds);
			this.setView(latlng, options.maxZoom ? Math.min(zoom, options.maxZoom) : zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		// @event locationfound: LocationEvent
		// Fired when geolocation (using the [`locate`](#map-locate) method)
		// went successfully.
		this.fire('locationfound', data);
	},

	// TODO handler.addTo
	// TODO Appropiate docs section?
	// @section Other Methods
	// @method addHandler(name: String, HandlerClass: Function): this
	// Adds a new `Handler` to the map, given its name and constructor function.
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	// @method remove(): this
	// Destroys the map and clears all related event listeners.
	remove: function () {

		this._initEvents(true);

		if (this._containerId !== this._container._leaflet_id) {
			throw new Error('Map container is being reused by another instance');
		}

		try {
			// throws error in IE6-8
			delete this._container._leaflet_id;
			delete this._containerId;
		} catch (e) {
			/*eslint-disable */
			this._container._leaflet_id = undefined;
			/*eslint-enable */
			this._containerId = undefined;
		}

		L.DomUtil.remove(this._mapPane);

		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		if (this._loaded) {
			// @section Map state change events
			// @event unload: Event
			// Fired when the map is destroyed with [remove](#map-remove) method.
			this.fire('unload');
		}

		for (var i in this._layers) {
			this._layers[i].remove();
		}

		return this;
	},

	// @section Other Methods
	// @method createPane(name: String, container?: HTMLElement): HTMLElement
	// Creates a new [map pane](#map-pane) with the given name if it doesn't exist already,
	// then returns it. The pane is created as a children of `container`, or
	// as a children of the main map pane if not set.
	createPane: function (name, container) {
		var className = 'leaflet-pane' + (name ? ' leaflet-' + name.replace('Pane', '') + '-pane' : ''),
		    pane = L.DomUtil.create('div', className, container || this._mapPane);

		if (name) {
			this._panes[name] = pane;
		}
		return pane;
	},

	// @section Methods for Getting Map State

	// @method getCenter(): LatLng
	// Returns the geographical center of the map view
	getCenter: function () {
		this._checkIfLoaded();

		if (this._lastCenter && !this._moved()) {
			return this._lastCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	// @method getZoom(): Number
	// Returns the current zoom level of the map view
	getZoom: function () {
		return this._zoom;
	},

	// @method getBounds(): LatLngBounds
	// Returns the geographical bounds visible in the current map view
	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	// @method getMinZoom(): Number
	// Returns the minimum zoom level of the map (if set in the `minZoom` option of the map or of any layers), or `0` by default.
	getMinZoom: function () {
		return this.options.minZoom === undefined ? this._layersMinZoom || 0 : this.options.minZoom;
	},

	// @method getMaxZoom(): Number
	// Returns the maximum zoom level of the map (if set in the `maxZoom` option of the map or of any layers).
	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	// @method getBoundsZoom(bounds: LatLngBounds, inside?: Boolean): Number
	// Returns the maximum zoom level on which the given bounds fit to the map
	// view in its entirety. If `inside` (optional) is set to `true`, the method
	// instead returns the minimum zoom level on which the map view fits into
	// the given bounds in its entirety.
	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);
		padding = L.point(padding || [0, 0]);

		var zoom = this.getZoom() || 0,
		    min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),
		    size = this.getSize().subtract(padding),
		    boundsSize = L.bounds(this.project(se, zoom), this.project(nw, zoom)).getSize(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;

		var scale = Math.min(size.x / boundsSize.x, size.y / boundsSize.y);
		zoom = this.getScaleZoom(scale, zoom);

		if (snap) {
			zoom = Math.round(zoom / (snap / 100)) * (snap / 100); // don't jump if within 1% of a snap level
			zoom = inside ? Math.ceil(zoom / snap) * snap : Math.floor(zoom / snap) * snap;
		}

		return Math.max(min, Math.min(max, zoom));
	},

	// @method getSize(): Point
	// Returns the current size of the map container (in pixels).
	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth || 0,
				this._container.clientHeight || 0);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	// @method getPixelBounds(): Bounds
	// Returns the bounds of the current map view in projected pixel
	// coordinates (sometimes useful in layer and overlay implementations).
	getPixelBounds: function (center, zoom) {
		var topLeftPoint = this._getTopLeftPoint(center, zoom);
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	// TODO: Check semantics - isn't the pixel origin the 0,0 coord relative to
	// the map pane? "left point of the map layer" can be confusing, specially
	// since there can be negative offsets.
	// @method getPixelOrigin(): Point
	// Returns the projected pixel coordinates of the top left point of
	// the map layer (useful in custom layer and overlay implementations).
	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._pixelOrigin;
	},

	// @method getPixelWorldBounds(zoom?: Number): Bounds
	// Returns the world's bounds in pixel coordinates for zoom level `zoom`.
	// If `zoom` is omitted, the map's current zoom level is used.
	getPixelWorldBounds: function (zoom) {
		return this.options.crs.getProjectedBounds(zoom === undefined ? this.getZoom() : zoom);
	},

	// @section Other Methods

	// @method getPane(pane: String|HTMLElement): HTMLElement
	// Returns a [map pane](#map-pane), given its name or its HTML element (its identity).
	getPane: function (pane) {
		return typeof pane === 'string' ? this._panes[pane] : pane;
	},

	// @method getPanes(): Object
	// Returns a plain object containing the names of all [panes](#map-pane) as keys and
	// the panes as values.
	getPanes: function () {
		return this._panes;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the map.
	getContainer: function () {
		return this._container;
	},


	// @section Conversion Methods

	// @method getZoomScale(toZoom: Number, fromZoom: Number): Number
	// Returns the scale factor to be applied to a map transition from zoom level
	// `fromZoom` to `toZoom`. Used internally to help with zoom animations.
	getZoomScale: function (toZoom, fromZoom) {
		// TODO replace with universal implementation after refactoring projections
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		return crs.scale(toZoom) / crs.scale(fromZoom);
	},

	// @method getScaleZoom(scale: Number, fromZoom: Number): Number
	// Returns the zoom level that the map would end up at, if it is at `fromZoom`
	// level and everything is scaled by a factor of `scale`. Inverse of
	// [`getZoomScale`](#map-getZoomScale).
	getScaleZoom: function (scale, fromZoom) {
		var crs = this.options.crs;
		fromZoom = fromZoom === undefined ? this._zoom : fromZoom;
		var zoom = crs.zoom(scale * crs.scale(fromZoom));
		return isNaN(zoom) ? Infinity : zoom;
	},

	// @method project(latlng: LatLng, zoom: Number): Point
	// Projects a geographical coordinate `LatLng` according to the projection
	// of the map's CRS, then scales it according to `zoom` and the CRS's
	// `Transformation`. The result is pixel coordinate relative to
	// the CRS origin.
	project: function (latlng, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	// @method unproject(point: Point, zoom: Number): LatLng
	// Inverse of [`project`](#map-project).
	unproject: function (point, zoom) {
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	// @method layerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding geographical coordinate (for the current zoom level).
	layerPointToLatLng: function (point) {
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	// @method latLngToLayerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the [origin pixel](#map-getpixelorigin).
	latLngToLayerPoint: function (latlng) {
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	// @method wrapLatLng(latlng: LatLng): LatLng
	// Returns a `LatLng` where `lat` and `lng` has been wrapped according to the
	// map's CRS's `wrapLat` and `wrapLng` properties, if they are outside the
	// CRS's bounds.
	// By default this means longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees.
	wrapLatLng: function (latlng) {
		return this.options.crs.wrapLatLng(L.latLng(latlng));
	},

	// @method wrapLatLngBounds(bounds: LatLngBounds): LatLngBounds
	// Returns a `LatLngBounds` with the same size as the given one, ensuring that
	// its center is within the CRS's bounds.
	// By default this means the center longitude is wrapped around the dateline so its
	// value is between -180 and +180 degrees, and the majority of the bounds
	// overlaps the CRS's bounds.
	wrapLatLngBounds: function (latlng) {
		return this.options.crs.wrapLatLngBounds(L.latLngBounds(latlng));
	},

	// @method distance(latlng1: LatLng, latlng2: LatLng): Number
	// Returns the distance between two geographical coordinates according to
	// the map's CRS. By default this measures distance in meters.
	distance: function (latlng1, latlng2) {
		return this.options.crs.distance(L.latLng(latlng1), L.latLng(latlng2));
	},

	// @method containerPointToLayerPoint(point: Point): Point
	// Given a pixel coordinate relative to the map container, returns the corresponding
	// pixel coordinate relative to the [origin pixel](#map-getpixelorigin).
	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	// @method layerPointToContainerPoint(point: Point): Point
	// Given a pixel coordinate relative to the [origin pixel](#map-getpixelorigin),
	// returns the corresponding pixel coordinate relative to the map container.
	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	// @method containerPointToLatLng(point: Point): LatLng
	// Given a pixel coordinate relative to the map container, returns
	// the corresponding geographical coordinate (for the current zoom level).
	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	// @method latLngToContainerPoint(latlng: LatLng): Point
	// Given a geographical coordinate, returns the corresponding pixel coordinate
	// relative to the map container.
	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	// @method mouseEventToContainerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to the
	// map container where the event took place.
	mouseEventToContainerPoint: function (e) {
		return L.DomEvent.getMousePosition(e, this._container);
	},

	// @method mouseEventToLayerPoint(ev: MouseEvent): Point
	// Given a MouseEvent object, returns the pixel coordinate relative to
	// the [origin pixel](#map-getpixelorigin) where the event took place.
	mouseEventToLayerPoint: function (e) {
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	// @method mouseEventToLatLng(ev: MouseEvent): LatLng
	// Given a MouseEvent object, returns geographical coordinate where the
	// event took place.
	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet_id) {
			throw new Error('Map container is already initialized.');
		}

		L.DomEvent.addListener(container, 'scroll', this._onScroll, this);
		this._containerId = L.Util.stamp(container);
	},

	_initLayout: function () {
		var container = this._container;

		this._fadeAnimated = this.options.fadeAnimation && L.Browser.any3d;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(L.Browser.safari ? ' leaflet-safari' : '') +
			(this._fadeAnimated ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};
		this._paneRenderers = {};

		// @section
		//
		// Panes are DOM elements used to control the ordering of layers on the map. You
		// can access panes with [`map.getPane`](#map-getpane) or
		// [`map.getPanes`](#map-getpanes) methods. New panes can be created with the
		// [`map.createPane`](#map-createpane) method.
		//
		// Every map has the following default panes that differ only in zIndex.
		//
		// @pane mapPane: HTMLElement = 'auto'
		// Pane that contains all other map panes

		this._mapPane = this.createPane('mapPane', this._container);
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		// @pane tilePane: HTMLElement = 200
		// Pane for `GridLayer`s and `TileLayer`s
		this.createPane('tilePane');
		// @pane overlayPane: HTMLElement = 400
		// Pane for vector overlays (`Path`s), like `Polyline`s and `Polygon`s
		this.createPane('shadowPane');
		// @pane shadowPane: HTMLElement = 500
		// Pane for overlay shadows (e.g. `Marker` shadows)
		this.createPane('overlayPane');
		// @pane markerPane: HTMLElement = 600
		// Pane for `Icon`s of `Marker`s
		this.createPane('markerPane');
		// @pane tooltipPane: HTMLElement = 650
		// Pane for tooltip.
		this.createPane('tooltipPane');
		// @pane popupPane: HTMLElement = 700
		// Pane for `Popup`s.
		this.createPane('popupPane');

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, 'leaflet-zoom-hide');
			L.DomUtil.addClass(panes.shadowPane, 'leaflet-zoom-hide');
		}
	},


	// private methods that modify map state

	// @section Map state change events
	_resetView: function (center, zoom) {
		L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));

		var loading = !this._loaded;
		this._loaded = true;
		zoom = this._limitZoom(zoom);

		this.fire('viewprereset');

		var zoomChanged = this._zoom !== zoom;
		this
			._moveStart(zoomChanged)
			._move(center, zoom)
			._moveEnd(zoomChanged);

		// @event viewreset: Event
		// Fired when the map needs to redraw its content (this usually happens
		// on map zoom or load). Very useful for creating custom overlays.
		this.fire('viewreset');

		// @event load: Event
		// Fired when the map is initialized (when its center and zoom are set
		// for the first time).
		if (loading) {
			this.fire('load');
		}
	},

	_moveStart: function (zoomChanged) {
		// @event zoomstart: Event
		// Fired when the map zoom is about to change (e.g. before zoom animation).
		// @event movestart: Event
		// Fired when the view of the map starts changing (e.g. user starts dragging the map).
		if (zoomChanged) {
			this.fire('zoomstart');
		}
		return this.fire('movestart');
	},

	_move: function (center, zoom, data) {
		if (zoom === undefined) {
			zoom = this._zoom;
		}
		var zoomChanged = this._zoom !== zoom;

		this._zoom = zoom;
		this._lastCenter = center;
		this._pixelOrigin = this._getNewPixelOrigin(center);

		// @event zoom: Event
		// Fired repeatedly during any change in zoom level, including zoom
		// and fly animations.
		if (zoomChanged || (data && data.pinch)) {	// Always fire 'zoom' if pinching because #3530
			this.fire('zoom', data);
		}

		// @event move: Event
		// Fired repeatedly during any movement of the map, including pan and
		// fly animations.
		return this.fire('move', data);
	},

	_moveEnd: function (zoomChanged) {
		// @event zoomend: Event
		// Fired when the map has changed, after any animations.
		if (zoomChanged) {
			this.fire('zoomend');
		}

		// @event moveend: Event
		// Fired when the center of the map stops changing (e.g. user stopped
		// dragging the map).
		return this.fire('moveend');
	},

	_stop: function () {
		L.Util.cancelAnimFrame(this._flyToFrame);
		if (this._panAnim) {
			this._panAnim.stop();
		}
		return this;
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_panInsideMaxBounds: function () {
		if (!this._enforcingBounds) {
			this.panInsideBounds(this.options.maxBounds);
		}
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// DOM event handling

	// @section Interaction events
	_initEvents: function (remove) {
		if (!L.DomEvent) { return; }

		this._targets = {};
		this._targets[L.stamp(this._container)] = this;

		var onOff = remove ? 'off' : 'on';

		// @event click: MouseEvent
		// Fired when the user clicks (or taps) the map.
		// @event dblclick: MouseEvent
		// Fired when the user double-clicks (or double-taps) the map.
		// @event mousedown: MouseEvent
		// Fired when the user pushes the mouse button on the map.
		// @event mouseup: MouseEvent
		// Fired when the user releases the mouse button on the map.
		// @event mouseover: MouseEvent
		// Fired when the mouse enters the map.
		// @event mouseout: MouseEvent
		// Fired when the mouse leaves the map.
		// @event mousemove: MouseEvent
		// Fired while the mouse moves over the map.
		// @event contextmenu: MouseEvent
		// Fired when the user pushes the right mouse button on the map, prevents
		// default browser context menu from showing if there are listeners on
		// this event. Also fired on mobile when the user holds a single touch
		// for a second (also called long press).
		// @event keypress: KeyboardEvent
		// Fired when the user presses a key from the keyboard while the map is focused.
		L.DomEvent[onOff](this._container, 'click dblclick mousedown mouseup ' +
			'mouseover mouseout mousemove contextmenu keypress', this._handleDOMEvent, this);

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}

		if (L.Browser.any3d && this.options.transform3DLimit) {
			this[onOff]('moveend', this._onMoveEnd);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this);
	},

	_onScroll: function () {
		this._container.scrollTop  = 0;
		this._container.scrollLeft = 0;
	},

	_onMoveEnd: function () {
		var pos = this._getMapPanePos();
		if (Math.max(Math.abs(pos.x), Math.abs(pos.y)) >= this.options.transform3DLimit) {
			// https://bugzilla.mozilla.org/show_bug.cgi?id=1203873 but Webkit also have
			// a pixel offset on very high values, see: http://jsfiddle.net/dg6r5hhb/
			this._resetView(this.getCenter(), this.getZoom());
		}
	},

	_findEventTargets: function (e, type) {
		var targets = [],
		    target,
		    isHover = type === 'mouseout' || type === 'mouseover',
		    src = e.target || e.srcElement,
		    dragging = false;

		while (src) {
			target = this._targets[L.stamp(src)];
			if (target && (type === 'click' || type === 'preclick') && !e._simulated && this._draggableMoved(target)) {
				// Prevent firing click after you just dragged an object.
				dragging = true;
				break;
			}
			if (target && target.listens(type, true)) {
				if (isHover && !L.DomEvent._isExternalTarget(src, e)) { break; }
				targets.push(target);
				if (isHover) { break; }
			}
			if (src === this._container) { break; }
			src = src.parentNode;
		}
		if (!targets.length && !dragging && !isHover && L.DomEvent._isExternalTarget(src, e)) {
			targets = [this];
		}
		return targets;
	},

	_handleDOMEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type === 'keypress' && e.keyCode === 13 ? 'click' : e.type;

		if (type === 'mousedown') {
			// prevents outline when clicking on keyboard-focusable element
			L.DomUtil.preventOutline(e.target || e.srcElement);
		}

		this._fireDOMEvent(e, type);
	},

	_fireDOMEvent: function (e, type, targets) {

		if (e.type === 'click') {
			// Fire a synthetic 'preclick' event which propagates up (mainly for closing popups).
			// @event preclick: MouseEvent
			// Fired before mouse click on the map (sometimes useful when you
			// want something to happen on click before any existing click
			// handlers start running).
			var synth = L.Util.extend({}, e);
			synth.type = 'preclick';
			this._fireDOMEvent(synth, synth.type, targets);
		}

		if (e._stopped) { return; }

		// Find the layer the event is propagating from and its parents.
		targets = (targets || []).concat(this._findEventTargets(e, type));

		if (!targets.length) { return; }

		var target = targets[0];
		if (type === 'contextmenu' && target.listens(type, true)) {
			L.DomEvent.preventDefault(e);
		}

		var data = {
			originalEvent: e
		};

		if (e.type !== 'keypress') {
			var isMarker = target instanceof L.Marker;
			data.containerPoint = isMarker ?
					this.latLngToContainerPoint(target.getLatLng()) : this.mouseEventToContainerPoint(e);
			data.layerPoint = this.containerPointToLayerPoint(data.containerPoint);
			data.latlng = isMarker ? target.getLatLng() : this.layerPointToLatLng(data.layerPoint);
		}

		for (var i = 0; i < targets.length; i++) {
			targets[i].fire(type, data, true);
			if (data.originalEvent._stopped ||
				(targets[i].options.nonBubblingEvents && L.Util.indexOf(targets[i].options.nonBubblingEvents, type) !== -1)) { return; }
		}
	},

	_draggableMoved: function (obj) {
		obj = obj.dragging && obj.dragging.enabled() ? obj : this;
		return (obj.dragging && obj.dragging.moved()) || (this.boxZoom && this.boxZoom.moved());
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	// @section Other Methods

	// @method whenReady(fn: Function, context?: Object): this
	// Runs the given function `fn` when the map gets initialized with
	// a view (center and zoom) and at least one layer, or immediately
	// if it's already initialized, optionally passing a function context.
	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, {target: this});
		} else {
			this.on('load', callback, context);
		}
		return this;
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane) || new L.Point(0, 0);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function (center, zoom) {
		var pixelOrigin = center && zoom !== undefined ?
			this._getNewPixelOrigin(center, zoom) :
			this.getPixelOrigin();
		return pixelOrigin.subtract(this._getMapPanePos());
	},

	_getNewPixelOrigin: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		return this.project(center, zoom)._subtract(viewHalf)._add(this._getMapPanePos())._round();
	},

	_latLngToNewLayerPoint: function (latlng, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return this.project(latlng, zoom)._subtract(topLeft);
	},

	_latLngBoundsToNewLayerBounds: function (latLngBounds, zoom, center) {
		var topLeft = this._getNewPixelOrigin(center, zoom);
		return L.bounds([
			this.project(latLngBounds.getSouthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthWest(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getSouthEast(), zoom)._subtract(topLeft),
			this.project(latLngBounds.getNorthEast(), zoom)._subtract(topLeft)
		]);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		// If offset is less than a pixel, ignore.
		// This prevents unstable projections from getting into
		// an infinite loop of tiny offsets.
		if (offset.round().equals([0, 0])) {
			return center;
		}

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var projectedMaxBounds = L.bounds(
		        this.project(maxBounds.getNorthEast(), zoom),
		        this.project(maxBounds.getSouthWest(), zoom)
		    ),
		    minOffset = projectedMaxBounds.min.subtract(pxBounds.min),
		    maxOffset = projectedMaxBounds.max.subtract(pxBounds.max),

		    dx = this._rebound(minOffset.x, -maxOffset.x),
		    dy = this._rebound(minOffset.y, -maxOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom(),
		    snap = L.Browser.any3d ? this.options.zoomSnap : 1;
		if (snap) {
			zoom = Math.round(zoom / snap) * snap;
		}
		return Math.max(min, Math.min(max, zoom));
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	},

	_createAnimProxy: function () {

		var proxy = this._proxy = L.DomUtil.create('div', 'leaflet-proxy leaflet-zoom-animated');
		this._panes.mapPane.appendChild(proxy);

		this.on('zoomanim', function (e) {
			var prop = L.DomUtil.TRANSFORM,
			    transform = proxy.style[prop];

			L.DomUtil.setTransform(proxy, this.project(e.center, e.zoom), this.getZoomScale(e.zoom, 1));

			// workaround for case when transform is the same and so transitionend event is not fired
			if (transform === proxy.style[prop] && this._animatingZoom) {
				this._onZoomTransitionEnd();
			}
		}, this);

		this.on('load moveend', function () {
			var c = this.getCenter(),
			    z = this.getZoom();
			L.DomUtil.setTransform(proxy, this.project(c, z), this.getZoomScale(z, 1));
		}, this);
	},

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		L.Util.requestAnimFrame(function () {
			this
			    ._moveStart(true)
			    ._animateZoom(center, zoom, true);
		}, this);

		return true;
	},

	_animateZoom: function (center, zoom, startAnim, noUpdate) {
		if (startAnim) {
			this._animatingZoom = true;

			// remember what center/zoom to set after animation
			this._animateToCenter = center;
			this._animateToZoom = zoom;

			L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');
		}

		// @event zoomanim: ZoomAnimEvent
		// Fired on every frame of a zoom animation
		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			noUpdate: noUpdate
		});

		// Work around webkit not firing 'transitionend', see https://github.com/Leaflet/Leaflet/issues/3689, 2693
		setTimeout(L.bind(this._onZoomTransitionEnd, this), 250);
	},

	_onZoomTransitionEnd: function () {
		if (!this._animatingZoom) { return; }

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._animatingZoom = false;

		this._move(this._animateToCenter, this._animateToZoom);

		// This anim frame should prevent an obscure iOS webkit tile loading race condition.
		L.Util.requestAnimFrame(function () {
			this._moveEnd(true);
		}, this);
	}
});

// @section

// @factory L.map(id: String, options?: Map options)
// Instantiates a map object given the DOM ID of a `<div>` element
// and optionally an object literal with `Map options`.
//
// @alternative
// @factory L.map(el: HTMLElement, options?: Map options)
// Instantiates a map object given an instance of a `<div>` HTML element
// and optionally an object literal with `Map options`.
L.map = function (id, options) {
	return new L.Map(id, options);
};




/*
 * @class Layer
 * @inherits Evented
 * @aka L.Layer
 * @aka ILayer
 *
 * A set of methods from the Layer base class that all Leaflet layers use.
 * Inherits all methods, options and events from `L.Evented`.
 *
 * @example
 *
 * ```js
 * var layer = L.Marker(latlng).addTo(map);
 * layer.addTo(map);
 * layer.remove();
 * ```
 *
 * @event add: Event
 * Fired after the layer is added to a map
 *
 * @event remove: Event
 * Fired after the layer is removed from a map
 */


L.Layer = L.Evented.extend({

	// Classes extending `L.Layer` will inherit the following options:
	options: {
		// @option pane: String = 'overlayPane'
		// By default the layer will be added to the map's [overlay pane](#map-overlaypane). Overriding this option will cause the layer to be placed on another pane by default.
		pane: 'overlayPane',
		nonBubblingEvents: [],  // Array of events that should not be bubbled to DOM parents (like the map),

		// @option attribution: String = null
		// String to be shown in the attribution control, describes the layer data, e.g. "© Mapbox".
		attribution: null
	},

	/* @section
	 * Classes extending `L.Layer` will inherit the following methods:
	 *
	 * @method addTo(map: Map): this
	 * Adds the layer to the given map
	 */
	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	// @method remove: this
	// Removes the layer from the map it is currently active on.
	remove: function () {
		return this.removeFrom(this._map || this._mapToAdd);
	},

	// @method removeFrom(map: Map): this
	// Removes the layer from the given map
	removeFrom: function (obj) {
		if (obj) {
			obj.removeLayer(this);
		}
		return this;
	},

	// @method getPane(name? : String): HTMLElement
	// Returns the `HTMLElement` representing the named pane on the map. If `name` is omitted, returns the pane for this layer.
	getPane: function (name) {
		return this._map.getPane(name ? (this.options[name] || name) : this.options.pane);
	},

	addInteractiveTarget: function (targetEl) {
		this._map._targets[L.stamp(targetEl)] = this;
		return this;
	},

	removeInteractiveTarget: function (targetEl) {
		delete this._map._targets[L.stamp(targetEl)];
		return this;
	},

	// @method getAttribution: String
	// Used by the `attribution control`, returns the [attribution option](#gridlayer-attribution).
	getAttribution: function () {
		return this.options.attribution;
	},

	_layerAdd: function (e) {
		var map = e.target;

		// check in case layer gets added and then removed before the map is ready
		if (!map.hasLayer(this)) { return; }

		this._map = map;
		this._zoomAnimated = map._zoomAnimated;

		if (this.getEvents) {
			var events = this.getEvents();
			map.on(events, this);
			this.once('remove', function () {
				map.off(events, this);
			}, this);
		}

		this.onAdd(map);

		if (this.getAttribution && map.attributionControl) {
			map.attributionControl.addAttribution(this.getAttribution());
		}

		this.fire('add');
		map.fire('layeradd', {layer: this});
	}
});

/* @section Extension methods
 * @uninheritable
 *
 * Every layer should extend from `L.Layer` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): this
 * Should contain code that creates DOM elements for the layer, adds them to `map panes` where they should belong and puts listeners on relevant map events. Called on [`map.addLayer(layer)`](#map-addlayer).
 *
 * @method onRemove(map: Map): this
 * Should contain all clean up code that removes the layer's elements from the DOM and removes listeners previously added in [`onAdd`](#layer-onadd). Called on [`map.removeLayer(layer)`](#map-removelayer).
 *
 * @method getEvents(): Object
 * This optional method should return an object like `{ viewreset: this._reset }` for [`addEventListener`](#evented-addeventlistener). The event handlers in this object will be automatically added and removed from the map with your layer.
 *
 * @method getAttribution(): String
 * This optional method should return a string containing HTML to be shown on the `Attribution control` whenever the layer is visible.
 *
 * @method beforeAdd(map: Map): this
 * Optional method. Called on [`map.addLayer(layer)`](#map-addlayer), before the layer is added to the map, before events are initialized, without waiting until the map is in a usable state. Use for early initialization only.
 */


/* @namespace Map
 * @section Layer events
 *
 * @event layeradd: LayerEvent
 * Fired when a new layer is added to the map.
 *
 * @event layerremove: LayerEvent
 * Fired when some layer is removed from the map
 *
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addLayer(layer: Layer): this
	// Adds the given layer to the map
	addLayer: function (layer) {
		var id = L.stamp(layer);
		if (this._layers[id]) { return this; }
		this._layers[id] = layer;

		layer._mapToAdd = this;

		if (layer.beforeAdd) {
			layer.beforeAdd(this);
		}

		this.whenReady(layer._layerAdd, layer);

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the map.
	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		if (layer.getAttribution && this.attributionControl) {
			this.attributionControl.removeAttribution(layer.getAttribution());
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
			layer.fire('remove');
		}

		layer._map = layer._mapToAdd = null;

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the map
	hasLayer: function (layer) {
		return !!layer && (L.stamp(layer) in this._layers);
	},

	/* @method eachLayer(fn: Function, context?: Object): this
	 * Iterates over the layers of the map, optionally specifying context of the iterator function.
	 * ```
	 * map.eachLayer(function(layer){
	 *     layer.bindPopup('Hello');
	 * });
	 * ```
	 */
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},

	_addZoomLimit: function (layer) {
		if (isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom)) {
			this._zoomBoundLayers[L.stamp(layer)] = layer;
			this._updateZoomLevels();
		}
	},

	_removeZoomLimit: function (layer) {
		var id = L.stamp(layer);

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}
	},

	_updateZoomLevels: function () {
		var minZoom = Infinity,
		    maxZoom = -Infinity,
		    oldZoomSpan = this._getZoomSpan();

		for (var i in this._zoomBoundLayers) {
			var options = this._zoomBoundLayers[i].options;

			minZoom = options.minZoom === undefined ? minZoom : Math.min(minZoom, options.minZoom);
			maxZoom = options.maxZoom === undefined ? maxZoom : Math.max(maxZoom, options.maxZoom);
		}

		this._layersMaxZoom = maxZoom === -Infinity ? undefined : maxZoom;
		this._layersMinZoom = minZoom === Infinity ? undefined : minZoom;

		// @section Map state change events
		// @event zoomlevelschange: Event
		// Fired when the number of zoomlevels on the map is changed due
		// to adding or removing a layer.
		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}

		if (this.options.maxZoom === undefined && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom) {
			this.setZoom(this._layersMaxZoom);
		}
		if (this.options.minZoom === undefined && this._layersMinZoom && this.getZoom() < this._layersMinZoom) {
			this.setZoom(this._layersMinZoom);
		}
	}
});



/*
 * @namespace DomEvent
 * Utility functions to work with the [DOM events](https://developer.mozilla.org/docs/Web/API/Event), used by Leaflet internally.
 */

// Inspired by John Resig, Dean Edwards and YUI addEvent implementations.



var eventsKey = '_leaflet_events';

L.DomEvent = {

	// @function on(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Adds a listener function (`fn`) to a particular DOM event type of the
	// element `el`. You can optionally specify the context of the listener
	// (object the `this` keyword will point to). You can also pass several
	// space-separated types (e.g. `'click dblclick'`).

	// @alternative
	// @function on(el: HTMLElement, eventMap: Object, context?: Object): this
	// Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	on: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._on(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._on(obj, types[i], fn, context);
			}
		}

		return this;
	},

	// @function off(el: HTMLElement, types: String, fn: Function, context?: Object): this
	// Removes a previously added listener function. If no function is specified,
	// it will remove all the listeners of that particular DOM event from the element.
	// Note that if you passed a custom context to on, you must pass the same
	// context to `off` in order to remove the listener.

	// @alternative
	// @function off(el: HTMLElement, eventMap: Object, context?: Object): this
	// Removes a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
	off: function (obj, types, fn, context) {

		if (typeof types === 'object') {
			for (var type in types) {
				this._off(obj, type, types[type], fn);
			}
		} else {
			types = L.Util.splitWords(types);

			for (var i = 0, len = types.length; i < len; i++) {
				this._off(obj, types[i], fn, context);
			}
		}

		return this;
	},

	_on: function (obj, type, fn, context) {
		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : '');

		if (obj[eventsKey] && obj[eventsKey][id]) { return this; }

		var handler = function (e) {
			return fn.call(context || obj, e || window.event);
		};

		var originalHandler = handler;

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.addPointerListener(obj, type, handler, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener &&
		           !(L.Browser.pointer && L.Browser.chrome)) {
			// Chrome >55 does not need the synthetic dblclicks from addDoubleTapListener
			// See #5180
			this.addDoubleTapListener(obj, handler, id);

		} else if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				handler = function (e) {
					e = e || window.event;
					if (L.DomEvent._isExternalTarget(obj, e)) {
						originalHandler(e);
					}
				};
				obj.addEventListener(type === 'mouseenter' ? 'mouseover' : 'mouseout', handler, false);

			} else {
				if (type === 'click' && L.Browser.android) {
					handler = function (e) {
						return L.DomEvent._filterClick(e, originalHandler);
					};
				}
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[eventsKey] = obj[eventsKey] || {};
		obj[eventsKey][id] = handler;

		return this;
	},

	_off: function (obj, type, fn, context) {

		var id = type + L.stamp(fn) + (context ? '_' + L.stamp(context) : ''),
		    handler = obj[eventsKey] && obj[eventsKey][id];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);

		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('onwheel' in obj ? 'wheel' : 'mousewheel', handler, false);

			} else {
				obj.removeEventListener(
					type === 'mouseenter' ? 'mouseover' :
					type === 'mouseleave' ? 'mouseout' : type, handler, false);
			}

		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[eventsKey][id] = null;

		return this;
	},

	// @function stopPropagation(ev: DOMEvent): this
	// Stop the given event from propagation to parent elements. Used inside the listener functions:
	// ```js
	// L.DomEvent.on(div, 'click', function (ev) {
	// 	L.DomEvent.stopPropagation(ev);
	// });
	// ```
	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else if (e.originalEvent) {  // In case of Leaflet event.
			e.originalEvent._stopped = true;
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	// @function disableScrollPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'mousewheel'` events (plus browser variants).
	disableScrollPropagation: function (el) {
		return L.DomEvent.on(el, 'mousewheel', L.DomEvent.stopPropagation);
	},

	// @function disableClickPropagation(el: HTMLElement): this
	// Adds `stopPropagation` to the element's `'click'`, `'doubleclick'`,
	// `'mousedown'` and `'touchstart'` events (plus browser variants).
	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		L.DomEvent.on(el, L.Draggable.START.join(' '), stop);

		return L.DomEvent.on(el, {
			click: L.DomEvent._fakeStop,
			dblclick: stop
		});
	},

	// @function preventDefault(ev: DOMEvent): this
	// Prevents the default action of the DOM Event `ev` from happening (such as
	// following a link in the href of the a element, or doing a POST request
	// with page reload when a `<form>` is submitted).
	// Use it inside listener functions.
	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	// @function stop(ev): this
	// Does `stopPropagation` and `preventDefault` at the same time.
	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	// @function getMousePosition(ev: DOMEvent, container?: HTMLElement): Point
	// Gets normalized mouse position from a DOM event relative to the
	// `container` or to the whole page if not specified.
	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	// Chrome on Win scrolls double the pixels as in other platforms (see #4538),
	// and Firefox scrolls device pixels, not CSS pixels
	_wheelPxFactor: (L.Browser.win && L.Browser.chrome) ? 2 :
	                L.Browser.gecko ? window.devicePixelRatio :
	                1,

	// @function getWheelDelta(ev: DOMEvent): Number
	// Gets normalized wheel delta from a mousewheel DOM event, in vertical
	// pixels scrolled (negative if scrolling down).
	// Events from pointing devices without precise scrolling are mapped to
	// a best guess of 60 pixels.
	getWheelDelta: function (e) {
		return (L.Browser.edge) ? e.wheelDeltaY / 2 : // Don't trust window-geometry-based delta
		       (e.deltaY && e.deltaMode === 0) ? -e.deltaY / L.DomEvent._wheelPxFactor : // Pixels
		       (e.deltaY && e.deltaMode === 1) ? -e.deltaY * 20 : // Lines
		       (e.deltaY && e.deltaMode === 2) ? -e.deltaY * 60 : // Pages
		       (e.deltaX || e.deltaZ) ? 0 :	// Skip horizontal/depth wheel events
		       e.wheelDelta ? (e.wheelDeltaY || e.wheelDelta) / 2 : // Legacy IE pixels
		       (e.detail && Math.abs(e.detail) < 32765) ? -e.detail * 20 : // Legacy Moz lines
		       e.detail ? e.detail / -32765 * 60 : // Legacy Moz pages
		       0;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_isExternalTarget: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || (e.originalEvent && e.originalEvent.timeStamp)),
		    elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 500ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 500) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		handler(e);
	}
};

// @function addListener(…): this
// Alias to [`L.DomEvent.on`](#domevent-on)
L.DomEvent.addListener = L.DomEvent.on;

// @function removeListener(…): this
// Alias to [`L.DomEvent.off`](#domevent-off)
L.DomEvent.removeListener = L.DomEvent.off;



/*
 * @class PosAnimation
 * @aka L.PosAnimation
 * @inherits Evented
 * Used internally for panning animations, utilizing CSS3 Transitions for modern browsers and a timer fallback for IE6-9.
 *
 * @example
 * ```js
 * var fx = new L.PosAnimation();
 * fx.run(el, [300, 500], 0.5);
 * ```
 *
 * @constructor L.PosAnimation()
 * Creates a `PosAnimation` object.
 *
 */

L.PosAnimation = L.Evented.extend({

	// @method run(el: HTMLElement, newPos: Point, duration?: Number, easeLinearity?: Number)
	// Run an animation of a given element to a new position, optionally setting
	// duration in seconds (`0.25` by default) and easing linearity factor (3rd
	// argument of the [cubic bezier curve](http://cubic-bezier.com/#0,0,.5,1),
	// `0.5` by default).
	run: function (el, newPos, duration, easeLinearity) {
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		// @event start: Event
		// Fired when the animation starts
		this.fire('start');

		this._animate();
	},

	// @method stop()
	// Stops the animation (if currently running).
	stop: function () {
		if (!this._inProgress) { return; }

		this._step(true);
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function (round) {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration), round);
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress, round) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		if (round) {
			pos._round();
		}
		L.DomUtil.setPosition(this._el, pos);

		// @event step: Event
		// Fired continuously during the animation.
		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		// @event end: Event
		// Fired when the animation ends.
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});



/*
 * @namespace Projection
 * @projection L.Projection.Mercator
 *
 * Elliptical Mercator projection — more complex than Spherical Mercator. Takes into account that Earth is a geoid, not a perfect sphere. Used by the EPSG:3395 CRS.
 */

L.Projection.Mercator = {
	R: 6378137,
	R_MINOR: 6356752.314245179,

	bounds: L.bounds([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]),

	project: function (latlng) {
		var d = Math.PI / 180,
		    r = this.R,
		    y = latlng.lat * d,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    con = e * Math.sin(y);

		var ts = Math.tan(Math.PI / 4 - y / 2) / Math.pow((1 - con) / (1 + con), e / 2);
		y = -r * Math.log(Math.max(ts, 1E-10));

		return new L.Point(latlng.lng * d * r, y);
	},

	unproject: function (point) {
		var d = 180 / Math.PI,
		    r = this.R,
		    tmp = this.R_MINOR / r,
		    e = Math.sqrt(1 - tmp * tmp),
		    ts = Math.exp(-point.y / r),
		    phi = Math.PI / 2 - 2 * Math.atan(ts);

		for (var i = 0, dphi = 0.1, con; i < 15 && Math.abs(dphi) > 1e-7; i++) {
			con = e * Math.sin(phi);
			con = Math.pow((1 - con) / (1 + con), e / 2);
			dphi = Math.PI / 2 - 2 * Math.atan(ts * con) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, point.x * d / r);
	}
};



/*
 * @namespace CRS
 * @crs L.CRS.EPSG3395
 *
 * Rarely used by some commercial tile providers. Uses Elliptical Mercator projection.
 */

L.CRS.EPSG3395 = L.extend({}, L.CRS.Earth, {
	code: 'EPSG:3395',
	projection: L.Projection.Mercator,

	transformation: (function () {
		var scale = 0.5 / (Math.PI * L.Projection.Mercator.R);
		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});



/*
 * @class GridLayer
 * @inherits Layer
 * @aka L.GridLayer
 *
 * Generic class for handling a tiled grid of HTML elements. This is the base class for all tile layers and replaces `TileLayer.Canvas`.
 * GridLayer can be extended to create a tiled grid of HTML elements like `<canvas>`, `<img>` or `<div>`. GridLayer will handle creating and animating these DOM elements for you.
 *
 *
 * @section Synchronous usage
 * @example
 *
 * To create a custom layer, extend GridLayer and implement the `createTile()` method, which will be passed a `Point` object with the `x`, `y`, and `z` (zoom level) coordinates to draw your tile.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords){
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // get a canvas context and draw something on it using coords.x, coords.y and coords.z
 *         var ctx = tile.getContext('2d');
 *
 *         // return the tile so it can be rendered on screen
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section Asynchronous usage
 * @example
 *
 * Tile creation can also be asynchronous, this is useful when using a third-party drawing library. Once the tile is finished drawing it can be passed to the `done()` callback.
 *
 * ```js
 * var CanvasLayer = L.GridLayer.extend({
 *     createTile: function(coords, done){
 *         var error;
 *
 *         // create a <canvas> element for drawing
 *         var tile = L.DomUtil.create('canvas', 'leaflet-tile');
 *
 *         // setup tile width and height according to the options
 *         var size = this.getTileSize();
 *         tile.width = size.x;
 *         tile.height = size.y;
 *
 *         // draw something asynchronously and pass the tile to the done() callback
 *         setTimeout(function() {
 *             done(error, tile);
 *         }, 1000);
 *
 *         return tile;
 *     }
 * });
 * ```
 *
 * @section
 */


L.GridLayer = L.Layer.extend({

	// @section
	// @aka GridLayer options
	options: {
		// @option tileSize: Number|Point = 256
		// Width and height of tiles in the grid. Use a number if width and height are equal, or `L.point(width, height)` otherwise.
		tileSize: 256,

		// @option opacity: Number = 1.0
		// Opacity of the tiles. Can be used in the `createTile()` function.
		opacity: 1,

		// @option updateWhenIdle: Boolean = depends
		// If `false`, new tiles are loaded during panning, otherwise only after it (for better performance). `true` by default on mobile browsers, otherwise `false`.
		updateWhenIdle: L.Browser.mobile,

		// @option updateWhenZooming: Boolean = true
		// By default, a smooth zoom animation (during a [touch zoom](#map-touchzoom) or a [`flyTo()`](#map-flyto)) will update grid layers every integer zoom level. Setting this option to `false` will update the grid layer only when the smooth animation ends.
		updateWhenZooming: true,

		// @option updateInterval: Number = 200
		// Tiles will not update more than once every `updateInterval` milliseconds when panning.
		updateInterval: 200,

		// @option zIndex: Number = 1
		// The explicit zIndex of the tile layer.
		zIndex: 1,

		// @option bounds: LatLngBounds = undefined
		// If set, tiles will only be loaded inside the set `LatLngBounds`.
		bounds: null,

		// @option minZoom: Number = 0
		// The minimum zoom level that tiles will be loaded at. By default the entire map.
		minZoom: 0,

		// @option maxZoom: Number = undefined
		// The maximum zoom level that tiles will be loaded at.
		maxZoom: undefined,

		// @option noWrap: Boolean = false
		// Whether the layer is wrapped around the antimeridian. If `true`, the
		// GridLayer will only be displayed once at low zoom levels. Has no
		// effect when the [map CRS](#map-crs) doesn't wrap around. Can be used
		// in combination with [`bounds`](#gridlayer-bounds) to prevent requesting
		// tiles outside the CRS limits.
		noWrap: false,

		// @option pane: String = 'tilePane'
		// `Map pane` where the grid layer will be added.
		pane: 'tilePane',

		// @option className: String = ''
		// A custom class name to assign to the tile layer. Empty by default.
		className: '',

		// @option keepBuffer: Number = 2
		// When panning the map, keep this many rows and columns of tiles before unloading them.
		keepBuffer: 2
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function () {
		this._initContainer();

		this._levels = {};
		this._tiles = {};

		this._resetView();
		this._update();
	},

	beforeAdd: function (map) {
		map._addZoomLimit(this);
	},

	onRemove: function (map) {
		this._removeAllTiles();
		L.DomUtil.remove(this._container);
		map._removeZoomLimit(this);
		this._container = null;
		this._tileZoom = null;
	},

	// @method bringToFront: this
	// Brings the tile layer to the top of all tile layers.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
			this._setAutoZIndex(Math.max);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings the tile layer to the bottom of all tile layers.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
			this._setAutoZIndex(Math.min);
		}
		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTML element that contains the tiles for this layer.
	getContainer: function () {
		return this._container;
	},

	// @method setOpacity(opacity: Number): this
	// Changes the [opacity](#gridlayer-opacity) of the grid layer.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// @method setZIndex(zIndex: Number): this
	// Changes the [zIndex](#gridlayer-zindex) of the grid layer.
	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	// @method isLoading: Boolean
	// Returns `true` if any tile in the grid layer has not finished loading.
	isLoading: function () {
		return this._loading;
	},

	// @method redraw: this
	// Causes the layer to clear all the tiles and request them again.
	redraw: function () {
		if (this._map) {
			this._removeAllTiles();
			this._update();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			viewprereset: this._invalidateAll,
			viewreset: this._resetView,
			zoom: this._resetView,
			moveend: this._onMoveEnd
		};

		if (!this.options.updateWhenIdle) {
			// update tiles on move, but not more often than once per given interval
			if (!this._onMove) {
				this._onMove = L.Util.throttle(this._onMoveEnd, this.options.updateInterval, this);
			}

			events.move = this._onMove;
		}

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @section Extension methods
	// Layers extending `GridLayer` shall reimplement the following method.
	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, must be overriden by classes extending `GridLayer`.
	// Returns the `HTMLElement` corresponding to the given `coords`. If the `done` callback
	// is specified, it must be called when the tile has finished loading and drawing.
	createTile: function () {
		return document.createElement('div');
	},

	// @section
	// @method getTileSize: Point
	// Normalizes the [tileSize option](#gridlayer-tilesize) into a point. Used by the `createTile()` method.
	getTileSize: function () {
		var s = this.options.tileSize;
		return s instanceof L.Point ? s : new L.Point(s, s);
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined && this.options.zIndex !== null) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (compare) {
		// go through all other layers of the same pane, set zIndex to max + 1 (front) or min - 1 (back)

		var layers = this.getPane().children,
		    edgeZIndex = -compare(-Infinity, Infinity); // -Infinity for max, Infinity for min

		for (var i = 0, len = layers.length, zIndex; i < len; i++) {

			zIndex = layers[i].style.zIndex;

			if (layers[i] !== this._container && zIndex) {
				edgeZIndex = compare(edgeZIndex, +zIndex);
			}
		}

		if (isFinite(edgeZIndex)) {
			this.options.zIndex = edgeZIndex + compare(-1, 1);
			this._updateZIndex();
		}
	},

	_updateOpacity: function () {
		if (!this._map) { return; }

		// IE doesn't inherit filter opacity properly, so we're forced to set it on tiles
		if (L.Browser.ielt9) { return; }

		L.DomUtil.setOpacity(this._container, this.options.opacity);

		var now = +new Date(),
		    nextFrame = false,
		    willPrune = false;

		for (var key in this._tiles) {
			var tile = this._tiles[key];
			if (!tile.current || !tile.loaded) { continue; }

			var fade = Math.min(1, (now - tile.loaded) / 200);

			L.DomUtil.setOpacity(tile.el, fade);
			if (fade < 1) {
				nextFrame = true;
			} else {
				if (tile.active) { willPrune = true; }
				tile.active = true;
			}
		}

		if (willPrune && !this._noPrune) { this._pruneTiles(); }

		if (nextFrame) {
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		}
	},

	_initContainer: function () {
		if (this._container) { return; }

		this._container = L.DomUtil.create('div', 'leaflet-layer ' + (this.options.className || ''));
		this._updateZIndex();

		if (this.options.opacity < 1) {
			this._updateOpacity();
		}

		this.getPane().appendChild(this._container);
	},

	_updateLevels: function () {

		var zoom = this._tileZoom,
		    maxZoom = this.options.maxZoom;

		if (zoom === undefined) { return undefined; }

		for (var z in this._levels) {
			if (this._levels[z].el.children.length || z === zoom) {
				this._levels[z].el.style.zIndex = maxZoom - Math.abs(zoom - z);
			} else {
				L.DomUtil.remove(this._levels[z].el);
				this._removeTilesAtZoom(z);
				delete this._levels[z];
			}
		}

		var level = this._levels[zoom],
		    map = this._map;

		if (!level) {
			level = this._levels[zoom] = {};

			level.el = L.DomUtil.create('div', 'leaflet-tile-container leaflet-zoom-animated', this._container);
			level.el.style.zIndex = maxZoom;

			level.origin = map.project(map.unproject(map.getPixelOrigin()), zoom).round();
			level.zoom = zoom;

			this._setZoomTransform(level, map.getCenter(), map.getZoom());

			// force the browser to consider the newly added element for transition
			L.Util.falseFn(level.el.offsetWidth);
		}

		this._level = level;

		return level;
	},

	_pruneTiles: function () {
		if (!this._map) {
			return;
		}

		var key, tile;

		var zoom = this._map.getZoom();
		if (zoom > this.options.maxZoom ||
			zoom < this.options.minZoom) {
			this._removeAllTiles();
			return;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			tile.retain = tile.current;
		}

		for (key in this._tiles) {
			tile = this._tiles[key];
			if (tile.current && !tile.active) {
				var coords = tile.coords;
				if (!this._retainParent(coords.x, coords.y, coords.z, coords.z - 5)) {
					this._retainChildren(coords.x, coords.y, coords.z, coords.z + 2);
				}
			}
		}

		for (key in this._tiles) {
			if (!this._tiles[key].retain) {
				this._removeTile(key);
			}
		}
	},

	_removeTilesAtZoom: function (zoom) {
		for (var key in this._tiles) {
			if (this._tiles[key].coords.z !== zoom) {
				continue;
			}
			this._removeTile(key);
		}
	},

	_removeAllTiles: function () {
		for (var key in this._tiles) {
			this._removeTile(key);
		}
	},

	_invalidateAll: function () {
		for (var z in this._levels) {
			L.DomUtil.remove(this._levels[z].el);
			delete this._levels[z];
		}
		this._removeAllTiles();

		this._tileZoom = null;
	},

	_retainParent: function (x, y, z, minZoom) {
		var x2 = Math.floor(x / 2),
		    y2 = Math.floor(y / 2),
		    z2 = z - 1,
		    coords2 = new L.Point(+x2, +y2);
		coords2.z = +z2;

		var key = this._tileCoordsToKey(coords2),
		    tile = this._tiles[key];

		if (tile && tile.active) {
			tile.retain = true;
			return true;

		} else if (tile && tile.loaded) {
			tile.retain = true;
		}

		if (z2 > minZoom) {
			return this._retainParent(x2, y2, z2, minZoom);
		}

		return false;
	},

	_retainChildren: function (x, y, z, maxZoom) {

		for (var i = 2 * x; i < 2 * x + 2; i++) {
			for (var j = 2 * y; j < 2 * y + 2; j++) {

				var coords = new L.Point(i, j);
				coords.z = z + 1;

				var key = this._tileCoordsToKey(coords),
				    tile = this._tiles[key];

				if (tile && tile.active) {
					tile.retain = true;
					continue;

				} else if (tile && tile.loaded) {
					tile.retain = true;
				}

				if (z + 1 < maxZoom) {
					this._retainChildren(i, j, z + 1, maxZoom);
				}
			}
		}
	},

	_resetView: function (e) {
		var animating = e && (e.pinch || e.flyTo);
		this._setView(this._map.getCenter(), this._map.getZoom(), animating, animating);
	},

	_animateZoom: function (e) {
		this._setView(e.center, e.zoom, true, e.noUpdate);
	},

	_setView: function (center, zoom, noPrune, noUpdate) {
		var tileZoom = Math.round(zoom);
		if ((this.options.maxZoom !== undefined && tileZoom > this.options.maxZoom) ||
		    (this.options.minZoom !== undefined && tileZoom < this.options.minZoom)) {
			tileZoom = undefined;
		}

		var tileZoomChanged = this.options.updateWhenZooming && (tileZoom !== this._tileZoom);

		if (!noUpdate || tileZoomChanged) {

			this._tileZoom = tileZoom;

			if (this._abortLoading) {
				this._abortLoading();
			}

			this._updateLevels();
			this._resetGrid();

			if (tileZoom !== undefined) {
				this._update(center);
			}

			if (!noPrune) {
				this._pruneTiles();
			}

			// Flag to prevent _updateOpacity from pruning tiles during
			// a zoom anim or a pinch gesture
			this._noPrune = !!noPrune;
		}

		this._setZoomTransforms(center, zoom);
	},

	_setZoomTransforms: function (center, zoom) {
		for (var i in this._levels) {
			this._setZoomTransform(this._levels[i], center, zoom);
		}
	},

	_setZoomTransform: function (level, center, zoom) {
		var scale = this._map.getZoomScale(zoom, level.zoom),
		    translate = level.origin.multiplyBy(scale)
		        .subtract(this._map._getNewPixelOrigin(center, zoom)).round();

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(level.el, translate, scale);
		} else {
			L.DomUtil.setPosition(level.el, translate);
		}
	},

	_resetGrid: function () {
		var map = this._map,
		    crs = map.options.crs,
		    tileSize = this._tileSize = this.getTileSize(),
		    tileZoom = this._tileZoom;

		var bounds = this._map.getPixelWorldBounds(this._tileZoom);
		if (bounds) {
			this._globalTileRange = this._pxBoundsToTileRange(bounds);
		}

		this._wrapX = crs.wrapLng && !this.options.noWrap && [
			Math.floor(map.project([0, crs.wrapLng[0]], tileZoom).x / tileSize.x),
			Math.ceil(map.project([0, crs.wrapLng[1]], tileZoom).x / tileSize.y)
		];
		this._wrapY = crs.wrapLat && !this.options.noWrap && [
			Math.floor(map.project([crs.wrapLat[0], 0], tileZoom).y / tileSize.x),
			Math.ceil(map.project([crs.wrapLat[1], 0], tileZoom).y / tileSize.y)
		];
	},

	_onMoveEnd: function () {
		if (!this._map || this._map._animatingZoom) { return; }

		this._update();
	},

	_getTiledPixelBounds: function (center) {
		var map = this._map,
		    mapZoom = map._animatingZoom ? Math.max(map._animateToZoom, map.getZoom()) : map.getZoom(),
		    scale = map.getZoomScale(mapZoom, this._tileZoom),
		    pixelCenter = map.project(center, this._tileZoom).floor(),
		    halfSize = map.getSize().divideBy(scale * 2);

		return new L.Bounds(pixelCenter.subtract(halfSize), pixelCenter.add(halfSize));
	},

	// Private method to load tiles in the grid's active zoom level according to map bounds
	_update: function (center) {
		var map = this._map;
		if (!map) { return; }
		var zoom = map.getZoom();

		if (center === undefined) { center = map.getCenter(); }
		if (this._tileZoom === undefined) { return; }	// if out of minzoom/maxzoom

		var pixelBounds = this._getTiledPixelBounds(center),
		    tileRange = this._pxBoundsToTileRange(pixelBounds),
		    tileCenter = tileRange.getCenter(),
		    queue = [],
		    margin = this.options.keepBuffer,
		    noPruneRange = new L.Bounds(tileRange.getBottomLeft().subtract([margin, -margin]),
		                              tileRange.getTopRight().add([margin, -margin]));

		for (var key in this._tiles) {
			var c = this._tiles[key].coords;
			if (c.z !== this._tileZoom || !noPruneRange.contains(L.point(c.x, c.y))) {
				this._tiles[key].current = false;
			}
		}

		// _update just loads more tiles. If the tile zoom level differs too much
		// from the map's, let _setView reset levels and prune old tiles.
		if (Math.abs(zoom - this._tileZoom) > 1) { this._setView(center, zoom); return; }

		// create a queue of coordinates to load tiles from
		for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {
			for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {
				var coords = new L.Point(i, j);
				coords.z = this._tileZoom;

				if (!this._isValidTile(coords)) { continue; }

				var tile = this._tiles[this._tileCoordsToKey(coords)];
				if (tile) {
					tile.current = true;
				} else {
					queue.push(coords);
				}
			}
		}

		// sort tile queue to load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(tileCenter) - b.distanceTo(tileCenter);
		});

		if (queue.length !== 0) {
			// if it's the first batch of tiles to load
			if (!this._loading) {
				this._loading = true;
				// @event loading: Event
				// Fired when the grid layer starts loading tiles.
				this.fire('loading');
			}

			// create DOM fragment to append tiles in one batch
			var fragment = document.createDocumentFragment();

			for (i = 0; i < queue.length; i++) {
				this._addTile(queue[i], fragment);
			}

			this._level.el.appendChild(fragment);
		}
	},

	_isValidTile: function (coords) {
		var crs = this._map.options.crs;

		if (!crs.infinite) {
			// don't load tile if it's out of bounds and not wrapped
			var bounds = this._globalTileRange;
			if ((!crs.wrapLng && (coords.x < bounds.min.x || coords.x > bounds.max.x)) ||
			    (!crs.wrapLat && (coords.y < bounds.min.y || coords.y > bounds.max.y))) { return false; }
		}

		if (!this.options.bounds) { return true; }

		// don't load tile if it doesn't intersect the bounds in options
		var tileBounds = this._tileCoordsToBounds(coords);
		return L.latLngBounds(this.options.bounds).overlaps(tileBounds);
	},

	_keyToBounds: function (key) {
		return this._tileCoordsToBounds(this._keyToTileCoords(key));
	},

	// converts tile coordinates to its geographical bounds
	_tileCoordsToBounds: function (coords) {

		var map = this._map,
		    tileSize = this.getTileSize(),

		    nwPoint = coords.scaleBy(tileSize),
		    sePoint = nwPoint.add(tileSize),

		    nw = map.unproject(nwPoint, coords.z),
		    se = map.unproject(sePoint, coords.z),
		    bounds = new L.LatLngBounds(nw, se);

		if (!this.options.noWrap) {
			map.wrapLatLngBounds(bounds);
		}

		return bounds;
	},

	// converts tile coordinates to key for the tile cache
	_tileCoordsToKey: function (coords) {
		return coords.x + ':' + coords.y + ':' + coords.z;
	},

	// converts tile cache key to coordinates
	_keyToTileCoords: function (key) {
		var k = key.split(':'),
		    coords = new L.Point(+k[0], +k[1]);
		coords.z = +k[2];
		return coords;
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];
		if (!tile) { return; }

		L.DomUtil.remove(tile.el);

		delete this._tiles[key];

		// @event tileunload: TileEvent
		// Fired when a tile is removed (e.g. when a tile goes off the screen).
		this.fire('tileunload', {
			tile: tile.el,
			coords: this._keyToTileCoords(key)
		});
	},

	_initTile: function (tile) {
		L.DomUtil.addClass(tile, 'leaflet-tile');

		var tileSize = this.getTileSize();
		tile.style.width = tileSize.x + 'px';
		tile.style.height = tileSize.y + 'px';

		tile.onselectstart = L.Util.falseFn;
		tile.onmousemove = L.Util.falseFn;

		// update opacity on tiles in IE7-8 because of filter inheritance problems
		if (L.Browser.ielt9 && this.options.opacity < 1) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}

		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.android && !L.Browser.android23) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
	},

	_addTile: function (coords, container) {
		var tilePos = this._getTilePos(coords),
		    key = this._tileCoordsToKey(coords);

		var tile = this.createTile(this._wrapCoords(coords), L.bind(this._tileReady, this, coords));

		this._initTile(tile);

		// if createTile is defined with a second argument ("done" callback),
		// we know that tile is async and will be ready later; otherwise
		if (this.createTile.length < 2) {
			// mark tile as ready, but delay one frame for opacity animation to happen
			L.Util.requestAnimFrame(L.bind(this._tileReady, this, coords, null, tile));
		}

		L.DomUtil.setPosition(tile, tilePos);

		// save tile in cache
		this._tiles[key] = {
			el: tile,
			coords: coords,
			current: true
		};

		container.appendChild(tile);
		// @event tileloadstart: TileEvent
		// Fired when a tile is requested and starts loading.
		this.fire('tileloadstart', {
			tile: tile,
			coords: coords
		});
	},

	_tileReady: function (coords, err, tile) {
		if (!this._map) { return; }

		if (err) {
			// @event tileerror: TileErrorEvent
			// Fired when there is an error loading a tile.
			this.fire('tileerror', {
				error: err,
				tile: tile,
				coords: coords
			});
		}

		var key = this._tileCoordsToKey(coords);

		tile = this._tiles[key];
		if (!tile) { return; }

		tile.loaded = +new Date();
		if (this._map._fadeAnimated) {
			L.DomUtil.setOpacity(tile.el, 0);
			L.Util.cancelAnimFrame(this._fadeFrame);
			this._fadeFrame = L.Util.requestAnimFrame(this._updateOpacity, this);
		} else {
			tile.active = true;
			this._pruneTiles();
		}

		if (!err) {
			L.DomUtil.addClass(tile.el, 'leaflet-tile-loaded');

			// @event tileload: TileEvent
			// Fired when a tile loads.
			this.fire('tileload', {
				tile: tile.el,
				coords: coords
			});
		}

		if (this._noTilesToLoad()) {
			this._loading = false;
			// @event load: Event
			// Fired when the grid layer loaded all visible tiles.
			this.fire('load');

			if (L.Browser.ielt9 || !this._map._fadeAnimated) {
				L.Util.requestAnimFrame(this._pruneTiles, this);
			} else {
				// Wait a bit more than 0.2 secs (the duration of the tile fade-in)
				// to trigger a pruning.
				setTimeout(L.bind(this._pruneTiles, this), 250);
			}
		}
	},

	_getTilePos: function (coords) {
		return coords.scaleBy(this.getTileSize()).subtract(this._level.origin);
	},

	_wrapCoords: function (coords) {
		var newCoords = new L.Point(
			this._wrapX ? L.Util.wrapNum(coords.x, this._wrapX) : coords.x,
			this._wrapY ? L.Util.wrapNum(coords.y, this._wrapY) : coords.y);
		newCoords.z = coords.z;
		return newCoords;
	},

	_pxBoundsToTileRange: function (bounds) {
		var tileSize = this.getTileSize();
		return new L.Bounds(
			bounds.min.unscaleBy(tileSize).floor(),
			bounds.max.unscaleBy(tileSize).ceil().subtract([1, 1]));
	},

	_noTilesToLoad: function () {
		for (var key in this._tiles) {
			if (!this._tiles[key].loaded) { return false; }
		}
		return true;
	}
});

// @factory L.gridLayer(options?: GridLayer options)
// Creates a new instance of GridLayer with the supplied options.
L.gridLayer = function (options) {
	return new L.GridLayer(options);
};



/*
 * @class TileLayer
 * @inherits GridLayer
 * @aka L.TileLayer
 * Used to load and display tile layers on the map. Extends `GridLayer`.
 *
 * @example
 *
 * ```js
 * L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png?{foo}', {foo: 'bar'}).addTo(map);
 * ```
 *
 * @section URL template
 * @example
 *
 * A string of the following form:
 *
 * ```
 * 'http://{s}.somedomain.com/blabla/{z}/{x}/{y}{r}.png'
 * ```
 *
 * `{s}` means one of the available subdomains (used sequentially to help with browser parallel requests per domain limitation; subdomain values are specified in options; `a`, `b` or `c` by default, can be omitted), `{z}` — zoom level, `{x}` and `{y}` — tile coordinates. `{r}` can be used to add @2x to the URL to load retina tiles.
 *
 * You can use custom keys in the template, which will be [evaluated](#util-template) from TileLayer options, like this:
 *
 * ```
 * L.tileLayer('http://{s}.somedomain.com/{foo}/{z}/{x}/{y}.png', {foo: 'bar'});
 * ```
 */


L.TileLayer = L.GridLayer.extend({

	// @section
	// @aka TileLayer options
	options: {
		// @option minZoom: Number = 0
		// Minimum zoom number.
		minZoom: 0,

		// @option maxZoom: Number = 18
		// Maximum zoom number.
		maxZoom: 18,

		// @option maxNativeZoom: Number = null
		// Maximum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels higher than `maxNativeZoom` will be loaded
		// from `maxNativeZoom` level and auto-scaled.
		maxNativeZoom: null,

		// @option minNativeZoom: Number = null
		// Minimum zoom number the tile source has available. If it is specified,
		// the tiles on all zoom levels lower than `minNativeZoom` will be loaded
		// from `minNativeZoom` level and auto-scaled.
		minNativeZoom: null,

		// @option subdomains: String|String[] = 'abc'
		// Subdomains of the tile service. Can be passed in the form of one string (where each letter is a subdomain name) or an array of strings.
		subdomains: 'abc',

		// @option errorTileUrl: String = ''
		// URL to the tile image to show in place of the tile that failed to load.
		errorTileUrl: '',

		// @option zoomOffset: Number = 0
		// The zoom number used in tile URLs will be offset with this value.
		zoomOffset: 0,

		// @option tms: Boolean = false
		// If `true`, inverses Y axis numbering for tiles (turn this on for [TMS](https://en.wikipedia.org/wiki/Tile_Map_Service) services).
		tms: false,

		// @option zoomReverse: Boolean = false
		// If set to true, the zoom number used in tile URLs will be reversed (`maxZoom - zoom` instead of `zoom`)
		zoomReverse: false,

		// @option detectRetina: Boolean = false
		// If `true` and user is on a retina display, it will request four tiles of half the specified size and a bigger zoom level in place of one to utilize the high resolution.
		detectRetina: false,

		// @option crossOrigin: Boolean = false
		// If true, all tiles will have their crossOrigin attribute set to ''. This is needed if you want to access tile pixel data.
		crossOrigin: false
	},

	initialize: function (url, options) {

		this._url = url;

		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);

			if (!options.zoomReverse) {
				options.zoomOffset++;
				options.maxZoom--;
			} else {
				options.zoomOffset--;
				options.minZoom++;
			}

			options.minZoom = Math.max(0, options.minZoom);
		}

		if (typeof options.subdomains === 'string') {
			options.subdomains = options.subdomains.split('');
		}

		// for https://github.com/Leaflet/Leaflet/issues/137
		if (!L.Browser.android) {
			this.on('tileunload', this._onTileRemove);
		}
	},

	// @method setUrl(url: String, noRedraw?: Boolean): this
	// Updates the layer's URL template and redraws it (unless `noRedraw` is set to `true`).
	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}
		return this;
	},

	// @method createTile(coords: Object, done?: Function): HTMLElement
	// Called only internally, overrides GridLayer's [`createTile()`](#gridlayer-createtile)
	// to return an `<img>` HTML element with the appropiate image URL given `coords`. The `done`
	// callback is called when the tile has been loaded.
	createTile: function (coords, done) {
		var tile = document.createElement('img');

		L.DomEvent.on(tile, 'load', L.bind(this._tileOnLoad, this, done, tile));
		L.DomEvent.on(tile, 'error', L.bind(this._tileOnError, this, done, tile));

		if (this.options.crossOrigin) {
			tile.crossOrigin = '';
		}

		/*
		 Alt tag is set to empty string to keep screen readers from reading URL and for compliance reasons
		 http://www.w3.org/TR/WCAG20-TECHS/H67
		*/
		tile.alt = '';

		/*
		 Set role="presentation" to force screen readers to ignore this
		 https://www.w3.org/TR/wai-aria/roles#textalternativecomputation
		*/
		tile.setAttribute('role', 'presentation');

		tile.src = this.getTileUrl(coords);

		return tile;
	},

	// @section Extension methods
	// @uninheritable
	// Layers extending `TileLayer` might reimplement the following method.
	// @method getTileUrl(coords: Object): String
	// Called only internally, returns the URL for a tile given its coordinates.
	// Classes extending `TileLayer` can override this function to provide custom tile URL naming schemes.
	getTileUrl: function (coords) {
		var data = {
			r: L.Browser.retina ? '@2x' : '',
			s: this._getSubdomain(coords),
			x: coords.x,
			y: coords.y,
			z: this._getZoomForUrl()
		};
		if (this._map && !this._map.options.crs.infinite) {
			var invertedY = this._globalTileRange.max.y - coords.y;
			if (this.options.tms) {
				data['y'] = invertedY;
			}
			data['-y'] = invertedY;
		}

		return L.Util.template(this._url, L.extend(data, this.options));
	},

	_tileOnLoad: function (done, tile) {
		// For https://github.com/Leaflet/Leaflet/issues/3332
		if (L.Browser.ielt9) {
			setTimeout(L.bind(done, this, null, tile), 0);
		} else {
			done(null, tile);
		}
	},

	_tileOnError: function (done, tile, e) {
		var errorUrl = this.options.errorTileUrl;
		if (errorUrl && tile.src !== errorUrl) {
			tile.src = errorUrl;
		}
		done(e, tile);
	},

	getTileSize: function () {
		var map = this._map,
		tileSize = L.GridLayer.prototype.getTileSize.call(this),
		zoom = this._tileZoom + this.options.zoomOffset,
		minNativeZoom = this.options.minNativeZoom,
		maxNativeZoom = this.options.maxNativeZoom;

		// decrease tile size when scaling below minNativeZoom
		if (minNativeZoom !== null && zoom < minNativeZoom) {
			return tileSize.divideBy(map.getZoomScale(minNativeZoom, zoom)).round();
		}

		// increase tile size when scaling above maxNativeZoom
		if (maxNativeZoom !== null && zoom > maxNativeZoom) {
			return tileSize.divideBy(map.getZoomScale(maxNativeZoom, zoom)).round();
		}

		return tileSize;
	},

	_onTileRemove: function (e) {
		e.tile.onload = null;
	},

	_getZoomForUrl: function () {
		var zoom = this._tileZoom,
		maxZoom = this.options.maxZoom,
		zoomReverse = this.options.zoomReverse,
		zoomOffset = this.options.zoomOffset,
		minNativeZoom = this.options.minNativeZoom,
		maxNativeZoom = this.options.maxNativeZoom;

		if (zoomReverse) {
			zoom = maxZoom - zoom;
		}

		zoom += zoomOffset;

		if (minNativeZoom !== null && zoom < minNativeZoom) {
			return minNativeZoom;
		}

		if (maxNativeZoom !== null && zoom > maxNativeZoom) {
			return maxNativeZoom;
		}

		return zoom;
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	// stops loading all tiles in the background layer
	_abortLoading: function () {
		var i, tile;
		for (i in this._tiles) {
			if (this._tiles[i].coords.z !== this._tileZoom) {
				tile = this._tiles[i].el;

				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;

				if (!tile.complete) {
					tile.src = L.Util.emptyImageUrl;
					L.DomUtil.remove(tile);
				}
			}
		}
	}
});


// @factory L.tilelayer(urlTemplate: String, options?: TileLayer options)
// Instantiates a tile layer object given a `URL template` and optionally an options object.

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};



/*
 * @class TileLayer.WMS
 * @inherits TileLayer
 * @aka L.TileLayer.WMS
 * Used to display [WMS](https://en.wikipedia.org/wiki/Web_Map_Service) services as tile layers on the map. Extends `TileLayer`.
 *
 * @example
 *
 * ```js
 * var nexrad = L.tileLayer.wms("http://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi", {
 * 	layers: 'nexrad-n0r-900913',
 * 	format: 'image/png',
 * 	transparent: true,
 * 	attribution: "Weather data © 2012 IEM Nexrad"
 * });
 * ```
 */

L.TileLayer.WMS = L.TileLayer.extend({

	// @section
	// @aka TileLayer.WMS options
	// If any custom options not documented here are used, they will be sent to the
	// WMS server as extra parameters in each request URL. This can be useful for
	// [non-standard vendor WMS parameters](http://docs.geoserver.org/stable/en/user/services/wms/vendor.html).
	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',

		// @option layers: String = ''
		// **(required)** Comma-separated list of WMS layers to show.
		layers: '',

		// @option styles: String = ''
		// Comma-separated list of WMS styles.
		styles: '',

		// @option format: String = 'image/jpeg'
		// WMS image format (use `'image/png'` for layers with transparency).
		format: 'image/jpeg',

		// @option transparent: Boolean = false
		// If `true`, the WMS service will return images with transparency.
		transparent: false,

		// @option version: String = '1.1.1'
		// Version of the WMS service to use
		version: '1.1.1'
	},

	options: {
		// @option crs: CRS = null
		// Coordinate Reference System to use for the WMS requests, defaults to
		// map CRS. Don't change this if you're not sure what it means.
		crs: null,

		// @option uppercase: Boolean = false
		// If `true`, WMS request parameter keys will be uppercase.
		uppercase: false
	},

	initialize: function (url, options) {

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams);

		// all keys that are not TileLayer options go to WMS params
		for (var i in options) {
			if (!(i in this.options)) {
				wmsParams[i] = options[i];
			}
		}

		options = L.setOptions(this, options);

		wmsParams.width = wmsParams.height = options.tileSize * (options.detectRetina && L.Browser.retina ? 2 : 1);

		this.wmsParams = wmsParams;
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;
		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (coords) {

		var tileBounds = this._tileCoordsToBounds(coords),
		    nw = this._crs.project(tileBounds.getNorthWest()),
		    se = this._crs.project(tileBounds.getSouthEast()),

		    bbox = (this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
			    [se.y, nw.x, nw.y, se.x] :
			    [nw.x, se.y, se.x, nw.y]).join(','),

		    url = L.TileLayer.prototype.getTileUrl.call(this, coords);

		return url +
			L.Util.getParamString(this.wmsParams, url, this.options.uppercase) +
			(this.options.uppercase ? '&BBOX=' : '&bbox=') + bbox;
	},

	// @method setParams(params: Object, noRedraw?: Boolean): this
	// Merges an object with the new parameters and re-requests tiles on the current screen (unless `noRedraw` was set to true).
	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});


// @factory L.tileLayer.wms(baseUrl: String, options: TileLayer.WMS options)
// Instantiates a WMS tile layer object given a base URL of the WMS service and a WMS parameters/options object.
L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};



/*
 * @class ImageOverlay
 * @aka L.ImageOverlay
 * @inherits Interactive layer
 *
 * Used to load and display a single image over specific bounds of the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * var imageUrl = 'http://www.lib.utexas.edu/maps/historical/newark_nj_1922.jpg',
 * 	imageBounds = [[40.712216, -74.22655], [40.773941, -74.12544]];
 * L.imageOverlay(imageUrl, imageBounds).addTo(map);
 * ```
 */

L.ImageOverlay = L.Layer.extend({

	// @section
	// @aka ImageOverlay options
	options: {
		// @option opacity: Number = 1.0
		// The opacity of the image overlay.
		opacity: 1,

		// @option alt: String = ''
		// Text for the `alt` attribute of the image (useful for accessibility).
		alt: '',

		// @option interactive: Boolean = false
		// If `true`, the image overlay will emit [mouse events](#interactive-layer) when clicked or hovered.
		interactive: false,

		// @option crossOrigin: Boolean = false
		// If true, the image will have its crossOrigin attribute set to ''. This is needed if you want to access image pixel data.
		crossOrigin: false
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function () {
		if (!this._image) {
			this._initImage();

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}

		if (this.options.interactive) {
			L.DomUtil.addClass(this._image, 'leaflet-interactive');
			this.addInteractiveTarget(this._image);
		}

		this.getPane().appendChild(this._image);
		this._reset();
	},

	onRemove: function () {
		L.DomUtil.remove(this._image);
		if (this.options.interactive) {
			this.removeInteractiveTarget(this._image);
		}
	},

	// @method setOpacity(opacity: Number): this
	// Sets the opacity of the overlay.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._image) {
			this._updateOpacity();
		}
		return this;
	},

	setStyle: function (styleOpts) {
		if (styleOpts.opacity) {
			this.setOpacity(styleOpts.opacity);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all overlays.
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._image);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all overlays.
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._image);
		}
		return this;
	},

	// @method setUrl(url: String): this
	// Changes the URL of the image.
	setUrl: function (url) {
		this._url = url;

		if (this._image) {
			this._image.src = url;
		}
		return this;
	},

	// @method setBounds(bounds: LatLngBounds): this
	// Update the bounds that this ImageOverlay covers
	setBounds: function (bounds) {
		this._bounds = bounds;

		if (this._map) {
			this._reset();
		}
		return this;
	},

	getEvents: function () {
		var events = {
			zoom: this._reset,
			viewreset: this._reset
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}

		return events;
	},

	// @method getBounds(): LatLngBounds
	// Get the bounds that this ImageOverlay covers
	getBounds: function () {
		return this._bounds;
	},

	// @method getElement(): HTMLElement
	// Get the img element that represents the ImageOverlay on the map
	getElement: function () {
		return this._image;
	},

	_initImage: function () {
		var img = this._image = L.DomUtil.create('img',
				'leaflet-image-layer ' + (this._zoomAnimated ? 'leaflet-zoom-animated' : ''));

		img.onselectstart = L.Util.falseFn;
		img.onmousemove = L.Util.falseFn;

		img.onload = L.bind(this.fire, this, 'load');

		if (this.options.crossOrigin) {
			img.crossOrigin = '';
		}

		img.src = this._url;
		img.alt = this.options.alt;
	},

	_animateZoom: function (e) {
		var scale = this._map.getZoomScale(e.zoom),
		    offset = this._map._latLngBoundsToNewLayerBounds(this._bounds, e.zoom, e.center).min;

		L.DomUtil.setTransform(this._image, offset, scale);
	},

	_reset: function () {
		var image = this._image,
		    bounds = new L.Bounds(
		        this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		        this._map.latLngToLayerPoint(this._bounds.getSouthEast())),
		    size = bounds.getSize();

		L.DomUtil.setPosition(image, bounds.min);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

// @factory L.imageOverlay(imageUrl: String, bounds: LatLngBounds, options?: ImageOverlay options)
// Instantiates an image overlay object given the URL of the image and the
// geographical bounds it is tied to.
L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};



/*
 * @class Icon
 * @aka L.Icon
 * @inherits Layer
 *
 * Represents an icon to provide when creating a marker.
 *
 * @example
 *
 * ```js
 * var myIcon = L.icon({
 *     iconUrl: 'my-icon.png',
 *     iconRetinaUrl: 'my-icon@2x.png',
 *     iconSize: [38, 95],
 *     iconAnchor: [22, 94],
 *     popupAnchor: [-3, -76],
 *     shadowUrl: 'my-icon-shadow.png',
 *     shadowRetinaUrl: 'my-icon-shadow@2x.png',
 *     shadowSize: [68, 95],
 *     shadowAnchor: [22, 94]
 * });
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * `L.Icon.Default` extends `L.Icon` and is the blue icon Leaflet uses for markers by default.
 *
 */

L.Icon = L.Class.extend({

	/* @section
	 * @aka Icon options
	 *
	 * @option iconUrl: String = null
	 * **(required)** The URL to the icon image (absolute or relative to your script path).
	 *
	 * @option iconRetinaUrl: String = null
	 * The URL to a retina sized version of the icon image (absolute or relative to your
	 * script path). Used for Retina screen devices.
	 *
	 * @option iconSize: Point = null
	 * Size of the icon image in pixels.
	 *
	 * @option iconAnchor: Point = null
	 * The coordinates of the "tip" of the icon (relative to its top left corner). The icon
	 * will be aligned so that this point is at the marker's geographical location. Centered
	 * by default if size is specified, also can be set in CSS with negative margins.
	 *
	 * @option popupAnchor: Point = null
	 * The coordinates of the point from which popups will "open", relative to the icon anchor.
	 *
	 * @option shadowUrl: String = null
	 * The URL to the icon shadow image. If not specified, no shadow image will be created.
	 *
	 * @option shadowRetinaUrl: String = null
	 *
	 * @option shadowSize: Point = null
	 * Size of the shadow image in pixels.
	 *
	 * @option shadowAnchor: Point = null
	 * The coordinates of the "tip" of the shadow (relative to its top left corner) (the same
	 * as iconAnchor if not specified).
	 *
	 * @option className: String = ''
	 * A custom class name to assign to both icon and shadow images. Empty by default.
	 */

	initialize: function (options) {
		L.setOptions(this, options);
	},

	// @method createIcon(oldIcon?: HTMLElement): HTMLElement
	// Called internally when the icon has to be shown, returns a `<img>` HTML element
	// styled according to the options.
	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	// @method createShadow(oldIcon?: HTMLElement): HTMLElement
	// As `createIcon`, but for the shadow beneath it.
	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img = this._createImg(src, oldIcon && oldIcon.tagName === 'IMG' ? oldIcon : null);
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options;
		var sizeOption = options[name + 'Size'];

		if (typeof sizeOption === 'number') {
			sizeOption = [sizeOption, sizeOption];
		}

		var size = L.point(sizeOption),
		    anchor = L.point(name === 'shadow' && options.shadowAnchor || options.iconAnchor ||
		            size && size.divideBy(2, true));

		img.className = 'leaflet-marker-' + name + ' ' + (options.className || '');

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		return L.Browser.retina && this.options[name + 'RetinaUrl'] || this.options[name + 'Url'];
	}
});


// @factory L.icon(options: Icon options)
// Creates an icon instance with the given options.
L.icon = function (options) {
	return new L.Icon(options);
};



/*
 * @miniclass Icon.Default (Icon)
 * @aka L.Icon.Default
 * @section
 *
 * A trivial subclass of `Icon`, represents the icon to use in `Marker`s when
 * no icon is specified. Points to the blue marker image distributed with Leaflet
 * releases.
 *
 * In order to customize the default icon, just change the properties of `L.Icon.Default.prototype.options`
 * (which is a set of `Icon options`).
 *
 * If you want to _completely_ replace the default icon, override the
 * `L.Marker.prototype.options.icon` with your own icon instead.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconUrl:       'marker-icon.png',
		iconRetinaUrl: 'marker-icon-2x.png',
		shadowUrl:     'marker-shadow.png',
		iconSize:    [25, 41],
		iconAnchor:  [12, 41],
		popupAnchor: [1, -34],
		tooltipAnchor: [16, -28],
		shadowSize:  [41, 41]
	},

	_getIconUrl: function (name) {
		if (!L.Icon.Default.imagePath) {	// Deprecated, backwards-compatibility only
			L.Icon.Default.imagePath = this._detectIconPath();
		}

		// @option imagePath: String
		// `L.Icon.Default` will try to auto-detect the absolute location of the
		// blue icon images. If you are placing these images in a non-standard
		// way, set this option to point to the right absolute path.
		return (this.options.imagePath || L.Icon.Default.imagePath) + L.Icon.prototype._getIconUrl.call(this, name);
	},

	_detectIconPath: function () {
		var el = L.DomUtil.create('div',  'leaflet-default-icon-path', document.body);
		var path = L.DomUtil.getStyle(el, 'background-image') ||
		           L.DomUtil.getStyle(el, 'backgroundImage');	// IE8

		document.body.removeChild(el);

		return path.indexOf('url') === 0 ?
			path.replace(/^url\([\"\']?/, '').replace(/marker-icon\.png[\"\']?\)$/, '') : '';
	}
});



/*
 * @class Marker
 * @inherits Interactive layer
 * @aka L.Marker
 * L.Marker is used to display clickable/draggable icons on the map. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.marker([50.5, 30.5]).addTo(map);
 * ```
 */

L.Marker = L.Layer.extend({

	// @section
	// @aka Marker options
	options: {
		// @option icon: Icon = *
		// Icon class to use for rendering the marker. See [Icon documentation](#L.Icon) for details on how to customize the marker icon. If not specified, a new `L.Icon.Default` is used.
		icon: new L.Icon.Default(),

		// Option inherited from "Interactive layer" abstract class
		interactive: true,

		// @option draggable: Boolean = false
		// Whether the marker is draggable with mouse/touch or not.
		draggable: false,

		// @option keyboard: Boolean = true
		// Whether the marker can be tabbed to with a keyboard and clicked by pressing enter.
		keyboard: true,

		// @option title: String = ''
		// Text for the browser tooltip that appear on marker hover (no tooltip by default).
		title: '',

		// @option alt: String = ''
		// Text for the `alt` attribute of the icon image (useful for accessibility).
		alt: '',

		// @option zIndexOffset: Number = 0
		// By default, marker images zIndex is set automatically based on its latitude. Use this option if you want to put the marker on top of all others (or below), specifying a high value like `1000` (or high negative value, respectively).
		zIndexOffset: 0,

		// @option opacity: Number = 1.0
		// The opacity of the marker.
		opacity: 1,

		// @option riseOnHover: Boolean = false
		// If `true`, the marker will get on top of others when you hover the mouse over it.
		riseOnHover: false,

		// @option riseOffset: Number = 250
		// The z-index offset used for the `riseOnHover` feature.
		riseOffset: 250,

		// @option pane: String = 'markerPane'
		// `Map pane` where the markers icon will be added.
		pane: 'markerPane',

		// FIXME: shadowPane is no longer a valid option
		nonBubblingEvents: ['click', 'dblclick', 'mouseover', 'mouseout', 'contextmenu']
	},

	/* @section
	 *
	 * In addition to [shared layer methods](#Layer) like `addTo()` and `remove()` and [popup methods](#Popup) like bindPopup() you can also use the following methods:
	 */

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._zoomAnimated = this._zoomAnimated && map.options.markerZoomAnimation;

		if (this._zoomAnimated) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._initIcon();
		this.update();
	},

	onRemove: function (map) {
		if (this.dragging && this.dragging.enabled()) {
			this.options.draggable = true;
			this.dragging.removeHooks();
		}

		if (this._zoomAnimated) {
			map.off('zoomanim', this._animateZoom, this);
		}

		this._removeIcon();
		this._removeShadow();
	},

	getEvents: function () {
		return {
			zoom: this.update,
			viewreset: this.update
		};
	},

	// @method getLatLng: LatLng
	// Returns the current geographical position of the marker.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Changes the marker position to the given point.
	setLatLng: function (latlng) {
		var oldLatLng = this._latlng;
		this._latlng = L.latLng(latlng);
		this.update();

		// @event move: Event
		// Fired when the marker is moved via [`setLatLng`](#marker-setlatlng) or by [dragging](#marker-dragging). Old and new coordinates are included in event arguments as `oldLatLng`, `latlng`.
		return this.fire('move', {oldLatLng: oldLatLng, latlng: this._latlng});
	},

	// @method setZIndexOffset(offset: Number): this
	// Changes the [zIndex offset](#marker-zindexoffset) of the marker.
	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		return this.update();
	},

	// @method setIcon(icon: Icon): this
	// Changes the marker icon.
	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup, this._popup.options);
		}

		return this;
	},

	getElement: function () {
		return this._icon;
	},

	update: function () {

		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    classToAdd = 'leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		var icon = options.icon.createIcon(this._icon),
		    addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		if (options.riseOnHover) {
			this.on({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		var newShadow = options.icon.createShadow(this._shadow),
		    addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
			newShadow.alt = '';
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		if (addIcon) {
			this.getPane().appendChild(this._icon);
		}
		this._initInteraction();
		if (newShadow && addShadow) {
			this.getPane('shadowPane').appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			this.off({
				mouseover: this._bringToFront,
				mouseout: this._resetZIndex
			});
		}

		L.DomUtil.remove(this._icon);
		this.removeInteractiveTarget(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			L.DomUtil.remove(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.interactive) { return; }

		L.DomUtil.addClass(this._icon, 'leaflet-interactive');

		this.addInteractiveTarget(this._icon);

		if (L.Handler.MarkerDrag) {
			var draggable = this.options.draggable;
			if (this.dragging) {
				draggable = this.dragging.enabled();
				this.dragging.disable();
			}

			this.dragging = new L.Handler.MarkerDrag(this);

			if (draggable) {
				this.dragging.enable();
			}
		}
	},

	// @method setOpacity(opacity: Number): this
	// Changes the opacity of the marker.
	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		var opacity = this.options.opacity;

		L.DomUtil.setOpacity(this._icon, opacity);

		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	},

	_getPopupAnchor: function () {
		return this.options.icon.options.popupAnchor || [0, 0];
	},

	_getTooltipAnchor: function () {
		return this.options.icon.options.tooltipAnchor || [0, 0];
	}
});


// factory L.marker(latlng: LatLng, options? : Marker options)

// @factory L.marker(latlng: LatLng, options? : Marker options)
// Instantiates a Marker object given a geographical point and optionally an options object.
L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};



/*
 * @class DivIcon
 * @aka L.DivIcon
 * @inherits Icon
 *
 * Represents a lightweight icon for markers that uses a simple `<div>`
 * element instead of an image. Inherits from `Icon` but ignores the `iconUrl` and shadow options.
 *
 * @example
 * ```js
 * var myIcon = L.divIcon({className: 'my-div-icon'});
 * // you can set .my-div-icon styles in CSS
 *
 * L.marker([50.505, 30.57], {icon: myIcon}).addTo(map);
 * ```
 *
 * By default, it has a 'leaflet-div-icon' CSS class and is styled as a little white square with a shadow.
 */

L.DivIcon = L.Icon.extend({
	options: {
		// @section
		// @aka DivIcon options
		iconSize: [12, 12], // also can be set through CSS

		// iconAnchor: (Point),
		// popupAnchor: (Point),

		// @option html: String = ''
		// Custom HTML code to put inside the div element, empty by default.
		html: false,

		// @option bgPos: Point = [0, 0]
		// Optional relative position of the background, in pixels
		bgPos: null,

		className: 'leaflet-div-icon'
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		div.innerHTML = options.html !== false ? options.html : '';

		if (options.bgPos) {
			var bgPos = L.point(options.bgPos);
			div.style.backgroundPosition = (-bgPos.x) + 'px ' + (-bgPos.y) + 'px';
		}
		this._setIconStyles(div, 'icon');

		return div;
	},

	createShadow: function () {
		return null;
	}
});

// @factory L.divIcon(options: DivIcon options)
// Creates a `DivIcon` instance with the given options.
L.divIcon = function (options) {
	return new L.DivIcon(options);
};



/*
 * @class DivOverlay
 * @inherits Layer
 * @aka L.DivOverlay
 * Base model for L.Popup and L.Tooltip. Inherit from it for custom popup like plugins.
 */

// @namespace DivOverlay
L.DivOverlay = L.Layer.extend({

	// @section
	// @aka DivOverlay options
	options: {
		// @option offset: Point = Point(0, 7)
		// The offset of the popup position. Useful to control the anchor
		// of the popup when opening it on some overlays.
		offset: [0, 7],

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: '',

		// @option pane: String = 'popupPane'
		// `Map pane` where the popup will be added.
		pane: 'popupPane'
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
	},

	onAdd: function (map) {
		this._zoomAnimated = map._zoomAnimated;

		if (!this._container) {
			this._initLayout();
		}

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		clearTimeout(this._removeTimeout);
		this.getPane().appendChild(this._container);
		this.update();

		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.bringToFront();
	},

	onRemove: function (map) {
		if (map._fadeAnimated) {
			L.DomUtil.setOpacity(this._container, 0);
			this._removeTimeout = setTimeout(L.bind(L.DomUtil.remove, L.DomUtil, this._container), 200);
		} else {
			L.DomUtil.remove(this._container);
		}
	},

	// @namespace Popup
	// @method getLatLng: LatLng
	// Returns the geographical point of popup.
	getLatLng: function () {
		return this._latlng;
	},

	// @method setLatLng(latlng: LatLng): this
	// Sets the geographical point where the popup will open.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	// @method getContent: String|HTMLElement
	// Returns the content of the popup.
	getContent: function () {
		return this._content;
	},

	// @method setContent(htmlContent: String|HTMLElement|Function): this
	// Sets the HTML content of the popup. If a function is passed the source layer will be passed to the function. The function should return a `String` or `HTMLElement` to be used in the popup.
	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	// @method getElement: String|HTMLElement
	// Alias for [getContent()](#popup-getcontent)
	getElement: function () {
		return this._container;
	},

	// @method update: null
	// Updates the popup content, layout and position. Useful for updating the popup after something inside changed, e.g. image loaded.
	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	getEvents: function () {
		var events = {
			zoom: this._updatePosition,
			viewreset: this._updatePosition
		};

		if (this._zoomAnimated) {
			events.zoomanim = this._animateZoom;
		}
		return events;
	},

	// @method isOpen: Boolean
	// Returns `true` when the popup is visible on the map.
	isOpen: function () {
		return !!this._map && this._map.hasLayer(this);
	},

	// @method bringToFront: this
	// Brings this popup in front of other popups (in the same map pane).
	bringToFront: function () {
		if (this._map) {
			L.DomUtil.toFront(this._container);
		}
		return this;
	},

	// @method bringToBack: this
	// Brings this popup to the back of other popups (in the same map pane).
	bringToBack: function () {
		if (this._map) {
			L.DomUtil.toBack(this._container);
		}
		return this;
	},

	_updateContent: function () {
		if (!this._content) { return; }

		var node = this._contentNode;
		var content = (typeof this._content === 'function') ? this._content(this._source || this) : this._content;

		if (typeof content === 'string') {
			node.innerHTML = content;
		} else {
			while (node.hasChildNodes()) {
				node.removeChild(node.firstChild);
			}
			node.appendChild(content);
		}
		this.fire('contentupdate');
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (this._zoomAnimated) {
			L.DomUtil.setPosition(this._container, pos.add(anchor));
		} else {
			offset = offset.add(pos).add(anchor);
		}

		var bottom = this._containerBottom = -offset.y,
		    left = this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x;

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = bottom + 'px';
		this._container.style.left = left + 'px';
	},

	_getAnchor: function () {
		return [0, 0];
	}

});



/*
 * @class Popup
 * @inherits DivOverlay
 * @aka L.Popup
 * Used to open popups in certain places of the map. Use [Map.openPopup](#map-openpopup) to
 * open popups while making sure that only one popup is open at one time
 * (recommended for usability), or use [Map.addLayer](#map-addlayer) to open as many as you want.
 *
 * @example
 *
 * If you want to just bind a popup to marker click and then open it, it's really easy:
 *
 * ```js
 * marker.bindPopup(popupContent).openPopup();
 * ```
 * Path overlays like polylines also have a `bindPopup` method.
 * Here's a more complicated way to open a popup on a map:
 *
 * ```js
 * var popup = L.popup()
 * 	.setLatLng(latlng)
 * 	.setContent('<p>Hello world!<br />This is a nice popup.</p>')
 * 	.openOn(map);
 * ```
 */


// @namespace Popup
L.Popup = L.DivOverlay.extend({

	// @section
	// @aka Popup options
	options: {
		// @option maxWidth: Number = 300
		// Max width of the popup, in pixels.
		maxWidth: 300,

		// @option minWidth: Number = 50
		// Min width of the popup, in pixels.
		minWidth: 50,

		// @option maxHeight: Number = null
		// If set, creates a scrollable container of the given height
		// inside a popup if its content exceeds it.
		maxHeight: null,

		// @option autoPan: Boolean = true
		// Set it to `false` if you don't want the map to do panning animation
		// to fit the opened popup.
		autoPan: true,

		// @option autoPanPaddingTopLeft: Point = null
		// The margin between the popup and the top left corner of the map
		// view after autopanning was performed.
		autoPanPaddingTopLeft: null,

		// @option autoPanPaddingBottomRight: Point = null
		// The margin between the popup and the bottom right corner of the map
		// view after autopanning was performed.
		autoPanPaddingBottomRight: null,

		// @option autoPanPadding: Point = Point(5, 5)
		// Equivalent of setting both top left and bottom right autopan padding to the same value.
		autoPanPadding: [5, 5],

		// @option keepInView: Boolean = false
		// Set it to `true` if you want to prevent users from panning the popup
		// off of the screen while it is open.
		keepInView: false,

		// @option closeButton: Boolean = true
		// Controls the presence of a close button in the popup.
		closeButton: true,

		// @option autoClose: Boolean = true
		// Set it to `false` if you want to override the default behavior of
		// the popup closing when user clicks the map (set globally by
		// the Map's [closePopupOnClick](#map-closepopuponclick) option).
		autoClose: true,

		// @option className: String = ''
		// A custom CSS class name to assign to the popup.
		className: ''
	},

	// @namespace Popup
	// @method openOn(map: Map): this
	// Adds the popup to the map and closes the previous one. The same as `map.openPopup(popup)`.
	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupopen: PopupEvent
		// Fired when a popup is opened in the map
		map.fire('popupopen', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupopen: PopupEvent
			// Fired when a popup bound to this layer is opened
			this._source.fire('popupopen', {popup: this}, true);
			// For non-path layers, we toggle the popup when clicking
			// again the layer, so prevent the map to reopen it.
			if (!(this._source instanceof L.Path)) {
				this._source.on('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Popup events
		// @event popupclose: PopupEvent
		// Fired when a popup in the map is closed
		map.fire('popupclose', {popup: this});

		if (this._source) {
			// @namespace Layer
			// @section Popup events
			// @event popupclose: PopupEvent
			// Fired when a popup bound to this layer is closed
			this._source.fire('popupclose', {popup: this}, true);
			if (!(this._source instanceof L.Path)) {
				this._source.off('preclick', L.DomEvent.stopPropagation);
			}
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}

		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
		    container = this._container = L.DomUtil.create('div',
			prefix + ' ' + (this.options.className || '') +
			' leaflet-zoom-animated');

		if (this.options.closeButton) {
			var closeButton = this._closeButton = L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper = L.DomUtil.create('div', prefix + '-content-wrapper', container);
		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent
			.disableClickPropagation(wrapper)
			.disableScrollPropagation(this._contentNode)
			.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center),
		    anchor = this._getAnchor();
		L.DomUtil.setPosition(this._container, pos.add(anchor));
	},

	_adjustPan: function () {
		if (!this.options.autoPan || (this._map._panAnim && this._map._panAnim._inProgress)) { return; }

		var map = this._map,
		    marginBottom = parseInt(L.DomUtil.getStyle(this._container, 'marginBottom'), 10) || 0,
		    containerHeight = this._container.offsetHeight + marginBottom,
		    containerWidth = this._containerWidth,
		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		layerPos._add(L.DomUtil.getPosition(this._container));

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		// @namespace Map
		// @section Popup events
		// @event autopanstart: Event
		// Fired when the map starts autopanning when opening a popup.
		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	},

	_getAnchor: function () {
		// Where should we anchor the popup on the source layer?
		return L.point(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]);
	}

});

// @namespace Popup
// @factory L.popup(options?: Popup options, source?: Layer)
// Instantiates a `Popup` object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the popup with a reference to the Layer to which it refers.
L.popup = function (options, source) {
	return new L.Popup(options, source);
};


/* @namespace Map
 * @section Interaction Options
 * @option closePopupOnClick: Boolean = true
 * Set it to `false` if you don't want popups to close when user clicks the map.
 */
L.Map.mergeOptions({
	closePopupOnClick: true
});


// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({
	// @method openPopup(popup: Popup): this
	// Opens the specified popup while closing the previously opened (to make sure only one is opened at one time for usability).
	// @alternative
	// @method openPopup(content: String|HTMLElement, latlng: LatLng, options?: Popup options): this
	// Creates a popup with the specified content and options and opens it in the given point on a map.
	openPopup: function (popup, latlng, options) {
		if (!(popup instanceof L.Popup)) {
			popup = new L.Popup(options).setContent(popup);
		}

		if (latlng) {
			popup.setLatLng(latlng);
		}

		if (this.hasLayer(popup)) {
			return this;
		}

		if (this._popup && this._popup.options.autoClose) {
			this.closePopup();
		}

		this._popup = popup;
		return this.addLayer(popup);
	},

	// @method closePopup(popup?: Popup): this
	// Closes the popup previously opened with [openPopup](#map-openpopup) (or the given one).
	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
		}
		return this;
	}
});

/*
 * @namespace Layer
 * @section Popup methods example
 *
 * All layers share a set of methods convenient for binding popups to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindPopup('Hi There!').addTo(map);
 * layer.openPopup();
 * layer.closePopup();
 * ```
 *
 * Popups will also be automatically opened when the layer is clicked on and closed when the layer is removed from the map or another popup is opened.
 */

// @section Popup methods
L.Layer.include({

	// @method bindPopup(content: String|HTMLElement|Function|Popup, options?: Popup options): this
	// Binds a popup to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
			content._source = this;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this.on({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = true;
		}

		return this;
	},

	// @method unbindPopup(): this
	// Removes the popup previously bound with `bindPopup`.
	unbindPopup: function () {
		if (this._popup) {
			this.off({
				click: this._openPopup,
				remove: this.closePopup,
				move: this._movePopup
			});
			this._popupHandlersAdded = false;
			this._popup = null;
		}
		return this;
	},

	// @method openPopup(latlng?: LatLng): this
	// Opens the bound popup at the specificed `latlng` or at the default popup anchor if no `latlng` is passed.
	openPopup: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._popup && this._map) {
			// set popup source to this layer
			this._popup._source = layer;

			// update the popup (content, layout, ect...)
			this._popup.update();

			// open the popup on the map
			this._map.openPopup(this._popup, latlng);
		}

		return this;
	},

	// @method closePopup(): this
	// Closes the popup bound to this layer if it is open.
	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	// @method togglePopup(): this
	// Opens or closes the popup bound to this layer depending on its current state.
	togglePopup: function (target) {
		if (this._popup) {
			if (this._popup._map) {
				this.closePopup();
			} else {
				this.openPopup(target);
			}
		}
		return this;
	},

	// @method isPopupOpen(): boolean
	// Returns `true` if the popup bound to this layer is currently open.
	isPopupOpen: function () {
		return (this._popup ? this._popup.isOpen() : false);
	},

	// @method setPopupContent(content: String|HTMLElement|Popup): this
	// Sets the content of the popup bound to this layer.
	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	// @method getPopup(): Popup
	// Returns the popup bound to this layer.
	getPopup: function () {
		return this._popup;
	},

	_openPopup: function (e) {
		var layer = e.layer || e.target;

		if (!this._popup) {
			return;
		}

		if (!this._map) {
			return;
		}

		// prevent map click
		L.DomEvent.stop(e);

		// if this inherits from Path its a vector and we can just
		// open the popup at the new location
		if (layer instanceof L.Path) {
			this.openPopup(e.layer || e.target, e.latlng);
			return;
		}

		// otherwise treat it like a marker and figure out
		// if we should toggle it open/closed
		if (this._map.hasLayer(this._popup) && this._popup._source === layer) {
			this.closePopup();
		} else {
			this.openPopup(layer, e.latlng);
		}
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});



/*
 * @class Tooltip
 * @inherits DivOverlay
 * @aka L.Tooltip
 * Used to display small texts on top of map layers.
 *
 * @example
 *
 * ```js
 * marker.bindTooltip("my tooltip text").openTooltip();
 * ```
 * Note about tooltip offset. Leaflet takes two options in consideration
 * for computing tooltip offseting:
 * - the `offset` Tooltip option: it defaults to [0, 0], and it's specific to one tooltip.
 *   Add a positive x offset to move the tooltip to the right, and a positive y offset to
 *   move it to the bottom. Negatives will move to the left and top.
 * - the `tooltipAnchor` Icon option: this will only be considered for Marker. You
 *   should adapt this value if you use a custom icon.
 */


// @namespace Tooltip
L.Tooltip = L.DivOverlay.extend({

	// @section
	// @aka Tooltip options
	options: {
		// @option pane: String = 'tooltipPane'
		// `Map pane` where the tooltip will be added.
		pane: 'tooltipPane',

		// @option offset: Point = Point(0, 0)
		// Optional offset of the tooltip position.
		offset: [0, 0],

		// @option direction: String = 'auto'
		// Direction where to open the tooltip. Possible values are: `right`, `left`,
		// `top`, `bottom`, `center`, `auto`.
		// `auto` will dynamicaly switch between `right` and `left` according to the tooltip
		// position on the map.
		direction: 'auto',

		// @option permanent: Boolean = false
		// Whether to open the tooltip permanently or only on mouseover.
		permanent: false,

		// @option sticky: Boolean = false
		// If true, the tooltip will follow the mouse instead of being fixed at the feature center.
		sticky: false,

		// @option interactive: Boolean = false
		// If true, the tooltip will listen to the feature events.
		interactive: false,

		// @option opacity: Number = 0.9
		// Tooltip container opacity.
		opacity: 0.9
	},

	onAdd: function (map) {
		L.DivOverlay.prototype.onAdd.call(this, map);
		this.setOpacity(this.options.opacity);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipopen: TooltipEvent
		// Fired when a tooltip is opened in the map.
		map.fire('tooltipopen', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipopen: TooltipEvent
			// Fired when a tooltip bound to this layer is opened.
			this._source.fire('tooltipopen', {tooltip: this}, true);
		}
	},

	onRemove: function (map) {
		L.DivOverlay.prototype.onRemove.call(this, map);

		// @namespace Map
		// @section Tooltip events
		// @event tooltipclose: TooltipEvent
		// Fired when a tooltip in the map is closed.
		map.fire('tooltipclose', {tooltip: this});

		if (this._source) {
			// @namespace Layer
			// @section Tooltip events
			// @event tooltipclose: TooltipEvent
			// Fired when a tooltip bound to this layer is closed.
			this._source.fire('tooltipclose', {tooltip: this}, true);
		}
	},

	getEvents: function () {
		var events = L.DivOverlay.prototype.getEvents.call(this);

		if (L.Browser.touch && !this.options.permanent) {
			events.preclick = this._close;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closeTooltip(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-tooltip',
		    className = prefix + ' ' + (this.options.className || '') + ' leaflet-zoom-' + (this._zoomAnimated ? 'animated' : 'hide');

		this._contentNode = this._container = L.DomUtil.create('div', className);
	},

	_updateLayout: function () {},

	_adjustPan: function () {},

	_setPosition: function (pos) {
		var map = this._map,
		    container = this._container,
		    centerPoint = map.latLngToContainerPoint(map.getCenter()),
		    tooltipPoint = map.layerPointToContainerPoint(pos),
		    direction = this.options.direction,
		    tooltipWidth = container.offsetWidth,
		    tooltipHeight = container.offsetHeight,
		    offset = L.point(this.options.offset),
		    anchor = this._getAnchor();

		if (direction === 'top') {
			pos = pos.add(L.point(-tooltipWidth / 2 + offset.x, -tooltipHeight + offset.y + anchor.y, true));
		} else if (direction === 'bottom') {
			pos = pos.subtract(L.point(tooltipWidth / 2 - offset.x, -offset.y, true));
		} else if (direction === 'center') {
			pos = pos.subtract(L.point(tooltipWidth / 2 + offset.x, tooltipHeight / 2 - anchor.y + offset.y, true));
		} else if (direction === 'right' || direction === 'auto' && tooltipPoint.x < centerPoint.x) {
			direction = 'right';
			pos = pos.add(L.point(offset.x + anchor.x, anchor.y - tooltipHeight / 2 + offset.y, true));
		} else {
			direction = 'left';
			pos = pos.subtract(L.point(tooltipWidth + anchor.x - offset.x, tooltipHeight / 2 - anchor.y - offset.y, true));
		}

		L.DomUtil.removeClass(container, 'leaflet-tooltip-right');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-left');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-top');
		L.DomUtil.removeClass(container, 'leaflet-tooltip-bottom');
		L.DomUtil.addClass(container, 'leaflet-tooltip-' + direction);
		L.DomUtil.setPosition(container, pos);
	},

	_updatePosition: function () {
		var pos = this._map.latLngToLayerPoint(this._latlng);
		this._setPosition(pos);
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._container) {
			L.DomUtil.setOpacity(this._container, opacity);
		}
	},

	_animateZoom: function (e) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, e.zoom, e.center);
		this._setPosition(pos);
	},

	_getAnchor: function () {
		// Where should we anchor the tooltip on the source layer?
		return L.point(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]);
	}

});

// @namespace Tooltip
// @factory L.tooltip(options?: Tooltip options, source?: Layer)
// Instantiates a Tooltip object given an optional `options` object that describes its appearance and location and an optional `source` object that is used to tag the tooltip with a reference to the Layer to which it refers.
L.tooltip = function (options, source) {
	return new L.Tooltip(options, source);
};

// @namespace Map
// @section Methods for Layers and Controls
L.Map.include({

	// @method openTooltip(tooltip: Tooltip): this
	// Opens the specified tooltip.
	// @alternative
	// @method openTooltip(content: String|HTMLElement, latlng: LatLng, options?: Tooltip options): this
	// Creates a tooltip with the specified content and options and open it.
	openTooltip: function (tooltip, latlng, options) {
		if (!(tooltip instanceof L.Tooltip)) {
			tooltip = new L.Tooltip(options).setContent(tooltip);
		}

		if (latlng) {
			tooltip.setLatLng(latlng);
		}

		if (this.hasLayer(tooltip)) {
			return this;
		}

		return this.addLayer(tooltip);
	},

	// @method closeTooltip(tooltip?: Tooltip): this
	// Closes the tooltip given as parameter.
	closeTooltip: function (tooltip) {
		if (tooltip) {
			this.removeLayer(tooltip);
		}
		return this;
	}

});

/*
 * @namespace Layer
 * @section Tooltip methods example
 *
 * All layers share a set of methods convenient for binding tooltips to it.
 *
 * ```js
 * var layer = L.Polygon(latlngs).bindTooltip('Hi There!').addTo(map);
 * layer.openTooltip();
 * layer.closeTooltip();
 * ```
 */

// @section Tooltip methods
L.Layer.include({

	// @method bindTooltip(content: String|HTMLElement|Function|Tooltip, options?: Tooltip options): this
	// Binds a tooltip to the layer with the passed `content` and sets up the
	// neccessary event listeners. If a `Function` is passed it will receive
	// the layer as the first argument and should return a `String` or `HTMLElement`.
	bindTooltip: function (content, options) {

		if (content instanceof L.Tooltip) {
			L.setOptions(content, options);
			this._tooltip = content;
			content._source = this;
		} else {
			if (!this._tooltip || options) {
				this._tooltip = L.tooltip(options, this);
			}
			this._tooltip.setContent(content);

		}

		this._initTooltipInteractions();

		if (this._tooltip.options.permanent && this._map && this._map.hasLayer(this)) {
			this.openTooltip();
		}

		return this;
	},

	// @method unbindTooltip(): this
	// Removes the tooltip previously bound with `bindTooltip`.
	unbindTooltip: function () {
		if (this._tooltip) {
			this._initTooltipInteractions(true);
			this.closeTooltip();
			this._tooltip = null;
		}
		return this;
	},

	_initTooltipInteractions: function (remove) {
		if (!remove && this._tooltipHandlersAdded) { return; }
		var onOff = remove ? 'off' : 'on',
		    events = {
			remove: this.closeTooltip,
			move: this._moveTooltip
		    };
		if (!this._tooltip.options.permanent) {
			events.mouseover = this._openTooltip;
			events.mouseout = this.closeTooltip;
			if (this._tooltip.options.sticky) {
				events.mousemove = this._moveTooltip;
			}
			if (L.Browser.touch) {
				events.click = this._openTooltip;
			}
		} else {
			events.add = this._openTooltip;
		}
		this[onOff](events);
		this._tooltipHandlersAdded = !remove;
	},

	// @method openTooltip(latlng?: LatLng): this
	// Opens the bound tooltip at the specificed `latlng` or at the default tooltip anchor if no `latlng` is passed.
	openTooltip: function (layer, latlng) {
		if (!(layer instanceof L.Layer)) {
			latlng = layer;
			layer = this;
		}

		if (layer instanceof L.FeatureGroup) {
			for (var id in this._layers) {
				layer = this._layers[id];
				break;
			}
		}

		if (!latlng) {
			latlng = layer.getCenter ? layer.getCenter() : layer.getLatLng();
		}

		if (this._tooltip && this._map) {

			// set tooltip source to this layer
			this._tooltip._source = layer;

			// update the tooltip (content, layout, ect...)
			this._tooltip.update();

			// open the tooltip on the map
			this._map.openTooltip(this._tooltip, latlng);

			// Tooltip container may not be defined if not permanent and never
			// opened.
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.addClass(this._tooltip._container, 'leaflet-clickable');
				this.addInteractiveTarget(this._tooltip._container);
			}
		}

		return this;
	},

	// @method closeTooltip(): this
	// Closes the tooltip bound to this layer if it is open.
	closeTooltip: function () {
		if (this._tooltip) {
			this._tooltip._close();
			if (this._tooltip.options.interactive && this._tooltip._container) {
				L.DomUtil.removeClass(this._tooltip._container, 'leaflet-clickable');
				this.removeInteractiveTarget(this._tooltip._container);
			}
		}
		return this;
	},

	// @method toggleTooltip(): this
	// Opens or closes the tooltip bound to this layer depending on its current state.
	toggleTooltip: function (target) {
		if (this._tooltip) {
			if (this._tooltip._map) {
				this.closeTooltip();
			} else {
				this.openTooltip(target);
			}
		}
		return this;
	},

	// @method isTooltipOpen(): boolean
	// Returns `true` if the tooltip bound to this layer is currently open.
	isTooltipOpen: function () {
		return this._tooltip.isOpen();
	},

	// @method setTooltipContent(content: String|HTMLElement|Tooltip): this
	// Sets the content of the tooltip bound to this layer.
	setTooltipContent: function (content) {
		if (this._tooltip) {
			this._tooltip.setContent(content);
		}
		return this;
	},

	// @method getTooltip(): Tooltip
	// Returns the tooltip bound to this layer.
	getTooltip: function () {
		return this._tooltip;
	},

	_openTooltip: function (e) {
		var layer = e.layer || e.target;

		if (!this._tooltip || !this._map) {
			return;
		}
		this.openTooltip(layer, this._tooltip.options.sticky ? e.latlng : undefined);
	},

	_moveTooltip: function (e) {
		var latlng = e.latlng, containerPoint, layerPoint;
		if (this._tooltip.options.sticky && e.originalEvent) {
			containerPoint = this._map.mouseEventToContainerPoint(e.originalEvent);
			layerPoint = this._map.containerPointToLayerPoint(containerPoint);
			latlng = this._map.layerPointToLatLng(layerPoint);
		}
		this._tooltip.setLatLng(latlng);
	}
});



/*
 * @class LayerGroup
 * @aka L.LayerGroup
 * @inherits Layer
 *
 * Used to group several layers and handle them as one. If you add it to the map,
 * any layers added or removed from the group will be added/removed on the map as
 * well. Extends `Layer`.
 *
 * @example
 *
 * ```js
 * L.layerGroup([marker1, marker2])
 * 	.addLayer(polyline)
 * 	.addTo(map);
 * ```
 */

L.LayerGroup = L.Layer.extend({

	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	// @method addLayer(layer: Layer): this
	// Adds the given layer to the group.
	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	// @method removeLayer(layer: Layer): this
	// Removes the given layer from the group.
	// @alternative
	// @method removeLayer(id: Number): this
	// Removes the layer with the given internal ID from the group.
	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	// @method hasLayer(layer: Layer): Boolean
	// Returns `true` if the given layer is currently added to the group.
	hasLayer: function (layer) {
		return !!layer && (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	// @method clearLayers(): this
	// Removes all the layers from the group.
	clearLayers: function () {
		for (var i in this._layers) {
			this.removeLayer(this._layers[i]);
		}
		return this;
	},

	// @method invoke(methodName: String, …): this
	// Calls `methodName` on every layer contained in this group, passing any
	// additional parameters. Has no effect if the layers contained do not
	// implement `methodName`.
	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		for (var i in this._layers) {
			map.addLayer(this._layers[i]);
		}
	},

	onRemove: function (map) {
		for (var i in this._layers) {
			map.removeLayer(this._layers[i]);
		}
	},

	// @method eachLayer(fn: Function, context?: Object): this
	// Iterates over the layers of the group, optionally specifying context of the iterator function.
	// ```js
	// group.eachLayer(function (layer) {
	// 	layer.bindPopup('Hello');
	// });
	// ```
	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	// @method getLayer(id: Number): Layer
	// Returns the layer with the given internal ID.
	getLayer: function (id) {
		return this._layers[id];
	},

	// @method getLayers(): Layer[]
	// Returns an array of all the layers added to the group.
	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	// @method setZIndex(zIndex: Number): this
	// Calls `setZIndex` on every layer contained in this group, passing the z-index.
	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	// @method getLayerId(layer: Layer): Number
	// Returns the internal ID for a layer
	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});


// @factory L.layerGroup(layers: Layer[])
// Create a layer group, optionally given an initial set of layers.
L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};



/*
 * @class FeatureGroup
 * @aka L.FeatureGroup
 * @inherits LayerGroup
 *
 * Extended `LayerGroup` that makes it easier to do the same thing to all its member layers:
 *  * [`bindPopup`](#layer-bindpopup) binds a popup to all of the layers at once (likewise with [`bindTooltip`](#layer-bindtooltip))
 *  * Events are propagated to the `FeatureGroup`, so if the group has an event
 * handler, it will handle events from any of the layers. This includes mouse events
 * and custom events.
 *  * Has `layeradd` and `layerremove` events
 *
 * @example
 *
 * ```js
 * L.featureGroup([marker1, marker2, polyline])
 * 	.bindPopup('Hello world!')
 * 	.on('click', function() { alert('Clicked on a member of the group!'); })
 * 	.addTo(map);
 * ```
 */

L.FeatureGroup = L.LayerGroup.extend({

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		layer.addEventParent(this);

		L.LayerGroup.prototype.addLayer.call(this, layer);

		// @event layeradd: LayerEvent
		// Fired when a layer is added to this `FeatureGroup`
		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.removeEventParent(this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		// @event layerremove: LayerEvent
		// Fired when a layer is removed from this `FeatureGroup`
		return this.fire('layerremove', {layer: layer});
	},

	// @method setStyle(style: Path options): this
	// Sets the given path options to each layer of the group that has a `setStyle` method.
	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	// @method bringToFront(): this
	// Brings the layer group to the top of all other layers
	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	// @method bringToBack(): this
	// Brings the layer group to the top of all other layers
	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	// @method getBounds(): LatLngBounds
	// Returns the LatLngBounds of the Feature Group (created from bounds and coordinates of its children).
	getBounds: function () {
		var bounds = new L.LatLngBounds();

		for (var id in this._layers) {
			var layer = this._layers[id];
			bounds.extend(layer.getBounds ? layer.getBounds() : layer.getLatLng());
		}
		return bounds;
	}
});

// @factory L.featureGroup(layers: Layer[])
// Create a feature group, optionally given an initial set of layers.
L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};



/*
 * @class Renderer
 * @inherits Layer
 * @aka L.Renderer
 *
 * Base class for vector renderer implementations (`SVG`, `Canvas`). Handles the
 * DOM container of the renderer, its bounds, and its zoom animation.
 *
 * A `Renderer` works as an implicit layer group for all `Path`s - the renderer
 * itself can be added or removed to the map. All paths use a renderer, which can
 * be implicit (the map will decide the type of renderer and use it automatically)
 * or explicit (using the [`renderer`](#path-renderer) option of the path).
 *
 * Do not use this class directly, use `SVG` and `Canvas` instead.
 *
 * @event update: Event
 * Fired when the renderer updates its bounds, center and zoom, for example when
 * its map has moved
 */

L.Renderer = L.Layer.extend({

	// @section
	// @aka Renderer options
	options: {
		// @option padding: Number = 0.1
		// How much to extend the clip area around the map view (relative to its size)
		// e.g. 0.1 would be 10% of map view in each direction
		padding: 0.1
	},

	initialize: function (options) {
		L.setOptions(this, options);
		L.stamp(this);
		this._layers = this._layers || {};
	},

	onAdd: function () {
		if (!this._container) {
			this._initContainer(); // defined by renderer implementations

			if (this._zoomAnimated) {
				L.DomUtil.addClass(this._container, 'leaflet-zoom-animated');
			}
		}

		this.getPane().appendChild(this._container);
		this._update();
		this.on('update', this._updatePaths, this);
	},

	onRemove: function () {
		L.DomUtil.remove(this._container);
		this.off('update', this._updatePaths, this);
	},

	getEvents: function () {
		var events = {
			viewreset: this._reset,
			zoom: this._onZoom,
			moveend: this._update,
			zoomend: this._onZoomEnd
		};
		if (this._zoomAnimated) {
			events.zoomanim = this._onAnimZoom;
		}
		return events;
	},

	_onAnimZoom: function (ev) {
		this._updateTransform(ev.center, ev.zoom);
	},

	_onZoom: function () {
		this._updateTransform(this._map.getCenter(), this._map.getZoom());
	},

	_updateTransform: function (center, zoom) {
		var scale = this._map.getZoomScale(zoom, this._zoom),
		    position = L.DomUtil.getPosition(this._container),
		    viewHalf = this._map.getSize().multiplyBy(0.5 + this.options.padding),
		    currentCenterPoint = this._map.project(this._center, zoom),
		    destCenterPoint = this._map.project(center, zoom),
		    centerOffset = destCenterPoint.subtract(currentCenterPoint),

		    topLeftOffset = viewHalf.multiplyBy(-scale).add(position).add(viewHalf).subtract(centerOffset);

		if (L.Browser.any3d) {
			L.DomUtil.setTransform(this._container, topLeftOffset, scale);
		} else {
			L.DomUtil.setPosition(this._container, topLeftOffset);
		}
	},

	_reset: function () {
		this._update();
		this._updateTransform(this._center, this._zoom);

		for (var id in this._layers) {
			this._layers[id]._reset();
		}
	},

	_onZoomEnd: function () {
		for (var id in this._layers) {
			this._layers[id]._project();
		}
	},

	_updatePaths: function () {
		for (var id in this._layers) {
			this._layers[id]._update();
		}
	},

	_update: function () {
		// Update pixel bounds of renderer container (for positioning/sizing/clipping later)
		// Subclasses are responsible of firing the 'update' event.
		var p = this.options.padding,
		    size = this._map.getSize(),
		    min = this._map.containerPointToLayerPoint(size.multiplyBy(-p)).round();

		this._bounds = new L.Bounds(min, min.add(size.multiplyBy(1 + p * 2)).round());

		this._center = this._map.getCenter();
		this._zoom = this._map.getZoom();
	}
});


L.Map.include({
	// @namespace Map; @method getRenderer(layer: Path): Renderer
	// Returns the instance of `Renderer` that should be used to render the given
	// `Path`. It will ensure that the `renderer` options of the map and paths
	// are respected, and that the renderers do exist on the map.
	getRenderer: function (layer) {
		// @namespace Path; @option renderer: Renderer
		// Use this specific instance of `Renderer` for this path. Takes
		// precedence over the map's [default renderer](#map-renderer).
		var renderer = layer.options.renderer || this._getPaneRenderer(layer.options.pane) || this.options.renderer || this._renderer;

		if (!renderer) {
			// @namespace Map; @option preferCanvas: Boolean = false
			// Whether `Path`s should be rendered on a `Canvas` renderer.
			// By default, all `Path`s are rendered in a `SVG` renderer.
			renderer = this._renderer = (this.options.preferCanvas && L.canvas()) || L.svg();
		}

		if (!this.hasLayer(renderer)) {
			this.addLayer(renderer);
		}
		return renderer;
	},

	_getPaneRenderer: function (name) {
		if (name === 'overlayPane' || name === undefined) {
			return false;
		}

		var renderer = this._paneRenderers[name];
		if (renderer === undefined) {
			renderer = (L.SVG && L.svg({pane: name})) || (L.Canvas && L.canvas({pane: name}));
			this._paneRenderers[name] = renderer;
		}
		return renderer;
	}
});



/*
 * @class Path
 * @aka L.Path
 * @inherits Interactive layer
 *
 * An abstract class that contains options and constants shared between vector
 * overlays (Polygon, Polyline, Circle). Do not use it directly. Extends `Layer`.
 */

L.Path = L.Layer.extend({

	// @section
	// @aka Path options
	options: {
		// @option stroke: Boolean = true
		// Whether to draw stroke along the path. Set it to `false` to disable borders on polygons or circles.
		stroke: true,

		// @option color: String = '#3388ff'
		// Stroke color
		color: '#3388ff',

		// @option weight: Number = 3
		// Stroke width in pixels
		weight: 3,

		// @option opacity: Number = 1.0
		// Stroke opacity
		opacity: 1,

		// @option lineCap: String= 'round'
		// A string that defines [shape to be used at the end](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linecap) of the stroke.
		lineCap: 'round',

		// @option lineJoin: String = 'round'
		// A string that defines [shape to be used at the corners](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-linejoin) of the stroke.
		lineJoin: 'round',

		// @option dashArray: String = null
		// A string that defines the stroke [dash pattern](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dasharray). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashArray: null,

		// @option dashOffset: String = null
		// A string that defines the [distance into the dash pattern to start the dash](https://developer.mozilla.org/docs/Web/SVG/Attribute/stroke-dashoffset). Doesn't work on `Canvas`-powered layers in [some old browsers](https://developer.mozilla.org/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility).
		dashOffset: null,

		// @option fill: Boolean = depends
		// Whether to fill the path with color. Set it to `false` to disable filling on polygons or circles.
		fill: false,

		// @option fillColor: String = *
		// Fill color. Defaults to the value of the [`color`](#path-color) option
		fillColor: null,

		// @option fillOpacity: Number = 0.2
		// Fill opacity.
		fillOpacity: 0.2,

		// @option fillRule: String = 'evenodd'
		// A string that defines [how the inside of a shape](https://developer.mozilla.org/docs/Web/SVG/Attribute/fill-rule) is determined.
		fillRule: 'evenodd',

		// className: '',

		// Option inherited from "Interactive layer" abstract class
		interactive: true
	},

	beforeAdd: function (map) {
		// Renderer is set here because we need to call renderer.getEvents
		// before this.getEvents.
		this._renderer = map.getRenderer(this);
	},

	onAdd: function () {
		this._renderer._initPath(this);
		this._reset();
		this._renderer._addPath(this);
	},

	onRemove: function () {
		this._renderer._removePath(this);
	},

	// @method redraw(): this
	// Redraws the layer. Sometimes useful after you changed the coordinates that the path uses.
	redraw: function () {
		if (this._map) {
			this._renderer._updatePath(this);
		}
		return this;
	},

	// @method setStyle(style: Path options): this
	// Changes the appearance of a Path based on the options in the `Path options` object.
	setStyle: function (style) {
		L.setOptions(this, style);
		if (this._renderer) {
			this._renderer._updateStyle(this);
		}
		return this;
	},

	// @method bringToFront(): this
	// Brings the layer to the top of all path layers.
	bringToFront: function () {
		if (this._renderer) {
			this._renderer._bringToFront(this);
		}
		return this;
	},

	// @method bringToBack(): this
	// Brings the layer to the bottom of all path layers.
	bringToBack: function () {
		if (this._renderer) {
			this._renderer._bringToBack(this);
		}
		return this;
	},

	getElement: function () {
		return this._path;
	},

	_reset: function () {
		// defined in children classes
		this._project();
		this._update();
	},

	_clickTolerance: function () {
		// used when doing hit detection for Canvas layers
		return (this.options.stroke ? this.options.weight / 2 : 0) + (L.Browser.touch ? 10 : 0);
	}
});



/*
 * @namespace LineUtil
 *
 * Various utility functions for polyine points processing, used by Leaflet internally to make polylines lightning-fast.
 */

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	// @function simplify(points: Point[], tolerance: Number): Point[]
	// Dramatically reduces the number of points in a polyline while retaining
	// its shape and returns a new array of simplified points, using the
	// [Douglas-Peucker algorithm](http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm).
	// Used for a huge performance boost when processing/displaying Leaflet polylines for
	// each zoom level and also reducing visual noise. tolerance affects the amount of
	// simplification (lesser value means higher quality but slower and with more points).
	// Also released as a separated micro-library [Simplify.js](http://mourner.github.com/simplify-js/).
	simplify: function (points, tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// @function pointToSegmentDistance(p: Point, p1: Point, p2: Point): Number
	// Returns the distance between point `p` and segment `p1` to `p2`.
	pointToSegmentDistance:  function (p, p1, p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	// @function closestPointOnSegment(p: Point, p1: Point, p2: Point): Number
	// Returns the closest point from a point `p` on a segment `p1` to `p2`.
	closestPointOnSegment: function (p, p1, p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},


	// @function clipSegment(a: Point, b: Point, bounds: Bounds, useLastCode?: Boolean, round?: Boolean): Point[]|Boolean
	// Clips the segment a to b by rectangular bounds with the
	// [Cohen-Sutherland algorithm](https://en.wikipedia.org/wiki/Cohen%E2%80%93Sutherland_algorithm)
	// (modifying the segment points directly!). Used by Leaflet to only show polyline
	// points that are on the screen or near, increasing performance.
	clipSegment: function (a, b, bounds, useLastCode, round) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			}

			// if a,b is outside the clip window (trivial reject)
			if (codeA & codeB) {
				return false;
			}

			// other cases
			codeOut = codeA || codeB;
			p = this._getEdgeIntersection(a, b, codeOut, bounds, round);
			newCode = this._getBitCode(p, bounds);

			if (codeOut === codeA) {
				a = p;
				codeA = newCode;
			} else {
				b = p;
				codeB = newCode;
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds, round) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max,
		    x, y;

		if (code & 8) { // top
			x = a.x + dx * (max.y - a.y) / dy;
			y = max.y;

		} else if (code & 4) { // bottom
			x = a.x + dx * (min.y - a.y) / dy;
			y = min.y;

		} else if (code & 2) { // right
			x = max.x;
			y = a.y + dy * (max.x - a.x) / dx;

		} else if (code & 1) { // left
			x = min.x;
			y = a.y + dy * (min.x - a.x) / dx;
		}

		return new L.Point(x, y, round);
	},

	_getBitCode: function (p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}

		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};



/*
 * @class Polyline
 * @aka L.Polyline
 * @inherits Path
 *
 * A class for drawing polyline overlays on a map. Extends `Path`.
 *
 * @example
 *
 * ```js
 * // create a red polyline from an array of LatLng points
 * var latlngs = [
 * 	[45.51, -122.68],
 * 	[37.77, -122.43],
 * 	[34.04, -118.2]
 * ];
 *
 * var polyline = L.polyline(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polyline
 * map.fitBounds(polyline.getBounds());
 * ```
 *
 * You can also pass a multi-dimensional array to represent a `MultiPolyline` shape:
 *
 * ```js
 * // create a red polyline from an array of arrays of LatLng points
 * var latlngs = [
 * 	[[45.51, -122.68],
 * 	 [37.77, -122.43],
 * 	 [34.04, -118.2]],
 * 	[[40.78, -73.91],
 * 	 [41.83, -87.62],
 * 	 [32.76, -96.72]]
 * ];
 * ```
 */

L.Polyline = L.Path.extend({

	// @section
	// @aka Polyline options
	options: {
		// @option smoothFactor: Number = 1.0
		// How much to simplify the polyline on each zoom level. More means
		// better performance and smoother look, and less means more accurate representation.
		smoothFactor: 1.0,

		// @option noClip: Boolean = false
		// Disable polyline clipping.
		noClip: false
	},

	initialize: function (latlngs, options) {
		L.setOptions(this, options);
		this._setLatLngs(latlngs);
	},

	// @method getLatLngs(): LatLng[]
	// Returns an array of the points in the path, or nested arrays of points in case of multi-polyline.
	getLatLngs: function () {
		return this._latlngs;
	},

	// @method setLatLngs(latlngs: LatLng[]): this
	// Replaces all the points in the polyline with the given array of geographical points.
	setLatLngs: function (latlngs) {
		this._setLatLngs(latlngs);
		return this.redraw();
	},

	// @method isEmpty(): Boolean
	// Returns `true` if the Polyline has no LatLngs.
	isEmpty: function () {
		return !this._latlngs.length;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity,
		    minPoint = null,
		    closest = L.LineUtil._sqClosestPointOnSegment,
		    p1, p2;

		for (var j = 0, jLen = this._parts.length; j < jLen; j++) {
			var points = this._parts[j];

			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];

				var sqDist = closest(p, p1, p2, true);

				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = closest(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	// @method getCenter(): LatLng
	// Returns the center ([centroid](http://en.wikipedia.org/wiki/Centroid)) of the polyline.
	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, halfDist, segDist, dist, p1, p2, ratio,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polyline centroid algorithm; only uses the first ring if there are multiple

		for (i = 0, halfDist = 0; i < len - 1; i++) {
			halfDist += points[i].distanceTo(points[i + 1]) / 2;
		}

		// The line is so small in the current view that all points are on the same pixel.
		if (halfDist === 0) {
			return this._map.layerPointToLatLng(points[0]);
		}

		for (i = 0, dist = 0; i < len - 1; i++) {
			p1 = points[i];
			p2 = points[i + 1];
			segDist = p1.distanceTo(p2);
			dist += segDist;

			if (dist > halfDist) {
				ratio = (dist - halfDist) / segDist;
				return this._map.layerPointToLatLng([
					p2.x - ratio * (p2.x - p1.x),
					p2.y - ratio * (p2.y - p1.y)
				]);
			}
		}
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		return this._bounds;
	},

	// @method addLatLng(latlng: LatLng, latlngs? LatLng[]): this
	// Adds a given point to the polyline. By default, adds to the first ring of
	// the polyline in case of a multi-polyline, but can be overridden by passing
	// a specific ring as a LatLng array (that you can earlier access with [`getLatLngs`](#polyline-getlatlngs)).
	addLatLng: function (latlng, latlngs) {
		latlngs = latlngs || this._defaultShape();
		latlng = L.latLng(latlng);
		latlngs.push(latlng);
		this._bounds.extend(latlng);
		return this.redraw();
	},

	_setLatLngs: function (latlngs) {
		this._bounds = new L.LatLngBounds();
		this._latlngs = this._convertLatLngs(latlngs);
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs) ? this._latlngs : this._latlngs[0];
	},

	// recursively convert latlngs input into actual LatLng instances; calculate bounds along the way
	_convertLatLngs: function (latlngs) {
		var result = [],
		    flat = L.Polyline._flat(latlngs);

		for (var i = 0, len = latlngs.length; i < len; i++) {
			if (flat) {
				result[i] = L.latLng(latlngs[i]);
				this._bounds.extend(result[i]);
			} else {
				result[i] = this._convertLatLngs(latlngs[i]);
			}
		}

		return result;
	},

	_project: function () {
		var pxBounds = new L.Bounds();
		this._rings = [];
		this._projectLatlngs(this._latlngs, this._rings, pxBounds);

		var w = this._clickTolerance(),
		    p = new L.Point(w, w);

		if (this._bounds.isValid() && pxBounds.isValid()) {
			pxBounds.min._subtract(p);
			pxBounds.max._add(p);
			this._pxBounds = pxBounds;
		}
	},

	// recursively turns latlngs into a set of rings with projected coordinates
	_projectLatlngs: function (latlngs, result, projectedBounds) {
		var flat = latlngs[0] instanceof L.LatLng,
		    len = latlngs.length,
		    i, ring;

		if (flat) {
			ring = [];
			for (i = 0; i < len; i++) {
				ring[i] = this._map.latLngToLayerPoint(latlngs[i]);
				projectedBounds.extend(ring[i]);
			}
			result.push(ring);
		} else {
			for (i = 0; i < len; i++) {
				this._projectLatlngs(latlngs[i], result, projectedBounds);
			}
		}
	},

	// clip polyline by renderer bounds so that we have less to render for performance
	_clipPoints: function () {
		var bounds = this._renderer._bounds;

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		var parts = this._parts,
		    i, j, k, len, len2, segment, points;

		for (i = 0, k = 0, len = this._rings.length; i < len; i++) {
			points = this._rings[i];

			for (j = 0, len2 = points.length; j < len2 - 1; j++) {
				segment = L.LineUtil.clipSegment(points[j], points[j + 1], bounds, j, true);

				if (!segment) { continue; }

				parts[k] = parts[k] || [];
				parts[k].push(segment[0]);

				// if segment goes out of screen, or it's the last one, it's the end of the line part
				if ((segment[1] !== points[j + 1]) || (j === len2 - 2)) {
					parts[k].push(segment[1]);
					k++;
				}
			}
		}
	},

	// simplify each clipped part of the polyline for performance
	_simplifyPoints: function () {
		var parts = this._parts,
		    tolerance = this.options.smoothFactor;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = L.LineUtil.simplify(parts[i], tolerance);
		}
	},

	_update: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();
		this._updatePath();
	},

	_updatePath: function () {
		this._renderer._updatePoly(this);
	}
});

// @factory L.polyline(latlngs: LatLng[], options?: Polyline options)
// Instantiates a polyline object given an array of geographical points and
// optionally an options object. You can create a `Polyline` object with
// multiple separate lines (`MultiPolyline`) by passing an array of arrays
// of geographic points.
L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};

L.Polyline._flat = function (latlngs) {
	// true if it's a flat array of latlngs; false if nested
	return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');
};



/*
 * @namespace PolyUtil
 * Various utility functions for polygon geometries.
 */

L.PolyUtil = {};

/* @function clipPolygon(points: Point[], bounds: Bounds, round?: Boolean): Point[]
 * Clips the polygon geometry defined by the given `points` by the given bounds (using the [Sutherland-Hodgeman algorithm](https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm)).
 * Used by Leaflet to only show polygon points that are on the screen or near, increasing
 * performance. Note that polygon points needs different algorithm for clipping
 * than polyline, so there's a seperate method for it.
 */
L.PolyUtil.clipPolygon = function (points, bounds, round) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds, round);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds, round);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};



/*
 * @class Polygon
 * @aka L.Polygon
 * @inherits Polyline
 *
 * A class for drawing polygon overlays on a map. Extends `Polyline`.
 *
 * Note that points you pass when creating a polygon shouldn't have an additional last point equal to the first one — it's better to filter out such points.
 *
 *
 * @example
 *
 * ```js
 * // create a red polygon from an array of LatLng points
 * var latlngs = [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]];
 *
 * var polygon = L.polygon(latlngs, {color: 'red'}).addTo(map);
 *
 * // zoom the map to the polygon
 * map.fitBounds(polygon.getBounds());
 * ```
 *
 * You can also pass an array of arrays of latlngs, with the first array representing the outer shape and the other arrays representing holes in the outer shape:
 *
 * ```js
 * var latlngs = [
 *   [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *   [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 * ];
 * ```
 *
 * Additionally, you can pass a multi-dimensional array to represent a MultiPolygon shape.
 *
 * ```js
 * var latlngs = [
 *   [ // first polygon
 *     [[37, -109.05],[41, -109.03],[41, -102.05],[37, -102.04]], // outer ring
 *     [[37.29, -108.58],[40.71, -108.58],[40.71, -102.50],[37.29, -102.50]] // hole
 *   ],
 *   [ // second polygon
 *     [[41, -111.03],[45, -111.04],[45, -104.05],[41, -104.05]]
 *   ]
 * ];
 * ```
 */

L.Polygon = L.Polyline.extend({

	options: {
		fill: true
	},

	isEmpty: function () {
		return !this._latlngs.length || !this._latlngs[0].length;
	},

	getCenter: function () {
		// throws error when not yet added to map as this center calculation requires projected coordinates
		if (!this._map) {
			throw new Error('Must add layer to map before using getCenter()');
		}

		var i, j, p1, p2, f, area, x, y, center,
		    points = this._rings[0],
		    len = points.length;

		if (!len) { return null; }

		// polygon centroid algorithm; only uses the first ring if there are multiple

		area = x = y = 0;

		for (i = 0, j = len - 1; i < len; j = i++) {
			p1 = points[i];
			p2 = points[j];

			f = p1.y * p2.x - p2.y * p1.x;
			x += (p1.x + p2.x) * f;
			y += (p1.y + p2.y) * f;
			area += f * 3;
		}

		if (area === 0) {
			// Polygon is so small that all points are on same pixel.
			center = points[0];
		} else {
			center = [x / area, y / area];
		}
		return this._map.layerPointToLatLng(center);
	},

	_convertLatLngs: function (latlngs) {
		var result = L.Polyline.prototype._convertLatLngs.call(this, latlngs),
		    len = result.length;

		// remove last point if it equals first one
		if (len >= 2 && result[0] instanceof L.LatLng && result[0].equals(result[len - 1])) {
			result.pop();
		}
		return result;
	},

	_setLatLngs: function (latlngs) {
		L.Polyline.prototype._setLatLngs.call(this, latlngs);
		if (L.Polyline._flat(this._latlngs)) {
			this._latlngs = [this._latlngs];
		}
	},

	_defaultShape: function () {
		return L.Polyline._flat(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0];
	},

	_clipPoints: function () {
		// polygons need a different clipping algorithm so we redefine that

		var bounds = this._renderer._bounds,
		    w = this.options.weight,
		    p = new L.Point(w, w);

		// increase clip padding by stroke width to avoid stroke on clip edges
		bounds = new L.Bounds(bounds.min.subtract(p), bounds.max.add(p));

		this._parts = [];
		if (!this._pxBounds || !this._pxBounds.intersects(bounds)) {
			return;
		}

		if (this.options.noClip) {
			this._parts = this._rings;
			return;
		}

		for (var i = 0, len = this._rings.length, clipped; i < len; i++) {
			clipped = L.PolyUtil.clipPolygon(this._rings[i], bounds, true);
			if (clipped.length) {
				this._parts.push(clipped);
			}
		}
	},

	_updatePath: function () {
		this._renderer._updatePoly(this, true);
	}
});


// @factory L.polygon(latlngs: LatLng[], options?: Polyline options)
L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};



/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

/*
 * @class Rectangle
 * @aka L.Retangle
 * @inherits Polygon
 *
 * A class for drawing rectangle overlays on a map. Extends `Polygon`.
 *
 * @example
 *
 * ```js
 * // define rectangle geographical bounds
 * var bounds = [[54.559322, -5.767822], [56.1210604, -3.021240]];
 *
 * // create an orange rectangle
 * L.rectangle(bounds, {color: "#ff7800", weight: 1}).addTo(map);
 *
 * // zoom the map to the rectangle bounds
 * map.fitBounds(bounds);
 * ```
 *
 */


L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	// @method setBounds(latLngBounds: LatLngBounds): this
	// Redraws the rectangle with the passed bounds.
	setBounds: function (latLngBounds) {
		return this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});


// @factory L.rectangle(latLngBounds: LatLngBounds, options?: Polyline options)
L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};



/*
 * @class CircleMarker
 * @aka L.CircleMarker
 * @inherits Path
 *
 * A circle of a fixed size with radius specified in pixels. Extends `Path`.
 */

L.CircleMarker = L.Path.extend({

	// @section
	// @aka CircleMarker options
	options: {
		fill: true,

		// @option radius: Number = 10
		// Radius of the circle marker, in pixels
		radius: 10
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
		this._radius = this.options.radius;
	},

	// @method setLatLng(latLng: LatLng): this
	// Sets the position of a circle marker to a new location.
	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		this.redraw();
		return this.fire('move', {latlng: this._latlng});
	},

	// @method getLatLng(): LatLng
	// Returns the current geographical position of the circle marker
	getLatLng: function () {
		return this._latlng;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle marker. Units are in pixels.
	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of the circle
	getRadius: function () {
		return this._radius;
	},

	setStyle : function (options) {
		var radius = options && options.radius || this._radius;
		L.Path.prototype.setStyle.call(this, options);
		this.setRadius(radius);
		return this;
	},

	_project: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
		this._updateBounds();
	},

	_updateBounds: function () {
		var r = this._radius,
		    r2 = this._radiusY || r,
		    w = this._clickTolerance(),
		    p = [r + w, r2 + w];
		this._pxBounds = new L.Bounds(this._point.subtract(p), this._point.add(p));
	},

	_update: function () {
		if (this._map) {
			this._updatePath();
		}
	},

	_updatePath: function () {
		this._renderer._updateCircle(this);
	},

	_empty: function () {
		return this._radius && !this._renderer._bounds.intersects(this._pxBounds);
	}
});


// @factory L.circleMarker(latlng: LatLng, options?: CircleMarker options)
// Instantiates a circle marker object given a geographical point, and an optional options object.
L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};



/*
 * @class Circle
 * @aka L.Circle
 * @inherits CircleMarker
 *
 * A class for drawing circle overlays on a map. Extends `CircleMarker`.
 *
 * It's an approximation and starts to diverge from a real circle closer to poles (due to projection distortion).
 *
 * @example
 *
 * ```js
 * L.circle([50.5, 30.5], {radius: 200}).addTo(map);
 * ```
 */

L.Circle = L.CircleMarker.extend({

	initialize: function (latlng, options, legacyOptions) {
		if (typeof options === 'number') {
			// Backwards compatibility with 0.7.x factory (latlng, radius, options?)
			options = L.extend({}, legacyOptions, {radius: options});
		}
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);

		if (isNaN(this.options.radius)) { throw new Error('Circle radius cannot be NaN'); }

		// @section
		// @aka Circle options
		// @option radius: Number; Radius of the circle, in meters.
		this._mRadius = this.options.radius;
	},

	// @method setRadius(radius: Number): this
	// Sets the radius of a circle. Units are in meters.
	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	// @method getRadius(): Number
	// Returns the current radius of a circle. Units are in meters.
	getRadius: function () {
		return this._mRadius;
	},

	// @method getBounds(): LatLngBounds
	// Returns the `LatLngBounds` of the path.
	getBounds: function () {
		var half = [this._radius, this._radiusY || this._radius];

		return new L.LatLngBounds(
			this._map.layerPointToLatLng(this._point.subtract(half)),
			this._map.layerPointToLatLng(this._point.add(half)));
	},

	setStyle: L.Path.prototype.setStyle,

	_project: function () {

		var lng = this._latlng.lng,
		    lat = this._latlng.lat,
		    map = this._map,
		    crs = map.options.crs;

		if (crs.distance === L.CRS.Earth.distance) {
			var d = Math.PI / 180,
			    latR = (this._mRadius / L.CRS.Earth.R) / d,
			    top = map.project([lat + latR, lng]),
			    bottom = map.project([lat - latR, lng]),
			    p = top.add(bottom).divideBy(2),
			    lat2 = map.unproject(p).lat,
			    lngR = Math.acos((Math.cos(latR * d) - Math.sin(lat * d) * Math.sin(lat2 * d)) /
			            (Math.cos(lat * d) * Math.cos(lat2 * d))) / d;

			if (isNaN(lngR) || lngR === 0) {
				lngR = latR / Math.cos(Math.PI / 180 * lat); // Fallback for edge case, #2425
			}

			this._point = p.subtract(map.getPixelOrigin());
			this._radius = isNaN(lngR) ? 0 : Math.max(Math.round(p.x - map.project([lat2, lng - lngR]).x), 1);
			this._radiusY = Math.max(Math.round(p.y - top.y), 1);

		} else {
			var latlng2 = crs.unproject(crs.project(this._latlng).subtract([this._mRadius, 0]));

			this._point = map.latLngToLayerPoint(this._latlng);
			this._radius = this._point.x - map.latLngToLayerPoint(latlng2).x;
		}

		this._updateBounds();
	}
});

// @factory L.circle(latlng: LatLng, options?: Circle options)
// Instantiates a circle object given a geographical point, and an options object
// which contains the circle radius.
// @alternative
// @factory L.circle(latlng: LatLng, radius: Number, options?: Circle options)
// Obsolete way of instantiating a circle, for compatibility with 0.7.x code.
// Do not use in new applications or plugins.
L.circle = function (latlng, options, legacyOptions) {
	return new L.Circle(latlng, options, legacyOptions);
};



/*
 * @class SVG
 * @inherits Renderer
 * @aka L.SVG
 *
 * Allows vector layers to be displayed with [SVG](https://developer.mozilla.org/docs/Web/SVG).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=svg), SVG is not
 * available in all web browsers, notably Android 2.x and 3.x.
 *
 * Although SVG is not available on IE7 and IE8, these browsers support
 * [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language)
 * (a now deprecated technology), and the SVG renderer will fall back to VML in
 * this case.
 *
 * @example
 *
 * Use SVG by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.svg()
 * });
 * ```
 *
 * Use a SVG renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.svg({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.SVG = L.Renderer.extend({

	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.zoomstart = this._onZoomStart;
		return events;
	},

	_initContainer: function () {
		this._container = L.SVG.create('svg');

		// makes it possible to click through svg root; we'll reset it back in individual paths
		this._container.setAttribute('pointer-events', 'none');

		this._rootGroup = L.SVG.create('g');
		this._container.appendChild(this._rootGroup);
	},

	_onZoomStart: function () {
		// Drag-then-pinch interactions might mess up the center and zoom.
		// In this case, the easiest way to prevent this is re-do the renderer
		//   bounds and padding when the zooming starts.
		this._update();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    size = b.getSize(),
		    container = this._container;

		// set size of svg-container if changed
		if (!this._svgSize || !this._svgSize.equals(size)) {
			this._svgSize = size;
			container.setAttribute('width', size.x);
			container.setAttribute('height', size.y);
		}

		// movement: update container viewBox so that we don't have to change coordinates of individual layers
		L.DomUtil.setPosition(container, b.min);
		container.setAttribute('viewBox', [b.min.x, b.min.y, size.x, size.y].join(' '));

		this.fire('update');
	},

	// methods below are called by vector layers implementations

	_initPath: function (layer) {
		var path = layer._path = L.SVG.create('path');

		// @namespace Path
		// @option className: String = null
		// Custom class name set on an element. Only for SVG renderer.
		if (layer.options.className) {
			L.DomUtil.addClass(path, layer.options.className);
		}

		if (layer.options.interactive) {
			L.DomUtil.addClass(path, 'leaflet-interactive');
		}

		this._updateStyle(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		this._rootGroup.appendChild(layer._path);
		layer.addInteractiveTarget(layer._path);
	},

	_removePath: function (layer) {
		L.DomUtil.remove(layer._path);
		layer.removeInteractiveTarget(layer._path);
		delete this._layers[L.stamp(layer)];
	},

	_updatePath: function (layer) {
		layer._project();
		layer._update();
	},

	_updateStyle: function (layer) {
		var path = layer._path,
		    options = layer.options;

		if (!path) { return; }

		if (options.stroke) {
			path.setAttribute('stroke', options.color);
			path.setAttribute('stroke-opacity', options.opacity);
			path.setAttribute('stroke-width', options.weight);
			path.setAttribute('stroke-linecap', options.lineCap);
			path.setAttribute('stroke-linejoin', options.lineJoin);

			if (options.dashArray) {
				path.setAttribute('stroke-dasharray', options.dashArray);
			} else {
				path.removeAttribute('stroke-dasharray');
			}

			if (options.dashOffset) {
				path.setAttribute('stroke-dashoffset', options.dashOffset);
			} else {
				path.removeAttribute('stroke-dashoffset');
			}
		} else {
			path.setAttribute('stroke', 'none');
		}

		if (options.fill) {
			path.setAttribute('fill', options.fillColor || options.color);
			path.setAttribute('fill-opacity', options.fillOpacity);
			path.setAttribute('fill-rule', options.fillRule || 'evenodd');
		} else {
			path.setAttribute('fill', 'none');
		}
	},

	_updatePoly: function (layer, closed) {
		this._setPath(layer, L.SVG.pointsToPath(layer._parts, closed));
	},

	_updateCircle: function (layer) {
		var p = layer._point,
		    r = layer._radius,
		    r2 = layer._radiusY || r,
		    arc = 'a' + r + ',' + r2 + ' 0 1,0 ';

		// drawing a circle with two half-arcs
		var d = layer._empty() ? 'M0 0' :
				'M' + (p.x - r) + ',' + p.y +
				arc + (r * 2) + ',0 ' +
				arc + (-r * 2) + ',0 ';

		this._setPath(layer, d);
	},

	_setPath: function (layer, path) {
		layer._path.setAttribute('d', path);
	},

	// SVG does not have the concept of zIndex so we resort to changing the DOM order of elements
	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._path);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._path);
	}
});


// @namespace SVG; @section
// There are several static functions which can be called without instantiating L.SVG:
L.extend(L.SVG, {
	// @function create(name: String): SVGElement
	// Returns a instance of [SVGElement](https://developer.mozilla.org/docs/Web/API/SVGElement),
	// corresponding to the class name passed. For example, using 'line' will return
	// an instance of [SVGLineElement](https://developer.mozilla.org/docs/Web/API/SVGLineElement).
	create: function (name) {
		return document.createElementNS('http://www.w3.org/2000/svg', name);
	},

	// @function pointsToPath(rings: Point[], closed: Boolean): String
	// Generates a SVG path string for multiple rings, with each ring turning
	// into "M..L..L.." instructions
	pointsToPath: function (rings, closed) {
		var str = '',
		    i, j, len, len2, points, p;

		for (i = 0, len = rings.length; i < len; i++) {
			points = rings[i];

			for (j = 0, len2 = points.length; j < len2; j++) {
				p = points[j];
				str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
			}

			// closes the ring for polygons; "x" is VML syntax
			str += closed ? (L.Browser.svg ? 'z' : 'x') : '';
		}

		// SVG complains about empty path strings
		return str || 'M0 0';
	}
});

// @namespace Browser; @property svg: Boolean
// `true` when the browser supports [SVG](https://developer.mozilla.org/docs/Web/SVG).
L.Browser.svg = !!(document.createElementNS && L.SVG.create('svg').createSVGRect);


// @namespace SVG
// @factory L.svg(options?: Renderer options)
// Creates a SVG renderer with the given options.
L.svg = function (options) {
	return L.Browser.svg || L.Browser.vml ? new L.SVG(options) : null;
};



/*
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

/*
 * @class SVG
 *
 * Although SVG is not available on IE7 and IE8, these browsers support [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language), and the SVG renderer will fall back to VML in this case.
 *
 * VML was deprecated in 2012, which means VML functionality exists only for backwards compatibility
 * with old versions of Internet Explorer.
 */

// @namespace Browser; @property vml: Boolean
// `true` if the browser supports [VML](https://en.wikipedia.org/wiki/Vector_Markup_Language).
L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

// redefine some SVG methods to handle VML syntax which is similar but with some differences
L.SVG.include(!L.Browser.vml ? {} : {

	_initContainer: function () {
		this._container = L.DomUtil.create('div', 'leaflet-vml-container');
	},

	_update: function () {
		if (this._map._animatingZoom) { return; }
		L.Renderer.prototype._update.call(this);
		this.fire('update');
	},

	_initPath: function (layer) {
		var container = layer._container = L.SVG.create('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape ' + (this.options.className || ''));

		container.coordsize = '1 1';

		layer._path = L.SVG.create('path');
		container.appendChild(layer._path);

		this._updateStyle(layer);
		this._layers[L.stamp(layer)] = layer;
	},

	_addPath: function (layer) {
		var container = layer._container;
		this._container.appendChild(container);

		if (layer.options.interactive) {
			layer.addInteractiveTarget(container);
		}
	},

	_removePath: function (layer) {
		var container = layer._container;
		L.DomUtil.remove(container);
		layer.removeInteractiveTarget(container);
		delete this._layers[L.stamp(layer)];
	},

	_updateStyle: function (layer) {
		var stroke = layer._stroke,
		    fill = layer._fill,
		    options = layer.options,
		    container = layer._container;

		container.stroked = !!options.stroke;
		container.filled = !!options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = layer._stroke = L.SVG.create('stroke');
			}
			container.appendChild(stroke);
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			stroke.endcap = options.lineCap.replace('butt', 'flat');
			stroke.joinstyle = options.lineJoin;

		} else if (stroke) {
			container.removeChild(stroke);
			layer._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = layer._fill = L.SVG.create('fill');
			}
			container.appendChild(fill);
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			layer._fill = null;
		}
	},

	_updateCircle: function (layer) {
		var p = layer._point.round(),
		    r = Math.round(layer._radius),
		    r2 = Math.round(layer._radiusY || r);

		this._setPath(layer, layer._empty() ? 'M0 0' :
				'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r2 + ' 0,' + (65535 * 360));
	},

	_setPath: function (layer, path) {
		layer._path.v = path;
	},

	_bringToFront: function (layer) {
		L.DomUtil.toFront(layer._container);
	},

	_bringToBack: function (layer) {
		L.DomUtil.toBack(layer._container);
	}
});

if (L.Browser.vml) {
	L.SVG.create = (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement('<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	})();
}



/*
 * @class Canvas
 * @inherits Renderer
 * @aka L.Canvas
 *
 * Allows vector layers to be displayed with [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
 * Inherits `Renderer`.
 *
 * Due to [technical limitations](http://caniuse.com/#search=canvas), Canvas is not
 * available in all web browsers, notably IE8, and overlapping geometries might
 * not display properly in some edge cases.
 *
 * @example
 *
 * Use Canvas by default for all paths in the map:
 *
 * ```js
 * var map = L.map('map', {
 * 	renderer: L.canvas()
 * });
 * ```
 *
 * Use a Canvas renderer with extra padding for specific vector geometries:
 *
 * ```js
 * var map = L.map('map');
 * var myRenderer = L.canvas({ padding: 0.5 });
 * var line = L.polyline( coordinates, { renderer: myRenderer } );
 * var circle = L.circle( center, { renderer: myRenderer } );
 * ```
 */

L.Canvas = L.Renderer.extend({
	getEvents: function () {
		var events = L.Renderer.prototype.getEvents.call(this);
		events.viewprereset = this._onViewPreReset;
		return events;
	},

	_onViewPreReset: function () {
		// Set a flag so that a viewprereset+moveend+viewreset only updates&redraws once
		this._postponeUpdatePaths = true;
	},

	onAdd: function () {
		L.Renderer.prototype.onAdd.call(this);

		// Redraw vectors since canvas is cleared upon removal,
		// in case of removing the renderer itself from the map.
		this._draw();
	},

	_initContainer: function () {
		var container = this._container = document.createElement('canvas');

		L.DomEvent
			.on(container, 'mousemove', L.Util.throttle(this._onMouseMove, 32, this), this)
			.on(container, 'click dblclick mousedown mouseup contextmenu', this._onClick, this)
			.on(container, 'mouseout', this._handleMouseOut, this);

		this._ctx = container.getContext('2d');
	},

	_updatePaths: function () {
		if (this._postponeUpdatePaths) { return; }

		var layer;
		this._redrawBounds = null;
		for (var id in this._layers) {
			layer = this._layers[id];
			layer._update();
		}
		this._redraw();
	},

	_update: function () {
		if (this._map._animatingZoom && this._bounds) { return; }

		this._drawnLayers = {};

		L.Renderer.prototype._update.call(this);

		var b = this._bounds,
		    container = this._container,
		    size = b.getSize(),
		    m = L.Browser.retina ? 2 : 1;

		L.DomUtil.setPosition(container, b.min);

		// set canvas size (also clearing it); use double size on retina
		container.width = m * size.x;
		container.height = m * size.y;
		container.style.width = size.x + 'px';
		container.style.height = size.y + 'px';

		if (L.Browser.retina) {
			this._ctx.scale(2, 2);
		}

		// translate so we use the same path coordinates after canvas element moves
		this._ctx.translate(-b.min.x, -b.min.y);

		// Tell paths to redraw themselves
		this.fire('update');
	},

	_reset: function () {
		L.Renderer.prototype._reset.call(this);

		if (this._postponeUpdatePaths) {
			this._postponeUpdatePaths = false;
			this._updatePaths();
		}
	},

	_initPath: function (layer) {
		this._updateDashArray(layer);
		this._layers[L.stamp(layer)] = layer;

		var order = layer._order = {
			layer: layer,
			prev: this._drawLast,
			next: null
		};
		if (this._drawLast) { this._drawLast.next = order; }
		this._drawLast = order;
		this._drawFirst = this._drawFirst || this._drawLast;
	},

	_addPath: function (layer) {
		this._requestRedraw(layer);
	},

	_removePath: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			this._drawLast = prev;
		}
		if (prev) {
			prev.next = next;
		} else {
			this._drawFirst = next;
		}

		delete layer._order;

		delete this._layers[L.stamp(layer)];

		this._requestRedraw(layer);
	},

	_updatePath: function (layer) {
		// Redraw the union of the layer's old pixel
		// bounds and the new pixel bounds.
		this._extendRedrawBounds(layer);
		layer._project();
		layer._update();
		// The redraw will extend the redraw bounds
		// with the new pixel bounds.
		this._requestRedraw(layer);
	},

	_updateStyle: function (layer) {
		this._updateDashArray(layer);
		this._requestRedraw(layer);
	},

	_updateDashArray: function (layer) {
		if (layer.options.dashArray) {
			var parts = layer.options.dashArray.split(','),
			    dashArray = [],
			    i;
			for (i = 0; i < parts.length; i++) {
				dashArray.push(Number(parts[i]));
			}
			layer.options._dashArray = dashArray;
		}
	},

	_requestRedraw: function (layer) {
		if (!this._map) { return; }

		this._extendRedrawBounds(layer);
		this._redrawRequest = this._redrawRequest || L.Util.requestAnimFrame(this._redraw, this);
	},

	_extendRedrawBounds: function (layer) {
		var padding = (layer.options.weight || 0) + 1;
		this._redrawBounds = this._redrawBounds || new L.Bounds();
		this._redrawBounds.extend(layer._pxBounds.min.subtract([padding, padding]));
		this._redrawBounds.extend(layer._pxBounds.max.add([padding, padding]));
	},

	_redraw: function () {
		this._redrawRequest = null;

		if (this._redrawBounds) {
			this._redrawBounds.min._floor();
			this._redrawBounds.max._ceil();
		}

		this._clear(); // clear layers in redraw bounds
		this._draw(); // draw layers

		this._redrawBounds = null;
	},

	_clear: function () {
		var bounds = this._redrawBounds;
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.clearRect(bounds.min.x, bounds.min.y, size.x, size.y);
		} else {
			this._ctx.clearRect(0, 0, this._container.width, this._container.height);
		}
	},

	_draw: function () {
		var layer, bounds = this._redrawBounds;
		this._ctx.save();
		if (bounds) {
			var size = bounds.getSize();
			this._ctx.beginPath();
			this._ctx.rect(bounds.min.x, bounds.min.y, size.x, size.y);
			this._ctx.clip();
		}

		this._drawing = true;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (!bounds || (layer._pxBounds && layer._pxBounds.intersects(bounds))) {
				layer._updatePath();
			}
		}

		this._drawing = false;

		this._ctx.restore();  // Restore state before clipping.
	},

	_updatePoly: function (layer, closed) {
		if (!this._drawing) { return; }

		var i, j, len2, p,
		    parts = layer._parts,
		    len = parts.length,
		    ctx = this._ctx;

		if (!len) { return; }

		this._drawnLayers[layer._leaflet_id] = layer;

		ctx.beginPath();

		if (ctx.setLineDash) {
			ctx.setLineDash(layer.options && layer.options._dashArray || []);
		}

		for (i = 0; i < len; i++) {
			for (j = 0, len2 = parts[i].length; j < len2; j++) {
				p = parts[i][j];
				ctx[j ? 'lineTo' : 'moveTo'](p.x, p.y);
			}
			if (closed) {
				ctx.closePath();
			}
		}

		this._fillStroke(ctx, layer);

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_updateCircle: function (layer) {

		if (!this._drawing || layer._empty()) { return; }

		var p = layer._point,
		    ctx = this._ctx,
		    r = layer._radius,
		    s = (layer._radiusY || r) / r;

		this._drawnLayers[layer._leaflet_id] = layer;

		if (s !== 1) {
			ctx.save();
			ctx.scale(1, s);
		}

		ctx.beginPath();
		ctx.arc(p.x, p.y / s, r, 0, Math.PI * 2, false);

		if (s !== 1) {
			ctx.restore();
		}

		this._fillStroke(ctx, layer);
	},

	_fillStroke: function (ctx, layer) {
		var options = layer.options;

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fillStyle = options.fillColor || options.color;
			ctx.fill(options.fillRule || 'evenodd');
		}

		if (options.stroke && options.weight !== 0) {
			ctx.globalAlpha = options.opacity;
			ctx.lineWidth = options.weight;
			ctx.strokeStyle = options.color;
			ctx.lineCap = options.lineCap;
			ctx.lineJoin = options.lineJoin;
			ctx.stroke();
		}
	},

	// Canvas obviously doesn't have mouse events for individual drawn objects,
	// so we emulate that by calculating what's under the mouse on mousemove/click manually

	_onClick: function (e) {
		var point = this._map.mouseEventToLayerPoint(e), layer, clickedLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point) && !this._map._draggableMoved(layer)) {
				clickedLayer = layer;
			}
		}
		if (clickedLayer)  {
			L.DomEvent._fakeStop(e);
			this._fireEvent([clickedLayer], e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map.dragging.moving() || this._map._animatingZoom) { return; }

		var point = this._map.mouseEventToLayerPoint(e);
		this._handleMouseHover(e, point);
	},


	_handleMouseOut: function (e) {
		var layer = this._hoveredLayer;
		if (layer) {
			// if we're leaving the layer, fire mouseout
			L.DomUtil.removeClass(this._container, 'leaflet-interactive');
			this._fireEvent([layer], e, 'mouseout');
			this._hoveredLayer = null;
		}
	},

	_handleMouseHover: function (e, point) {
		var layer, candidateHoveredLayer;

		for (var order = this._drawFirst; order; order = order.next) {
			layer = order.layer;
			if (layer.options.interactive && layer._containsPoint(point)) {
				candidateHoveredLayer = layer;
			}
		}

		if (candidateHoveredLayer !== this._hoveredLayer) {
			this._handleMouseOut(e);

			if (candidateHoveredLayer) {
				L.DomUtil.addClass(this._container, 'leaflet-interactive'); // change cursor
				this._fireEvent([candidateHoveredLayer], e, 'mouseover');
				this._hoveredLayer = candidateHoveredLayer;
			}
		}

		if (this._hoveredLayer) {
			this._fireEvent([this._hoveredLayer], e);
		}
	},

	_fireEvent: function (layers, e, type) {
		this._map._fireDOMEvent(e, type || e.type, layers);
	},

	_bringToFront: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (next) {
			next.prev = prev;
		} else {
			// Already last
			return;
		}
		if (prev) {
			prev.next = next;
		} else if (next) {
			// Update first entry unless this is the
			// signle entry
			this._drawFirst = next;
		}

		order.prev = this._drawLast;
		this._drawLast.next = order;

		order.next = null;
		this._drawLast = order;

		this._requestRedraw(layer);
	},

	_bringToBack: function (layer) {
		var order = layer._order;
		var next = order.next;
		var prev = order.prev;

		if (prev) {
			prev.next = next;
		} else {
			// Already first
			return;
		}
		if (next) {
			next.prev = prev;
		} else if (prev) {
			// Update last entry unless this is the
			// signle entry
			this._drawLast = prev;
		}

		order.prev = null;

		order.next = this._drawFirst;
		this._drawFirst.prev = order;
		this._drawFirst = order;

		this._requestRedraw(layer);
	}
});

// @namespace Browser; @property canvas: Boolean
// `true` when the browser supports [`<canvas>`](https://developer.mozilla.org/docs/Web/API/Canvas_API).
L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

// @namespace Canvas
// @factory L.canvas(options?: Renderer options)
// Creates a Canvas renderer with the given options.
L.canvas = function (options) {
	return L.Browser.canvas ? new L.Canvas(options) : null;
};

L.Polyline.prototype._containsPoint = function (p, closed) {
	var i, j, k, len, len2, part,
	    w = this._clickTolerance();

	if (!this._pxBounds.contains(p)) { return false; }

	// hit detection for polylines
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			if (!closed && (j === 0)) { continue; }

			if (L.LineUtil.pointToSegmentDistance(p, part[k], part[j]) <= w) {
				return true;
			}
		}
	}
	return false;
};

L.Polygon.prototype._containsPoint = function (p) {
	var inside = false,
	    part, p1, p2, i, j, k, len, len2;

	if (!this._pxBounds.contains(p)) { return false; }

	// ray casting algorithm for detecting if point is in polygon
	for (i = 0, len = this._parts.length; i < len; i++) {
		part = this._parts[i];

		for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
			p1 = part[j];
			p2 = part[k];

			if (((p1.y > p.y) !== (p2.y > p.y)) && (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
				inside = !inside;
			}
		}
	}

	// also check if it's on polygon stroke
	return inside || L.Polyline.prototype._containsPoint.call(this, p, true);
};

L.CircleMarker.prototype._containsPoint = function (p) {
	return p.distanceTo(this._point) <= this._radius + this._clickTolerance();
};



/*
 * @class GeoJSON
 * @aka L.GeoJSON
 * @inherits FeatureGroup
 *
 * Represents a GeoJSON object or an array of GeoJSON objects. Allows you to parse
 * GeoJSON data and display it on the map. Extends `FeatureGroup`.
 *
 * @example
 *
 * ```js
 * L.geoJSON(data, {
 * 	style: function (feature) {
 * 		return {color: feature.properties.color};
 * 	}
 * }).bindPopup(function (layer) {
 * 	return layer.feature.properties.description;
 * }).addTo(map);
 * ```
 */

L.GeoJSON = L.FeatureGroup.extend({

	/* @section
	 * @aka GeoJSON options
	 *
	 * @option pointToLayer: Function = *
	 * A `Function` defining how GeoJSON points spawn Leaflet layers. It is internally
	 * called when data is added, passing the GeoJSON point feature and its `LatLng`.
	 * The default is to spawn a default `Marker`:
	 * ```js
	 * function(geoJsonPoint, latlng) {
	 * 	return L.marker(latlng);
	 * }
	 * ```
	 *
	 * @option style: Function = *
	 * A `Function` defining the `Path options` for styling GeoJSON lines and polygons,
	 * called internally when data is added.
	 * The default value is to not override any defaults:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return {}
	 * }
	 * ```
	 *
	 * @option onEachFeature: Function = *
	 * A `Function` that will be called once for each created `Feature`, after it has
	 * been created and styled. Useful for attaching events and popups to features.
	 * The default is to do nothing with the newly created layers:
	 * ```js
	 * function (feature, layer) {}
	 * ```
	 *
	 * @option filter: Function = *
	 * A `Function` that will be used to decide whether to include a feature or not.
	 * The default is to include all features:
	 * ```js
	 * function (geoJsonFeature) {
	 * 	return true;
	 * }
	 * ```
	 * Note: dynamically changing the `filter` option will have effect only on newly
	 * added data. It will _not_ re-evaluate already included features.
	 *
	 * @option coordsToLatLng: Function = *
	 * A `Function` that will be used for converting GeoJSON coordinates to `LatLng`s.
	 * The default is the `coordsToLatLng` static method.
	 */

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	// @method addData( <GeoJSON> data ): this
	// Adds a GeoJSON object to the layer.
	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(feature);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return this; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options);
		if (!layer) {
			return this;
		}
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	// @method resetStyle( <Path> layer ): this
	// Resets the given vector layer's style to the original GeoJSON style, useful for resetting style after hover events.
	resetStyle: function (layer) {
		// reset any custom styles
		layer.options = L.Util.extend({}, layer.defaultOptions);
		this._setLayerStyle(layer, this.options.style);
		return this;
	},

	// @method setStyle( <Function> style ): this
	// Changes styles of GeoJSON vector layers with the given style function.
	setStyle: function (style) {
		return this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

// @section
// There are several static functions which can be called without instantiating L.GeoJSON:
L.extend(L.GeoJSON, {
	// @function geometryToLayer(featureData: Object, options?: GeoJSON options): Layer
	// Creates a `Layer` from a given GeoJSON feature. Can use a custom
	// [`pointToLayer`](#geojson-pointtolayer) and/or [`coordsToLatLng`](#geojson-coordstolatlng)
	// functions if provided as options.
	geometryToLayer: function (geojson, options) {

		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry ? geometry.coordinates : null,
		    layers = [],
		    pointToLayer = options && options.pointToLayer,
		    coordsToLatLng = options && options.coordsToLatLng || this.coordsToLatLng,
		    latlng, latlngs, i, len;

		if (!coords && !geometry) {
			return null;
		}

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'LineString' ? 0 : 1, coordsToLatLng);
			return new L.Polyline(latlngs, options);

		case 'Polygon':
		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, geometry.type === 'Polygon' ? 1 : 2, coordsToLatLng);
			return new L.Polygon(latlngs, options);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {
				var layer = this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, options);

				if (layer) {
					layers.push(layer);
				}
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	// @function coordsToLatLng(coords: Array): LatLng
	// Creates a `LatLng` object from an array of 2 numbers (longitude, latitude)
	// or 3 numbers (longitude, latitude, altitude) used in GeoJSON for points.
	coordsToLatLng: function (coords) {
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	// @function coordsToLatLngs(coords: Array, levelsDeep?: Number, coordsToLatLng?: Function): Array
	// Creates a multidimensional array of `LatLng`s from a GeoJSON coordinates array.
	// `levelsDeep` specifies the nesting level (0 is for an array of points, 1 for an array of arrays of points, etc., 0 by default).
	// Can use a custom [`coordsToLatLng`](#geojson-coordstolatlng) function.
	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) {
		var latlngs = [];

		for (var i = 0, len = coords.length, latlng; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	// @function latLngToCoords(latlng: LatLng): Array
	// Reverse of [`coordsToLatLng`](#geojson-coordstolatlng)
	latLngToCoords: function (latlng) {
		return latlng.alt !== undefined ?
				[latlng.lng, latlng.lat, latlng.alt] :
				[latlng.lng, latlng.lat];
	},

	// @function latLngsToCoords(latlngs: Array, levelsDeep?: Number, closed?: Boolean): Array
	// Reverse of [`coordsToLatLngs`](#geojson-coordstolatlngs)
	// `closed` determines whether the first point should be appended to the end of the array to close the feature, only used when `levelsDeep` is 0. False by default.
	latLngsToCoords: function (latlngs, levelsDeep, closed) {
		var coords = [];

		for (var i = 0, len = latlngs.length; i < len; i++) {
			coords.push(levelsDeep ?
				L.GeoJSON.latLngsToCoords(latlngs[i], levelsDeep - 1, closed) :
				L.GeoJSON.latLngToCoords(latlngs[i]));
		}

		if (!levelsDeep && closed) {
			coords.push(coords[0]);
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ?
				L.extend({}, layer.feature, {geometry: newGeometry}) :
				L.GeoJSON.asFeature(newGeometry);
	},

	// @function asFeature(geojson: Object): Object
	// Normalize GeoJSON geometries/features into GeoJSON features.
	asFeature: function (geojson) {
		if (geojson.type === 'Feature' || geojson.type === 'FeatureCollection') {
			return geojson;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geojson
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

// @namespace Marker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the marker (as a GeoJSON `Point` Feature).
L.Marker.include(PointToGeoJSON);

// @namespace CircleMarker
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the circle marker (as a GeoJSON `Point` Feature).
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);


// @namespace Polyline
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polyline (as a GeoJSON `LineString` or `MultiLineString` Feature).
L.Polyline.prototype.toGeoJSON = function () {
	var multi = !L.Polyline._flat(this._latlngs);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 1 : 0);

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'LineString',
		coordinates: coords
	});
};

// @namespace Polygon
// @method toGeoJSON(): Object
// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the polygon (as a GeoJSON `Polygon` or `MultiPolygon` Feature).
L.Polygon.prototype.toGeoJSON = function () {
	var holes = !L.Polyline._flat(this._latlngs),
	    multi = holes && !L.Polyline._flat(this._latlngs[0]);

	var coords = L.GeoJSON.latLngsToCoords(this._latlngs, multi ? 2 : holes ? 1 : 0, true);

	if (!holes) {
		coords = [coords];
	}

	return L.GeoJSON.getFeature(this, {
		type: (multi ? 'Multi' : '') + 'Polygon',
		coordinates: coords
	});
};


// @namespace LayerGroup
L.LayerGroup.include({
	toMultiPoint: function () {
		var coords = [];

		this.eachLayer(function (layer) {
			coords.push(layer.toGeoJSON().geometry.coordinates);
		});

		return L.GeoJSON.getFeature(this, {
			type: 'MultiPoint',
			coordinates: coords
		});
	},

	// @method toGeoJSON(): Object
	// Returns a [`GeoJSON`](http://en.wikipedia.org/wiki/GeoJSON) representation of the layer group (as a GeoJSON `GeometryCollection`).
	toGeoJSON: function () {

		var type = this.feature && this.feature.geometry && this.feature.geometry.type;

		if (type === 'MultiPoint') {
			return this.toMultiPoint();
		}

		var isGeometryCollection = type === 'GeometryCollection',
		    jsons = [];

		this.eachLayer(function (layer) {
			if (layer.toGeoJSON) {
				var json = layer.toGeoJSON();
				jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
			}
		});

		if (isGeometryCollection) {
			return L.GeoJSON.getFeature(this, {
				geometries: jsons,
				type: 'GeometryCollection'
			});
		}

		return {
			type: 'FeatureCollection',
			features: jsons
		};
	}
});

// @namespace GeoJSON
// @factory L.geoJSON(geojson?: Object, options?: GeoJSON options)
// Creates a GeoJSON layer. Optionally accepts an object in
// [GeoJSON format](http://geojson.org/geojson-spec.html) to display on the map
// (you can alternatively add it later with `addData` method) and an `options` object.
L.geoJSON = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};
// Backward compatibility.
L.geoJson = L.geoJSON;



/*
 * @class Draggable
 * @aka L.Draggable
 * @inherits Evented
 *
 * A class for making DOM elements draggable (including touch support).
 * Used internally for map and marker dragging. Only works for elements
 * that were positioned with [`L.DomUtil.setPosition`](#domutil-setposition).
 *
 * @example
 * ```js
 * var draggable = new L.Draggable(elementToDrag);
 * draggable.enable();
 * ```
 */

L.Draggable = L.Evented.extend({

	options: {
		// @option clickTolerance: Number = 3
		// The max number of pixels a user can shift the mouse pointer during a click
		// for it to be considered a valid click (as opposed to a mouse drag).
		clickTolerance: 3
	},

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	// @constructor L.Draggable(el: HTMLElement, dragHandle?: HTMLElement, preventOutline: Boolean)
	// Creates a `Draggable` object for moving `el` when you start dragging the `dragHandle` element (equals `el` itself by default).
	initialize: function (element, dragStartTarget, preventOutline) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
		this._preventOutline = preventOutline;
	},

	// @method enable()
	// Enables the dragging ability
	enable: function () {
		if (this._enabled) { return; }

		L.DomEvent.on(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = true;
	},

	// @method disable()
	// Disables the dragging ability
	disable: function () {
		if (!this._enabled) { return; }

		// If we're currently dragging this draggable,
		// disabling it counts as first ending the drag.
		if (L.Draggable._dragging === this) {
			this.finishDrag();
		}

		L.DomEvent.off(this._dragStartTarget, L.Draggable.START.join(' '), this._onDown, this);

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		this._moved = false;

		if (L.DomUtil.hasClass(this._element, 'leaflet-zoom-anim')) { return; }

		if (L.Draggable._dragging || e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }
		L.Draggable._dragging = this;  // Prevent dragging multiple objects at once.

		if (this._preventOutline) {
			L.DomUtil.preventOutline(this._element);
		}

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		// @event down: Event
		// Fired when a drag is about to start.
		this.fire('down');

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);

		L.DomEvent
			.on(document, L.Draggable.MOVE[e.type], this._onMove, this)
			.on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }

		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }
		if (Math.abs(offset.x) + Math.abs(offset.y) < this.options.clickTolerance) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			// @event dragstart: Event
			// Fired when a drag starts
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');

			this._lastTarget = e.target || e.srcElement;
			// IE and Edge do not give the <use> element, so fetch it
			// if necessary
			if ((window.SVGElementInstance) && (this._lastTarget instanceof SVGElementInstance)) {
				this._lastTarget = this._lastTarget.correspondingUseElement;
			}
			L.DomUtil.addClass(this._lastTarget, 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._lastEvent = e;
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true);
	},

	_updatePosition: function () {
		var e = {originalEvent: this._lastEvent};

		// @event predrag: Event
		// Fired continuously during dragging *before* each corresponding
		// update of the element's position.
		this.fire('predrag', e);
		L.DomUtil.setPosition(this._element, this._newPos);

		// @event drag: Event
		// Fired continuously during dragging.
		this.fire('drag', e);
	},

	_onUp: function (e) {
		// Ignore simulated events, since we handle both touch and
		// mouse explicitly; otherwise we risk getting duplicates of
		// touch events, see #4315.
		// Also ignore the event if disabled; this happens in IE11
		// under some circumstances, see #3666.
		if (e._simulated || !this._enabled) { return; }
		this.finishDrag();
	},

	finishDrag: function () {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');

		if (this._lastTarget) {
			L.DomUtil.removeClass(this._lastTarget, 'leaflet-drag-target');
			this._lastTarget = null;
		}

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
				.off(document, L.Draggable.MOVE[i], this._onMove, this)
				.off(document, L.Draggable.END[i], this._onUp, this);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			// @event dragend: DragEndEvent
			// Fired when the drag ends.
			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
		L.Draggable._dragging = false;
	}

});



/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

// @class Handler
// @aka L.Handler
// Abstract class for map interaction handlers

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	// @method enable(): this
	// Enables the handler
	enable: function () {
		if (this._enabled) { return this; }

		this._enabled = true;
		this.addHooks();
		return this;
	},

	// @method disable(): this
	// Disables the handler
	disable: function () {
		if (!this._enabled) { return this; }

		this._enabled = false;
		this.removeHooks();
		return this;
	},

	// @method enabled(): Boolean
	// Returns `true` if the handler is enabled
	enabled: function () {
		return !!this._enabled;
	}

	// @section Extension methods
	// Classes inheriting from `Handler` must implement the two following methods:
	// @method addHooks()
	// Called when the handler is enabled, should add event hooks.
	// @method removeHooks()
	// Called when the handler is disabled, should remove the event hooks added previously.
});



/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option dragging: Boolean = true
	// Whether the map be draggable with mouse/touch or not.
	dragging: true,

	// @section Panning Inertia Options
	// @option inertia: Boolean = *
	// If enabled, panning of the map will have an inertia effect where
	// the map builds momentum while dragging and continues moving in
	// the same direction for some time. Feels especially nice on touch
	// devices. Enabled by default unless running on old Android devices.
	inertia: !L.Browser.android23,

	// @option inertiaDeceleration: Number = 3000
	// The rate with which the inertial movement slows down, in pixels/second².
	inertiaDeceleration: 3400, // px/s^2

	// @option inertiaMaxSpeed: Number = Infinity
	// Max speed of the inertial movement, in pixels/second.
	inertiaMaxSpeed: Infinity, // px/s

	// @option easeLinearity: Number = 0.2
	easeLinearity: 0.2,

	// TODO refactor, move to CRS
	// @option worldCopyJump: Boolean = false
	// With this option enabled, the map tracks when you pan to another "copy"
	// of the world and seamlessly jumps to the original one so that all overlays
	// like markers and vector layers are still visible.
	worldCopyJump: false,

	// @option maxBoundsViscosity: Number = 0.0
	// If `maxBounds` is set, this option will control how solid the bounds
	// are when dragging the map around. The default value of `0.0` allows the
	// user to drag outside the bounds at normal speed, higher values will
	// slow down map dragging outside bounds, and `1.0` makes the bounds fully
	// solid, preventing the user from dragging outside the bounds.
	maxBoundsViscosity: 0.0
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				down: this._onDown,
				dragstart: this._onDragStart,
				drag: this._onDrag,
				dragend: this._onDragEnd
			}, this);

			this._draggable.on('predrag', this._onPreDragLimit, this);
			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDragWrap, this);
				map.on('zoomend', this._onZoomEnd, this);

				map.whenReady(this._onZoomEnd, this);
			}
		}
		L.DomUtil.addClass(this._map._container, 'leaflet-grab leaflet-touch-drag');
		this._draggable.enable();
		this._positions = [];
		this._times = [];
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-grab');
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-drag');
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	moving: function () {
		return this._draggable && this._draggable._moving;
	},

	_onDown: function () {
		this._map._stop();
	},

	_onDragStart: function () {
		var map = this._map;

		if (this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
			var bounds = L.latLngBounds(this._map.options.maxBounds);

			this._offsetLimit = L.bounds(
				this._map.latLngToContainerPoint(bounds.getNorthWest()).multiplyBy(-1),
				this._map.latLngToContainerPoint(bounds.getSouthEast()).multiplyBy(-1)
					.add(this._map.getSize()));

			this._viscosity = Math.min(1.0, Math.max(0.0, this._map.options.maxBoundsViscosity));
		} else {
			this._offsetLimit = null;
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function (e) {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._absPos || this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 50) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onZoomEnd: function () {
		var pxCenter = this._map.getSize().divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.getPixelWorldBounds().getSize().x;
	},

	_viscousLimit: function (value, threshold) {
		return value - (value - threshold) * this._viscosity;
	},

	_onPreDragLimit: function () {
		if (!this._viscosity || !this._offsetLimit) { return; }

		var offset = this._draggable._newPos.subtract(this._draggable._startPos);

		var limit = this._offsetLimit;
		if (offset.x < limit.min.x) { offset.x = this._viscousLimit(offset.x, limit.min.x); }
		if (offset.y < limit.min.y) { offset.y = this._viscousLimit(offset.y, limit.min.y); }
		if (offset.x > limit.max.x) { offset.x = this._viscousLimit(offset.x, limit.max.x); }
		if (offset.y > limit.max.y) { offset.y = this._viscousLimit(offset.y, limit.max.y); }

		this._draggable._newPos = this._draggable._startPos.add(offset);
	},

	_onPreDragWrap: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._absPos = this._draggable._newPos.clone();
		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,

		    noInertia = !options.inertia || this._times.length < 2;

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x && !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true,
						animate: true
					});
				});
			}
		}
	}
});

// @section Handlers
// @property dragging: Handler
// Map dragging handler (by both mouse and touch).
L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);



/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

// @namespace Map
// @section Interaction Options

L.Map.mergeOptions({
	// @option doubleClickZoom: Boolean|String = true
	// Whether the map can be zoomed in by double clicking on it and
	// zoomed out by double clicking while holding shift. If passed
	// `'center'`, double-click zoom will zoom to the center of the
	//  view regardless of where the mouse was.
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    oldZoom = map.getZoom(),
		    delta = map.options.zoomDelta,
		    zoom = e.originalEvent.shiftKey ? oldZoom - delta : oldZoom + delta;

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

// @section Handlers
//
// Map properties include interaction handlers that allow you to control
// interaction behavior in runtime, enabling or disabling certain features such
// as dragging or touch zoom (see `Handler` methods). For example:
//
// ```js
// map.doubleClickZoom.disable();
// ```
//
// @property doubleClickZoom: Handler
// Double click zoom handler.
L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);



/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Mousewheel options
	// @option scrollWheelZoom: Boolean|String = true
	// Whether the map can be zoomed by using the mouse wheel. If passed `'center'`,
	// it will zoom to the center of the view regardless of where the mouse was.
	scrollWheelZoom: true,

	// @option wheelDebounceTime: Number = 40
	// Limits the rate at which a wheel can fire (in milliseconds). By default
	// user can't zoom via wheel more often than once per 40 ms.
	wheelDebounceTime: 40,

	// @option wheelPxPerZoomLevel: Number = 60
	// How many scroll pixels (as reported by [L.DomEvent.getWheelDelta](#domevent-getwheeldelta))
	// mean a change of one full zoom level. Smaller values will make wheel-zooming
	// faster (and vice versa).
	wheelPxPerZoomLevel: 60
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);

		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll, this);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		var debounce = this._map.options.wheelDebounceTime;

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(debounce - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.stop(e);
	},

	_performZoom: function () {
		var map = this._map,
		    zoom = map.getZoom(),
		    snap = this._map.options.zoomSnap || 0;

		map._stop(); // stop panning and fly animations if any

		// map the delta with a sigmoid function to -4..4 range leaning on -1..1
		var d2 = this._delta / (this._map.options.wheelPxPerZoomLevel * 4),
		    d3 = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(d2)))) / Math.LN2,
		    d4 = snap ? Math.ceil(d3 / snap) * snap : d3,
		    delta = map._limitZoom(zoom + (this._delta > 0 ? d4 : -d4)) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

// @section Handlers
// @property scrollWheelZoom: Handler
// Scroll wheel zoom handler.
L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);



/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last, touch,
		    doubleTap = false,
		    delay = 250;

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				if ((!L.Browser.edge) || e.pointerType === 'mouse') { return; }
				count = L.DomEvent._pointersCount;
			} else {
				count = e.touches.length;
			}

			if (count > 1) { return; }

			var now = Date.now(),
			    delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (doubleTap && !touch.cancelBubble) {
				if (L.Browser.pointer) {
					if ((!L.Browser.edge) || e.pointerType === 'mouse') { return; }

					// work around .type being readonly with MSPointer* events
					var newTouch = {},
					    prop, i;

					for (i in touch) {
						prop = touch[i];
						newTouch[i] = prop && prop.bind ? prop.bind(touch) : prop;
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}

		var pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend;

		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;
		obj[pre + 'dblclick' + id] = handler;

		obj.addEventListener(touchstart, onTouchStart, false);
		obj.addEventListener(touchend, onTouchEnd, false);

		// On some platforms (notably, chrome<55 on win10 + touchscreen + mouse),
		// the browser doesn't fire touchend/pointerup events but does fire
		// native dblclicks. See #4127.
		// Edge 14 also fires native dblclicks, but only for pointerType mouse, see #5180.
		obj.addEventListener('dblclick', handler, false);

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_',
		    touchstart = obj[pre + this._touchstart + id],
		    touchend = obj[pre + this._touchend + id],
		    dblclick = obj[pre + 'dblclick' + id];

		obj.removeEventListener(this._touchstart, touchstart, false);
		obj.removeEventListener(this._touchend, touchend, false);
		if (!L.Browser.edge) {
			obj.removeEventListener('dblclick', dblclick, false);
		}

		return this;
	}
});



/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	POINTER_DOWN:   L.Browser.msPointer ? 'MSPointerDown'   : 'pointerdown',
	POINTER_MOVE:   L.Browser.msPointer ? 'MSPointerMove'   : 'pointermove',
	POINTER_UP:     L.Browser.msPointer ? 'MSPointerUp'     : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',
	TAG_WHITE_LIST: ['INPUT', 'SELECT', 'OPTION'],

	_pointers: {},
	_pointersCount: 0,

	// Provides a touch events wrapper for (ms)pointer events.
	// ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		if (type === 'touchstart') {
			this._addPointerStart(obj, handler, id);

		} else if (type === 'touchmove') {
			this._addPointerMove(obj, handler, id);

		} else if (type === 'touchend') {
			this._addPointerEnd(obj, handler, id);
		}

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var handler = obj['_leaflet_' + type + id];

		if (type === 'touchstart') {
			obj.removeEventListener(this.POINTER_DOWN, handler, false);

		} else if (type === 'touchmove') {
			obj.removeEventListener(this.POINTER_MOVE, handler, false);

		} else if (type === 'touchend') {
			obj.removeEventListener(this.POINTER_UP, handler, false);
			obj.removeEventListener(this.POINTER_CANCEL, handler, false);
		}

		return this;
	},

	_addPointerStart: function (obj, handler, id) {
		var onDown = L.bind(function (e) {
			if (e.pointerType !== 'mouse' && e.MSPOINTER_TYPE_MOUSE && e.pointerType !== e.MSPOINTER_TYPE_MOUSE) {
				// In IE11, some touch events needs to fire for form controls, or
				// the controls will stop working. We keep a whitelist of tag names that
				// need these events. For other target tags, we prevent default on the event.
				if (this.TAG_WHITE_LIST.indexOf(e.target.tagName) < 0) {
					L.DomEvent.preventDefault(e);
				} else {
					return;
				}
			}

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchstart' + id] = onDown;
		obj.addEventListener(this.POINTER_DOWN, onDown, false);

		// need to keep track of what pointers and how many are active to provide e.touches emulation
		if (!this._pointerDocListener) {
			var pointerUp = L.bind(this._globalPointerUp, this);

			// we listen documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_DOWN, L.bind(this._globalPointerDown, this), true);
			document.documentElement.addEventListener(this.POINTER_MOVE, L.bind(this._globalPointerMove, this), true);
			document.documentElement.addEventListener(this.POINTER_UP, pointerUp, true);
			document.documentElement.addEventListener(this.POINTER_CANCEL, pointerUp, true);

			this._pointerDocListener = true;
		}
	},

	_globalPointerDown: function (e) {
		this._pointers[e.pointerId] = e;
		this._pointersCount++;
	},

	_globalPointerMove: function (e) {
		if (this._pointers[e.pointerId]) {
			this._pointers[e.pointerId] = e;
		}
	},

	_globalPointerUp: function (e) {
		delete this._pointers[e.pointerId];
		this._pointersCount--;
	},

	_handlePointer: function (e, handler) {
		e.touches = [];
		for (var i in this._pointers) {
			e.touches.push(this._pointers[i]);
		}
		e.changedTouches = [e];

		handler(e);
	},

	_addPointerMove: function (obj, handler, id) {
		var onMove = L.bind(function (e) {
			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchmove' + id] = onMove;
		obj.addEventListener(this.POINTER_MOVE, onMove, false);
	},

	_addPointerEnd: function (obj, handler, id) {
		var onUp = L.bind(function (e) {
			this._handlePointer(e, handler);
		}, this);

		obj['_leaflet_touchend' + id] = onUp;
		obj.addEventListener(this.POINTER_UP, onUp, false);
		obj.addEventListener(this.POINTER_CANCEL, onUp, false);
	}
});



/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option touchZoom: Boolean|String = *
	// Whether the map can be zoomed by touch-dragging with two fingers. If
	// passed `'center'`, it will zoom to the center of the view regardless of
	// where the touch events (fingers) were. Enabled for touch-capable web
	// browsers except for old Androids.
	touchZoom: L.Browser.touch && !L.Browser.android23,

	// @option bounceAtZoomLimits: Boolean = true
	// Set it to false if you don't want the map to zoom beyond min/max zoom
	// and then bounce back when pinch-zooming.
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomUtil.addClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomUtil.removeClass(this._map._container, 'leaflet-touch-zoom');
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;
		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]);

		this._centerPoint = map.getSize()._divideBy(2);
		this._startLatLng = map.containerPointToLatLng(this._centerPoint);
		if (map.options.touchZoom !== 'center') {
			this._pinchStartLatLng = map.containerPointToLatLng(p1.add(p2)._divideBy(2));
		}

		this._startDist = p1.distanceTo(p2);
		this._startZoom = map.getZoom();

		this._moved = false;
		this._zooming = true;

		map._stop();

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var map = this._map,
		    p1 = map.mouseEventToContainerPoint(e.touches[0]),
		    p2 = map.mouseEventToContainerPoint(e.touches[1]),
		    scale = p1.distanceTo(p2) / this._startDist;


		this._zoom = map.getScaleZoom(scale, this._startZoom);

		if (!map.options.bounceAtZoomLimits && (
			(this._zoom < map.getMinZoom() && scale < 1) ||
			(this._zoom > map.getMaxZoom() && scale > 1))) {
			this._zoom = map._limitZoom(this._zoom);
		}

		if (map.options.touchZoom === 'center') {
			this._center = this._startLatLng;
			if (scale === 1) { return; }
		} else {
			// Get delta from pinch to center, so centerLatLng is delta applied to initial pinchLatLng
			var delta = p1._add(p2)._divideBy(2)._subtract(this._centerPoint);
			if (scale === 1 && delta.x === 0 && delta.y === 0) { return; }
			this._center = map.unproject(map.project(this._pinchStartLatLng, this._zoom).subtract(delta), this._zoom);
		}

		if (!this._moved) {
			map._moveStart(true);
			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);

		var moveFn = L.bind(map._move, map, this._center, this._zoom, {pinch: true, round: false});
		this._animRequest = L.Util.requestAnimFrame(moveFn, this, true);

		L.DomEvent.preventDefault(e);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		this._zooming = false;
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		// Pinch updates GridLayers' levels only when zoomSnap is off, so zoomSnap becomes noUpdate.
		if (this._map.options.zoomAnimation) {
			this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), true, this._map.options.zoomSnap);
		} else {
			this._map._resetView(this._center, this._map._limitZoom(this._zoom));
		}
	}
});

// @section Handlers
// @property touchZoom: Handler
// Touch zoom handler.
L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);



/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @section Touch interaction options
	// @option tap: Boolean = true
	// Enables mobile hacks for supporting instant taps (fixing 200ms click
	// delay on iOS/Android) and touch holds (fired as `contextmenu` events).
	tap: true,

	// @option tapTolerance: Number = 15
	// The max number of pixels a user can shift his finger during touch
	// for it to be considered a valid tap.
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		this._simulateEvent('mousedown', first);

		L.DomEvent.on(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent.off(document, {
			touchmove: this._onMove,
			touchend: this._onUp
		}, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			this._simulateEvent('mouseup', first);

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
		this._simulateEvent('mousemove', first);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

// @section Handlers
// @property tap: Handler
// Mobile touch hacks (quick tap and touch hold) handler.
if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}



/*
 * L.Handler.BoxZoom is used to add shift-drag zoom interaction to the map
 * (zoom to a selected bounding box), enabled by default.
 */

// @namespace Map
// @section Interaction Options
L.Map.mergeOptions({
	// @option boxZoom: Boolean = true
	// Whether the map can be zoomed to a rectangular area specified by
	// dragging the mouse while pressing the shift key.
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown, this);
	},

	moved: function () {
		return this._moved;
	},

	_resetState: function () {
		this._moved = false;
	},

	_onMouseDown: function (e) {
		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		this._resetState();

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startPoint = this._map.mouseEventToContainerPoint(e);

		L.DomEvent.on(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._moved = true;

			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._container);
			L.DomUtil.addClass(this._container, 'leaflet-crosshair');

			this._map.fire('boxzoomstart');
		}

		this._point = this._map.mouseEventToContainerPoint(e);

		var bounds = new L.Bounds(this._point, this._startPoint),
		    size = bounds.getSize();

		L.DomUtil.setPosition(this._box, bounds.min);

		this._box.style.width  = size.x + 'px';
		this._box.style.height = size.y + 'px';
	},

	_finish: function () {
		if (this._moved) {
			L.DomUtil.remove(this._box);
			L.DomUtil.removeClass(this._container, 'leaflet-crosshair');
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent.off(document, {
			contextmenu: L.DomEvent.stop,
			mousemove: this._onMouseMove,
			mouseup: this._onMouseUp,
			keydown: this._onKeyDown
		}, this);
	},

	_onMouseUp: function (e) {
		if ((e.which !== 1) && (e.button !== 1)) { return; }

		this._finish();

		if (!this._moved) { return; }
		// Postpone to next JS tick so internal click event handling
		// still see it as "moved".
		setTimeout(L.bind(this._resetState, this), 0);

		var bounds = new L.LatLngBounds(
		        this._map.containerPointToLatLng(this._startPoint),
		        this._map.containerPointToLatLng(this._point));

		this._map
			.fitBounds(bounds)
			.fire('boxzoomend', {boxZoomBounds: bounds});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

// @section Handlers
// @property boxZoom: Handler
// Box (shift-drag with mouse) zoom handler.
L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);



/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

// @namespace Map
// @section Keyboard Navigation Options
L.Map.mergeOptions({
	// @option keyboard: Boolean = true
	// Makes the map focusable and allows users to navigate the map with keyboard
	// arrows and `+`/`-` keys.
	keyboard: true,

	// @option keyboardPanDelta: Number = 80
	// Amount of pixels to pan when pressing an arrow key.
	keyboardPanDelta: 80
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 54, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanDelta(map.options.keyboardPanDelta);
		this._setZoomDelta(map.options.zoomDelta);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex <= 0) {
			container.tabIndex = '0';
		}

		L.DomEvent.on(container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.on({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	removeHooks: function () {
		this._removeHooks();

		L.DomEvent.off(this._map._container, {
			focus: this._onFocus,
			blur: this._onBlur,
			mousedown: this._onMouseDown
		}, this);

		this._map.off({
			focus: this._addHooks,
			blur: this._removeHooks
		}, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanDelta: function (panDelta) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * panDelta, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [panDelta, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, panDelta];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * panDelta];
		}
	},

	_setZoomDelta: function (zoomDelta) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoomDelta;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoomDelta;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		if (e.altKey || e.ctrlKey || e.metaKey) { return; }

		var key = e.keyCode,
		    map = this._map,
		    offset;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			offset = this._panKeys[key];
			if (e.shiftKey) {
				offset = L.point(offset).multiplyBy(3);
			}

			map.panBy(offset);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + (e.shiftKey ? 3 : 1) * this._zoomKeys[key]);

		} else if (key === 27) {
			map.closePopup();

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

// @section Handlers
// @section Handlers
// @property keyboard: Handler
// Keyboard navigation handler.
L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);



/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */


/* @namespace Marker
 * @section Interaction handlers
 *
 * Interaction handlers are properties of a marker instance that allow you to control interaction behavior in runtime, enabling or disabling certain features such as dragging (see `Handler` methods). Example:
 *
 * ```js
 * marker.dragging.disable();
 * ```
 *
 * @property dragging: Handler
 * Marker dragging handler (by both mouse and touch).
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;

		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon, true);
		}

		this._draggable.on({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).enable();

		L.DomUtil.addClass(icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable.off({
			dragstart: this._onDragStart,
			drag: this._onDrag,
			dragend: this._onDragEnd
		}, this).disable();

		if (this._marker._icon) {
			L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
		}
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		// @section Dragging events
		// @event dragstart: Event
		// Fired when the user starts dragging the marker.

		// @event movestart: Event
		// Fired when the marker starts moving (because of dragging).

		this._oldLatLng = this._marker.getLatLng();
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function (e) {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;
		e.latlng = latlng;
		e.oldLatLng = this._oldLatLng;

		// @event drag: Event
		// Fired repeatedly while the user drags the marker.
		marker
		    .fire('move', e)
		    .fire('drag', e);
	},

	_onDragEnd: function (e) {
		// @event dragend: DragEndEvent
		// Fired when the user stops dragging the marker.

		// @event moveend: Event
		// Fired when the marker stops moving (because of dragging).
		delete this._oldLatLng;
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});



/*
 * @class Control
 * @aka L.Control
 * @inherits Class
 *
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	// @section
	// @aka Control options
	options: {
		// @option position: String = 'topright'
		// The position of the control (one of the map corners). Possible values are `'topleft'`,
		// `'topright'`, `'bottomleft'` or `'bottomright'`
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	/* @section
	 * Classes extending L.Control will inherit the following methods:
	 *
	 * @method getPosition: string
	 * Returns the position of the control.
	 */
	getPosition: function () {
		return this.options.position;
	},

	// @method setPosition(position: string): this
	// Sets the position of the control.
	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	// @method getContainer: HTMLElement
	// Returns the HTMLElement that contains the control.
	getContainer: function () {
		return this._container;
	},

	// @method addTo(map: Map): this
	// Adds the control to the given map.
	addTo: function (map) {
		this.remove();
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	// @method remove: this
	// Removes the control from the map it is currently active on.
	remove: function () {
		if (!this._map) {
			return this;
		}

		L.DomUtil.remove(this._container);

		if (this.onRemove) {
			this.onRemove(this._map);
		}

		this._map = null;

		return this;
	},

	_refocusOnMap: function (e) {
		// if map exists and event is not a keyboard event
		if (this._map && e && e.screenX > 0 && e.screenY > 0) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};

/* @section Extension methods
 * @uninheritable
 *
 * Every control should extend from `L.Control` and (re-)implement the following methods.
 *
 * @method onAdd(map: Map): HTMLElement
 * Should return the container DOM element for the control and add listeners on relevant map events. Called on [`control.addTo(map)`](#control-addTo).
 *
 * @method onRemove(map: Map)
 * Optional method. Should contain all clean up code that removes the listeners previously added in [`onAdd`](#control-onadd). Called on [`control.remove()`](#control-remove).
 */

/* @namespace Map
 * @section Methods for Layers and Controls
 */
L.Map.include({
	// @method addControl(control: Control): this
	// Adds the given control to the map
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	// @method removeControl(control: Control): this
	// Removes the given control from the map
	removeControl: function (control) {
		control.remove();
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		L.DomUtil.remove(this._controlContainer);
	}
});



/*
 * @class Control.Zoom
 * @aka L.Control.Zoom
 * @inherits Control
 *
 * A basic zoom control with two buttons (zoom in and zoom out). It is put on the map by default unless you set its [`zoomControl` option](#map-zoomcontrol) to `false`. Extends `Control`.
 */

L.Control.Zoom = L.Control.extend({
	// @section
	// @aka Control.Zoom options
	options: {
		position: 'topleft',

		// @option zoomInText: String = '+'
		// The text set on the 'zoom in' button.
		zoomInText: '+',

		// @option zoomInTitle: String = 'Zoom in'
		// The title set on the 'zoom in' button.
		zoomInTitle: 'Zoom in',

		// @option zoomOutText: String = '-'
		// The text set on the 'zoom out' button.
		zoomOutText: '-',

		// @option zoomOutTitle: String = 'Zoom out'
		// The title set on the 'zoom out' button.
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar'),
		    options = this.options;

		this._zoomInButton  = this._createButton(options.zoomInText, options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn);
		this._zoomOutButton = this._createButton(options.zoomOutText, options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	disable: function () {
		this._disabled = true;
		this._updateDisabled();
		return this;
	},

	enable: function () {
		this._disabled = false;
		this._updateDisabled();
		return this;
	},

	_zoomIn: function (e) {
		if (!this._disabled && this._map._zoom < this._map.getMaxZoom()) {
			this._map.zoomIn(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_zoomOut: function (e) {
		if (!this._disabled && this._map._zoom > this._map.getMinZoom()) {
			this._map.zoomOut(this._map.options.zoomDelta * (e.shiftKey ? 3 : 1));
		}
	},

	_createButton: function (html, title, className, container, fn) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		/*
		 * Will force screen readers like VoiceOver to read this as "Zoom in - button"
		 */
		link.setAttribute('role', 'button');
		link.setAttribute('aria-label', title);

		L.DomEvent
		    .on(link, 'mousedown dblclick', L.DomEvent.stopPropagation)
		    .on(link, 'click', L.DomEvent.stop)
		    .on(link, 'click', fn, this)
		    .on(link, 'click', this._refocusOnMap, this);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
		    className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (this._disabled || map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (this._disabled || map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

// @namespace Map
// @section Control options
// @option zoomControl: Boolean = true
// Whether a [zoom control](#control-zoom) is added to the map by default.
L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

// @namespace Control.Zoom
// @factory L.control.zoom(options: Control.Zoom options)
// Creates a zoom control
L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * @class Control.Attribution
 * @aka L.Control.Attribution
 * @inherits Control
 *
 * The attribution control allows you to display attribution data in a small text box on a map. It is put on the map by default unless you set its [`attributionControl` option](#map-attributioncontrol) to `false`, and it fetches attribution texts from layers with the [`getAttribution` method](#layer-getattribution) automatically. Extends Control.
 */

L.Control.Attribution = L.Control.extend({
	// @section
	// @aka Control.Attribution options
	options: {
		position: 'bottomright',

		// @option prefix: String = 'Leaflet'
		// The HTML text shown before the attributions. Pass `false` to disable.
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		map.attributionControl = this;
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		if (L.DomEvent) {
			L.DomEvent.disableClickPropagation(this._container);
		}

		// TODO ugly, refactor
		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}

		this._update();

		return this._container;
	},

	// @method setPrefix(prefix: String): this
	// Sets the text before the attributions.
	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	// @method addAttribution(text: String): this
	// Adds an attribution text (e.g. `'Vector data &copy; Mapbox'`).
	addAttribution: function (text) {
		if (!text) { return this; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	// @method removeAttribution(text: String): this
	// Removes an attribution text.
	removeAttribution: function (text) {
		if (!text) { return this; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	}
});

// @namespace Map
// @section Control options
// @option attributionControl: Boolean = true
// Whether a [attribution control](#control-attribution) is added to the map by default.
L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		new L.Control.Attribution().addTo(this);
	}
});

// @namespace Control.Attribution
// @factory L.control.attribution(options: Control.Attribution options)
// Creates an attribution control.
L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};



/*
 * @class Control.Scale
 * @aka L.Control.Scale
 * @inherits Control
 *
 * A simple scale control that shows the scale of the current center of screen in metric (m/km) and imperial (mi/ft) systems. Extends `Control`.
 *
 * @example
 *
 * ```js
 * L.control.scale().addTo(map);
 * ```
 */

L.Control.Scale = L.Control.extend({
	// @section
	// @aka Control.Scale options
	options: {
		position: 'bottomleft',

		// @option maxWidth: Number = 100
		// Maximum width of the control in pixels. The width is set dynamically to show round values (e.g. 100, 200, 500).
		maxWidth: 100,

		// @option metric: Boolean = True
		// Whether to show the metric scale line (m/km).
		metric: true,

		// @option imperial: Boolean = True
		// Whether to show the imperial scale line (mi/ft).
		imperial: true

		// @option updateWhenIdle: Boolean = false
		// If `true`, the control is updated on [`moveend`](#map-moveend), otherwise it's always up-to-date (updated on [`move`](#map-move)).
	},

	onAdd: function (map) {
		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className + '-line', container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className, container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className, container);
		}
	},

	_update: function () {
		var map = this._map,
		    y = map.getSize().y / 2;

		var maxMeters = map.distance(
				map.containerPointToLatLng([0, y]),
				map.containerPointToLatLng([this.options.maxWidth, y]));

		this._updateScales(maxMeters);
	},

	_updateScales: function (maxMeters) {
		if (this.options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}
		if (this.options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters),
		    label = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';

		this._updateScale(this._mScale, label, meters / maxMeters);
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);
			this._updateScale(this._iScale, miles + ' mi', miles / maxMiles);

		} else {
			feet = this._getRoundNum(maxFeet);
			this._updateScale(this._iScale, feet + ' ft', feet / maxFeet);
		}
	},

	_updateScale: function (scale, text, ratio) {
		scale.style.width = Math.round(this.options.maxWidth * ratio) + 'px';
		scale.innerHTML = text;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 :
		    d >= 5 ? 5 :
		    d >= 3 ? 3 :
		    d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});


// @factory L.control.scale(options?: Control.Scale options)
// Creates an scale control with the given options.
L.control.scale = function (options) {
	return new L.Control.Scale(options);
};



/*
 * @class Control.Layers
 * @aka L.Control.Layers
 * @inherits Control
 *
 * The layers control gives users the ability to switch between different base layers and switch overlays on/off (check out the [detailed example](http://leafletjs.com/examples/layers-control.html)). Extends `Control`.
 *
 * @example
 *
 * ```js
 * var baseLayers = {
 * 	"Mapbox": mapbox,
 * 	"OpenStreetMap": osm
 * };
 *
 * var overlays = {
 * 	"Marker": marker,
 * 	"Roads": roadsLayer
 * };
 *
 * L.control.layers(baseLayers, overlays).addTo(map);
 * ```
 *
 * The `baseLayers` and `overlays` parameters are object literals with layer names as keys and `Layer` objects as values:
 *
 * ```js
 * {
 *     "<someName1>": layer1,
 *     "<someName2>": layer2
 * }
 * ```
 *
 * The layer names can contain HTML, which allows you to add additional styling to the items:
 *
 * ```js
 * {"<img src='my-layer-icon' /> <span class='my-layer-item'>My Layer</span>": myLayer}
 * ```
 */


L.Control.Layers = L.Control.extend({
	// @section
	// @aka Control.Layers options
	options: {
		// @option collapsed: Boolean = true
		// If `true`, the control will be collapsed into an icon and expanded on mouse hover or touch.
		collapsed: true,
		position: 'topright',

		// @option autoZIndex: Boolean = true
		// If `true`, the control will assign zIndexes in increasing order to all of its layers so that the order is preserved when switching them on/off.
		autoZIndex: true,

		// @option hideSingleBase: Boolean = false
		// If `true`, the base layers in the control will be hidden when there is only one.
		hideSingleBase: false,

		// @option sortLayers: Boolean = false
		// Whether to sort the layers. When `false`, layers will keep the order
		// in which they were added to the control.
		sortLayers: false,

		// @option sortFunction: Function = *
		// A [compare function](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
		// that will be used for sorting the layers, when `sortLayers` is `true`.
		// The function receives both the `L.Layer` instances and their names, as in
		// `sortFunction(layerA, layerB, nameA, nameB)`.
		// By default, it sorts layers alphabetically by their name.
		sortFunction: function (layerA, layerB, nameA, nameB) {
			return nameA < nameB ? -1 : (nameB < nameA ? 1 : 0);
		}
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = [];
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		this._map = map;
		map.on('zoomend', this._checkDisabledLayers, this);

		return this._container;
	},

	onRemove: function () {
		this._map.off('zoomend', this._checkDisabledLayers, this);

		for (var i = 0; i < this._layers.length; i++) {
			this._layers[i].layer.off('add remove', this._onLayerChange, this);
		}
	},

	// @method addBaseLayer(layer: Layer, name: String): this
	// Adds a base layer (radio button entry) with the given name to the control.
	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		return (this._map) ? this._update() : this;
	},

	// @method addOverlay(layer: Layer, name: String): this
	// Adds an overlay (checkbox entry) with the given name to the control.
	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		return (this._map) ? this._update() : this;
	},

	// @method removeLayer(layer: Layer): this
	// Remove the given layer from the control.
	removeLayer: function (layer) {
		layer.off('add remove', this._onLayerChange, this);

		var obj = this._getLayer(L.stamp(layer));
		if (obj) {
			this._layers.splice(this._layers.indexOf(obj), 1);
		}
		return (this._map) ? this._update() : this;
	},

	// @method expand(): this
	// Expand the control container if collapsed.
	expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
		this._form.style.height = null;
		var acceptableHeight = this._map.getSize().y - (this._container.offsetTop + 50);
		if (acceptableHeight < this._form.clientHeight) {
			L.DomUtil.addClass(this._form, 'leaflet-control-layers-scrollbar');
			this._form.style.height = acceptableHeight + 'px';
		} else {
			L.DomUtil.removeClass(this._form, 'leaflet-control-layers-scrollbar');
		}
		this._checkDisabledLayers();
		return this;
	},

	// @method collapse(): this
	// Collapse the control container if expanded.
	collapse: function () {
		L.DomUtil.removeClass(this._container, 'leaflet-control-layers-expanded');
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className),
		    collapsed = this.options.collapsed;

		// makes this work on IE touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		L.DomEvent.disableClickPropagation(container);
		if (!L.Browser.touch) {
			L.DomEvent.disableScrollPropagation(container);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (collapsed) {
			this._map.on('click', this.collapse, this);

			if (!L.Browser.android) {
				L.DomEvent.on(container, {
					mouseenter: this.expand,
					mouseleave: this.collapse
				}, this);
			}
		}

		var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
		link.href = '#';
		link.title = 'Layers';

		if (L.Browser.touch) {
			L.DomEvent
			    .on(link, 'click', L.DomEvent.stop)
			    .on(link, 'click', this.expand, this);
		} else {
			L.DomEvent.on(link, 'focus', this.expand, this);
		}

		// work around for Firefox Android issue https://github.com/Leaflet/Leaflet/issues/2033
		L.DomEvent.on(form, 'click', function () {
			setTimeout(L.bind(this._onInputClick, this), 0);
		}, this);

		// TODO keyboard accessibility

		if (!collapsed) {
			this.expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_getLayer: function (id) {
		for (var i = 0; i < this._layers.length; i++) {

			if (this._layers[i] && L.stamp(this._layers[i].layer) === id) {
				return this._layers[i];
			}
		}
	},

	_addLayer: function (layer, name, overlay) {
		layer.on('add remove', this._onLayerChange, this);

		this._layers.push({
			layer: layer,
			name: name,
			overlay: overlay
		});

		if (this.options.sortLayers) {
			this._layers.sort(L.bind(function (a, b) {
				return this.options.sortFunction(a.layer, b.layer, a.name, b.name);
			}, this));
		}

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) { return this; }

		L.DomUtil.empty(this._baseLayersList);
		L.DomUtil.empty(this._overlaysList);

		var baseLayersPresent, overlaysPresent, i, obj, baseLayersCount = 0;

		for (i = 0; i < this._layers.length; i++) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
			baseLayersCount += !obj.overlay ? 1 : 0;
		}

		// Hide base layers section if there's only one layer.
		if (this.options.hideSingleBase) {
			baseLayersPresent = baseLayersPresent && baseLayersCount > 1;
			this._baseLayersList.style.display = baseLayersPresent ? '' : 'none';
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';

		return this;
	},

	_onLayerChange: function (e) {
		if (!this._handlingClick) {
			this._update();
		}

		var obj = this._getLayer(L.stamp(e.target));

		// @namespace Map
		// @section Layer events
		// @event baselayerchange: LayersControlEvent
		// Fired when the base layer is changed through the [layer control](#control-layers).
		// @event overlayadd: LayersControlEvent
		// Fired when an overlay is selected through the [layer control](#control-layers).
		// @event overlayremove: LayersControlEvent
		// Fired when an overlay is deselected through the [layer control](#control-layers).
		// @namespace Control.Layers
		var type = obj.overlay ?
			(e.type === 'add' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'add' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' +
				name + '"' + (checked ? ' checked="checked"' : '') + '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    checked = this._map.hasLayer(obj.layer),
		    input;

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		// Helps from preventing layer control flicker when checkboxes are disabled
		// https://github.com/Leaflet/Leaflet/issues/2771
		var holder = document.createElement('div');

		label.appendChild(holder);
		holder.appendChild(input);
		holder.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		this._checkDisabledLayers();
		return label;
	},

	_onInputClick: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input, layer, hasLayer;
		var addedLayers = [],
		    removedLayers = [];

		this._handlingClick = true;

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			hasLayer = this._map.hasLayer(layer);

			if (input.checked && !hasLayer) {
				addedLayers.push(layer);

			} else if (!input.checked && hasLayer) {
				removedLayers.push(layer);
			}
		}

		// Bugfix issue 2318: Should remove all old layers before readding new ones
		for (i = 0; i < removedLayers.length; i++) {
			this._map.removeLayer(removedLayers[i]);
		}
		for (i = 0; i < addedLayers.length; i++) {
			this._map.addLayer(addedLayers[i]);
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_checkDisabledLayers: function () {
		var inputs = this._form.getElementsByTagName('input'),
		    input,
		    layer,
		    zoom = this._map.getZoom();

		for (var i = inputs.length - 1; i >= 0; i--) {
			input = inputs[i];
			layer = this._getLayer(input.layerId).layer;
			input.disabled = (layer.options.minZoom !== undefined && zoom < layer.options.minZoom) ||
			                 (layer.options.maxZoom !== undefined && zoom > layer.options.maxZoom);

		}
	},

	_expand: function () {
		// Backward compatibility, remove me in 1.1.
		return this.expand();
	},

	_collapse: function () {
		// Backward compatibility, remove me in 1.1.
		return this.collapse();
	}

});


// @factory L.control.layers(baselayers?: Object, overlays?: Object, options?: Control.Layers options)
// Creates an attribution control with the given layers. Base layers will be switched with radio buttons, while overlays will be switched with checkboxes. Note that all base layers should be passed in the base layers object, but only one should be added to the map during map instantiation.
L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};



}(window, document));

},{}],331:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],332:[function(require,module,exports){
(function (global){
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = throttle;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],333:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"pseudomap":396,"util":1006,"yallist":1013}],334:[function(require,module,exports){
// super simple module for the most common nodejs use case.
exports.markdown = require("./markdown");
exports.parse = exports.markdown.toHTML;

},{"./markdown":335}],335:[function(require,module,exports){
// Released under MIT license
// Copyright (c) 2009-2010 Dominic Baggott
// Copyright (c) 2009-2010 Ash Berlin
// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)

/*jshint browser:true, devel:true */

(function( expose ) {

/**
 *  class Markdown
 *
 *  Markdown processing in Javascript done right. We have very particular views
 *  on what constitutes 'right' which include:
 *
 *  - produces well-formed HTML (this means that em and strong nesting is
 *    important)
 *
 *  - has an intermediate representation to allow processing of parsed data (We
 *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
 *
 *  - is easily extensible to add new dialects without having to rewrite the
 *    entire parsing mechanics
 *
 *  - has a good test suite
 *
 *  This implementation fulfills all of these (except that the test suite could
 *  do with expanding to automatically run all the fixtures from other Markdown
 *  implementations.)
 *
 *  ##### Intermediate Representation
 *
 *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
 *
 *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
 **/
var Markdown = expose.Markdown = function(dialect) {
  switch (typeof dialect) {
    case "undefined":
      this.dialect = Markdown.dialects.Gruber;
      break;
    case "object":
      this.dialect = dialect;
      break;
    default:
      if ( dialect in Markdown.dialects ) {
        this.dialect = Markdown.dialects[dialect];
      }
      else {
        throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
      }
      break;
  }
  this.em_state = [];
  this.strong_state = [];
  this.debug_indent = "";
};

/**
 *  parse( markdown, [dialect] ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *
 *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
 **/
expose.parse = function( source, dialect ) {
  // dialect will default if undefined
  var md = new Markdown( dialect );
  return md.toTree( source );
};

/**
 *  toHTML( markdown, [dialect]  ) -> String
 *  toHTML( md_tree ) -> String
 *  - markdown (String): markdown string to parse
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Take markdown (either as a string or as a JsonML tree) and run it through
 *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
 **/
expose.toHTML = function toHTML( source , dialect , options ) {
  var input = expose.toHTMLTree( source , dialect , options );

  return expose.renderJsonML( input );
};

/**
 *  toHTMLTree( markdown, [dialect] ) -> JsonML
 *  toHTMLTree( md_tree ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
 *  to this function, it is first parsed into a markdown tree by calling
 *  [[parse]].
 **/
expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {
  // convert string input to an MD tree
  if ( typeof input ==="string" ) input = this.parse( input, dialect );

  // Now convert the MD tree to an HTML tree

  // remove references from the tree
  var attrs = extract_attr( input ),
      refs = {};

  if ( attrs && attrs.references ) {
    refs = attrs.references;
  }

  var html = convert_tree_to_html( input, refs , options );
  merge_text_nodes( html );
  return html;
};

// For Spidermonkey based engines
function mk_block_toSource() {
  return "Markdown.mk_block( " +
          uneval(this.toString()) +
          ", " +
          uneval(this.trailing) +
          ", " +
          uneval(this.lineNumber) +
          " )";
}

// node
function mk_block_inspect() {
  var util = require("util");
  return "Markdown.mk_block( " +
          util.inspect(this.toString()) +
          ", " +
          util.inspect(this.trailing) +
          ", " +
          util.inspect(this.lineNumber) +
          " )";

}

var mk_block = Markdown.mk_block = function(block, trail, line) {
  // Be helpful for default case in tests.
  if ( arguments.length == 1 ) trail = "\n\n";

  var s = new String(block);
  s.trailing = trail;
  // To make it clear its not just a string
  s.inspect = mk_block_inspect;
  s.toSource = mk_block_toSource;

  if ( line != undefined )
    s.lineNumber = line;

  return s;
};

function count_lines( str ) {
  var n = 0, i = -1;
  while ( ( i = str.indexOf("\n", i + 1) ) !== -1 ) n++;
  return n;
}

// Internal - split source into rough blocks
Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {
  input = input.replace(/(\r\n|\n|\r)/g, "\n");
  // [\s\S] matches _anything_ (newline or space)
  // [^] is equivalent but doesn't work in IEs.
  var re = /([\s\S]+?)($|\n#|\n(?:\s*\n|$)+)/g,
      blocks = [],
      m;

  var line_no = 1;

  if ( ( m = /^(\s*\n)/.exec(input) ) != null ) {
    // skip (but count) leading blank lines
    line_no += count_lines( m[0] );
    re.lastIndex = m[0].length;
  }

  while ( ( m = re.exec(input) ) !== null ) {
    if (m[2] == "\n#") {
      m[2] = "\n";
      re.lastIndex--;
    }
    blocks.push( mk_block( m[1], m[2], line_no ) );
    line_no += count_lines( m[0] );
  }

  return blocks;
};

/**
 *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
 *  - block (String): the block to process
 *  - next (Array): the following blocks
 *
 * Process `block` and return an array of JsonML nodes representing `block`.
 *
 * It does this by asking each block level function in the dialect to process
 * the block until one can. Succesful handling is indicated by returning an
 * array (with zero or more JsonML nodes), failure by a false value.
 *
 * Blocks handlers are responsible for calling [[Markdown#processInline]]
 * themselves as appropriate.
 *
 * If the blocks were split incorrectly or adjacent blocks need collapsing you
 * can adjust `next` in place using shift/splice etc.
 *
 * If any of this default behaviour is not right for the dialect, you can
 * define a `__call__` method on the dialect that will get invoked to handle
 * the block processing.
 */
Markdown.prototype.processBlock = function processBlock( block, next ) {
  var cbs = this.dialect.block,
      ord = cbs.__order__;

  if ( "__call__" in cbs ) {
    return cbs.__call__.call(this, block, next);
  }

  for ( var i = 0; i < ord.length; i++ ) {
    //D:this.debug( "Testing", ord[i] );
    var res = cbs[ ord[i] ].call( this, block, next );
    if ( res ) {
      //D:this.debug("  matched");
      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )
        this.debug(ord[i], "didn't return a proper array");
      //D:this.debug( "" );
      return res;
    }
  }

  // Uhoh! no match! Should we throw an error?
  return [];
};

Markdown.prototype.processInline = function processInline( block ) {
  return this.dialect.inline.__call__.call( this, String( block ) );
};

/**
 *  Markdown#toTree( source ) -> JsonML
 *  - source (String): markdown source to parse
 *
 *  Parse `source` into a JsonML tree representing the markdown document.
 **/
// custom_tree means set this.tree to `custom_tree` and restore old value on return
Markdown.prototype.toTree = function toTree( source, custom_root ) {
  var blocks = source instanceof Array ? source : this.split_blocks( source );

  // Make tree a member variable so its easier to mess with in extensions
  var old_tree = this.tree;
  try {
    this.tree = custom_root || this.tree || [ "markdown" ];

    blocks:
    while ( blocks.length ) {
      var b = this.processBlock( blocks.shift(), blocks );

      // Reference blocks and the like won't return any content
      if ( !b.length ) continue blocks;

      this.tree.push.apply( this.tree, b );
    }
    return this.tree;
  }
  finally {
    if ( custom_root ) {
      this.tree = old_tree;
    }
  }
};

// Noop by default
Markdown.prototype.debug = function () {
  var args = Array.prototype.slice.call( arguments);
  args.unshift(this.debug_indent);
  if ( typeof print !== "undefined" )
      print.apply( print, args );
  if ( typeof console !== "undefined" && typeof console.log !== "undefined" )
      console.log.apply( null, args );
}

Markdown.prototype.loop_re_over_block = function( re, block, cb ) {
  // Dont use /g regexps with this
  var m,
      b = block.valueOf();

  while ( b.length && (m = re.exec(b) ) != null ) {
    b = b.substr( m[0].length );
    cb.call(this, m);
  }
  return b;
};

/**
 * Markdown.dialects
 *
 * Namespace of built-in dialects.
 **/
Markdown.dialects = {};

/**
 * Markdown.dialects.Gruber
 *
 * The default dialect that follows the rules set out by John Gruber's
 * markdown.pl as closely as possible. Well actually we follow the behaviour of
 * that script which in some places is not exactly what the syntax web page
 * says.
 **/
Markdown.dialects.Gruber = {
  block: {
    atxHeader: function atxHeader( block, next ) {
      var m = block.match( /^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/ );

      if ( !m ) return undefined;

      var header = [ "header", { level: m[ 1 ].length } ];
      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));

      if ( m[0].length < block.length )
        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );

      return [ header ];
    },

    setextHeader: function setextHeader( block, next ) {
      var m = block.match( /^(.*)\n([-=])\2\2+(?:\n|$)/ );

      if ( !m ) return undefined;

      var level = ( m[ 2 ] === "=" ) ? 1 : 2;
      var header = [ "header", { level : level }, m[ 1 ] ];

      if ( m[0].length < block.length )
        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );

      return [ header ];
    },

    code: function code( block, next ) {
      // |    Foo
      // |bar
      // should be a code block followed by a paragraph. Fun
      //
      // There might also be adjacent code block to merge.

      var ret = [],
          re = /^(?: {0,3}\t| {4})(.*)\n?/,
          lines;

      // 4 spaces + content
      if ( !block.match( re ) ) return undefined;

      block_search:
      do {
        // Now pull out the rest of the lines
        var b = this.loop_re_over_block(
                  re, block.valueOf(), function( m ) { ret.push( m[1] ); } );

        if ( b.length ) {
          // Case alluded to in first comment. push it back on as a new block
          next.unshift( mk_block(b, block.trailing) );
          break block_search;
        }
        else if ( next.length ) {
          // Check the next block - it might be code too
          if ( !next[0].match( re ) ) break block_search;

          // Pull how how many blanks lines follow - minus two to account for .join
          ret.push ( block.trailing.replace(/[^\n]/g, "").substring(2) );

          block = next.shift();
        }
        else {
          break block_search;
        }
      } while ( true );

      return [ [ "code_block", ret.join("\n") ] ];
    },

    horizRule: function horizRule( block, next ) {
      // this needs to find any hr in the block to handle abutting blocks
      var m = block.match( /^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/ );

      if ( !m ) {
        return undefined;
      }

      var jsonml = [ [ "hr" ] ];

      // if there's a leading abutting block, process it
      if ( m[ 1 ] ) {
        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );
      }

      // if there's a trailing abutting block, stick it into next
      if ( m[ 3 ] ) {
        next.unshift( mk_block( m[ 3 ] ) );
      }

      return jsonml;
    },

    // There are two types of lists. Tight and loose. Tight lists have no whitespace
    // between the items (and result in text just in the <li>) and loose lists,
    // which have an empty line between list items, resulting in (one or more)
    // paragraphs inside the <li>.
    //
    // There are all sorts weird edge cases about the original markdown.pl's
    // handling of lists:
    //
    // * Nested lists are supposed to be indented by four chars per level. But
    //   if they aren't, you can get a nested list by indenting by less than
    //   four so long as the indent doesn't match an indent of an existing list
    //   item in the 'nest stack'.
    //
    // * The type of the list (bullet or number) is controlled just by the
    //    first item at the indent. Subsequent changes are ignored unless they
    //    are for nested lists
    //
    lists: (function( ) {
      // Use a closure to hide a few variables.
      var any_list = "[*+-]|\\d+\\.",
          bullet_list = /[*+-]/,
          number_list = /\d+\./,
          // Capture leading indent as it matters for determining nested lists.
          is_list_re = new RegExp( "^( {0,3})(" + any_list + ")[ \t]+" ),
          indent_re = "(?: {0,3}\\t| {4})";

      // TODO: Cache this regexp for certain depths.
      // Create a regexp suitable for matching an li for a given stack depth
      function regex_for_depth( depth ) {

        return new RegExp(
          // m[1] = indent, m[2] = list_type
          "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
          // m[3] = cont
          "(^" + indent_re + "{0," + (depth-1) + "}[ ]{0,4})"
        );
      }
      function expand_tab( input ) {
        return input.replace( / {0,3}\t/g, "    " );
      }

      // Add inline content `inline` to `li`. inline comes from processInline
      // so is an array of content
      function add(li, loose, inline, nl) {
        if ( loose ) {
          li.push( [ "para" ].concat(inline) );
          return;
        }
        // Hmmm, should this be any block level element or just paras?
        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == "para"
                   ? li[li.length -1]
                   : li;

        // If there is already some content in this list, add the new line in
        if ( nl && li.length > 1 ) inline.unshift(nl);

        for ( var i = 0; i < inline.length; i++ ) {
          var what = inline[i],
              is_str = typeof what == "string";
          if ( is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == "string" ) {
            add_to[ add_to.length-1 ] += what;
          }
          else {
            add_to.push( what );
          }
        }
      }

      // contained means have an indent greater than the current one. On
      // *every* line in the block
      function get_contained_blocks( depth, blocks ) {

        var re = new RegExp( "^(" + indent_re + "{" + depth + "}.*?\\n?)*$" ),
            replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
            ret = [];

        while ( blocks.length > 0 ) {
          if ( re.exec( blocks[0] ) ) {
            var b = blocks.shift(),
                // Now remove that indent
                x = b.replace( replace, "");

            ret.push( mk_block( x, b.trailing, b.lineNumber ) );
          }
          else {
            break;
          }
        }
        return ret;
      }

      // passed to stack.forEach to turn list items up the stack into paras
      function paragraphify(s, i, stack) {
        var list = s.list;
        var last_li = list[list.length-1];

        if ( last_li[1] instanceof Array && last_li[1][0] == "para" ) {
          return;
        }
        if ( i + 1 == stack.length ) {
          // Last stack frame
          // Keep the same array, but replace the contents
          last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ) );
        }
        else {
          var sublist = last_li.pop();
          last_li.push( ["para"].concat( last_li.splice(1, last_li.length - 1) ), sublist );
        }
      }

      // The matcher function
      return function( block, next ) {
        var m = block.match( is_list_re );
        if ( !m ) return undefined;

        function make_list( m ) {
          var list = bullet_list.exec( m[2] )
                   ? ["bulletlist"]
                   : ["numberlist"];

          stack.push( { list: list, indent: m[1] } );
          return list;
        }


        var stack = [], // Stack of lists for nesting.
            list = make_list( m ),
            last_li,
            loose = false,
            ret = [ stack[0].list ],
            i;

        // Loop to search over block looking for inner block elements and loose lists
        loose_search:
        while ( true ) {
          // Split into lines preserving new lines at end of line
          var lines = block.split( /(?=\n)/ );

          // We have to grab all lines for a li and call processInline on them
          // once as there are some inline things that can span lines.
          var li_accumulate = "";

          // Loop over the lines in this block looking for tight lists.
          tight_search:
          for ( var line_no = 0; line_no < lines.length; line_no++ ) {
            var nl = "",
                l = lines[line_no].replace(/^\n/, function(n) { nl = n; return ""; });

            // TODO: really should cache this
            var line_re = regex_for_depth( stack.length );

            m = l.match( line_re );
            //print( "line:", uneval(l), "\nline match:", uneval(m) );

            // We have a list item
            if ( m[1] !== undefined ) {
              // Process the previous list item, if any
              if ( li_accumulate.length ) {
                add( last_li, loose, this.processInline( li_accumulate ), nl );
                // Loose mode will have been dealt with. Reset it
                loose = false;
                li_accumulate = "";
              }

              m[1] = expand_tab( m[1] );
              var wanted_depth = Math.floor(m[1].length/4)+1;
              //print( "want:", wanted_depth, "stack:", stack.length);
              if ( wanted_depth > stack.length ) {
                // Deep enough for a nested list outright
                //print ( "new nested list" );
                list = make_list( m );
                last_li.push( list );
                last_li = list[1] = [ "listitem" ];
              }
              else {
                // We aren't deep enough to be strictly a new level. This is
                // where Md.pl goes nuts. If the indent matches a level in the
                // stack, put it there, else put it one deeper then the
                // wanted_depth deserves.
                var found = false;
                for ( i = 0; i < stack.length; i++ ) {
                  if ( stack[ i ].indent != m[1] ) continue;
                  list = stack[ i ].list;
                  stack.splice( i+1, stack.length - (i+1) );
                  found = true;
                  break;
                }

                if (!found) {
                  //print("not found. l:", uneval(l));
                  wanted_depth++;
                  if ( wanted_depth <= stack.length ) {
                    stack.splice(wanted_depth, stack.length - wanted_depth);
                    //print("Desired depth now", wanted_depth, "stack:", stack.length);
                    list = stack[wanted_depth-1].list;
                    //print("list:", uneval(list) );
                  }
                  else {
                    //print ("made new stack for messy indent");
                    list = make_list(m);
                    last_li.push(list);
                  }
                }

                //print( uneval(list), "last", list === stack[stack.length-1].list );
                last_li = [ "listitem" ];
                list.push(last_li);
              } // end depth of shenegains
              nl = "";
            }

            // Add content
            if ( l.length > m[0].length ) {
              li_accumulate += nl + l.substr( m[0].length );
            }
          } // tight_search

          if ( li_accumulate.length ) {
            add( last_li, loose, this.processInline( li_accumulate ), nl );
            // Loose mode will have been dealt with. Reset it
            loose = false;
            li_accumulate = "";
          }

          // Look at the next block - we might have a loose list. Or an extra
          // paragraph for the current li
          var contained = get_contained_blocks( stack.length, next );

          // Deal with code blocks or properly nested lists
          if ( contained.length > 0 ) {
            // Make sure all listitems up the stack are paragraphs
            forEach( stack, paragraphify, this);

            last_li.push.apply( last_li, this.toTree( contained, [] ) );
          }

          var next_block = next[0] && next[0].valueOf() || "";

          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {
            block = next.shift();

            // Check for an HR following a list: features/lists/hr_abutting
            var hr = this.dialect.block.horizRule( block, next );

            if ( hr ) {
              ret.push.apply(ret, hr);
              break;
            }

            // Make sure all listitems up the stack are paragraphs
            forEach( stack, paragraphify, this);

            loose = true;
            continue loose_search;
          }
          break;
        } // loose_search

        return ret;
      };
    })(),

    blockquote: function blockquote( block, next ) {
      if ( !block.match( /^>/m ) )
        return undefined;

      var jsonml = [];

      // separate out the leading abutting block, if any. I.e. in this case:
      //
      //  a
      //  > b
      //
      if ( block[ 0 ] != ">" ) {
        var lines = block.split( /\n/ ),
            prev = [],
            line_no = block.lineNumber;

        // keep shifting lines until you find a crotchet
        while ( lines.length && lines[ 0 ][ 0 ] != ">" ) {
            prev.push( lines.shift() );
            line_no++;
        }

        var abutting = mk_block( prev.join( "\n" ), "\n", block.lineNumber );
        jsonml.push.apply( jsonml, this.processBlock( abutting, [] ) );
        // reassemble new block of just block quotes!
        block = mk_block( lines.join( "\n" ), block.trailing, line_no );
      }


      // if the next block is also a blockquote merge it in
      while ( next.length && next[ 0 ][ 0 ] == ">" ) {
        var b = next.shift();
        block = mk_block( block + block.trailing + b, b.trailing, block.lineNumber );
      }

      // Strip off the leading "> " and re-process as a block.
      var input = block.replace( /^> ?/gm, "" ),
          old_tree = this.tree,
          processedBlock = this.toTree( input, [ "blockquote" ] ),
          attr = extract_attr( processedBlock );

      // If any link references were found get rid of them
      if ( attr && attr.references ) {
        delete attr.references;
        // And then remove the attribute object if it's empty
        if ( isEmpty( attr ) ) {
          processedBlock.splice( 1, 1 );
        }
      }

      jsonml.push( processedBlock );
      return jsonml;
    },

    referenceDefn: function referenceDefn( block, next) {
      var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
      // interesting matches are [ , ref_id, url, , title, title ]

      if ( !block.match(re) )
        return undefined;

      // make an attribute node if it doesn't exist
      if ( !extract_attr( this.tree ) ) {
        this.tree.splice( 1, 0, {} );
      }

      var attrs = extract_attr( this.tree );

      // make a references hash if it doesn't exist
      if ( attrs.references === undefined ) {
        attrs.references = {};
      }

      var b = this.loop_re_over_block(re, block, function( m ) {

        if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
          m[2] = m[2].substring( 1, m[2].length - 1 );

        var ref = attrs.references[ m[1].toLowerCase() ] = {
          href: m[2]
        };

        if ( m[4] !== undefined )
          ref.title = m[4];
        else if ( m[5] !== undefined )
          ref.title = m[5];

      } );

      if ( b.length )
        next.unshift( mk_block( b, block.trailing ) );

      return [];
    },

    para: function para( block, next ) {
      // everything's a para!
      return [ ["para"].concat( this.processInline( block ) ) ];
    }
  }
};

Markdown.dialects.Gruber.inline = {

    __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {
      var m,
          res,
          lastIndex = 0;

      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
      var re = new RegExp( "([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")" );

      m = re.exec( text );
      if (!m) {
        // Just boring text
        return [ text.length, text ];
      }
      else if ( m[1] ) {
        // Some un-interesting text matched. Return that first
        return [ m[1].length, m[1] ];
      }

      var res;
      if ( m[2] in this.dialect.inline ) {
        res = this.dialect.inline[ m[2] ].call(
                  this,
                  text.substr( m.index ), m, previous_nodes || [] );
      }
      // Default for now to make dev easier. just slurp special and output it.
      res = res || [ m[2].length, m[2] ];
      return res;
    },

    __call__: function inline( text, patterns ) {

      var out = [],
          res;

      function add(x) {
        //D:self.debug("  adding output", uneval(x));
        if ( typeof x == "string" && typeof out[out.length-1] == "string" )
          out[ out.length-1 ] += x;
        else
          out.push(x);
      }

      while ( text.length > 0 ) {
        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );
        text = text.substr( res.shift() );
        forEach(res, add )
      }

      return out;
    },

    // These characters are intersting elsewhere, so have rules for them so that
    // chunks of plain text blocks don't include them
    "]": function () {},
    "}": function () {},

    __escape__ : /^\\[\\`\*_{}\[\]()#\+.!\-]/,

    "\\": function escaped( text ) {
      // [ length of input processed, node/children to add... ]
      // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
      if ( this.dialect.inline.__escape__.exec( text ) )
        return [ 2, text.charAt( 1 ) ];
      else
        // Not an esacpe
        return [ 1, "\\" ];
    },

    "![": function image( text ) {

      // Unlike images, alt text is plain text only. no other elements are
      // allowed in there

      // ![Alt text](/path/to/img.jpg "Optional title")
      //      1          2            3       4         <--- captures
      var m = text.match( /^!\[(.*?)\][ \t]*\([ \t]*([^")]*?)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/ );

      if ( m ) {
        if ( m[2] && m[2][0] == "<" && m[2][m[2].length-1] == ">" )
          m[2] = m[2].substring( 1, m[2].length - 1 );

        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\/ )[0];

        var attrs = { alt: m[1], href: m[2] || "" };
        if ( m[4] !== undefined)
          attrs.title = m[4];

        return [ m[0].length, [ "img", attrs ] ];
      }

      // ![Alt text][id]
      m = text.match( /^!\[(.*?)\][ \t]*\[(.*?)\]/ );

      if ( m ) {
        // We can't check if the reference is known here as it likely wont be
        // found till after. Check it in md tree->hmtl tree conversion
        return [ m[0].length, [ "img_ref", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];
      }

      // Just consume the '!['
      return [ 2, "![" ];
    },

    "[": function link( text ) {

      var orig = String(text);
      // Inline content is possible inside `link text`
      var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), "]" );

      // No closing ']' found. Just consume the [
      if ( !res ) return [ 1, "[" ];

      var consumed = 1 + res[ 0 ],
          children = res[ 1 ],
          link,
          attrs;

      // At this point the first [...] has been parsed. See what follows to find
      // out which kind of link we are (reference or direct url)
      text = text.substr( consumed );

      // [link text](/path/to/img.jpg "Optional title")
      //                 1            2       3         <--- captures
      // This will capture up to the last paren in the block. We then pull
      // back based on if there a matching ones in the url
      //    ([here](/url/(test))
      // The parens have to be balanced
      var m = text.match( /^\s*\([ \t]*([^"']*)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/ );
      if ( m ) {
        var url = m[1];
        consumed += m[0].length;

        if ( url && url[0] == "<" && url[url.length-1] == ">" )
          url = url.substring( 1, url.length - 1 );

        // If there is a title we don't have to worry about parens in the url
        if ( !m[3] ) {
          var open_parens = 1; // One open that isn't in the capture
          for ( var len = 0; len < url.length; len++ ) {
            switch ( url[len] ) {
            case "(":
              open_parens++;
              break;
            case ")":
              if ( --open_parens == 0) {
                consumed -= url.length - len;
                url = url.substring(0, len);
              }
              break;
            }
          }
        }

        // Process escapes only
        url = this.dialect.inline.__call__.call( this, url, /\\/ )[0];

        attrs = { href: url || "" };
        if ( m[3] !== undefined)
          attrs.title = m[3];

        link = [ "link", attrs ].concat( children );
        return [ consumed, link ];
      }

      // [Alt text][id]
      // [Alt text] [id]
      m = text.match( /^\s*\[(.*?)\]/ );

      if ( m ) {

        consumed += m[ 0 ].length;

        // [links][] uses links as its reference
        attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };

        link = [ "link_ref", attrs ].concat( children );

        // We can't check if the reference is known here as it likely wont be
        // found till after. Check it in md tree->hmtl tree conversion.
        // Store the original so that conversion can revert if the ref isn't found.
        return [ consumed, link ];
      }

      // [id]
      // Only if id is plain (no formatting.)
      if ( children.length == 1 && typeof children[0] == "string" ) {

        attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };
        link = [ "link_ref", attrs, children[0] ];
        return [ consumed, link ];
      }

      // Just consume the "["
      return [ 1, "[" ];
    },


    "<": function autoLink( text ) {
      var m;

      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/ ) ) != null ) {
        if ( m[3] ) {
          return [ m[0].length, [ "link", { href: "mailto:" + m[3] }, m[3] ] ];

        }
        else if ( m[2] == "mailto" ) {
          return [ m[0].length, [ "link", { href: m[1] }, m[1].substr("mailto:".length ) ] ];
        }
        else
          return [ m[0].length, [ "link", { href: m[1] }, m[1] ] ];
      }

      return [ 1, "<" ];
    },

    "`": function inlineCode( text ) {
      // Inline code block. as many backticks as you like to start it
      // Always skip over the opening ticks.
      var m = text.match( /(`+)(([\s\S]*?)\1)/ );

      if ( m && m[2] )
        return [ m[1].length + m[2].length, [ "inlinecode", m[3] ] ];
      else {
        // TODO: No matching end code found - warn!
        return [ 1, "`" ];
      }
    },

    "  \n": function lineBreak( text ) {
      return [ 3, [ "linebreak" ] ];
    }

};

// Meta Helper/generator method for em and strong handling
function strong_em( tag, md ) {

  var state_slot = tag + "_state",
      other_slot = tag == "strong" ? "em_state" : "strong_state";

  function CloseTag(len) {
    this.len_after = len;
    this.name = "close_" + md;
  }

  return function ( text, orig_match ) {

    if ( this[state_slot][0] == md ) {
      // Most recent em is of this type
      //D:this.debug("closing", md);
      this[state_slot].shift();

      // "Consume" everything to go back to the recrusion in the else-block below
      return[ text.length, new CloseTag(text.length-md.length) ];
    }
    else {
      // Store a clone of the em/strong states
      var other = this[other_slot].slice(),
          state = this[state_slot].slice();

      this[state_slot].unshift(md);

      //D:this.debug_indent += "  ";

      // Recurse
      var res = this.processInline( text.substr( md.length ) );
      //D:this.debug_indent = this.debug_indent.substr(2);

      var last = res[res.length - 1];

      //D:this.debug("processInline from", tag + ": ", uneval( res ) );

      var check = this[state_slot].shift();
      if ( last instanceof CloseTag ) {
        res.pop();
        // We matched! Huzzah.
        var consumed = text.length - last.len_after;
        return [ consumed, [ tag ].concat(res) ];
      }
      else {
        // Restore the state of the other kind. We might have mistakenly closed it.
        this[other_slot] = other;
        this[state_slot] = state;

        // We can't reuse the processed result as it could have wrong parsing contexts in it.
        return [ md.length, md ];
      }
    }
  }; // End returned function
}

Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
Markdown.dialects.Gruber.inline["*"]  = strong_em("em", "*");
Markdown.dialects.Gruber.inline["_"]  = strong_em("em", "_");


// Build default order from insertion order.
Markdown.buildBlockOrder = function(d) {
  var ord = [];
  for ( var i in d ) {
    if ( i == "__order__" || i == "__call__" ) continue;
    ord.push( i );
  }
  d.__order__ = ord;
};

// Build patterns for inline matcher
Markdown.buildInlinePatterns = function(d) {
  var patterns = [];

  for ( var i in d ) {
    // __foo__ is reserved and not a pattern
    if ( i.match( /^__.*__$/) ) continue;
    var l = i.replace( /([\\.*+?|()\[\]{}])/g, "\\$1" )
             .replace( /\n/, "\\n" );
    patterns.push( i.length == 1 ? l : "(?:" + l + ")" );
  }

  patterns = patterns.join("|");
  d.__patterns__ = patterns;
  //print("patterns:", uneval( patterns ) );

  var fn = d.__call__;
  d.__call__ = function(text, pattern) {
    if ( pattern != undefined ) {
      return fn.call(this, text, pattern);
    }
    else
    {
      return fn.call(this, text, patterns);
    }
  };
};

Markdown.DialectHelpers = {};
Markdown.DialectHelpers.inline_until_char = function( text, want ) {
  var consumed = 0,
      nodes = [];

  while ( true ) {
    if ( text.charAt( consumed ) == want ) {
      // Found the character we were looking for
      consumed++;
      return [ consumed, nodes ];
    }

    if ( consumed >= text.length ) {
      // No closing char found. Abort.
      return null;
    }

    var res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );
    consumed += res[ 0 ];
    // Add any returned nodes.
    nodes.push.apply( nodes, res.slice( 1 ) );
  }
}

// Helper function to make sub-classing a dialect easier
Markdown.subclassDialect = function( d ) {
  function Block() {}
  Block.prototype = d.block;
  function Inline() {}
  Inline.prototype = d.inline;

  return { block: new Block(), inline: new Inline() };
};

Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );
Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );

Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );

Markdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {
  var meta = split_meta_hash( meta_string ),
      attr = {};

  for ( var i = 0; i < meta.length; ++i ) {
    // id: #foo
    if ( /^#/.test( meta[ i ] ) ) {
      attr.id = meta[ i ].substring( 1 );
    }
    // class: .foo
    else if ( /^\./.test( meta[ i ] ) ) {
      // if class already exists, append the new one
      if ( attr["class"] ) {
        attr["class"] = attr["class"] + meta[ i ].replace( /./, " " );
      }
      else {
        attr["class"] = meta[ i ].substring( 1 );
      }
    }
    // attribute: foo=bar
    else if ( /\=/.test( meta[ i ] ) ) {
      var s = meta[ i ].split( /\=/ );
      attr[ s[ 0 ] ] = s[ 1 ];
    }
  }

  return attr;
}

function split_meta_hash( meta_string ) {
  var meta = meta_string.split( "" ),
      parts = [ "" ],
      in_quotes = false;

  while ( meta.length ) {
    var letter = meta.shift();
    switch ( letter ) {
      case " " :
        // if we're in a quoted section, keep it
        if ( in_quotes ) {
          parts[ parts.length - 1 ] += letter;
        }
        // otherwise make a new part
        else {
          parts.push( "" );
        }
        break;
      case "'" :
      case '"' :
        // reverse the quotes and move straight on
        in_quotes = !in_quotes;
        break;
      case "\\" :
        // shift off the next letter to be used straight away.
        // it was escaped so we'll keep it whatever it is
        letter = meta.shift();
      default :
        parts[ parts.length - 1 ] += letter;
        break;
    }
  }

  return parts;
}

Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {
  // we're only interested in the first block
  if ( block.lineNumber > 1 ) return undefined;

  // document_meta blocks consist of one or more lines of `Key: Value\n`
  if ( ! block.match( /^(?:\w+:.*\n)*\w+:.*$/ ) ) return undefined;

  // make an attribute node if it doesn't exist
  if ( !extract_attr( this.tree ) ) {
    this.tree.splice( 1, 0, {} );
  }

  var pairs = block.split( /\n/ );
  for ( p in pairs ) {
    var m = pairs[ p ].match( /(\w+):\s*(.*)$/ ),
        key = m[ 1 ].toLowerCase(),
        value = m[ 2 ];

    this.tree[ 1 ][ key ] = value;
  }

  // document_meta produces no content!
  return [];
};

Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {
  // check if the last line of the block is an meta hash
  var m = block.match( /(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/ );
  if ( !m ) return undefined;

  // process the meta hash
  var attr = this.dialect.processMetaHash( m[ 2 ] );

  var hash;

  // if we matched ^ then we need to apply meta to the previous block
  if ( m[ 1 ] === "" ) {
    var node = this.tree[ this.tree.length - 1 ];
    hash = extract_attr( node );

    // if the node is a string (rather than JsonML), bail
    if ( typeof node === "string" ) return undefined;

    // create the attribute hash if it doesn't exist
    if ( !hash ) {
      hash = {};
      node.splice( 1, 0, hash );
    }

    // add the attributes in
    for ( a in attr ) {
      hash[ a ] = attr[ a ];
    }

    // return nothing so the meta hash is removed
    return [];
  }

  // pull the meta hash off the block and process what's left
  var b = block.replace( /\n.*$/, "" ),
      result = this.processBlock( b, [] );

  // get or make the attributes hash
  hash = extract_attr( result[ 0 ] );
  if ( !hash ) {
    hash = {};
    result[ 0 ].splice( 1, 0, hash );
  }

  // attach the attributes to the block
  for ( a in attr ) {
    hash[ a ] = attr[ a ];
  }

  return result;
};

Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {
  // one or more terms followed by one or more definitions, in a single block
  var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
      list = [ "dl" ],
      i, m;

  // see if we're dealing with a tight or loose block
  if ( ( m = block.match( tight ) ) ) {
    // pull subsequent tight DL blocks out of `next`
    var blocks = [ block ];
    while ( next.length && tight.exec( next[ 0 ] ) ) {
      blocks.push( next.shift() );
    }

    for ( var b = 0; b < blocks.length; ++b ) {
      var m = blocks[ b ].match( tight ),
          terms = m[ 1 ].replace( /\n$/, "" ).split( /\n/ ),
          defns = m[ 2 ].split( /\n:\s+/ );

      // print( uneval( m ) );

      for ( i = 0; i < terms.length; ++i ) {
        list.push( [ "dt", terms[ i ] ] );
      }

      for ( i = 0; i < defns.length; ++i ) {
        // run inline processing over the definition
        list.push( [ "dd" ].concat( this.processInline( defns[ i ].replace( /(\n)\s+/, "$1" ) ) ) );
      }
    }
  }
  else {
    return undefined;
  }

  return [ list ];
};

// splits on unescaped instances of @ch. If @ch is not a character the result
// can be unpredictable

Markdown.dialects.Maruku.block.table = function table (block, next) {

    var _split_on_unescaped = function(s, ch) {
        ch = ch || '\\s';
        if (ch.match(/^[\\|\[\]{}?*.+^$]$/)) { ch = '\\' + ch; }
        var res = [ ],
            r = new RegExp('^((?:\\\\.|[^\\\\' + ch + '])*)' + ch + '(.*)'),
            m;
        while(m = s.match(r)) {
            res.push(m[1]);
            s = m[2];
        }
        res.push(s);
        return res;
    }

    var leading_pipe = /^ {0,3}\|(.+)\n {0,3}\|\s*([\-:]+[\-| :]*)\n((?:\s*\|.*(?:\n|$))*)(?=\n|$)/,
        // find at least an unescaped pipe in each line
        no_leading_pipe = /^ {0,3}(\S(?:\\.|[^\\|])*\|.*)\n {0,3}([\-:]+\s*\|[\-| :]*)\n((?:(?:\\.|[^\\|])*\|.*(?:\n|$))*)(?=\n|$)/,
        i, m;
    if (m = block.match(leading_pipe)) {
        // remove leading pipes in contents
        // (header and horizontal rule already have the leading pipe left out)
        m[3] = m[3].replace(/^\s*\|/gm, '');
    } else if (! ( m = block.match(no_leading_pipe))) {
        return undefined;
    }

    var table = [ "table", [ "thead", [ "tr" ] ], [ "tbody" ] ];

    // remove trailing pipes, then split on pipes
    // (no escaped pipes are allowed in horizontal rule)
    m[2] = m[2].replace(/\|\s*$/, '').split('|');

    // process alignment
    var html_attrs = [ ];
    forEach (m[2], function (s) {
        if (s.match(/^\s*-+:\s*$/))       html_attrs.push({align: "right"});
        else if (s.match(/^\s*:-+\s*$/))  html_attrs.push({align: "left"});
        else if (s.match(/^\s*:-+:\s*$/)) html_attrs.push({align: "center"});
        else                              html_attrs.push({});
    });

    // now for the header, avoid escaped pipes
    m[1] = _split_on_unescaped(m[1].replace(/\|\s*$/, ''), '|');
    for (i = 0; i < m[1].length; i++) {
        table[1][1].push(['th', html_attrs[i] || {}].concat(
            this.processInline(m[1][i].trim())));
    }

    // now for body contents
    forEach (m[3].replace(/\|\s*$/mg, '').split('\n'), function (row) {
        var html_row = ['tr'];
        row = _split_on_unescaped(row, '|');
        for (i = 0; i < row.length; i++) {
            html_row.push(['td', html_attrs[i] || {}].concat(this.processInline(row[i].trim())));
        }
        table[2].push(html_row);
    }, this);

    return [table];
}

Markdown.dialects.Maruku.inline[ "{:" ] = function inline_meta( text, matches, out ) {
  if ( !out.length ) {
    return [ 2, "{:" ];
  }

  // get the preceeding element
  var before = out[ out.length - 1 ];

  if ( typeof before === "string" ) {
    return [ 2, "{:" ];
  }

  // match a meta hash
  var m = text.match( /^\{:\s*((?:\\\}|[^\}])*)\s*\}/ );

  // no match, false alarm
  if ( !m ) {
    return [ 2, "{:" ];
  }

  // attach the attributes to the preceeding element
  var meta = this.dialect.processMetaHash( m[ 1 ] ),
      attr = extract_attr( before );

  if ( !attr ) {
    attr = {};
    before.splice( 1, 0, attr );
  }

  for ( var k in meta ) {
    attr[ k ] = meta[ k ];
  }

  // cut out the string and replace it with nothing
  return [ m[ 0 ].length, "" ];
};

Markdown.dialects.Maruku.inline.__escape__ = /^\\[\\`\*_{}\[\]()#\+.!\-|:]/;

Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );
Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == "[object Array]";
};

var forEach;
// Don't mess with Array.prototype. Its not friendly
if ( Array.prototype.forEach ) {
  forEach = function( arr, cb, thisp ) {
    return arr.forEach( cb, thisp );
  };
}
else {
  forEach = function(arr, cb, thisp) {
    for (var i = 0; i < arr.length; i++) {
      cb.call(thisp || arr, arr[i], i, arr);
    }
  }
}

var isEmpty = function( obj ) {
  for ( var key in obj ) {
    if ( hasOwnProperty.call( obj, key ) ) {
      return false;
    }
  }

  return true;
}

function extract_attr( jsonml ) {
  return isArray(jsonml)
      && jsonml.length > 1
      && typeof jsonml[ 1 ] === "object"
      && !( isArray(jsonml[ 1 ]) )
      ? jsonml[ 1 ]
      : undefined;
}



/**
 *  renderJsonML( jsonml[, options] ) -> String
 *  - jsonml (Array): JsonML array to render to XML
 *  - options (Object): options
 *
 *  Converts the given JsonML into well-formed XML.
 *
 *  The options currently understood are:
 *
 *  - root (Boolean): wether or not the root node should be included in the
 *    output, or just its children. The default `false` is to not include the
 *    root itself.
 */
expose.renderJsonML = function( jsonml, options ) {
  options = options || {};
  // include the root element in the rendered output?
  options.root = options.root || false;

  var content = [];

  if ( options.root ) {
    content.push( render_tree( jsonml ) );
  }
  else {
    jsonml.shift(); // get rid of the tag
    if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
      jsonml.shift(); // get rid of the attributes
    }

    while ( jsonml.length ) {
      content.push( render_tree( jsonml.shift() ) );
    }
  }

  return content.join( "\n\n" );
};

function escapeHTML( text ) {
  return text.replace( /&/g, "&amp;" )
             .replace( /</g, "&lt;" )
             .replace( />/g, "&gt;" )
             .replace( /"/g, "&quot;" )
             .replace( /'/g, "&#39;" );
}

function render_tree( jsonml ) {
  // basic case
  if ( typeof jsonml === "string" ) {
    return escapeHTML( jsonml );
  }

  var tag = jsonml.shift(),
      attributes = {},
      content = [];

  if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
    attributes = jsonml.shift();
  }

  while ( jsonml.length ) {
    content.push( render_tree( jsonml.shift() ) );
  }

  var tag_attrs = "";
  for ( var a in attributes ) {
    tag_attrs += " " + a + '="' + escapeHTML( attributes[ a ] ) + '"';
  }

  // be careful about adding whitespace here for inline elements
  if ( tag == "img" || tag == "br" || tag == "hr" ) {
    return "<"+ tag + tag_attrs + "/>";
  }
  else {
    return "<"+ tag + tag_attrs + ">" + content.join( "" ) + "</" + tag + ">";
  }
}

function convert_tree_to_html( tree, references, options ) {
  var i;
  options = options || {};

  // shallow clone
  var jsonml = tree.slice( 0 );

  if ( typeof options.preprocessTreeNode === "function" ) {
      jsonml = options.preprocessTreeNode(jsonml, references);
  }

  // Clone attributes if they exist
  var attrs = extract_attr( jsonml );
  if ( attrs ) {
    jsonml[ 1 ] = {};
    for ( i in attrs ) {
      jsonml[ 1 ][ i ] = attrs[ i ];
    }
    attrs = jsonml[ 1 ];
  }

  // basic case
  if ( typeof jsonml === "string" ) {
    return jsonml;
  }

  // convert this node
  switch ( jsonml[ 0 ] ) {
    case "header":
      jsonml[ 0 ] = "h" + jsonml[ 1 ].level;
      delete jsonml[ 1 ].level;
      break;
    case "bulletlist":
      jsonml[ 0 ] = "ul";
      break;
    case "numberlist":
      jsonml[ 0 ] = "ol";
      break;
    case "listitem":
      jsonml[ 0 ] = "li";
      break;
    case "para":
      jsonml[ 0 ] = "p";
      break;
    case "markdown":
      jsonml[ 0 ] = "html";
      if ( attrs ) delete attrs.references;
      break;
    case "code_block":
      jsonml[ 0 ] = "pre";
      i = attrs ? 2 : 1;
      var code = [ "code" ];
      code.push.apply( code, jsonml.splice( i, jsonml.length - i ) );
      jsonml[ i ] = code;
      break;
    case "inlinecode":
      jsonml[ 0 ] = "code";
      break;
    case "img":
      jsonml[ 1 ].src = jsonml[ 1 ].href;
      delete jsonml[ 1 ].href;
      break;
    case "linebreak":
      jsonml[ 0 ] = "br";
    break;
    case "link":
      jsonml[ 0 ] = "a";
      break;
    case "link_ref":
      jsonml[ 0 ] = "a";

      // grab this ref and clean up the attribute node
      var ref = references[ attrs.ref ];

      // if the reference exists, make the link
      if ( ref ) {
        delete attrs.ref;

        // add in the href and title, if present
        attrs.href = ref.href;
        if ( ref.title ) {
          attrs.title = ref.title;
        }

        // get rid of the unneeded original text
        delete attrs.original;
      }
      // the reference doesn't exist, so revert to plain text
      else {
        return attrs.original;
      }
      break;
    case "img_ref":
      jsonml[ 0 ] = "img";

      // grab this ref and clean up the attribute node
      var ref = references[ attrs.ref ];

      // if the reference exists, make the link
      if ( ref ) {
        delete attrs.ref;

        // add in the href and title, if present
        attrs.src = ref.href;
        if ( ref.title ) {
          attrs.title = ref.title;
        }

        // get rid of the unneeded original text
        delete attrs.original;
      }
      // the reference doesn't exist, so revert to plain text
      else {
        return attrs.original;
      }
      break;
  }

  // convert all the children
  i = 1;

  // deal with the attribute node, if it exists
  if ( attrs ) {
    // if there are keys, skip over it
    for ( var key in jsonml[ 1 ] ) {
        i = 2;
        break;
    }
    // if there aren't, remove it
    if ( i === 1 ) {
      jsonml.splice( i, 1 );
    }
  }

  for ( ; i < jsonml.length; ++i ) {
    jsonml[ i ] = convert_tree_to_html( jsonml[ i ], references, options );
  }

  return jsonml;
}


// merges adjacent text nodes into a single node
function merge_text_nodes( jsonml ) {
  // skip the tag name and attribute hash
  var i = extract_attr( jsonml ) ? 2 : 1;

  while ( i < jsonml.length ) {
    // if it's a string check the next item too
    if ( typeof jsonml[ i ] === "string" ) {
      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === "string" ) {
        // merge the second string into the first and remove it
        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];
      }
      else {
        ++i;
      }
    }
    // if it's not a string recurse
    else {
      merge_text_nodes( jsonml[ i ] );
      ++i;
    }
  }
}

} )( (function() {
  if ( typeof exports === "undefined" ) {
    window.markdown = {};
    return window.markdown;
  }
  else {
    return exports;
  }
} )() );

},{"util":1006}],336:[function(require,module,exports){
(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory();
  } else {
    root.materialColors = factory();
  }
})(this, function() {
  return {"red":{"50":"#ffebee","100":"#ffcdd2","200":"#ef9a9a","300":"#e57373","400":"#ef5350","500":"#f44336","600":"#e53935","700":"#d32f2f","800":"#c62828","900":"#b71c1c","a100":"#ff8a80","a200":"#ff5252","a400":"#ff1744","a700":"#d50000"},"pink":{"50":"#fce4ec","100":"#f8bbd0","200":"#f48fb1","300":"#f06292","400":"#ec407a","500":"#e91e63","600":"#d81b60","700":"#c2185b","800":"#ad1457","900":"#880e4f","a100":"#ff80ab","a200":"#ff4081","a400":"#f50057","a700":"#c51162"},"purple":{"50":"#f3e5f5","100":"#e1bee7","200":"#ce93d8","300":"#ba68c8","400":"#ab47bc","500":"#9c27b0","600":"#8e24aa","700":"#7b1fa2","800":"#6a1b9a","900":"#4a148c","a100":"#ea80fc","a200":"#e040fb","a400":"#d500f9","a700":"#aa00ff"},"deepPurple":{"50":"#ede7f6","100":"#d1c4e9","200":"#b39ddb","300":"#9575cd","400":"#7e57c2","500":"#673ab7","600":"#5e35b1","700":"#512da8","800":"#4527a0","900":"#311b92","a100":"#b388ff","a200":"#7c4dff","a400":"#651fff","a700":"#6200ea"},"indigo":{"50":"#e8eaf6","100":"#c5cae9","200":"#9fa8da","300":"#7986cb","400":"#5c6bc0","500":"#3f51b5","600":"#3949ab","700":"#303f9f","800":"#283593","900":"#1a237e","a100":"#8c9eff","a200":"#536dfe","a400":"#3d5afe","a700":"#304ffe"},"blue":{"50":"#e3f2fd","100":"#bbdefb","200":"#90caf9","300":"#64b5f6","400":"#42a5f5","500":"#2196f3","600":"#1e88e5","700":"#1976d2","800":"#1565c0","900":"#0d47a1","a100":"#82b1ff","a200":"#448aff","a400":"#2979ff","a700":"#2962ff"},"lightBlue":{"50":"#e1f5fe","100":"#b3e5fc","200":"#81d4fa","300":"#4fc3f7","400":"#29b6f6","500":"#03a9f4","600":"#039be5","700":"#0288d1","800":"#0277bd","900":"#01579b","a100":"#80d8ff","a200":"#40c4ff","a400":"#00b0ff","a700":"#0091ea"},"cyan":{"50":"#e0f7fa","100":"#b2ebf2","200":"#80deea","300":"#4dd0e1","400":"#26c6da","500":"#00bcd4","600":"#00acc1","700":"#0097a7","800":"#00838f","900":"#006064","a100":"#84ffff","a200":"#18ffff","a400":"#00e5ff","a700":"#00b8d4"},"teal":{"50":"#e0f2f1","100":"#b2dfdb","200":"#80cbc4","300":"#4db6ac","400":"#26a69a","500":"#009688","600":"#00897b","700":"#00796b","800":"#00695c","900":"#004d40","a100":"#a7ffeb","a200":"#64ffda","a400":"#1de9b6","a700":"#00bfa5"},"green":{"50":"#e8f5e9","100":"#c8e6c9","200":"#a5d6a7","300":"#81c784","400":"#66bb6a","500":"#4caf50","600":"#43a047","700":"#388e3c","800":"#2e7d32","900":"#1b5e20","a100":"#b9f6ca","a200":"#69f0ae","a400":"#00e676","a700":"#00c853"},"lightGreen":{"50":"#f1f8e9","100":"#dcedc8","200":"#c5e1a5","300":"#aed581","400":"#9ccc65","500":"#8bc34a","600":"#7cb342","700":"#689f38","800":"#558b2f","900":"#33691e","a100":"#ccff90","a200":"#b2ff59","a400":"#76ff03","a700":"#64dd17"},"lime":{"50":"#f9fbe7","100":"#f0f4c3","200":"#e6ee9c","300":"#dce775","400":"#d4e157","500":"#cddc39","600":"#c0ca33","700":"#afb42b","800":"#9e9d24","900":"#827717","a100":"#f4ff81","a200":"#eeff41","a400":"#c6ff00","a700":"#aeea00"},"yellow":{"50":"#fffde7","100":"#fff9c4","200":"#fff59d","300":"#fff176","400":"#ffee58","500":"#ffeb3b","600":"#fdd835","700":"#fbc02d","800":"#f9a825","900":"#f57f17","a100":"#ffff8d","a200":"#ffff00","a400":"#ffea00","a700":"#ffd600"},"amber":{"50":"#fff8e1","100":"#ffecb3","200":"#ffe082","300":"#ffd54f","400":"#ffca28","500":"#ffc107","600":"#ffb300","700":"#ffa000","800":"#ff8f00","900":"#ff6f00","a100":"#ffe57f","a200":"#ffd740","a400":"#ffc400","a700":"#ffab00"},"orange":{"50":"#fff3e0","100":"#ffe0b2","200":"#ffcc80","300":"#ffb74d","400":"#ffa726","500":"#ff9800","600":"#fb8c00","700":"#f57c00","800":"#ef6c00","900":"#e65100","a100":"#ffd180","a200":"#ffab40","a400":"#ff9100","a700":"#ff6d00"},"deepOrange":{"50":"#fbe9e7","100":"#ffccbc","200":"#ffab91","300":"#ff8a65","400":"#ff7043","500":"#ff5722","600":"#f4511e","700":"#e64a19","800":"#d84315","900":"#bf360c","a100":"#ff9e80","a200":"#ff6e40","a400":"#ff3d00","a700":"#dd2c00"},"brown":{"50":"#efebe9","100":"#d7ccc8","200":"#bcaaa4","300":"#a1887f","400":"#8d6e63","500":"#795548","600":"#6d4c41","700":"#5d4037","800":"#4e342e","900":"#3e2723"},"grey":{"50":"#fafafa","100":"#f5f5f5","200":"#eeeeee","300":"#e0e0e0","400":"#bdbdbd","500":"#9e9e9e","600":"#757575","700":"#616161","800":"#424242","900":"#212121"},"blueGrey":{"50":"#eceff1","100":"#cfd8dc","200":"#b0bec5","300":"#90a4ae","400":"#78909c","500":"#607d8b","600":"#546e7a","700":"#455a64","800":"#37474f","900":"#263238"},"darkText":{"primary":"rgba(0, 0, 0, 0.87)","secondary":"rgba(0, 0, 0, 0.54)","disabled":"rgba(0, 0, 0, 0.38)","dividers":"rgba(0, 0, 0, 0.12)"},"lightText":{"primary":"rgba(255, 255, 255, 1)","secondary":"rgba(255, 255, 255, 0.7)","disabled":"rgba(255, 255, 255, 0.5)","dividers":"rgba(255, 255, 255, 0.12)"},"darkIcons":{"active":"rgba(0, 0, 0, 0.54)","inactive":"rgba(0, 0, 0, 0.38)"},"lightIcons":{"active":"rgba(255, 255, 255, 1)","inactive":"rgba(255, 255, 255, 0.5)"},"white":"#ffffff","black":"#000000"};
});

},{}],337:[function(require,module,exports){
//! moment.js
//! version : 2.18.1
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isUndefined(input) {
    return input === void 0;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null,
        rfc2822         : false,
        weekdayMismatch : false
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i = 0; i < momentProperties.length; i++) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
    // TODO: Remove "ordinalParse" fallback in next major release.
    this._dayOfMonthOrdinalParseLenient = new RegExp(
        (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
            '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    ss : '%d seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return isArray(this._months) ? this._months :
            this._months['standalone'];
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return isArray(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    // can't just apply() to create a date:
    // https://stackoverflow.com/q/181348
    var date = new Date(y, m, d, h, M, s, ms);

    // the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    // the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

// https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return isArray(this._weekdays) ? this._weekdays :
            this._weekdays['standalone'];
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('k',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);
addRegexToken('kk', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['k', 'kk'], function (input, array, config) {
    var kInput = toInt(input);
    array[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
var basicRfcRegex = /^((?:Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d?\d\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(?:\d\d)?\d\d\s)(\d\d:\d\d)(\:\d\d)?(\s(?:UT|GMT|[ECMP][SD]T|[A-IK-Za-ik-z]|[+-]\d{4}))$/;

// date and time from ref 2822 format
function configFromRFC2822(config) {
    var string, match, dayFormat,
        dateFormat, timeFormat, tzFormat;
    var timezones = {
        ' GMT': ' +0000',
        ' EDT': ' -0400',
        ' EST': ' -0500',
        ' CDT': ' -0500',
        ' CST': ' -0600',
        ' MDT': ' -0600',
        ' MST': ' -0700',
        ' PDT': ' -0700',
        ' PST': ' -0800'
    };
    var military = 'YXWVUTSRQPONZABCDEFGHIKLM';
    var timezone, timezoneIndex;

    string = config._i
        .replace(/\([^\)]*\)|[\n\t]/g, ' ') // Remove comments and folding whitespace
        .replace(/(\s\s+)/g, ' ') // Replace multiple-spaces with a single space
        .replace(/^\s|\s$/g, ''); // Remove leading and trailing spaces
    match = basicRfcRegex.exec(string);

    if (match) {
        dayFormat = match[1] ? 'ddd' + ((match[1].length === 5) ? ', ' : ' ') : '';
        dateFormat = 'D MMM ' + ((match[2].length > 10) ? 'YYYY ' : 'YY ');
        timeFormat = 'HH:mm' + (match[4] ? ':ss' : '');

        // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
        if (match[1]) { // day of week given
            var momentDate = new Date(match[2]);
            var momentDay = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'][momentDate.getDay()];

            if (match[1].substr(0,3) !== momentDay) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return;
            }
        }

        switch (match[5].length) {
            case 2: // military
                if (timezoneIndex === 0) {
                    timezone = ' +0000';
                } else {
                    timezoneIndex = military.indexOf(match[5][1].toUpperCase()) - 12;
                    timezone = ((timezoneIndex < 0) ? ' -' : ' +') +
                        (('' + timezoneIndex).replace(/^-?/, '0')).match(/..$/)[0] + '00';
                }
                break;
            case 4: // Zone
                timezone = timezones[match[5]];
                break;
            default: // UT or +/-9999
                timezone = timezones[' GMT'];
        }
        match[5] = timezone;
        config._i = match.splice(1).join('');
        tzFormat = ' ZZ';
        config._f = dayFormat + dateFormat + timeFormat + tzFormat;
        configFromStringAndFormat(config);
        getParsingFlags(config).rfc2822 = true;
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    configFromRFC2822(config);
    if (config._isValid === false) {
        delete config._isValid;
    } else {
        return;
    }

    // Final attempt, use Input Fallback
    hooks.createFromInputFallback(config);
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// constant that refers to the RFC 2822 form
hooks.RFC_2822 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }
    if (config._f === hooks.RFC_2822) {
        configFromRFC2822(config);
        return;
    }
    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (isUndefined(input)) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (isObject(input)) {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

function isDurationValid(m) {
    for (var key in m) {
        if (!(ordering.indexOf(key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
            return false;
        }
    }

    var unitHasDecimal = false;
    for (var i = 0; i < ordering.length; ++i) {
        if (m[ordering[i]]) {
            if (unitHasDecimal) {
                return false; // only allow non-integers for smallest unit
            }
            if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                unitHasDecimal = true;
            }
        }
    }

    return true;
}

function isValid$1() {
    return this._isValid;
}

function createInvalid$1() {
    return createDuration(NaN);
}

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    this._isValid = isDurationValid(normalizedInput);

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime, keepMinutes) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16 && !keepMinutes) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm, false, true);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString() {
    if (!this.isValid()) {
        return null;
    }
    var m = this.clone().utc();
    if (m.year() < 0 || m.year() > 9999) {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
    if (isFunction(Date.prototype.toISOString)) {
        // native implementation is ~50x faster, use it when we can
        return this.toDate().toISOString();
    }
    return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$2 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    // TODO: Remove "ordinalParse" fallback in next major release.
    return isStrict ?
      (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
      locale._dayOfMonthOrdinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$2;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    if (!this.isValid()) {
        return NaN;
    }
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    if (!this.isValid()) {
        return NaN;
    }
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this.isValid() ? this[units + 's']() : NaN;
}

function makeGetter(name) {
    return function () {
        return this.isValid() ? this._data[name] : NaN;
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    ss: 44,         // a few seconds to seconds
    s : 45,         // seconds to minute
    m : 45,         // minutes to hour
    h : 22,         // hours to day
    d : 26,         // days to month
    M : 11          // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds <= thresholds.ss && ['s', seconds]  ||
            seconds < thresholds.s   && ['ss', seconds] ||
            minutes <= 1             && ['m']           ||
            minutes < thresholds.m   && ['mm', minutes] ||
            hours   <= 1             && ['h']           ||
            hours   < thresholds.h   && ['hh', hours]   ||
            days    <= 1             && ['d']           ||
            days    < thresholds.d   && ['dd', days]    ||
            months  <= 1             && ['M']           ||
            months  < thresholds.M   && ['MM', months]  ||
            years   <= 1             && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    if (threshold === 's') {
        thresholds.ss = limit - 1;
    }
    return true;
}

function humanize (withSuffix) {
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    if (!this.isValid()) {
        return this.localeData().invalidDate();
    }

    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.isValid        = isValid$1;
proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.18.1';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],338:[function(require,module,exports){
var BuildEnumsetExprComponent, ExprUtils, H, R, React, RemovableComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprUtils = require("mwater-expressions").ExprUtils;

RemovableComponent = require('./RemovableComponent');

module.exports = BuildEnumsetExprComponent = (function(superClass) {
  extend(BuildEnumsetExprComponent, superClass);

  function BuildEnumsetExprComponent() {
    this.handleValueChange = bind(this.handleValueChange, this);
    return BuildEnumsetExprComponent.__super__.constructor.apply(this, arguments);
  }

  BuildEnumsetExprComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    value: React.PropTypes.object,
    enumValues: React.PropTypes.array,
    onChange: React.PropTypes.func
  };

  BuildEnumsetExprComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  BuildEnumsetExprComponent.prototype.handleValueChange = function(id, value) {
    var values;
    values = _.clone(this.props.value.values);
    values[id] = value;
    return this.props.onChange(_.extend({}, this.props.value, {
      values: values
    }));
  };

  BuildEnumsetExprComponent.prototype.renderValues = function() {
    var ExprComponent, exprUtils;
    ExprComponent = require('./ExprComponent');
    exprUtils = new ExprUtils(this.props.schema);
    return H.table({
      className: "table table-bordered"
    }, H.thead(null, H.tr(null, H.th({
      key: "name"
    }, "Choice"), H.th({
      key: "include"
    }, "Include if"))), H.tbody(null, _.map(this.props.enumValues, (function(_this) {
      return function(enumValue) {
        return H.tr({
          key: enumValue.id
        }, H.td({
          key: "name"
        }, exprUtils.localizeString(enumValue.name, _this.context.locale)), H.td({
          key: "value",
          style: {
            maxWidth: "30em"
          }
        }, R(ExprComponent, {
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          table: _this.props.value.table,
          value: _this.props.value.values[enumValue.id],
          onChange: _this.handleValueChange.bind(null, enumValue.id),
          types: ['boolean']
        })));
      };
    })(this))));
  };

  BuildEnumsetExprComponent.prototype.render = function() {
    return R(RemovableComponent, {
      onRemove: this.props.onChange.bind(null, null)
    }, this.props.enumValues ? this.renderValues() : H.i(null, "Cannot display build enumset without known values"));
  };

  return BuildEnumsetExprComponent;

})(React.Component);

},{"./ExprComponent":342,"./RemovableComponent":352,"lodash":"lodash","mwater-expressions":14,"react":"react"}],339:[function(require,module,exports){
var ContentEditableComponent, H, R, React, pasteHtmlAtCaret, selection,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

selection = require('./saveSelection');

module.exports = ContentEditableComponent = (function(superClass) {
  extend(ContentEditableComponent, superClass);

  function ContentEditableComponent() {
    this.handleFocus = bind(this.handleFocus, this);
    this.handleBlur = bind(this.handleBlur, this);
    this.handleInput = bind(this.handleInput, this);
    return ContentEditableComponent.__super__.constructor.apply(this, arguments);
  }

  ContentEditableComponent.propTypes = {
    html: React.PropTypes.string.isRequired,
    onChange: React.PropTypes.func.isRequired,
    style: React.PropTypes.object,
    onClick: React.PropTypes.func,
    onFocus: React.PropTypes.func,
    onBlur: React.PropTypes.func
  };

  ContentEditableComponent.prototype.handleInput = function(ev) {
    if (!this.refs.editor) {
      return;
    }
    return this.props.onChange(this.refs.editor);
  };

  ContentEditableComponent.prototype.handleBlur = function(ev) {
    var base;
    if (typeof (base = this.props).onBlur === "function") {
      base.onBlur(ev);
    }
    if (this.selSaver) {
      clearTimeout(this.selSaver);
      this.selSaver = null;
    }
    if (!this.refs.editor) {
      return;
    }
    return this.props.onChange(this.refs.editor);
  };

  ContentEditableComponent.prototype.handleFocus = function(ev) {
    var base, saveRange;
    if (typeof (base = this.props).onFocus === "function") {
      base.onFocus(ev);
    }
    saveRange = (function(_this) {
      return function() {
        _this.range = selection.save(_this.refs.editor);
        return _this.selSaver = setTimeout(saveRange, 200);
      };
    })(this);
    if (!this.selSaver) {
      return this.selSaver = setTimeout(saveRange, 200);
    }
  };

  ContentEditableComponent.prototype.focus = function() {
    return this.refs.editor.focus();
  };

  ContentEditableComponent.prototype.pasteHTML = function(html, selectPastedContent) {
    this.refs.editor.focus();
    if (this.range) {
      selection.restore(this.refs.editor, this.range);
    }
    pasteHtmlAtCaret(html, selectPastedContent);
    return this.props.onChange(this.refs.editor);
  };

  ContentEditableComponent.prototype.shouldComponentUpdate = function(nextProps) {
    var changed;
    changed = !this.refs.editor || nextProps.html !== this.props.html || this.refs.editor.innerHTML !== this.lastInnerHTML;
    return changed;
  };

  ContentEditableComponent.prototype.componentWillUpdate = function() {
    return this.range = selection.save(this.refs.editor);
  };

  ContentEditableComponent.prototype.componentDidMount = function() {
    if (this.refs.editor) {
      this.refs.editor.innerHTML = this.props.html;
      return this.lastInnerHTML = this.refs.editor.innerHTML;
    }
  };

  ContentEditableComponent.prototype.componentDidUpdate = function() {
    if (this.refs.editor) {
      this.refs.editor.innerHTML = this.props.html;
      this.lastInnerHTML = this.refs.editor.innerHTML;
    }
    if (document.activeElement === this.refs.editor && this.range) {
      return selection.restore(this.refs.editor, this.range);
    }
  };

  ContentEditableComponent.prototype.componentWillUnmount = function() {
    if (this.selSaver) {
      clearTimeout(this.selSaver);
      return this.selSaver = null;
    }
  };

  ContentEditableComponent.prototype.render = function() {
    return H.div({
      contentEditable: true,
      spellCheck: true,
      ref: "editor",
      onClick: this.props.onClick,
      style: this.props.style,
      onInput: this.handleInput,
      onFocus: this.handleFocus,
      onBlur: this.handleBlur
    });
  };

  return ContentEditableComponent;

})(React.Component);

pasteHtmlAtCaret = function(html, selectPastedContent) {
  var el, firstNode, frag, lastNode, node, range, sel;
  range = void 0;
  sel = window.getSelection();
  if (sel.getRangeAt && sel.rangeCount) {
    range = sel.getRangeAt(0);
    range.deleteContents();
    el = document.createElement('div');
    el.innerHTML = html;
    frag = document.createDocumentFragment();
    node = void 0;
    lastNode = void 0;
    while (node = el.firstChild) {
      lastNode = frag.appendChild(node);
    }
    firstNode = frag.firstChild;
    range = range.cloneRange();
    range.insertNode(frag);
    range.collapse(true);
    sel.removeAllRanges();
    return sel.addRange(range);
  }
};

},{"./saveSelection":369,"react":"react"}],340:[function(require,module,exports){
var DateTimePickerComponent, H, R, React, moment,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

H = React.DOM;

moment = require('moment');

require("eonasdan-bootstrap-datetimepicker/build/js/bootstrap-datetimepicker.min.js");

module.exports = DateTimePickerComponent = (function(superClass) {
  extend(DateTimePickerComponent, superClass);

  function DateTimePickerComponent() {
    this.onChange = bind(this.onChange, this);
    return DateTimePickerComponent.__super__.constructor.apply(this, arguments);
  }

  DateTimePickerComponent.propTypes = {
    timepicker: React.PropTypes.bool,
    onChange: React.PropTypes.func,
    date: React.PropTypes.object,
    defaultDate: React.PropTypes.object
  };

  DateTimePickerComponent.defaultProps = {
    timepicker: false
  };

  DateTimePickerComponent.prototype.onChange = function(event) {
    var base;
    return typeof (base = this.props).onChange === "function" ? base.onChange(event.date) : void 0;
  };

  DateTimePickerComponent.prototype.componentDidMount = function() {
    var node, picker, pickerOptions;
    node = this.refs.main;
    pickerOptions = {
      format: this.props.timepicker ? "YYYY-MM-DD HH-mm-ss" : "YYYY-MM-DD",
      inline: true,
      sideBySide: true
    };
    if (this.props.defaultDate) {
      pickerOptions.defaultDate = this.props.defaultDate;
    }
    picker = $(node).datetimepicker(pickerOptions);
    $(node).data("DateTimePicker").date(this.props.date || null);
    return $(node).on("dp.change", this.onChange);
  };

  DateTimePickerComponent.prototype.componentWillReceiveProps = function(nextProps) {
    var node;
    if (nextProps.date === null && this.props.date === null) {
      return;
    }
    if ((nextProps.date != null) && (this.props.date != null) && nextProps.date.isSame(this.props.date)) {
      return;
    }
    node = this.refs.main;
    $(node).off("dp.change", this.onChange);
    $(node).data("DateTimePicker").date(nextProps.date || null);
    return $(node).on("dp.change", this.onChange);
  };

  DateTimePickerComponent.prototype.componentWillUnmount = function() {
    var node;
    node = this.refs.main;
    return $(node).data("DateTimePicker").destroy();
  };

  DateTimePickerComponent.prototype.render = function() {
    return H.div({
      ref: "main"
    });
  };

  return DateTimePickerComponent;

})(React.Component);

},{"eonasdan-bootstrap-datetimepicker/build/js/bootstrap-datetimepicker.min.js":273,"moment":337,"react":"react"}],341:[function(require,module,exports){
var EnumSetComponent, ExprUtils, H, React, ReactSelect, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

ReactSelect = require('react-select');

_ = require('lodash');

ExprUtils = require("mwater-expressions").ExprUtils;

module.exports = EnumSetComponent = (function(superClass) {
  extend(EnumSetComponent, superClass);

  function EnumSetComponent() {
    this.handleChange = bind(this.handleChange, this);
    return EnumSetComponent.__super__.constructor.apply(this, arguments);
  }

  EnumSetComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    enumValues: React.PropTypes.array.isRequired
  };

  EnumSetComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  EnumSetComponent.prototype.handleChange = function(val) {
    var value;
    value = val ? val.split("\n") : [];
    value = _.map(value, JSON.parse);
    if (value.length > 0) {
      return this.props.onChange({
        type: "literal",
        valueType: "enumset",
        value: value
      });
    } else {
      return this.props.onChange(null);
    }
  };

  EnumSetComponent.prototype.render = function() {
    var options, value;
    value = null;
    if (this.props.value && this.props.value.value.length > 0) {
      value = _.map(this.props.value.value, JSON.stringify).join("\n");
    }
    options = _.map(this.props.enumValues, (function(_this) {
      return function(val) {
        return {
          value: JSON.stringify(val.id),
          label: ExprUtils.localizeString(val.name, _this.context.locale)
        };
      };
    })(this));
    return H.div({
      style: {
        width: "100%"
      }
    }, React.createElement(ReactSelect, {
      value: value,
      multi: true,
      delimiter: "\n",
      options: options,
      onChange: this.handleChange
    }));
  };

  return EnumSetComponent;

})(React.Component);

},{"lodash":"lodash","mwater-expressions":14,"react":"react","react-select":818}],342:[function(require,module,exports){
var ExprCleaner, ExprComponent, ExprElementBuilder, H, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprCleaner = require("mwater-expressions").ExprCleaner;

ExprElementBuilder = require('./ExprElementBuilder');

module.exports = ExprComponent = (function(superClass) {
  extend(ExprComponent, superClass);

  function ExprComponent() {
    this.handleChange = bind(this.handleChange, this);
    this.openEditor = bind(this.openEditor, this);
    return ExprComponent.__super__.constructor.apply(this, arguments);
  }

  ExprComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    value: React.PropTypes.object,
    onChange: React.PropTypes.func,
    types: React.PropTypes.array,
    enumValues: React.PropTypes.array,
    idTable: React.PropTypes.string,
    preferLiteral: React.PropTypes.bool,
    aggrStatuses: React.PropTypes.array,
    placeholder: React.PropTypes.string
  };

  ExprComponent.defaultProps = {
    aggrStatuses: ["individual", "literal"]
  };

  ExprComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  ExprComponent.prototype.openEditor = function() {
    var ref;
    return (ref = this.refs.exprLink) != null ? ref.showModal() : void 0;
  };

  ExprComponent.prototype.handleChange = function(expr) {
    return this.props.onChange(this.cleanExpr(expr));
  };

  ExprComponent.prototype.cleanExpr = function(expr) {
    return new ExprCleaner(this.props.schema).cleanExpr(expr, {
      table: this.props.table,
      types: this.props.types,
      enumValueIds: this.props.enumValues ? _.pluck(this.props.enumValues, "id") : void 0,
      idTable: this.props.idTable,
      aggrStatuses: this.props.aggrStatuses
    });
  };

  ExprComponent.prototype.render = function() {
    var expr;
    expr = this.cleanExpr(this.props.value);
    return new ExprElementBuilder(this.props.schema, this.props.dataSource, this.context.locale).build(expr, this.props.table, this.handleChange, {
      types: this.props.types,
      enumValues: this.props.enumValues,
      preferLiteral: this.props.preferLiteral,
      idTable: this.props.idTable,
      includeAggr: indexOf.call(this.props.aggrStatuses, "aggregate") >= 0,
      aggrStatuses: this.props.aggrStatuses,
      placeholder: this.props.placeholder,
      exprLinkRef: !expr ? "exprLink" : void 0
    });
  };

  return ExprComponent;

})(React.Component);

},{"./ExprElementBuilder":343,"lodash":"lodash","mwater-expressions":14,"react":"react"}],343:[function(require,module,exports){
var BuildEnumsetExprComponent, EnumSetComponent, ExprElementBuilder, ExprLinkComponent, ExprUtils, H, IdLiteralComponent, LinkComponent, R, React, ScoreExprComponent, StackedComponent, WrappedLinkComponent, _,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprUtils = require("mwater-expressions").ExprUtils;

EnumSetComponent = require('./EnumSetComponent');

LinkComponent = require('./LinkComponent');

StackedComponent = require('./StackedComponent');

IdLiteralComponent = require('./IdLiteralComponent');

ScoreExprComponent = require('./ScoreExprComponent');

BuildEnumsetExprComponent = require('./BuildEnumsetExprComponent');

ExprLinkComponent = require('./ExprLinkComponent');

module.exports = ExprElementBuilder = (function() {
  function ExprElementBuilder(schema, dataSource, locale) {
    this.schema = schema;
    this.dataSource = dataSource;
    this.locale = locale;
    this.exprUtils = new ExprUtils(this.schema);
  }

  ExprElementBuilder.prototype.build = function(expr, table, onChange, options) {
    var anyTypeAllowed, booleanOnly, createWrapOp, elem, exprType, links;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      aggrStatuses: ["individual", "literal"]
    });
    booleanOnly = options.types && options.types.length === 1 && options.types[0] === "boolean";
    anyTypeAllowed = !options.types || (indexOf.call(options.types, "boolean") >= 0 && indexOf.call(options.aggrStatuses, "individual") >= 0 && options.types.length === 1) || (indexOf.call(options.types, "number") >= 0 && indexOf.call(options.aggrStatuses, "aggregate") >= 0);
    exprType = this.exprUtils.getExprType(expr);
    if (!expr || !expr.type || expr.type === "literal" || expr.type === "field") {
      elem = R(ExprLinkComponent, {
        schema: this.schema,
        dataSource: this.dataSource,
        table: table,
        value: expr,
        onChange: onChange,
        types: !anyTypeAllowed ? options.types : void 0,
        allowCase: !booleanOnly,
        enumValues: options.enumValues,
        idTable: options.idTable,
        initialMode: options.preferLiteral ? "literal" : void 0,
        includeAggr: options.includeAggr,
        aggrStatuses: options.aggrStatuses,
        placeholder: options.placeholder,
        refExpr: options.refExpr,
        ref: options.exprLinkRef
      });
    } else if (expr.type === "op") {
      elem = this.buildOp(expr, table, onChange, options);
    } else if (expr.type === "scalar") {
      elem = this.buildScalar(expr, onChange, {
        key: options.key,
        types: options.types,
        enumValues: options.enumValues
      });
    } else if (expr.type === "case") {
      elem = this.buildCase(expr, onChange, {
        key: options.key,
        types: options.types,
        enumValues: options.enumValues
      });
    } else if (expr.type === "id") {
      elem = this.buildId(expr, onChange, {
        key: options.key
      });
    } else if (expr.type === "score") {
      elem = this.buildScore(expr, onChange, {
        key: options.key
      });
    } else if (expr.type === "build enumset") {
      elem = this.buildBuildEnumset(expr, onChange, {
        key: options.key,
        enumValues: options.enumValues
      });
    } else {
      throw new Error("Unhandled expression type " + expr.type);
    }
    links = [];
    createWrapOp = (function(_this) {
      return function(op, name, type) {
        if (type == null) {
          type = "unary";
        }
        if (indexOf.call(options.suppressWrapOps || [], op) < 0) {
          if (type === "unary") {
            return links.push({
              label: name,
              onClick: function() {
                return onChange({
                  type: "op",
                  op: op,
                  table: table,
                  exprs: [expr]
                });
              }
            });
          } else if (expr.op !== op || type === "binary") {
            return links.push({
              label: name,
              onClick: function() {
                return onChange({
                  type: "op",
                  op: op,
                  table: table,
                  exprs: [expr, null]
                });
              }
            });
          } else {
            return links.push({
              label: name,
              onClick: function() {
                var exprs;
                exprs = expr.exprs.slice();
                exprs.push(null);
                return onChange(_.extend({}, expr, {
                  exprs: exprs
                }));
              }
            });
          }
        }
      };
    })(this);
    if (exprType === "boolean") {
      createWrapOp("and", "+ And", "n");
      createWrapOp("or", "+ Or", "n");
      createWrapOp("not", "Not", "unary");
      createWrapOp("is null", "Is blank", "unary");
    }
    if (exprType === "number") {
      createWrapOp("+", "+", "n");
      createWrapOp("-", "-", "binary");
      createWrapOp("*", "*", "n");
      createWrapOp("/", "/", "binary");
      if (indexOf.call(options.aggrStatuses, "aggregate") >= 0 && this.exprUtils.getExprAggrStatus(expr) === "individual") {
        createWrapOp("sum", "Total", "unary");
      }
    }
    if (expr && expr.type === "case") {
      links.push({
        label: "+ If",
        onClick: (function(_this) {
          return function() {
            var cases;
            cases = expr.cases.slice();
            cases.push({
              when: null,
              then: null
            });
            return onChange(_.extend({}, expr, {
              cases: cases
            }));
          };
        })(this)
      });
    }
    if (links.length > 0) {
      elem = R(WrappedLinkComponent, {
        links: links
      }, elem);
    }
    return elem;
  };

  ExprElementBuilder.prototype.buildId = function(expr, onChange, options) {
    if (options == null) {
      options = {};
    }
    return R(LinkComponent, {
      dropdownItems: [
        {
          id: "remove",
          name: [
            H.i({
              className: "fa fa-remove text-muted"
            }), " Remove"
          ]
        }
      ],
      onDropdownItemClicked: (function(_this) {
        return function() {
          return onChange(null);
        };
      })(this)
    }, this.exprUtils.summarizeExpr(expr));
  };

  ExprElementBuilder.prototype.buildScalar = function(expr, onChange, options) {
    var anyTypeAllowed, destTable, innerAggrStatuses, innerElem, innerOnChange, j, join, joinCol, joinsStr, len, multipleJoins, ref, ref1, summary;
    if (options == null) {
      options = {};
    }
    destTable = expr.table;
    joinsStr = "";
    ref = expr.joins;
    for (j = 0, len = ref.length; j < len; j++) {
      join = ref[j];
      joinCol = this.schema.getColumn(destTable, join);
      joinsStr += ExprUtils.localizeString(joinCol.name, this.locale) + " > ";
      destTable = joinCol.join.toTable;
    }
    if (expr.expr && ((ref1 = expr.expr.type) === "field" || ref1 === "id")) {
      summary = this.exprUtils.summarizeExpr(_.omit(expr, "aggr"));
      return H.div({
        style: {
          display: "flex",
          alignItems: "baseline"
        }
      }, R(LinkComponent, {
        dropdownItems: [
          {
            id: "remove",
            name: [
              H.i({
                className: "fa fa-remove text-muted"
              }), " Remove"
            ]
          }
        ],
        onDropdownItemClicked: (function(_this) {
          return function() {
            return onChange(null);
          };
        })(this)
      }, summary));
    } else {
      innerOnChange = (function(_this) {
        return function(value) {
          return onChange(_.extend({}, expr, {
            expr: value
          }));
        };
      })(this);
      multipleJoins = this.exprUtils.isMultipleJoins(expr.table, expr.joins);
      innerAggrStatuses = multipleJoins ? ["literal", "aggregate"] : ["literal", "individual"];
      anyTypeAllowed = !options.types || (indexOf.call(options.types, "boolean") >= 0 && options.types.length === 1);
      innerElem = this.build(expr.expr, destTable, innerOnChange, {
        types: !anyTypeAllowed ? options.types : void 0,
        idTable: options.idTable,
        enumValues: options.enumValues,
        aggrStatuses: innerAggrStatuses
      });
    }
    return H.div({
      style: {
        display: "flex",
        alignItems: "baseline"
      }
    }, R(LinkComponent, {
      dropdownItems: [
        {
          id: "remove",
          name: [
            H.i({
              className: "fa fa-remove text-muted"
            }), " Remove"
          ]
        }
      ],
      onDropdownItemClicked: (function(_this) {
        return function() {
          return onChange(null);
        };
      })(this)
    }, joinsStr), innerElem);
  };

  ExprElementBuilder.prototype.buildOp = function(expr, table, onChange, options) {
    var aggr, innerAggrStatuses, items, lhsElem, lhsOnChange, lhsTypes, opElem, opItem, opItems, rhs1OnChange, rhs2OnChange, rhsElem, rhsOnChange;
    if (options == null) {
      options = {};
    }
    switch (expr.op) {
      case 'and':
      case 'or':
      case '+':
      case '*':
      case '-':
      case "/":
        items = _.map(expr.exprs, (function(_this) {
          return function(innerExpr, i) {
            var elem, handleRemove, innerElemOnChange, ref, types;
            innerElemOnChange = function(newValue) {
              var newExprs;
              newExprs = expr.exprs.slice();
              newExprs[i] = newValue;
              return onChange(_.extend({}, expr, {
                exprs: newExprs
              }));
            };
            types = (ref = expr.op) === 'and' || ref === 'or' ? ["boolean"] : ["number"];
            elem = _this.build(innerExpr, table, innerElemOnChange, {
              types: types,
              aggrStatuses: options.aggrStatuses,
              suppressWrapOps: [expr.op],
              key: "expr" + i
            });
            handleRemove = function() {
              var exprs;
              exprs = expr.exprs.slice();
              exprs.splice(i, 1);
              return onChange(_.extend({}, expr, {
                exprs: exprs
              }));
            };
            return {
              elem: elem,
              onRemove: handleRemove
            };
          };
        })(this));
        return R(StackedComponent, {
          joinLabel: expr.op,
          items: items
        });
      default:
        opItems = this.exprUtils.findMatchingOpItems({
          op: expr.op,
          resultTypes: options.types,
          lhsExpr: expr.exprs[0]
        });
        opItem = opItems[0];
        if (!opItem) {
          throw new Error("No opItem defined for op:" + expr.op + ", resultType: " + options.types + ", lhs:" + (JSON.stringify(expr.exprs[0])));
        }
        if (opItem.exprTypes.length === 0) {
          return R(LinkComponent, {
            dropdownItems: [
              {
                id: "remove",
                name: [
                  H.i({
                    className: "fa fa-remove text-muted"
                  }), " Remove"
                ]
              }
            ],
            onDropdownItemClicked: ((function(_this) {
              return function() {
                return onChange(null);
              };
            })(this))
          }, this.exprUtils.summarizeExpr(expr, this.locale));
        }
        innerAggrStatuses = opItem.aggr ? ["literal", "individual"] : options.aggrStatuses;
        lhsOnChange = (function(_this) {
          return function(newValue) {
            var newExprs;
            newExprs = expr.exprs.slice();
            newExprs[0] = newValue;
            return onChange(_.extend({}, expr, {
              exprs: newExprs
            }));
          };
        })(this);
        lhsTypes = [opItem.exprTypes[0]];
        if (!expr.exprs[0]) {
          lhsTypes = _.map(opItems, function(oi) {
            return oi.exprTypes[0];
          });
        }
        lhsElem = this.build(expr.exprs[0], table, lhsOnChange, {
          types: lhsTypes,
          aggrStatuses: innerAggrStatuses,
          key: "lhs",
          placeholder: opItem.lhsPlaceholder
        });
        if (expr.op === "between") {
          rhs1OnChange = (function(_this) {
            return function(newValue) {
              var newExprs;
              newExprs = expr.exprs.slice();
              newExprs[1] = newValue;
              return onChange(_.extend({}, expr, {
                exprs: newExprs
              }));
            };
          })(this);
          rhs2OnChange = (function(_this) {
            return function(newValue) {
              var newExprs;
              newExprs = expr.exprs.slice();
              newExprs[2] = newValue;
              return onChange(_.extend({}, expr, {
                exprs: newExprs
              }));
            };
          })(this);
          rhsElem = [
            this.build(expr.exprs[1], table, rhs1OnChange, {
              types: [opItem.exprTypes[1]],
              enumValues: this.exprUtils.getExprEnumValues(expr.exprs[0]),
              idTable: this.exprUtils.getExprIdTable(expr.exprs[0]),
              refExpr: expr.exprs[0],
              preferLiteral: true,
              aggrStatuses: innerAggrStatuses,
              key: "expr1"
            }), "\u00A0and\u00A0", this.build(expr.exprs[2], table, rhs2OnChange, {
              types: [opItem.exprTypes[2]],
              enumValues: this.exprUtils.getExprEnumValues(expr.exprs[0]),
              idTable: this.exprUtils.getExprIdTable(expr.exprs[0]),
              refExpr: expr.exprs[0],
              preferLiteral: true,
              aggrStatuses: innerAggrStatuses,
              key: "expr2"
            })
          ];
        } else if (opItem.exprTypes.length > 1) {
          rhsOnChange = (function(_this) {
            return function(newValue) {
              var newExprs;
              newExprs = expr.exprs.slice();
              newExprs[1] = newValue;
              return onChange(_.extend({}, expr, {
                exprs: newExprs
              }));
            };
          })(this);
          rhsElem = this.build(expr.exprs[1], table, rhsOnChange, {
            key: "rhs",
            types: [opItem.exprTypes[1]],
            enumValues: this.exprUtils.getExprEnumValues(expr.exprs[0]),
            idTable: this.exprUtils.getExprIdTable(expr.exprs[0]),
            refExpr: expr.exprs[0],
            preferLiteral: opItem.rhsLiteral,
            aggrStatuses: innerAggrStatuses,
            placeholder: opItem.rhsPlaceholder
          });
        }
        aggr = null;
        if (indexOf.call(options.aggrStatuses, "aggregate") < 0) {
          aggr = false;
        }
        opItems = this.exprUtils.findMatchingOpItems({
          resultTypes: options.types,
          lhsExpr: expr.exprs[0],
          aggr: aggr
        });
        opItems = _.filter(opItems, function(oi) {
          return oi.op !== expr.op;
        });
        opItems = _.filter(opItems, function(oi) {
          return oi.prefix === opItem.prefix;
        });
        opItems = _.uniq(opItems, "op");
        opElem = R(LinkComponent, {
          dropdownItems: [
            {
              id: "_remove",
              name: [
                H.i({
                  className: "fa fa-remove text-muted"
                }), " Remove"
              ]
            }
          ].concat(_.map(opItems, function(oi) {
            return {
              id: oi.op,
              name: oi.name
            };
          })),
          onDropdownItemClicked: (function(_this) {
            return function(op) {
              if (op === "_remove") {
                return onChange(null);
              } else {
                return onChange(_.extend({}, expr, {
                  op: op
                }));
              }
            };
          })(this)
        }, opItem.prefixLabel || opItem.name);
        if (opItem.prefix) {
          return H.div({
            style: {
              display: "flex",
              alignItems: "baseline",
              flexWrap: "wrap"
            }
          }, opElem, lhsElem, opItem.joiner ? H.span({
            style: {
              paddingLeft: 5,
              paddingRight: 5
            }
          }, opItem.joiner) : void 0, rhsElem);
        } else {
          return H.div({
            style: {
              display: "flex",
              alignItems: "baseline",
              flexWrap: "wrap"
            }
          }, lhsElem, opElem, rhsElem);
        }
    }
  };

  ExprElementBuilder.prototype.buildCase = function(expr, onChange, options) {
    var items, labelStyle, onElseChange;
    labelStyle = {
      flex: "0 0 auto",
      padding: 5,
      color: "#AAA"
    };
    items = _.map(expr.cases, (function(_this) {
      return function(cse, i) {
        var elem, handleRemove, innerElemOnThenChange, innerElemOnWhenChange;
        innerElemOnWhenChange = function(newWhen) {
          var cases;
          cases = expr.cases.slice();
          cases[i] = _.extend({}, cases[i], {
            when: newWhen
          });
          return onChange(_.extend({}, expr, {
            cases: cases
          }));
        };
        innerElemOnThenChange = function(newThen) {
          var cases;
          cases = expr.cases.slice();
          cases[i] = _.extend({}, cases[i], {
            then: newThen
          });
          return onChange(_.extend({}, expr, {
            cases: cases
          }));
        };
        elem = H.div({
          key: "" + i,
          style: {
            display: "flex",
            alignItems: "baseline"
          }
        }, H.div({
          key: "when",
          style: {
            display: "flex",
            alignItems: "baseline"
          }
        }, H.div({
          key: "label",
          style: labelStyle
        }, "if"), _this.build(cse.when, expr.table, innerElemOnWhenChange, {
          key: "content",
          types: ["boolean"],
          suppressWrapOps: ["if"],
          aggrStatuses: options.aggrStatuses
        })), H.div({
          key: "then",
          style: {
            display: "flex",
            alignItems: "baseline"
          }
        }, H.div({
          key: "label",
          style: labelStyle
        }, "then"), _this.build(cse.then, expr.table, innerElemOnThenChange, {
          key: "content",
          types: options.types,
          preferLiteral: true,
          enumValues: options.enumValues,
          aggrStatuses: options.aggrStatuses
        })));
        handleRemove = function() {
          var cases;
          cases = expr.cases.slice();
          cases.splice(i, 1);
          return onChange(_.extend({}, expr, {
            cases: cases
          }));
        };
        return {
          elem: elem,
          onRemove: handleRemove
        };
      };
    })(this));
    onElseChange = (function(_this) {
      return function(newValue) {
        return onChange(_.extend({}, expr, {
          "else": newValue
        }));
      };
    })(this);
    items.push({
      elem: H.div({
        key: "when",
        style: {
          display: "flex",
          alignItems: "baseline"
        }
      }, H.div({
        key: "label",
        style: labelStyle
      }, "else"), this.build(expr["else"], expr.table, onElseChange, {
        key: "content",
        types: options.types,
        preferLiteral: true,
        enumValues: options.enumValues,
        aggrStatuses: options.aggrStatuses
      }))
    });
    return R(StackedComponent, {
      items: items
    });
  };

  ExprElementBuilder.prototype.buildScore = function(expr, onChange, options) {
    return R(ScoreExprComponent, {
      schema: this.schema,
      dataSource: this.dataSource,
      value: expr,
      onChange: onChange
    });
  };

  ExprElementBuilder.prototype.buildBuildEnumset = function(expr, onChange, options) {
    return R(BuildEnumsetExprComponent, {
      schema: this.schema,
      dataSource: this.dataSource,
      value: expr,
      enumValues: options.enumValues,
      onChange: onChange
    });
  };

  return ExprElementBuilder;

})();

WrappedLinkComponent = (function(superClass) {
  extend(WrappedLinkComponent, superClass);

  function WrappedLinkComponent() {
    return WrappedLinkComponent.__super__.constructor.apply(this, arguments);
  }

  WrappedLinkComponent.propTypes = {
    links: React.PropTypes.array.isRequired
  };

  WrappedLinkComponent.prototype.renderLinks = function() {
    return H.div({
      style: {
        position: "absolute",
        left: 10,
        bottom: 0
      },
      className: "hover-display-child"
    }, _.map(this.props.links, (function(_this) {
      return function(link, i) {
        return H.a({
          key: "" + i,
          style: {
            paddingLeft: 3,
            paddingRight: 3,
            backgroundColor: "white",
            cursor: "pointer",
            fontSize: 12
          },
          onClick: link.onClick
        }, link.label);
      };
    })(this)));
  };

  WrappedLinkComponent.prototype.render = function() {
    return H.div({
      style: {
        paddingBottom: 20,
        position: "relative"
      },
      className: "hover-display-parent"
    }, H.div({
      style: {
        position: "absolute",
        height: 10,
        bottom: 10,
        left: 0,
        right: 0,
        borderLeft: "solid 1px #DDD",
        borderBottom: "solid 1px #DDD",
        borderRight: "solid 1px #DDD"
      },
      className: "hover-display-child"
    }), this.renderLinks(), this.props.children);
  };

  return WrappedLinkComponent;

})(React.Component);

},{"./BuildEnumsetExprComponent":338,"./EnumSetComponent":341,"./ExprLinkComponent":344,"./IdLiteralComponent":346,"./LinkComponent":348,"./ScoreExprComponent":355,"./StackedComponent":360,"lodash":"lodash","mwater-expressions":14,"react":"react"}],344:[function(require,module,exports){
var ExprLinkComponent, ExprUtils, H, LinkComponent, LiteralExprStringComponent, R, React, SelectExprModalComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

SelectExprModalComponent = require('./SelectExprModalComponent');

LinkComponent = require('./LinkComponent');

ExprUtils = require("mwater-expressions").ExprUtils;

LiteralExprStringComponent = require('./LiteralExprStringComponent');

module.exports = ExprLinkComponent = (function(superClass) {
  extend(ExprLinkComponent, superClass);

  ExprLinkComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    value: React.PropTypes.object,
    onChange: React.PropTypes.func,
    types: React.PropTypes.array,
    enumValues: React.PropTypes.array,
    idTable: React.PropTypes.string,
    initialMode: React.PropTypes.oneOf(['field', 'formula', 'literal']),
    allowCase: React.PropTypes.bool,
    aggrStatuses: React.PropTypes.array,
    refExpr: React.PropTypes.object,
    placeholder: React.PropTypes.string
  };

  ExprLinkComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  ExprLinkComponent.defaultProps = {
    placeholder: "Select...",
    initialMode: "field",
    aggrStatuses: ['individual', 'literal']
  };

  function ExprLinkComponent() {
    this.renderLiteral = bind(this.renderLiteral, this);
    this.renderField = bind(this.renderField, this);
    this.renderNone = bind(this.renderNone, this);
    this.handleClick = bind(this.handleClick, this);
    this.showModal = bind(this.showModal, this);
    ExprLinkComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      modalVisible: false
    };
  }

  ExprLinkComponent.prototype.showModal = function() {
    return this.setState({
      modalVisible: true
    });
  };

  ExprLinkComponent.prototype.handleClick = function() {
    return this.setState({
      modalVisible: true
    });
  };

  ExprLinkComponent.prototype.renderNone = function() {
    return H.a({
      onClick: this.handleClick,
      style: {
        cursor: "pointer",
        fontStyle: "italic",
        color: "#478"
      }
    }, this.props.placeholder);
  };

  ExprLinkComponent.prototype.renderField = function() {
    var exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    return R(LinkComponent, {
      dropdownItems: [
        {
          id: "edit",
          name: [
            H.i({
              className: "fa fa-pencil text-muted"
            }), " Edit"
          ]
        }, {
          id: "remove",
          name: [
            H.i({
              className: "fa fa-remove text-muted"
            }), " Remove"
          ]
        }
      ],
      onDropdownItemClicked: ((function(_this) {
        return function(id) {
          if (id === "edit") {
            return _this.setState({
              modalVisible: true
            });
          } else {
            return _this.props.onChange(null);
          }
        };
      })(this))
    }, exprUtils.summarizeExpr(this.props.value));
  };

  ExprLinkComponent.prototype.renderLiteral = function() {
    return R(LinkComponent, {
      dropdownItems: [
        {
          id: "edit",
          name: [
            H.i({
              className: "fa fa-pencil text-muted"
            }), " Edit"
          ]
        }, {
          id: "remove",
          name: [
            H.i({
              className: "fa fa-remove text-muted"
            }), " Remove"
          ]
        }
      ],
      onDropdownItemClicked: ((function(_this) {
        return function(id) {
          if (id === "edit") {
            return _this.setState({
              modalVisible: true
            });
          } else {
            return _this.props.onChange(null);
          }
        };
      })(this))
    }, R(LiteralExprStringComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      value: this.props.value,
      enumValues: this.props.enumValues
    }));
  };

  ExprLinkComponent.prototype.render = function() {
    var initialMode, ref;
    initialMode = this.props.initialMode;
    if (this.props.value) {
      if ((ref = this.props.value.type) === "field" || ref === "scalar") {
        initialMode = "field";
      } else if (this.props.value.type === "literal") {
        initialMode = "literal";
      } else {
        initialMode = "formula";
      }
    }
    return H.div(null, this.state.modalVisible ? R(SelectExprModalComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      value: this.props.value,
      types: this.props.types,
      enumValues: this.props.enumValues,
      idTable: this.props.idTable,
      initialMode: initialMode,
      allowCase: this.props.allowCase,
      aggrStatuses: this.props.aggrStatuses,
      refExpr: this.props.refExpr,
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            modalVisible: false
          });
        };
      })(this),
      onSelect: (function(_this) {
        return function(expr) {
          _this.setState({
            modalVisible: false
          });
          return _this.props.onChange(expr);
        };
      })(this)
    }) : void 0, !this.props.value ? this.renderNone() : this.props.value.type === "field" ? this.renderField() : this.props.value.type === "literal" ? this.renderLiteral() : void 0);
  };

  return ExprLinkComponent;

})(React.Component);

},{"./LinkComponent":348,"./LiteralExprStringComponent":349,"./SelectExprModalComponent":356,"lodash":"lodash","mwater-expressions":14,"react":"react"}],345:[function(require,module,exports){
var ExprCleaner, ExprElementBuilder, ExprLinkComponent, FilterExprComponent, H, R, React, RemovableComponent, StackedComponent, _, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

update = require('update-object');

ExprCleaner = require("mwater-expressions").ExprCleaner;

ExprElementBuilder = require('./ExprElementBuilder');

StackedComponent = require('./StackedComponent');

RemovableComponent = require('./RemovableComponent');

ExprLinkComponent = require('./ExprLinkComponent');

module.exports = FilterExprComponent = (function(superClass) {
  extend(FilterExprComponent, superClass);

  FilterExprComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    value: React.PropTypes.object,
    onChange: React.PropTypes.func,
    addLabel: React.PropTypes.node
  };

  FilterExprComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  FilterExprComponent.defaultProps = {
    addLabel: "+ Add Filter"
  };

  function FilterExprComponent() {
    this.handleRemove = bind(this.handleRemove, this);
    this.handleAndRemove = bind(this.handleAndRemove, this);
    this.handleAndChange = bind(this.handleAndChange, this);
    this.handleChange = bind(this.handleChange, this);
    this.handleAddFilter = bind(this.handleAddFilter, this);
    FilterExprComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      displayNull: false
    };
  }

  FilterExprComponent.prototype.handleAddFilter = function() {
    if (this.props.value && this.props.value.op === "and") {
      this.props.onChange(update(this.props.value, {
        exprs: {
          $push: [null]
        }
      }));
      return;
    }
    if (this.props.value) {
      this.props.onChange({
        type: "op",
        op: "and",
        table: this.props.table,
        exprs: [this.props.value, null]
      });
      return;
    }
    return this.setState({
      displayNull: true
    }, (function(_this) {
      return function() {
        var ref;
        return (ref = _this.refs.newExpr) != null ? ref.showModal() : void 0;
      };
    })(this));
  };

  FilterExprComponent.prototype.handleChange = function(expr) {
    return this.props.onChange(this.cleanExpr(expr));
  };

  FilterExprComponent.prototype.cleanExpr = function(expr) {
    return new ExprCleaner(this.props.schema).cleanExpr(expr, {
      table: this.props.table,
      types: ["boolean"]
    });
  };

  FilterExprComponent.prototype.handleAndChange = function(i, expr) {
    return this.handleChange(update(this.props.value, {
      exprs: {
        $splice: [[i, 1, expr]]
      }
    }));
  };

  FilterExprComponent.prototype.handleAndRemove = function(i) {
    return this.handleChange(update(this.props.value, {
      exprs: {
        $splice: [[i, 1]]
      }
    }));
  };

  FilterExprComponent.prototype.handleRemove = function() {
    this.setState({
      displayNull: false
    });
    return this.handleChange(null);
  };

  FilterExprComponent.prototype.renderAddFilter = function() {
    return H.div(null, H.a({
      onClick: this.handleAddFilter
    }, this.props.addLabel));
  };

  FilterExprComponent.prototype.render = function() {
    var expr;
    expr = this.cleanExpr(this.props.value);
    if (expr && expr.op === "and") {
      return H.div(null, R(StackedComponent, {
        joinLabel: "and",
        items: _.map(expr.exprs, (function(_this) {
          return function(subexpr, i) {
            return {
              elem: new ExprElementBuilder(_this.props.schema, _this.props.dataSource, _this.context.locale).build(subexpr, _this.props.table, _this.handleAndChange.bind(null, i), {
                types: ["boolean"],
                preferLiteral: false,
                suppressWrapOps: ['and']
              }),
              onRemove: _this.handleAndRemove.bind(null, i)
            };
          };
        })(this))
      }), _.last(expr.exprs) !== null ? this.renderAddFilter() : void 0);
    } else if (expr) {
      return H.div(null, R(RemovableComponent, {
        onRemove: this.handleRemove
      }, new ExprElementBuilder(this.props.schema, this.props.dataSource, this.context.locale).build(expr, this.props.table, this.handleChange, {
        types: ["boolean"],
        preferLiteral: false,
        suppressWrapOps: ['and']
      })), this.renderAddFilter());
    } else if (this.state.displayNull) {
      return R(ExprLinkComponent, {
        ref: "newExpr",
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        table: this.props.table,
        onChange: this.handleChange
      });
    } else {
      return this.renderAddFilter();
    }
  };

  return FilterExprComponent;

})(React.Component);

},{"./ExprElementBuilder":343,"./ExprLinkComponent":344,"./RemovableComponent":352,"./StackedComponent":360,"lodash":"lodash","mwater-expressions":14,"react":"react","update-object":1003}],346:[function(require,module,exports){
var AsyncLoadComponent, ExprCompiler, H, IdLiteralComponent, React, ReactSelect, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

ReactSelect = require('react-select');

ExprCompiler = require("mwater-expressions").ExprCompiler;

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

module.exports = IdLiteralComponent = (function(superClass) {
  extend(IdLiteralComponent, superClass);

  function IdLiteralComponent() {
    this.getOptions = bind(this.getOptions, this);
    this.handleChange = bind(this.handleChange, this);
    return IdLiteralComponent.__super__.constructor.apply(this, arguments);
  }

  IdLiteralComponent.propTypes = {
    value: React.PropTypes.any,
    onChange: React.PropTypes.func.isRequired,
    idTable: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    placeholder: React.PropTypes.string,
    orderBy: React.PropTypes.array,
    multi: React.PropTypes.bool
  };

  IdLiteralComponent.prototype.focus = function() {
    return this.refs.select.focus();
  };

  IdLiteralComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return newProps.value !== oldProps.value || newProps.idTable !== oldProps.idTable;
  };

  IdLiteralComponent.prototype.load = function(props, prevProps, callback) {
    var idColumn, labelColumn, query, table;
    if (!props.value) {
      callback({
        currentValue: null
      });
      return;
    }
    table = props.schema.getTable(props.idTable);
    idColumn = {
      type: "field",
      tableAlias: "main",
      column: table.primaryKey
    };
    if (table.label) {
      labelColumn = {
        type: "field",
        tableAlias: "main",
        column: table.label
      };
    } else {
      labelColumn = idColumn;
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: idColumn,
          alias: "value"
        }, {
          type: "select",
          expr: labelColumn,
          alias: "label"
        }
      ],
      from: {
        type: "table",
        table: this.props.idTable,
        alias: "main"
      },
      where: {
        type: "op",
        op: "=",
        modifier: "any",
        exprs: [
          idColumn, {
            type: "literal",
            value: (props.multi ? props.value : [props.value])
          }
        ]
      }
    };
    return props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err || !rows[0]) {
          callback({
            currentValue: null
          });
          return;
        }
        if (!_this.props.multi) {
          return callback({
            currentValue: {
              label: rows[0].label,
              value: rows[0].value
            }
          });
        } else {
          return callback({
            currentValue: rows
          });
        }
      };
    })(this));
  };

  IdLiteralComponent.prototype.handleChange = function(value) {
    if (this.props.multi) {
      value = value ? value.split("\n") : null;
      return this.props.onChange(value);
    } else {
      return this.props.onChange(value || null);
    }
  };

  IdLiteralComponent.prototype.getOptions = function(input, cb) {
    var idColumn, labelColumn, query, table;
    if (!input || _.isObject(input)) {
      cb(null, {
        options: [],
        complete: false
      });
      return;
    }
    table = this.props.schema.getTable(this.props.idTable);
    idColumn = {
      type: "field",
      tableAlias: "main",
      column: table.primaryKey
    };
    if (table.label) {
      labelColumn = {
        type: "field",
        tableAlias: "main",
        column: table.label
      };
    } else {
      labelColumn = idColumn;
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: idColumn,
          alias: "value"
        }, {
          type: "select",
          expr: labelColumn,
          alias: "label"
        }
      ],
      from: {
        type: "table",
        table: this.props.idTable,
        alias: "main"
      },
      where: {
        type: "op",
        op: "like",
        exprs: [
          {
            type: "op",
            op: "lower",
            exprs: [labelColumn]
          }, input.toLowerCase() + "%"
        ]
      },
      orderBy: [
        {
          ordinal: 2,
          direction: "asc"
        }
      ],
      limit: 50
    };
    if (this.props.orderBy) {
      query.orderBy = this.props.orderBy.concat(query.orderBy);
    }
    this.props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err) {
          cb(err);
          return;
        }
        rows = _.filter(rows, function(r) {
          return r.label;
        });
        return cb(null, {
          options: _.map(rows, function(r) {
            return {
              value: r.value,
              label: r.label
            };
          }),
          complete: false
        });
      };
    })(this));
  };

  IdLiteralComponent.prototype.render = function() {
    var value;
    value = this.state.currentValue || "";
    return H.div({
      style: {
        width: "100%"
      }
    }, React.createElement(ReactSelect, {
      ref: "select",
      value: value,
      placeholder: this.props.placeholder || "Select",
      asyncOptions: this.getOptions,
      multi: this.props.multi,
      delimiter: "\n",
      isLoading: this.state.loading,
      onChange: this.handleChange
    }));
  };

  return IdLiteralComponent;

})(AsyncLoadComponent);

},{"lodash":"lodash","mwater-expressions":14,"react":"react","react-library/lib/AsyncLoadComponent":782,"react-select":818}],347:[function(require,module,exports){
var ActionCancelModalComponent, ContentEditableComponent, ExprComponent, ExprInsertModalComponent, ExprUpdateModalComponent, ExprUtils, H, InlineExprsEditorComponent, R, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

ExprComponent = require('./ExprComponent');

ExprUtils = require("mwater-expressions").ExprUtils;

ActionCancelModalComponent = require("react-library/lib/ActionCancelModalComponent");

ContentEditableComponent = require('./ContentEditableComponent');

module.exports = InlineExprsEditorComponent = (function(superClass) {
  extend(InlineExprsEditorComponent, superClass);

  function InlineExprsEditorComponent() {
    this.handleChange = bind(this.handleChange, this);
    this.handleClick = bind(this.handleClick, this);
    this.handleUpdate = bind(this.handleUpdate, this);
    this.handleInsert = bind(this.handleInsert, this);
    this.handleInsertClick = bind(this.handleInsertClick, this);
    return InlineExprsEditorComponent.__super__.constructor.apply(this, arguments);
  }

  InlineExprsEditorComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    text: React.PropTypes.string,
    exprs: React.PropTypes.array,
    onChange: React.PropTypes.func.isRequired,
    multiline: React.PropTypes.bool,
    rows: React.PropTypes.number
  };

  InlineExprsEditorComponent.defaultProps = {
    exprs: []
  };

  InlineExprsEditorComponent.prototype.handleInsertClick = function() {
    return this.refs.insertModal.open();
  };

  InlineExprsEditorComponent.prototype.handleInsert = function(expr) {
    if (expr) {
      return this.refs.contentEditable.pasteHTML(this.createExprHtml(expr), false);
    }
  };

  InlineExprsEditorComponent.prototype.handleUpdate = function(expr, index) {
    var exprs;
    exprs = this.props.exprs.slice();
    exprs[index] = expr;
    return this.props.onChange(this.props.text, exprs);
  };

  InlineExprsEditorComponent.prototype.handleClick = function(ev) {
    var index;
    index = ev.target.dataset["index"];
    if (index && index.match(/^\d+$/)) {
      index = parseInt(index);
      return this.refs.updateModal.open(this.props.exprs[index], index);
    }
  };

  InlineExprsEditorComponent.prototype.handleChange = function(elem) {
    var exprs, index, processNode, text, wasBr;
    text = "";
    exprs = [];
    wasBr = false;
    index = 0;
    processNode = (function(_this) {
      return function(node, isFirst) {
        var commentNode, i, len, nodeText, ref, ref1, ref2, results, subnode;
        if (node.nodeType === 1) {
          if ((ref = node.tagName) === 'br' || ref === 'BR') {
            text += '\n';
            wasBr = true;
            return;
          }
          if (node.className && node.className.match(/inline-expr-block/)) {
            commentNode = _.find(node.childNodes, function(subnode) {
              return subnode.nodeType === 8;
            });
            if (commentNode) {
              text += "{" + index + "}";
              exprs.push(JSON.parse(decodeURIComponent(commentNode.nodeValue)));
              index += 1;
            }
            return;
          }
          if (node.tagName.toLowerCase() === "div" && node.innerHTML.toLowerCase() === "<br>") {
            text += "\n";
            wasBr = false;
            return;
          }
          if (!isFirst && !wasBr && ((ref1 = node.tagName) === 'div' || ref1 === 'DIV')) {
            text += "\n";
          }
          wasBr = false;
          ref2 = node.childNodes;
          results = [];
          for (i = 0, len = ref2.length; i < len; i++) {
            subnode = ref2[i];
            results.push(processNode(subnode));
          }
          return results;
        } else if (node.nodeType === 3) {
          wasBr = false;
          nodeText = node.nodeValue;
          if (!_this.props.multiline) {
            nodeText = nodeText.replace(/\r?\n/g, " ");
          }
          return text += nodeText;
        }
      };
    })(this);
    processNode(elem, true);
    text = text.replace(/\u2060/g, '');
    if (!this.props.multiline) {
      text = text.replace(/\r?\n/g, "");
    }
    return this.props.onChange(text, exprs);
  };

  InlineExprsEditorComponent.prototype.createExprHtml = function(expr, index) {
    var exprUtils, summary;
    exprUtils = new ExprUtils(this.props.schema);
    summary = exprUtils.summarizeExpr(expr) || "";
    if (summary.length > 50) {
      summary = summary.substr(0, 50) + "...";
    }
    return '<div class="inline-expr-block" contentEditable="false" data-index="' + index + '"><!--' + encodeURIComponent(JSON.stringify(expr)) + '-->' + _.escape(summary) + '</div>&#x2060;';
  };

  InlineExprsEditorComponent.prototype.createContentEditableHtml = function() {
    var html;
    html = _.escape(this.props.text);
    html = html.replace(/\{(\d+)\}/g, (function(_this) {
      return function(match, index) {
        var expr;
        index = parseInt(index);
        expr = _this.props.exprs[index];
        if (expr) {
          return _this.createExprHtml(expr, index);
        }
        return "";
      };
    })(this));
    if (this.props.multiline) {
      html = html.replace(/\r?\n/g, "<br>");
    }
    html = html.replace(/<br>$/, "<div><br></div>");
    if (html.length === 0) {
      html = '&#x2060;';
    }
    return html;
  };

  InlineExprsEditorComponent.prototype.renderInsertModal = function() {
    return R(ExprInsertModalComponent, {
      ref: "insertModal",
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      onInsert: this.handleInsert
    });
  };

  InlineExprsEditorComponent.prototype.renderUpdateModal = function() {
    return R(ExprUpdateModalComponent, {
      ref: "updateModal",
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      onUpdate: this.handleUpdate
    });
  };

  InlineExprsEditorComponent.prototype.render = function() {
    return H.div({
      style: {
        position: "relative"
      }
    }, this.renderInsertModal(), this.renderUpdateModal(), H.div({
      style: {
        paddingRight: 20
      }
    }, R(ContentEditableComponent, {
      ref: "contentEditable",
      html: this.createContentEditableHtml(),
      style: {
        padding: "6px 12px",
        border: "1px solid #ccc",
        borderRadius: 4,
        minHeight: (this.props.multiline && this.props.rows ? (this.props.rows * 2.5) + "ex" : void 0)
      },
      onChange: this.handleChange,
      onClick: this.handleClick
    })), H.a({
      onClick: this.handleInsertClick,
      style: {
        cursor: "pointer",
        position: "absolute",
        right: 5,
        top: 8,
        fontStyle: "italic",
        color: "#337ab7"
      }
    }, "f", H.sub(null, "x")));
  };

  return InlineExprsEditorComponent;

})(React.Component);

ExprInsertModalComponent = (function(superClass) {
  extend(ExprInsertModalComponent, superClass);

  ExprInsertModalComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    onInsert: React.PropTypes.func.isRequired
  };

  function ExprInsertModalComponent() {
    ExprInsertModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      expr: null
    };
  }

  ExprInsertModalComponent.prototype.open = function() {
    return this.setState({
      open: true,
      expr: null
    });
  };

  ExprInsertModalComponent.prototype.render = function() {
    if (!this.state.open) {
      return null;
    }
    return R(ActionCancelModalComponent, {
      size: "large",
      actionLabel: "Insert",
      onAction: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          }, function() {
            return _this.props.onInsert(_this.state.expr);
          });
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this),
      title: "Insert Expression"
    }, H.div({
      style: {
        paddingBottom: 200
      }
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ['text', 'number', 'enum', 'date', 'datetime'],
      value: this.state.expr,
      onChange: (function(_this) {
        return function(expr) {
          return _this.setState({
            expr: expr
          });
        };
      })(this)
    })));
  };

  return ExprInsertModalComponent;

})(React.Component);

ExprUpdateModalComponent = (function(superClass) {
  extend(ExprUpdateModalComponent, superClass);

  ExprUpdateModalComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    onUpdate: React.PropTypes.func.isRequired
  };

  function ExprUpdateModalComponent() {
    ExprUpdateModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      expr: null,
      index: null
    };
  }

  ExprUpdateModalComponent.prototype.open = function(expr, index) {
    return this.setState({
      open: true,
      expr: expr,
      index: index
    });
  };

  ExprUpdateModalComponent.prototype.render = function() {
    if (!this.state.open) {
      return null;
    }
    return R(ActionCancelModalComponent, {
      size: "large",
      actionLabel: "Update",
      onAction: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          }, function() {
            return _this.props.onUpdate(_this.state.expr, _this.state.index);
          });
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this),
      title: "Update Expression"
    }, H.div({
      style: {
        paddingBottom: 200
      }
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ['text', 'number', 'enum', 'date', 'datetime'],
      value: this.state.expr,
      onChange: (function(_this) {
        return function(expr) {
          return _this.setState({
            expr: expr
          });
        };
      })(this)
    })));
  };

  return ExprUpdateModalComponent;

})(React.Component);

},{"./ContentEditableComponent":339,"./ExprComponent":342,"mwater-expressions":14,"react":"react","react-library/lib/ActionCancelModalComponent":781}],348:[function(require,module,exports){
var H, LinkComponent, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

_ = require('lodash');

module.exports = LinkComponent = (function(superClass) {
  extend(LinkComponent, superClass);

  function LinkComponent() {
    this.renderDropdownItem = bind(this.renderDropdownItem, this);
    return LinkComponent.__super__.constructor.apply(this, arguments);
  }

  LinkComponent.propTypes = {
    onClick: React.PropTypes.func,
    onRemove: React.PropTypes.func,
    dropdownItems: React.PropTypes.array,
    onDropdownItemClicked: React.PropTypes.func
  };

  LinkComponent.prototype.renderRemove = function() {
    if (this.props.onRemove) {
      return H.span({
        className: "link-component-remove",
        onClick: this.props.onRemove
      }, H.span({
        className: "glyphicon glyphicon-remove"
      }));
    }
  };

  LinkComponent.prototype.renderDropdownItem = function(item) {
    var id, key, name;
    id = item.id || item.value;
    name = item.name || item.label;
    if (name == null) {
      return H.li({
        className: "divider"
      });
    }
    key = id;
    if (!_.isString(key)) {
      key = JSON.stringify(key);
    }
    return H.li({
      key: key
    }, H.a({
      key: id,
      onClick: this.props.onDropdownItemClicked.bind(null, id)
    }, name));
  };

  LinkComponent.prototype.render = function() {
    var elem;
    elem = H.div({
      className: "link-component",
      "data-toggle": "dropdown"
    }, H.div({
      style: {
        display: "inline-block"
      },
      onClick: this.props.onClick
    }, this.props.children), this.renderRemove());
    if (this.props.dropdownItems) {
      return H.div({
        className: "dropdown",
        style: {
          display: "inline-block"
        }
      }, elem, H.ul({
        className: "dropdown-menu",
        style: {
          cursor: "pointer"
        }
      }, _.map(this.props.dropdownItems, this.renderDropdownItem)));
    } else {
      return elem;
    }
  };

  return LinkComponent;

})(React.Component);

},{"lodash":"lodash","react":"react"}],349:[function(require,module,exports){
var AsyncLoadComponent, ExprCompiler, ExprUtils, H, LiteralExprStringComponent, R, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprCompiler = require("mwater-expressions").ExprCompiler;

ExprUtils = require("mwater-expressions").ExprUtils;

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

module.exports = LiteralExprStringComponent = (function(superClass) {
  extend(LiteralExprStringComponent, superClass);

  function LiteralExprStringComponent() {
    return LiteralExprStringComponent.__super__.constructor.apply(this, arguments);
  }

  LiteralExprStringComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    value: React.PropTypes.object,
    enumValues: React.PropTypes.array
  };

  LiteralExprStringComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  LiteralExprStringComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return !_.isEqual(newProps.value, oldProps.value);
  };

  LiteralExprStringComponent.prototype.load = function(props, prevProps, callback) {
    var idColumn, labelColumn, query, ref, table;
    if (!props.value || ((ref = props.value.valueType) !== 'id' && ref !== "id[]")) {
      callback({
        label: null
      });
      return;
    }
    table = props.schema.getTable(props.value.idTable);
    idColumn = {
      type: "field",
      tableAlias: "main",
      column: table.primaryKey
    };
    if (table.label) {
      labelColumn = {
        type: "field",
        tableAlias: "main",
        column: table.label
      };
    } else {
      labelColumn = idColumn;
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: labelColumn,
          alias: "label"
        }
      ],
      from: {
        type: "table",
        table: table.id,
        alias: "main"
      },
      where: {
        type: "op",
        op: "=",
        modifier: "any",
        exprs: [
          idColumn, {
            type: "literal",
            value: (props.value.valueType === "id[]" ? props.value.value : [props.value.value])
          }
        ]
      }
    };
    return props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err || !rows[0]) {
          callback({
            label: "(error)"
          });
          return;
        }
        if (props.value.valueType === "id") {
          return callback({
            label: rows[0].label
          });
        } else {
          return callback({
            label: _.pluck(rows, "label").join(", ") || "None"
          });
        }
      };
    })(this));
  };

  LiteralExprStringComponent.prototype.render = function() {
    var exprUtils, ref, ref1, str, type;
    exprUtils = new ExprUtils(this.props.schema);
    type = (ref = this.props.value) != null ? ref.valueType : void 0;
    if (type !== 'id' && type !== 'id[]') {
      str = exprUtils.stringifyLiteralValue(type, (ref1 = this.props.value) != null ? ref1.value : void 0, this.context.locale, this.props.enumValues);
      if (type === "text") {
        str = '"' + str + '"';
      }
    } else {
      if (this.state.loading) {
        str = "...";
      } else {
        str = this.state.label;
      }
    }
    return H.span(null, str);
  };

  return LiteralExprStringComponent;

})(AsyncLoadComponent);

},{"lodash":"lodash","mwater-expressions":14,"react":"react","react-library/lib/AsyncLoadComponent":782}],350:[function(require,module,exports){
var H, LocalizedStringComponent, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = LocalizedStringComponent = (function(superClass) {
  extend(LocalizedStringComponent, superClass);

  function LocalizedStringComponent() {
    return LocalizedStringComponent.__super__.constructor.apply(this, arguments);
  }

  LocalizedStringComponent.propTypes = {
    value: React.PropTypes.object
  };

  LocalizedStringComponent.prototype.render = function() {
    if (this.props.value) {
      return H.span(null, this.props.value[this.props.value._base || "en"]);
    } else {
      return null;
    }
  };

  return LocalizedStringComponent;

})(React.Component);

},{"react":"react"}],351:[function(require,module,exports){
var H, LocalizedStringEditorComp, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = LocalizedStringEditorComp = (function(superClass) {
  extend(LocalizedStringEditorComp, superClass);

  function LocalizedStringEditorComp() {
    this.onLanguageSelectionClick = bind(this.onLanguageSelectionClick, this);
    this.handleChangeValue = bind(this.handleChangeValue, this);
    this.handleRemoveValue = bind(this.handleRemoveValue, this);
    LocalizedStringEditorComp.__super__.constructor.apply(this, arguments);
    this.state = {
      selectedLanguageCode: "en"
    };
  }

  LocalizedStringEditorComp.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    availableLanguages: React.PropTypes.array,
    readonly: React.PropTypes.bool,
    multiline: React.PropTypes.bool
  };

  LocalizedStringEditorComp.prototype.handleRemoveValue = function() {
    var names;
    names = _.clone(this.props.value);
    delete names[this.state.selectedLanguageCode];
    return this.props.onChange(names);
  };

  LocalizedStringEditorComp.prototype.handleChangeValue = function(ev) {
    var currentValue, names, newValue;
    if (this.props.readonly) {
      return;
    }
    newValue = ev.target.value;
    currentValue = this.props.value && this.props.value[this.state.selectedLanguageCode];
    if ((currentValue != null) && currentValue !== "") {
      if ((newValue == null) || newValue === "") {
        this.handleRemoveValue();
        return;
      }
    }
    names = _.clone(this.props.value || {
      _base: "en"
    });
    names[this.state.selectedLanguageCode] = newValue;
    if (!names._base) {
      names._base = this.state.selectedLanguageCode;
    }
    return this.props.onChange(names);
  };

  LocalizedStringEditorComp.prototype.onLanguageSelectionClick = function(languageCode) {
    return this.setState({
      selectedLanguageCode: languageCode
    });
  };

  LocalizedStringEditorComp.prototype.render = function() {
    var availableLanguages, currentText, placeholder;
    if (this.props.value) {
      currentText = this.props.value[this.state.selectedLanguageCode];
      placeholder = null;
      if (this.state.selectedLanguageCode !== this.props.value._base) {
        placeholder = this.props.value[this.props.value._base];
      }
    }
    availableLanguages = this.props.availableLanguages || [
      {
        id: "en",
        name: "en"
      }, {
        id: "fr",
        name: "fr"
      }, {
        id: "es",
        name: "es"
      }, {
        id: "pt",
        name: "pt"
      }
    ];
    return H.div({
      className: "input-group"
    }, this.props.multiline ? H.textarea({
      className: "form-control",
      rows: 5,
      onChange: this.handleChangeValue,
      value: currentText,
      placeholder: placeholder
    }) : H.input({
      type: "text",
      className: "form-control",
      onChange: this.handleChangeValue,
      value: currentText,
      placeholder: placeholder
    }), H.div({
      className: "input-group-btn"
    }, H.button({
      type: "button",
      className: "btn btn-default dropdown-toggle",
      "data-toggle": "dropdown"
    }, this.state.selectedLanguageCode, " ", H.span({
      className: "caret"
    })), H.ul({
      className: "dropdown-menu"
    }, _.map(availableLanguages, (function(_this) {
      return function(availableLanguage) {
        return H.li({
          key: availableLanguage.id
        }, H.a({
          onClick: _this.onLanguageSelectionClick.bind(null, availableLanguage.id)
        }, availableLanguage.name));
      };
    })(this)))));
  };

  return LocalizedStringEditorComp;

})(React.Component);

},{"react":"react"}],352:[function(require,module,exports){
var H, React, RemovableComponent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = RemovableComponent = (function(superClass) {
  extend(RemovableComponent, superClass);

  function RemovableComponent() {
    return RemovableComponent.__super__.constructor.apply(this, arguments);
  }

  RemovableComponent.propTypes = {
    onRemove: React.PropTypes.func
  };

  RemovableComponent.prototype.render = function() {
    return H.div({
      style: {
        display: "flex"
      },
      className: "hover-display-parent"
    }, H.div({
      style: {
        flex: "1 1 auto"
      }
    }, this.props.children), this.props.onRemove ? H.div({
      style: {
        flex: "0 0 auto",
        alignSelf: "center"
      },
      className: "hover-display-child"
    }, H.a({
      onClick: this.props.onRemove,
      style: {
        fontSize: "80%",
        cursor: "pointer",
        marginLeft: 5
      }
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))) : void 0);
  };

  return RemovableComponent;

})(React.Component);

},{"react":"react"}],353:[function(require,module,exports){
var ExprUtils, ScalarExprTreeBuilder, _,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

ExprUtils = require("mwater-expressions").ExprUtils;

module.exports = ScalarExprTreeBuilder = (function() {
  function ScalarExprTreeBuilder(schema, locale) {
    this.schema = schema;
    this.locale = locale;
    this.exprUtils = new ExprUtils(this.schema);
  }

  ScalarExprTreeBuilder.prototype.getTree = function(options) {
    if (options == null) {
      options = {};
    }
    return this.createTableChildNodes({
      startTable: options.table,
      table: options.table,
      joins: [],
      types: options.types,
      idTable: options.idTable,
      includeAggr: options.includeAggr,
      initialValue: options.initialValue,
      filter: options.filter,
      depth: 0
    });
  };

  ScalarExprTreeBuilder.prototype.createTableChildNodes = function(options) {
    var node, nodes, table;
    nodes = [];
    if (!options.includeAggr && options.idTable === options.table && (!options.types || indexOf.call(options.types, "id") >= 0)) {
      node = {
        name: ExprUtils.localizeString(this.schema.getTable(options.table).name, this.locale),
        desc: ExprUtils.localizeString(this.schema.getTable(options.table).desc, this.locale),
        value: {
          table: options.startTable,
          joins: options.joins,
          expr: {
            type: "id",
            table: options.table
          }
        },
        tableId: options.table
      };
      if (!options.filter || (node.name && node.name.match(options.filter))) {
        nodes.push(node);
      }
    }
    table = this.schema.getTable(options.table);
    if (options.includeAggr) {
      node = {
        name: "Number of " + (ExprUtils.localizeString(this.schema.getTable(options.table).name, this.locale)),
        value: {
          table: options.startTable,
          joins: options.joins,
          expr: {
            type: "op",
            op: "count",
            table: options.table,
            exprs: []
          }
        },
        tableId: options.tableId
      };
      if (!options.filter || (node.name && node.name.match(options.filter))) {
        nodes.push(node);
      }
    }
    nodes = nodes.concat(this.createNodes(table.contents, options));
    if (options.includeAggr && options.depth > 0) {
      nodes.push({
        name: "Advanced...",
        desc: "Use to create an advanced function here",
        value: {
          table: options.startTable,
          joins: options.joins,
          expr: null
        },
        tableId: options.tableId
      });
    }
    return nodes;
  };

  ScalarExprTreeBuilder.prototype.createNodes = function(contents, options) {
    var fn, i, item, len, nodes;
    nodes = [];
    fn = (function(_this) {
      return function(item) {
        var childOptions, desc, matches, name, node, numChildren;
        if (item.type === "section") {
          if (!item.deprecated) {
            name = ExprUtils.localizeString(item.name, _this.locale);
            desc = ExprUtils.localizeString(item.desc, _this.locale);
            matches = !options.filter || name.match(options.filter) || (desc && desc.match(options.filter));
            childOptions = _.extend({}, options);
            if (matches) {
              childOptions.filter = null;
            }
            childOptions.depth += 1;
            node = {
              name: name,
              desc: desc,
              children: function() {
                return _this.createNodes(item.contents, childOptions);
              },
              tableId: options.table,
              item: item
            };
            numChildren = node.children().length;
            if (numChildren > 0 || !options.filter) {
              if (options.depth < 2 && options.filter && !matches) {
                node.initiallyOpen = true;
              }
              if (!options.filter) {
                return nodes.push(node);
              } else if (matches) {
                return nodes.push(node);
              } else if (options.depth < 2 && numChildren) {
                return nodes.push(node);
              }
            }
          }
        } else {
          if (!item.deprecated) {
            node = _this.createColumnNode(_.extend(options, {
              column: item
            }));
            if (node) {
              return nodes.push(node);
            }
          }
        }
      };
    })(this);
    for (i = 0, len = contents.length; i < len; i++) {
      item = contents[i];
      fn(item);
    }
    return nodes;
  };

  ScalarExprTreeBuilder.prototype.createColumnNode = function(options) {
    var column, fieldExpr, initVal, joins, matches, node, ref, ref1, ref2, ref3, types;
    column = options.column;
    node = {
      name: ExprUtils.localizeString(column.name, this.locale),
      desc: ExprUtils.localizeString(column.desc, this.locale),
      tableId: options.table,
      item: column
    };
    matches = !options.filter || (node.name && node.name.match(options.filter)) || (node.desc && node.desc.match(options.filter));
    if (column.type === "join") {
      joins = options.joins.slice();
      joins.push(column.id);
      initVal = options.initialValue;
      if ((ref = this.schema.getTable(column.join.toTable)) != null ? ref.label : void 0) {
        if (((ref1 = column.join.type) === 'n-1' || ref1 === '1-1') && (!options.types || indexOf.call(options.types, 'id') >= 0) && (!options.idTable || column.join.toTable === options.idTable)) {
          node.value = {
            table: options.startTable,
            joins: options.joins,
            expr: {
              type: "field",
              table: options.table,
              column: column.id
            }
          };
        }
        if (((ref2 = column.join.type) === 'n-n' || ref2 === '1-n') && (!options.types || indexOf.call(options.types, 'id[]') >= 0) && (!options.idTable || column.join.toTable === options.idTable)) {
          node.value = {
            table: options.startTable,
            joins: options.joins,
            expr: {
              type: "field",
              table: options.table,
              column: column.id
            }
          };
        }
      }
      node.children = (function(_this) {
        return function() {
          var filter, includeAggr;
          includeAggr = _this.exprUtils.isMultipleJoins(options.startTable, joins);
          if (!matches) {
            filter = options.filter;
          } else {
            filter = null;
          }
          return _this.createTableChildNodes({
            startTable: options.startTable,
            table: column.join.toTable,
            joins: joins,
            types: options.types,
            includeAggr: includeAggr,
            initialValue: initVal,
            filter: filter,
            depth: options.depth + 1
          });
        };
      })(this);
      if (initVal && initVal.joins && _.isEqual(initVal.joins.slice(0, joins.length), joins)) {
        node.initiallyOpen = true;
      }
      if (options.depth < 1 && options.filter && !matches) {
        node.initiallyOpen = true;
      }
      if (!options.filter) {
        return node;
      } else if (matches) {
        return node;
      } else if (options.depth < 1 && node.children().length > 0) {
        return node;
      }
      return null;
    } else {
      if (!matches) {
        return;
      }
      fieldExpr = {
        type: "field",
        table: options.table,
        column: column.id
      };
      if (!this.exprUtils.isMultipleJoins(options.startTable, options.joins) && this.exprUtils.getExprAggrStatus(fieldExpr) === "aggregate" && !options.includeAggr) {
        return;
      }
      if (options.types) {
        if (this.exprUtils.isMultipleJoins(options.startTable, options.joins)) {
          types = this.exprUtils.getAggrTypes(fieldExpr);
          if (_.intersection(types, options.types).length === 0) {
            return;
          }
        } else {
          if (ref3 = this.exprUtils.getExprType(fieldExpr), indexOf.call(options.types, ref3) < 0) {
            return;
          }
        }
      }
      node.value = {
        table: options.startTable,
        joins: options.joins,
        expr: fieldExpr
      };
    }
    return node;
  };

  return ScalarExprTreeBuilder;

})();

},{"lodash":"lodash","mwater-expressions":14}],354:[function(require,module,exports){
var H, R, React, ReactDOM, ScalarExprTreeComponent, ScalarExprTreeLeafComponent, ScalarExprTreeNodeComponent, ScalarExprTreeTreeComponent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

R = React.createElement;

module.exports = ScalarExprTreeComponent = (function(superClass) {
  extend(ScalarExprTreeComponent, superClass);

  function ScalarExprTreeComponent() {
    return ScalarExprTreeComponent.__super__.constructor.apply(this, arguments);
  }

  ScalarExprTreeComponent.propTypes = {
    tree: React.PropTypes.array.isRequired,
    onChange: React.PropTypes.func.isRequired,
    height: React.PropTypes.number
  };

  ScalarExprTreeComponent.prototype.render = function() {
    return H.div({
      style: {
        overflowY: (this.props.height ? "auto" : void 0),
        height: this.props.height
      }
    }, R(ScalarExprTreeTreeComponent, {
      tree: this.props.tree,
      onChange: this.props.onChange,
      frame: this
    }));
  };

  return ScalarExprTreeComponent;

})(React.Component);

ScalarExprTreeTreeComponent = (function(superClass) {
  extend(ScalarExprTreeTreeComponent, superClass);

  function ScalarExprTreeTreeComponent() {
    return ScalarExprTreeTreeComponent.__super__.constructor.apply(this, arguments);
  }

  ScalarExprTreeTreeComponent.propTypes = {
    tree: React.PropTypes.array.isRequired,
    onChange: React.PropTypes.func.isRequired,
    prefix: React.PropTypes.string
  };

  ScalarExprTreeTreeComponent.prototype.render = function() {
    var elems, i, item, j, len, ref;
    elems = [];
    ref = this.props.tree;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      item = ref[i];
      if (item.children) {
        elems.push(R(ScalarExprTreeNodeComponent, {
          key: item.name + item.desc,
          item: item,
          prefix: this.props.prefix,
          onChange: this.props.onChange
        }));
      } else {
        elems.push(R(ScalarExprTreeLeafComponent, {
          key: item.name + item.desc,
          item: item,
          prefix: this.props.prefix,
          onChange: this.props.onChange
        }));
      }
    }
    return H.div(null, elems);
  };

  return ScalarExprTreeTreeComponent;

})(React.Component);

ScalarExprTreeLeafComponent = (function(superClass) {
  extend(ScalarExprTreeLeafComponent, superClass);

  function ScalarExprTreeLeafComponent() {
    this.handleClick = bind(this.handleClick, this);
    return ScalarExprTreeLeafComponent.__super__.constructor.apply(this, arguments);
  }

  ScalarExprTreeLeafComponent.propTypes = {
    item: React.PropTypes.object.isRequired,
    prefix: React.PropTypes.string
  };

  ScalarExprTreeLeafComponent.prototype.handleClick = function() {
    return this.props.onChange(this.props.item.value);
  };

  ScalarExprTreeLeafComponent.prototype.render = function() {
    var style;
    style = {
      padding: 4,
      borderRadius: 4,
      cursor: "pointer",
      color: "#478"
    };
    return H.div({
      style: style,
      className: "hover-grey-background",
      onClick: this.handleClick
    }, this.props.prefix ? H.span({
      className: "text-muted"
    }, this.props.prefix) : void 0, this.props.item.name, this.props.item.desc ? H.span({
      className: "text-muted",
      style: {
        fontSize: 12,
        paddingLeft: 3
      }
    }, " - " + this.props.item.desc) : void 0);
  };

  return ScalarExprTreeLeafComponent;

})(React.Component);

ScalarExprTreeNodeComponent = (function(superClass) {
  extend(ScalarExprTreeNodeComponent, superClass);

  ScalarExprTreeNodeComponent.propTypes = {
    item: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  ScalarExprTreeNodeComponent.contextTypes = {
    decorateScalarExprTreeSectionChildren: React.PropTypes.func
  };

  function ScalarExprTreeNodeComponent(props) {
    this.handleItemClick = bind(this.handleItemClick, this);
    this.handleArrowClick = bind(this.handleArrowClick, this);
    ScalarExprTreeNodeComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      collapse: this.props.item.initiallyOpen ? "open" : "closed"
    };
  }

  ScalarExprTreeNodeComponent.prototype.handleArrowClick = function() {
    if (this.state.collapse === "open") {
      return this.setState({
        collapse: "closed"
      });
    } else if (this.state.collapse === "closed") {
      return this.setState({
        collapse: "open"
      });
    }
  };

  ScalarExprTreeNodeComponent.prototype.handleItemClick = function() {
    if (!this.props.item.value) {
      return this.handleArrowClick();
    } else {
      return this.props.onChange(this.props.item.value);
    }
  };

  ScalarExprTreeNodeComponent.prototype.render = function() {
    var arrow, children, color, prefix;
    arrow = null;
    if (this.state.collapse === "closed") {
      arrow = H.i({
        className: "fa fa-plus-square-o",
        style: {
          width: 15
        }
      });
    } else if (this.state.collapse === "open") {
      arrow = H.i({
        className: "fa fa-minus-square-o",
        style: {
          width: 15
        }
      });
    }
    if (this.state.collapse === "open") {
      prefix = this.props.prefix || "";
      if (this.props.item.item.type === "join") {
        prefix = prefix + this.props.item.name + " > ";
      }
      children = R(ScalarExprTreeTreeComponent, {
        prefix: prefix,
        tree: this.props.item.children(),
        onChange: this.props.onChange
      });
      if (this.context.decorateScalarExprTreeSectionChildren && this.props.item.item.type === "section") {
        children = this.context.decorateScalarExprTreeSectionChildren({
          children: children,
          tableId: this.props.item.tableId,
          section: this.props.item.item
        });
      }
      children = H.div({
        style: {
          paddingLeft: 18
        },
        key: "tree"
      }, children);
    }
    color = this.props.item.value ? "#478" : void 0;
    return H.div(null, H.div({
      style: {
        cursor: "pointer",
        padding: 4,
        marginLeft: 20,
        position: "relative"
      },
      key: "item",
      className: (this.props.item.value ? "hover-grey-background" : void 0)
    }, H.span({
      style: {
        color: "#478",
        cursor: "pointer",
        position: "absolute",
        left: -15
      },
      onClick: this.handleArrowClick
    }, arrow), H.div({
      style: {
        color: color,
        display: "inline-block"
      },
      onClick: this.handleItemClick
    }, this.props.prefix ? H.span({
      className: "text-muted"
    }, this.props.prefix) : void 0, this.props.item.name, this.props.item.desc ? H.span({
      className: "text-muted",
      style: {
        fontSize: 12,
        paddingLeft: 3
      }
    }, " - " + this.props.item.desc) : void 0)), children);
  };

  return ScalarExprTreeNodeComponent;

})(React.Component);

},{"react":"react","react-dom":"react-dom"}],355:[function(require,module,exports){
var ExprUtils, H, R, React, RemovableComponent, ScoreExprComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprUtils = require("mwater-expressions").ExprUtils;

RemovableComponent = require('./RemovableComponent');

module.exports = ScoreExprComponent = (function(superClass) {
  extend(ScoreExprComponent, superClass);

  function ScoreExprComponent() {
    this.handleScoreChange = bind(this.handleScoreChange, this);
    this.handleInputChange = bind(this.handleInputChange, this);
    return ScoreExprComponent.__super__.constructor.apply(this, arguments);
  }

  ScoreExprComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    value: React.PropTypes.object,
    onChange: React.PropTypes.func
  };

  ScoreExprComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  ScoreExprComponent.prototype.handleInputChange = function(expr) {
    return this.props.onChange(_.extend({}, this.props.value, {
      input: expr
    }));
  };

  ScoreExprComponent.prototype.handleScoreChange = function(id, value) {
    var scores;
    scores = _.clone(this.props.value.scores);
    scores[id] = value;
    return this.props.onChange(_.extend({}, this.props.value, {
      scores: scores
    }));
  };

  ScoreExprComponent.prototype.renderScores = function() {
    var ExprComponent, enumValues, exprUtils;
    ExprComponent = require('./ExprComponent');
    exprUtils = new ExprUtils(this.props.schema);
    enumValues = exprUtils.getExprEnumValues(this.props.value.input);
    if (!enumValues) {
      return null;
    }
    return H.table({
      className: "table table-bordered"
    }, H.thead(null, H.tr(null, H.th({
      key: "name"
    }, "Choice"), H.th({
      key: "score"
    }, "Score"))), H.tbody(null, _.map(enumValues, (function(_this) {
      return function(enumValue) {
        return H.tr({
          key: enumValue.id
        }, H.td({
          key: "name"
        }, exprUtils.localizeString(enumValue.name, _this.context.locale)), H.td({
          key: "score",
          style: {
            maxWidth: "20em"
          }
        }, R(ExprComponent, {
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          table: _this.props.value.table,
          value: _this.props.value.scores[enumValue.id],
          onChange: _this.handleScoreChange.bind(null, enumValue.id),
          types: ['number'],
          preferLiteral: true
        })));
      };
    })(this))));
  };

  ScoreExprComponent.prototype.render = function() {
    var ExprComponent;
    ExprComponent = require('./ExprComponent');
    return R(RemovableComponent, {
      onRemove: this.props.onChange.bind(null, null)
    }, H.div(null, "Score choices of: ", H.div({
      style: {
        display: "inline-block",
        maxWidth: "50em"
      }
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.value.table,
      value: this.props.value.input,
      onChange: this.handleInputChange,
      types: ['enum', 'enumset']
    }))), this.renderScores());
  };

  return ScoreExprComponent;

})(React.Component);

},{"./ExprComponent":342,"./RemovableComponent":352,"lodash":"lodash","mwater-expressions":14,"react":"react"}],356:[function(require,module,exports){
var ExprUtils, H, ModalWindowComponent, R, React, SelectExprModalComponent, SelectFieldExprComponent, SelectFormulaExprComponent, SelectLiteralExprComponent, TabbedComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ExprUtils = require("mwater-expressions").ExprUtils;

ModalWindowComponent = require('react-library/lib/ModalWindowComponent');

TabbedComponent = require('react-library/lib/TabbedComponent');

SelectFieldExprComponent = require('./SelectFieldExprComponent');

SelectFormulaExprComponent = require('./SelectFormulaExprComponent');

SelectLiteralExprComponent = require('./SelectLiteralExprComponent');

module.exports = SelectExprModalComponent = (function(superClass) {
  extend(SelectExprModalComponent, superClass);

  function SelectExprModalComponent() {
    return SelectExprModalComponent.__super__.constructor.apply(this, arguments);
  }

  SelectExprModalComponent.propTypes = {
    onSelect: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    value: React.PropTypes.object,
    types: React.PropTypes.array,
    enumValues: React.PropTypes.array,
    idTable: React.PropTypes.string,
    initialMode: React.PropTypes.oneOf(['field', 'formula', 'literal']),
    allowCase: React.PropTypes.bool,
    aggrStatuses: React.PropTypes.array,
    refExpr: React.PropTypes.object,
    placeholder: React.PropTypes.string
  };

  SelectExprModalComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  SelectExprModalComponent.defaultProps = {
    placeholder: "Select...",
    initialMode: "field",
    aggrStatuses: ['individual', 'literal']
  };

  SelectExprModalComponent.prototype.renderContents = function() {
    var table, tabs;
    table = this.props.schema.getTable(this.props.table);
    tabs = [
      {
        id: "field",
        label: [
          H.i({
            className: "fa fa-table"
          }), " " + (ExprUtils.localizeString(table.name, this.context.locale)) + " Field"
        ],
        elem: R(SelectFieldExprComponent, {
          schema: this.props.schema,
          dataSource: this.props.dataSource,
          onChange: this.props.onSelect,
          table: this.props.table,
          types: this.props.types,
          allowCase: this.props.allowCase,
          enumValues: this.props.enumValues,
          idTable: this.props.idTable,
          aggrStatuses: this.props.aggrStatuses
        })
      }, {
        id: "formula",
        label: [
          H.i({
            className: "fa fa-calculator"
          }), " Formula"
        ],
        elem: R(SelectFormulaExprComponent, {
          table: this.props.table,
          onChange: this.props.onSelect,
          types: this.props.types,
          allowCase: this.props.allowCase,
          aggrStatuses: this.props.aggrStatuses
        })
      }
    ];
    if (indexOf.call(this.props.aggrStatuses, "literal") >= 0) {
      tabs.push({
        id: "literal",
        label: [
          H.i({
            className: "fa fa-pencil"
          }), " Value"
        ],
        elem: R(SelectLiteralExprComponent, {
          value: this.props.value,
          onChange: this.props.onSelect,
          onCancel: this.props.onCancel,
          schema: this.props.schema,
          dataSource: this.props.dataSource,
          table: this.props.table,
          types: this.props.types,
          enumValues: this.props.enumValues,
          idTable: this.props.idTable,
          refExpr: this.props.refExpr
        })
      });
    }
    return H.div(null, H.h3({
      style: {
        marginTop: 0
      }
    }, "Select Field, Formula or Value"), R(TabbedComponent, {
      tabs: tabs,
      initialTabId: this.props.initialMode
    }));
  };

  SelectExprModalComponent.prototype.render = function() {
    return R(ModalWindowComponent, {
      isOpen: true,
      onRequestClose: this.props.onCancel
    }, this.renderContents());
  };

  return SelectExprModalComponent;

})(React.Component);

},{"./SelectFieldExprComponent":357,"./SelectFormulaExprComponent":358,"./SelectLiteralExprComponent":359,"lodash":"lodash","mwater-expressions":14,"react":"react","react-library/lib/ModalWindowComponent":787,"react-library/lib/TabbedComponent":792}],357:[function(require,module,exports){
var ExprUtils, H, R, React, ScalarExprTreeBuilder, ScalarExprTreeComponent, SelectFieldExprComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ScalarExprTreeComponent = require('./ScalarExprTreeComponent');

ScalarExprTreeBuilder = require('./ScalarExprTreeBuilder');

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = SelectFieldExprComponent = (function(superClass) {
  extend(SelectFieldExprComponent, superClass);

  SelectFieldExprComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    types: React.PropTypes.array,
    enumValues: React.PropTypes.array,
    idTable: React.PropTypes.string,
    aggrStatuses: React.PropTypes.array
  };

  function SelectFieldExprComponent() {
    this.handleTreeChange = bind(this.handleTreeChange, this);
    this.handleSearchTextChange = bind(this.handleSearchTextChange, this);
    SelectFieldExprComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      searchText: ""
    };
  }

  SelectFieldExprComponent.prototype.componentDidMount = function() {
    return this.refs.search.focus();
  };

  SelectFieldExprComponent.prototype.handleSearchTextChange = function(ev) {
    return this.setState({
      searchText: ev.target.value
    });
  };

  SelectFieldExprComponent.prototype.handleTreeChange = function(val) {
    var buildExpr, ev, expr, exprUtils, fromEnumValues, i, len, literal, matchingEnumValue, ref;
    this.setState({
      focused: false
    });
    expr = val.expr;
    exprUtils = new ExprUtils(this.props.schema);
    if (exprUtils.getExprType(val.expr) === "enum" && this.props.enumValues) {
      expr = {
        type: "case",
        table: expr.table,
        cases: _.map(this.props.enumValues, (function(_this) {
          return function(ev) {
            var fromEnumValues, literal, matchingEnumValue;
            fromEnumValues = exprUtils.getExprEnumValues(expr);
            matchingEnumValue = _.find(fromEnumValues, function(fev) {
              return fev.name.en === ev.name.en;
            });
            if (matchingEnumValue) {
              literal = {
                type: "literal",
                valueType: "enumset",
                value: [matchingEnumValue.id]
              };
            } else {
              literal = null;
            }
            return {
              when: {
                type: "op",
                table: expr.table,
                op: "= any",
                exprs: [expr, literal]
              },
              then: {
                type: "literal",
                valueType: "enum",
                value: ev.id
              }
            };
          };
        })(this)),
        "else": null
      };
    }
    if (exprUtils.getExprType(val.expr) === "enumset" && this.props.enumValues) {
      buildExpr = {
        type: "build enumset",
        table: expr.table,
        values: {}
      };
      ref = this.props.enumValues;
      for (i = 0, len = ref.length; i < len; i++) {
        ev = ref[i];
        fromEnumValues = exprUtils.getExprEnumValues(expr);
        matchingEnumValue = _.find(fromEnumValues, function(fev) {
          return fev.name.en === ev.name.en;
        });
        if (matchingEnumValue) {
          literal = {
            type: "literal",
            valueType: "enumset",
            value: [matchingEnumValue.id]
          };
        } else {
          literal = null;
        }
        buildExpr.values[ev.id] = {
          type: "op",
          table: expr.table,
          op: "contains",
          exprs: [expr, literal]
        };
      }
      expr = buildExpr;
    }
    if (val.joins.length === 0) {
      return this.props.onChange(expr);
    } else {
      return this.props.onChange({
        type: "scalar",
        table: this.props.table,
        joins: val.joins,
        expr: expr
      });
    }
  };

  SelectFieldExprComponent.prototype.render = function() {
    var filter, tree, treeBuilder;
    if (this.state.searchText) {
      filter = new RegExp(_.escapeRegExp(this.state.searchText), "i");
    }
    treeBuilder = new ScalarExprTreeBuilder(this.props.schema, this.context.locale);
    tree = treeBuilder.getTree({
      table: this.props.table,
      types: this.props.types,
      idTable: this.props.idTable,
      includeAggr: indexOf.call(this.props.aggrStatuses, "aggregate") >= 0,
      filter: filter
    });
    return H.div(null, H.input({
      ref: "search",
      type: "text",
      placeholder: "Search Fields...",
      className: "form-control input-lg",
      value: this.state.searchText,
      onChange: this.handleSearchTextChange
    }), H.div({
      style: {
        paddingTop: 10,
        paddingBottom: 200
      }
    }, R(ScalarExprTreeComponent, {
      key: "scalar_tree:" + this.state.searchText,
      tree: tree,
      onChange: this.handleTreeChange
    })));
  };

  return SelectFieldExprComponent;

})(React.Component);

},{"./ScalarExprTreeBuilder":353,"./ScalarExprTreeComponent":354,"lodash":"lodash","mwater-expressions":14,"react":"react"}],358:[function(require,module,exports){
var ExprUtils, H, R, React, ScalarExprTreeBuilder, ScalarExprTreeComponent, SelectFormulaExprComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

ScalarExprTreeComponent = require('./ScalarExprTreeComponent');

ScalarExprTreeBuilder = require('./ScalarExprTreeBuilder');

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = SelectFormulaExprComponent = (function(superClass) {
  extend(SelectFormulaExprComponent, superClass);

  SelectFormulaExprComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    table: React.PropTypes.string.isRequired,
    allowCase: React.PropTypes.bool,
    types: React.PropTypes.array,
    aggrStatuses: React.PropTypes.array
  };

  function SelectFormulaExprComponent() {
    this.handleOpSelected = bind(this.handleOpSelected, this);
    this.handleBuildEnumsetSelected = bind(this.handleBuildEnumsetSelected, this);
    this.handleScoreSelected = bind(this.handleScoreSelected, this);
    this.handleIfSelected = bind(this.handleIfSelected, this);
    this.handleSearchTextChange = bind(this.handleSearchTextChange, this);
    SelectFormulaExprComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      searchText: ""
    };
  }

  SelectFormulaExprComponent.prototype.componentDidMount = function() {
    return this.refs.search.focus();
  };

  SelectFormulaExprComponent.prototype.handleSearchTextChange = function(ev) {
    return this.setState({
      searchText: ev.target.value
    });
  };

  SelectFormulaExprComponent.prototype.handleIfSelected = function() {
    var ifExpr;
    ifExpr = {
      type: "case",
      table: this.props.table,
      cases: [
        {
          when: null,
          then: null
        }
      ],
      "else": null
    };
    return this.props.onChange(ifExpr);
  };

  SelectFormulaExprComponent.prototype.handleScoreSelected = function() {
    var scoreExpr;
    scoreExpr = {
      type: "score",
      table: this.props.table,
      input: null,
      scores: {}
    };
    return this.props.onChange(scoreExpr);
  };

  SelectFormulaExprComponent.prototype.handleBuildEnumsetSelected = function() {
    var expr;
    expr = {
      type: "build enumset",
      table: this.props.table,
      values: {}
    };
    return this.props.onChange(expr);
  };

  SelectFormulaExprComponent.prototype.handleOpSelected = function(op) {
    var expr;
    expr = {
      type: "op",
      table: this.props.table,
      op: op,
      exprs: []
    };
    return this.props.onChange(expr);
  };

  SelectFormulaExprComponent.prototype.render = function() {
    var aggr, exprUtils, filter, i, items, len, opItem, opItems, ref;
    if (this.state.searchText) {
      filter = new RegExp(_.escapeRegExp(this.state.searchText), "i");
    }
    items = [];
    if (this.props.allowCase) {
      items.push({
        name: "If/then",
        desc: "Choose different values based on a condition",
        onClick: this.handleIfSelected
      });
    }
    if (!this.props.types || indexOf.call(this.props.types, 'number') >= 0) {
      items.push({
        name: "Score",
        desc: "Assign scores to different choices of a field and find total.",
        onClick: this.handleScoreSelected
      });
    }
    aggr = null;
    if (indexOf.call(this.props.aggrStatuses, "aggregate") < 0) {
      aggr = false;
    }
    exprUtils = new ExprUtils(this.props.schema);
    opItems = exprUtils.findMatchingOpItems({
      resultTypes: this.props.types,
      prefix: true,
      aggr: aggr
    });
    ref = _.uniq(opItems, "op");
    for (i = 0, len = ref.length; i < len; i++) {
      opItem = ref[i];
      items.push({
        name: opItem.name,
        desc: opItem.desc,
        onClick: this.handleOpSelected.bind(null, opItem.op)
      });
    }
    if ((!this.props.types || indexOf.call(this.props.types, 'enumset') >= 0) && this.props.enumValues && this.props.enumValues.length > 0) {
      items.push({
        name: "Build enumset",
        desc: "Advanced: Create a multi-choice answer based on conditions",
        onClick: this.handleBuildEnumsetSelected
      });
    }
    if (this.state.searchText) {
      filter = new RegExp(_.escapeRegExp(this.state.searchText), "i");
      items = _.filter(items, function(item) {
        return item.name.match(filter) || item.desc.match(filter);
      });
    }
    return H.div(null, H.input({
      ref: "search",
      type: "text",
      placeholder: "Search Formulas...",
      className: "form-control input-lg",
      value: this.state.searchText,
      onChange: this.handleSearchTextChange
    }), H.div({
      style: {
        paddingTop: 10
      }
    }, _.map(items, (function(_this) {
      return function(item) {
        return H.div({
          key: item.name,
          style: {
            padding: 4,
            borderRadius: 4,
            cursor: "pointer",
            color: "#478"
          },
          className: "hover-grey-background",
          onClick: item.onClick
        }, item.name, item.desc ? H.span({
          className: "text-muted",
          style: {
            fontSize: 12,
            paddingLeft: 3
          }
        }, " - " + item.desc) : void 0);
      };
    })(this))));
  };

  return SelectFormulaExprComponent;

})(React.Component);

},{"./ScalarExprTreeBuilder":353,"./ScalarExprTreeComponent":354,"lodash":"lodash","mwater-expressions":14,"react":"react"}],359:[function(require,module,exports){
var DateTimePickerComponent, EnumAsListComponent, EnumComponent, EnumSetComponent, EnumsetAsListComponent, ExprUtils, H, IdLiteralComponent, R, React, SelectLiteralExprComponent, TextArrayComponent, _, moment,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

R = React.createElement;

H = React.DOM;

moment = require('moment');

ExprUtils = require('mwater-expressions').ExprUtils;

DateTimePickerComponent = require('./DateTimePickerComponent');

EnumSetComponent = require('./EnumSetComponent');

TextArrayComponent = require('./TextArrayComponent');

IdLiteralComponent = require('./IdLiteralComponent');

module.exports = SelectLiteralExprComponent = (function(superClass) {
  extend(SelectLiteralExprComponent, superClass);

  SelectLiteralExprComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    types: React.PropTypes.array,
    enumValues: React.PropTypes.array,
    idTable: React.PropTypes.string,
    refExpr: React.PropTypes.object
  };

  function SelectLiteralExprComponent(props) {
    this.handleTextChange = bind(this.handleTextChange, this);
    this.handleAccept = bind(this.handleAccept, this);
    this.handleDateTimeSelected = bind(this.handleDateTimeSelected, this);
    this.handleDateSelected = bind(this.handleDateSelected, this);
    this.handleChange = bind(this.handleChange, this);
    var ref;
    SelectLiteralExprComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      value: props.value,
      inputText: null,
      changed: false,
      inputTextError: false
    };
    if (props.value && ((ref = props.value.valueType) === 'text' || ref === 'number')) {
      this.state.inputText = "" + props.value.value;
    }
  }

  SelectLiteralExprComponent.prototype.componentDidMount = function() {
    var ref;
    return (ref = this.refs.input) != null ? ref.focus() : void 0;
  };

  SelectLiteralExprComponent.prototype.handleChange = function(value) {
    return this.setState({
      value: value,
      changed: true
    });
  };

  SelectLiteralExprComponent.prototype.handleDateSelected = function(date) {
    if (date) {
      return this.setState({
        value: {
          type: "literal",
          valueType: "date",
          value: date.format("YYYY-MM-DD")
        },
        changed: true
      });
    } else {
      return this.setState({
        value: null,
        changed: true
      });
    }
  };

  SelectLiteralExprComponent.prototype.handleDateTimeSelected = function(datetime) {
    if (datetime) {
      return this.setState({
        value: {
          type: "literal",
          valueType: "datetime",
          value: datetime.toISOString()
        },
        changed: true
      });
    } else {
      return this.setState({
        value: null,
        changed: true
      });
    }
  };

  SelectLiteralExprComponent.prototype.handleAccept = function() {
    var value;
    if (this.state.inputText != null) {
      if (this.state.inputText === "") {
        this.props.onChange(null);
        return;
      }
      if (((this.props.value && this.props.value.valueType === "number") || indexOf.call(this.props.types || ['number'], "number") >= 0) && this.state.inputText.match(/^-?\d+(\.\d+)?$/)) {
        value = parseFloat(this.state.inputText);
        return this.props.onChange({
          type: "literal",
          valueType: "number",
          value: value
        });
      } else if ((this.props.value && this.props.value.valueType === "text") || indexOf.call(this.props.types || ['text'], "text") >= 0) {
        return this.props.onChange({
          type: "literal",
          valueType: "text",
          value: this.state.inputText
        });
      } else if (indexOf.call(this.props.types || ['id'], "id") >= 0 && this.props.idTable) {
        return this.props.onChange({
          type: "literal",
          valueType: "id",
          idTable: this.props.idTable,
          value: this.state.inputText
        });
      } else {
        return this.setState({
          inputTextError: true
        });
      }
    } else {
      return this.props.onChange(this.state.value);
    }
  };

  SelectLiteralExprComponent.prototype.handleTextChange = function(ev) {
    return this.setState({
      inputText: ev.target.value,
      changed: true
    });
  };

  SelectLiteralExprComponent.prototype.renderTextBox = function() {
    return H.div({
      className: (this.state.inputTextError ? "has-error" : void 0)
    }, H.input({
      ref: "input",
      type: "text",
      className: "form-control",
      value: this.state.inputText || "",
      onChange: this.handleTextChange,
      placeholder: "Enter value..."
    }));
  };

  SelectLiteralExprComponent.prototype.renderInput = function() {
    var expr, exprType, exprUtils, idTable;
    expr = this.state.value;
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType(expr);
    if (exprType === "text[]" || _.isEqual(this.props.types, ["text[]"])) {
      return R(TextArrayComponent, {
        ref: "input",
        value: expr,
        refExpr: this.props.refExpr,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        onChange: this.handleChange
      });
    }
    if (exprType === "enum" || _.isEqual(this.props.types, ["enum"])) {
      return R(EnumAsListComponent, {
        value: expr,
        enumValues: this.props.enumValues,
        onChange: this.handleChange
      });
    }
    if (exprType === "enumset" || _.isEqual(this.props.types, ["enumset"])) {
      return R(EnumsetAsListComponent, {
        value: expr,
        enumValues: this.props.enumValues,
        onChange: this.handleChange
      });
    }
    if (exprType === "id" || _.isEqual(this.props.types, ["id"]) && this.props.idTable) {
      idTable = this.props.idTable || exprUtils.getExprIdTable(expr);
      return R(IdLiteralComponent, {
        ref: "input",
        value: expr != null ? expr.value : void 0,
        idTable: idTable,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        onChange: (function(_this) {
          return function(value) {
            return _this.handleChange(value ? {
              type: "literal",
              valueType: "id",
              idTable: idTable,
              value: value
            } : null);
          };
        })(this)
      });
    }
    if (exprType === "id[]" || _.isEqual(this.props.types, ["id[]"]) && this.props.idTable) {
      idTable = this.props.idTable || exprUtils.getExprIdTable(expr);
      return R(IdLiteralComponent, {
        ref: "input",
        value: expr != null ? expr.value : void 0,
        idTable: idTable,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        multi: true,
        onChange: (function(_this) {
          return function(value) {
            return _this.handleChange(value && value.length > 0 ? {
              type: "literal",
              valueType: "id[]",
              idTable: idTable,
              value: value
            } : null);
          };
        })(this)
      });
    }
    if ((exprType === 'text' || exprType === 'number') || !this.props.types || indexOf.call(this.props.types, "text") >= 0 || indexOf.call(this.props.types, "number") >= 0) {
      return this.renderTextBox();
    }
    if ((this.props.value && this.props.value.valueType === "date") || indexOf.call(this.props.types || [], "date") >= 0) {
      return R(DateTimePickerComponent, {
        date: this.state.value ? moment(this.state.value.value, moment.ISO_8601) : void 0,
        onChange: this.handleDateSelected
      });
    }
    if ((this.props.value && this.props.value.valueType === "datetime") || indexOf.call(this.props.types || [], "datetime") >= 0) {
      return R(DateTimePickerComponent, {
        date: this.state.value ? moment(this.state.value.value, moment.ISO_8601) : void 0,
        timepicker: true,
        onChange: this.handleDateTimeSelected
      });
    }
    return H.div({
      className: "text-warning"
    }, "Literal input not supported for this type");
  };

  SelectLiteralExprComponent.prototype.render = function() {
    return H.div(null, H.div({
      style: {
        paddingBottom: 10
      }
    }, H.button({
      type: "button",
      className: "btn btn-primary",
      onClick: this.handleAccept,
      disabled: !this.state.changed
    }, H.i({
      className: "fa fa-check"
    }), " OK"), " ", H.button({
      type: "button",
      className: "btn btn-default",
      onClick: this.props.onCancel
    }, "Cancel")), this.renderInput());
  };

  return SelectLiteralExprComponent;

})(React.Component);

EnumAsListComponent = (function(superClass) {
  extend(EnumAsListComponent, superClass);

  function EnumAsListComponent() {
    this.handleChange = bind(this.handleChange, this);
    return EnumAsListComponent.__super__.constructor.apply(this, arguments);
  }

  EnumAsListComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    enumValues: React.PropTypes.array.isRequired
  };

  EnumAsListComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  EnumAsListComponent.prototype.handleChange = function(val) {
    if (!val) {
      return this.props.onChange(null);
    } else {
      return this.props.onChange({
        type: "literal",
        valueType: "enum",
        value: val
      });
    }
  };

  EnumAsListComponent.prototype.render = function() {
    var itemStyle, ref, value;
    value = (ref = this.props.value) != null ? ref.value : void 0;
    itemStyle = {
      padding: 4,
      marginLeft: 5,
      borderRadius: 4,
      cursor: "pointer"
    };
    return H.div(null, _.map(this.props.enumValues, (function(_this) {
      return function(val) {
        return H.div({
          key: val.id,
          className: "hover-grey-background",
          style: itemStyle,
          onClick: _this.handleChange.bind(null, val.id)
        }, val.id === value ? H.i({
          className: "fa fa-fw fa-check",
          style: {
            color: "#2E6DA4"
          }
        }) : H.i({
          className: "fa fa-fw"
        }), " ", ExprUtils.localizeString(val.name, _this.context.locale));
      };
    })(this)));
  };

  return EnumAsListComponent;

})(React.Component);

EnumsetAsListComponent = (function(superClass) {
  extend(EnumsetAsListComponent, superClass);

  function EnumsetAsListComponent() {
    this.handleToggle = bind(this.handleToggle, this);
    return EnumsetAsListComponent.__super__.constructor.apply(this, arguments);
  }

  EnumsetAsListComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    enumValues: React.PropTypes.array.isRequired
  };

  EnumsetAsListComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  EnumsetAsListComponent.prototype.handleToggle = function(val) {
    var items, ref;
    items = ((ref = this.props.value) != null ? ref.value : void 0) || [];
    if (indexOf.call(items, val) >= 0) {
      items = _.without(items, val);
    } else {
      items = items.concat([val]);
    }
    if (items.length === 0) {
      return this.props.onChange(null);
    } else {
      return this.props.onChange({
        type: "literal",
        valueType: "enumset",
        value: items
      });
    }
  };

  EnumsetAsListComponent.prototype.render = function() {
    var itemStyle, items, ref;
    items = ((ref = this.props.value) != null ? ref.value : void 0) || [];
    itemStyle = {
      padding: 4,
      marginLeft: 5,
      borderRadius: 4,
      cursor: "pointer"
    };
    return H.div(null, _.map(this.props.enumValues, (function(_this) {
      return function(val) {
        var ref1;
        return H.div({
          key: val.id,
          className: "hover-grey-background",
          style: itemStyle,
          onClick: _this.handleToggle.bind(null, val.id)
        }, (ref1 = val.id, indexOf.call(items, ref1) >= 0) ? H.i({
          className: "fa fa-fw fa-check-square",
          style: {
            color: "#2E6DA4"
          }
        }) : H.i({
          className: "fa fa-fw fa-square",
          style: {
            color: "#DDDDDD"
          }
        }), " ", ExprUtils.localizeString(val.name, _this.context.locale));
      };
    })(this)));
  };

  return EnumsetAsListComponent;

})(React.Component);

EnumComponent = (function(superClass) {
  extend(EnumComponent, superClass);

  function EnumComponent() {
    this.handleChange = bind(this.handleChange, this);
    return EnumComponent.__super__.constructor.apply(this, arguments);
  }

  EnumComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    enumValues: React.PropTypes.array.isRequired
  };

  EnumComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  EnumComponent.prototype.handleChange = function(val) {
    if (!val) {
      return this.props.onChange(null);
    } else {
      return this.props.onChange({
        type: "literal",
        valueType: "enum",
        value: JSON.parse(val)
      });
    }
  };

  EnumComponent.prototype.render = function() {
    var options, value;
    value = this.props.value.value;
    options = _.map(this.props.enumValues, (function(_this) {
      return function(val) {
        return {
          value: JSON.stringify(val.id),
          label: ExprUtils.localizeString(val.name, _this.context.locale)
        };
      };
    })(this));
    return H.div({
      style: {
        width: "100%"
      }
    }, React.createElement(ReactSelect, {
      value: value,
      multi: false,
      options: options,
      onChange: this.handleChange
    }));
  };

  return EnumComponent;

})(React.Component);

},{"./DateTimePickerComponent":340,"./EnumSetComponent":341,"./IdLiteralComponent":346,"./TextArrayComponent":361,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],360:[function(require,module,exports){
var CrossComponent, H, R, React, StackedComponent, width,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

CrossComponent = require('react-library/lib/CrossComponent');

React = require('react');

H = React.DOM;

R = React.createElement;

width = 60;

module.exports = StackedComponent = (function(superClass) {
  extend(StackedComponent, superClass);

  function StackedComponent() {
    return StackedComponent.__super__.constructor.apply(this, arguments);
  }

  StackedComponent.propTypes = {
    joinLabel: React.PropTypes.node,
    items: React.PropTypes.arrayOf(React.PropTypes.shape({
      elem: React.PropTypes.node.isRequired,
      onRemove: React.PropTypes.func
    })).isRequired
  };

  StackedComponent.prototype.renderRow = function(item, i, first, last) {
    return H.div({
      style: {
        display: "flex"
      },
      className: "hover-display-parent"
    }, H.div({
      style: {
        flex: "0 0 " + width + "px",
        display: "flex"
      }
    }, R(CrossComponent, {
      n: !first ? "solid 1px #DDD" : void 0,
      e: "solid 1px #DDD",
      s: !last ? "solid 1px #DDD" : void 0,
      height: "auto"
    })), H.div({
      style: {
        flex: "1 1 auto"
      }
    }, item.elem), item.onRemove ? H.div({
      style: {
        flex: "0 0 auto",
        alignSelf: "center"
      },
      className: "hover-display-child"
    }, H.a({
      onClick: item.onRemove,
      style: {
        fontSize: "80%",
        cursor: "pointer",
        marginLeft: 5
      }
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))) : void 0);
  };

  StackedComponent.prototype.render = function() {
    var child, i, j, len, ref, rowElems;
    rowElems = [];
    ref = this.props.items;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      child = ref[i];
      if (i > 0 && this.props.joinLabel) {
        rowElems.push(H.div({
          style: {
            width: width,
            textAlign: "center"
          }
        }, this.props.joinLabel));
      }
      rowElems.push(this.renderRow(child, i, i === 0, i === this.props.items.length - 1));
    }
    return H.div({
      style: {
        display: "flex",
        flexDirection: "column"
      }
    }, rowElems);
  };

  return StackedComponent;

})(React.Component);

},{"react":"react","react-library/lib/CrossComponent":784}],361:[function(require,module,exports){
var ExprCompiler, H, React, ReactSelect, TextArrayComponent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

ReactSelect = require('react-select');

ExprCompiler = require("mwater-expressions").ExprCompiler;

module.exports = TextArrayComponent = (function(superClass) {
  extend(TextArrayComponent, superClass);

  function TextArrayComponent() {
    this.getOptions = bind(this.getOptions, this);
    this.handleChange = bind(this.handleChange, this);
    return TextArrayComponent.__super__.constructor.apply(this, arguments);
  }

  TextArrayComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    refExpr: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  TextArrayComponent.prototype.focus = function() {
    return this.refs.select.focus();
  };

  TextArrayComponent.prototype.handleChange = function(val) {
    var value;
    value = val ? val.split("\n") : [];
    return this.props.onChange({
      type: "literal",
      valueType: "text[]",
      value: value
    });
  };

  TextArrayComponent.prototype.escapeRegex = function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  TextArrayComponent.prototype.getOptions = function(input, cb) {
    var exprCompiler, query;
    exprCompiler = new ExprCompiler(this.props.schema);
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: exprCompiler.compileExpr({
            expr: this.props.refExpr,
            tableAlias: "main"
          }),
          alias: "value"
        }, {
          type: "select",
          expr: {
            type: "op",
            op: "count",
            exprs: []
          },
          alias: "number"
        }
      ],
      from: exprCompiler.compileTable(this.props.refExpr.table, "main"),
      where: {
        type: "op",
        op: "~*",
        exprs: [
          exprCompiler.compileExpr({
            expr: this.props.refExpr,
            tableAlias: "main"
          }), "^" + this.escapeRegex(input)
        ]
      },
      groupBy: [1],
      orderBy: [
        {
          ordinal: 2,
          direction: "desc"
        }, {
          ordinal: 1,
          direction: "asc"
        }
      ],
      limit: 50
    };
    this.props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err) {
          cb(err);
          return;
        }
        rows = _.filter(rows, function(r) {
          return r.value;
        });
        return cb(null, {
          options: _.map(rows, function(r) {
            return {
              value: r.value,
              label: r.value
            };
          }),
          complete: false
        });
      };
    })(this));
  };

  TextArrayComponent.prototype.render = function() {
    var value;
    value = "";
    if (this.props.value && this.props.value.value.length > 0) {
      value = this.props.value.value.join("\n");
    }
    return H.div({
      style: {
        width: "100%"
      }
    }, React.createElement(ReactSelect, {
      ref: "select",
      value: value,
      multi: true,
      delimiter: "\n",
      placeholder: "Select...",
      asyncOptions: this.getOptions,
      onChange: this.handleChange
    }));
  };

  return TextArrayComponent;

})(React.Component);

},{"mwater-expressions":14,"react":"react","react-select":818}],362:[function(require,module,exports){
exports.ExprComponent = require('./ExprComponent');

exports.FilterExprComponent = require('./FilterExprComponent');

exports.LinkComponent = require('./LinkComponent');

exports.InlineExprsEditorComponent = require('./InlineExprsEditorComponent');

exports.ContentEditableComponent = require('./ContentEditableComponent');

exports.IdLiteralComponent = require('./IdLiteralComponent');

exports.PropertyListComponent = require('./properties/PropertyListComponent');

},{"./ContentEditableComponent":339,"./ExprComponent":342,"./FilterExprComponent":345,"./IdLiteralComponent":346,"./InlineExprsEditorComponent":347,"./LinkComponent":348,"./properties/PropertyListComponent":366}],363:[function(require,module,exports){
var FormGroupComponent, H, R, React, _, classNames,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

H = React.DOM;

_ = require('lodash');

classNames = require('classnames');

module.exports = FormGroupComponent = (function(superClass) {
  extend(FormGroupComponent, superClass);

  function FormGroupComponent() {
    return FormGroupComponent.__super__.constructor.apply(this, arguments);
  }

  FormGroupComponent.prototype.render = function() {
    var classes;
    classes = {
      "form-group": true,
      "has-error": this.props.hasErrors,
      "has-warning": this.props.hasWarnings,
      "has-success": this.props.hasSuccess
    };
    return H.div({
      className: classNames(classes)
    }, H.label(null, this.props.label), this.props.children);
  };

  return FormGroupComponent;

})(React.Component);

},{"classnames":118,"lodash":"lodash","react":"react"}],364:[function(require,module,exports){
var FormGroupComponent, H, IdFieldComponent, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

H = React.DOM;

_ = require('lodash');

FormGroupComponent = require('./FormGroupComponent');

module.exports = IdFieldComponent = (function(superClass) {
  extend(IdFieldComponent, superClass);

  IdFieldComponent.propTypes = {
    value: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired
  };

  function IdFieldComponent(props) {
    this.handleChange = bind(this.handleChange, this);
    this.isValid = bind(this.isValid, this);
    IdFieldComponent.__super__.constructor.call(this, props);
  }

  IdFieldComponent.prototype.isValid = function(string) {
    return /^[a-z][a-z_0-9]*$/.test(string);
  };

  IdFieldComponent.prototype.handleChange = function(ev) {
    return this.props.onChange(ev.target.value);
  };

  IdFieldComponent.prototype.render = function() {
    return R(FormGroupComponent, {
      label: "ID",
      hasWarnings: !this.isValid(this.props.value)
    }, H.input({
      type: "text",
      className: "form-control",
      value: this.props.value || "",
      onChange: this.handleChange
    }), H.p({
      className: "help-block"
    }, "Lowercase, numbers and underscores"));
  };

  return IdFieldComponent;

})(React.Component);

},{"./FormGroupComponent":363,"lodash":"lodash","react":"react"}],365:[function(require,module,exports){
var PropertyListEditorComponent, R, React, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

uuid = require('uuid');

PropertyListEditorComponent = require('./PropertyListEditorComponent');

module.exports = function(WrappedComponent) {
  var NestedListClipboardEnhancement;
  return NestedListClipboardEnhancement = (function(superClass) {
    extend(NestedListClipboardEnhancement, superClass);

    NestedListClipboardEnhancement.childContextTypes = {
      clipboard: React.PropTypes.object
    };

    function NestedListClipboardEnhancement(props) {
      this.getChildContext = bind(this.getChildContext, this);
      this.handlePaste = bind(this.handlePaste, this);
      this.paste = bind(this.paste, this);
      this.cut = bind(this.cut, this);
      this.handlePasteInto = bind(this.handlePasteInto, this);
      this.handleCopy = bind(this.handleCopy, this);
      this.findItemById = bind(this.findItemById, this);
      this.handleCut = bind(this.handleCut, this);
      NestedListClipboardEnhancement.__super__.constructor.call(this, props);
      this.state = {
        clipboard: null
      };
    }

    NestedListClipboardEnhancement.prototype.handleCut = function(listId, itemId) {
      return this.handleCopy(listId, itemId, true);
    };

    NestedListClipboardEnhancement.prototype.findItemById = function(listId, itemId) {
      var find, found, list, value;
      value = _.cloneDeep(this.props.properties);
      list = _.find(value, {
        id: itemId
      });
      if (list) {
        return list;
      }
      found = null;
      find = function(listId, itemId, items) {
        var i, len, property;
        for (i = 0, len = items.length; i < len; i++) {
          property = items[i];
          if (property.id === listId) {
            return _.find(property.contents, {
              id: itemId
            });
          } else {
            found = find(listId, itemId, _.filter(property.contents, {
              type: "section"
            }));
            if (found) {
              return found;
            }
          }
        }
      };
      return find(listId, itemId, _.filter(value, {
        type: "section"
      }));
    };

    NestedListClipboardEnhancement.prototype.handleCopy = function(listId, itemId, cut) {
      var property;
      if (cut == null) {
        cut = false;
      }
      property = this.findItemById(listId, itemId);
      if (!cut) {
        if (this.props.propertyIdGenerator) {
          property.id = this.props.propertyIdGenerator();
        } else {
          property.id = uuid.v4().split("-")[0];
        }
      }
      return this.setState({
        clipboard: {
          listId: listId,
          itemId: itemId,
          property: property,
          cut: cut
        }
      });
    };

    NestedListClipboardEnhancement.prototype.handlePasteInto = function(listId, itemId) {
      var cutIndex, didCut, didPaste, pasteIndex, pasteInto, value;
      if (!this.state.clipboard) {
        return;
      }
      value = _.cloneDeep(this.props.properties);
      didPaste = false;
      didCut = false;
      if (this.state.clipboard.cut) {
        cutIndex = _.findIndex(value, {
          id: this.state.clipboard.itemId
        });
        if (cutIndex > -1) {
          _.pullAt(value, cutIndex);
          didCut = true;
        } else {
          didCut = this.cut(this.state.clipboard.listId, this.state.clipboard.itemId, _.filter(value, {
            type: "section"
          }));
        }
      }
      pasteIndex = _.findIndex(value, {
        id: itemId
      });
      if (pasteIndex > -1) {
        if (!value[pasteIndex].contents) {
          value[pasteIndex].contents = [];
        }
        value[pasteIndex].contents.push(this.state.clipboard.property);
        didPaste = true;
      } else {
        pasteInto = (function(_this) {
          return function(listId, itemId, items) {
            var i, len, property, results;
            results = [];
            for (i = 0, len = items.length; i < len; i++) {
              property = items[i];
              if (property.id === listId) {
                pasteIndex = _.findIndex(property.contents, {
                  id: itemId
                });
                if (!property.contents[pasteIndex].contents) {
                  property.contents[pasteIndex].contents = [];
                }
                property.contents[pasteIndex].contents.push(_this.state.clipboard.property);
                results.push(didPaste = true);
              } else {
                results.push(didPaste = pasteInto(listId, itemId, _.filter(property.contents, {
                  type: "section"
                })));
              }
            }
            return results;
          };
        })(this);
        pasteInto(listId, itemId, _.filter(value, {
          type: "section"
        }));
      }
      if (didPaste) {
        if (this.state.clipboard.cut && !didCut) {
          return;
        }
        this.setState({
          clipboard: null
        });
        return this.props.onChange(value);
      }
    };

    NestedListClipboardEnhancement.prototype.cut = function(listId, itemId, items) {
      var cutIndex, didCut, i, len, property;
      didCut = false;
      for (i = 0, len = items.length; i < len; i++) {
        property = items[i];
        if (property.id === listId) {
          cutIndex = _.findIndex(property.contents, {
            id: this.state.clipboard.itemId
          });
          _.pullAt(property.contents, cutIndex);
          didCut = true;
        } else {
          didCut = this.cut(listId, itemId, _.filter(property.contents, {
            type: "section"
          }));
        }
      }
      return didCut;
    };

    NestedListClipboardEnhancement.prototype.paste = function(listId, itemId, items) {
      var didPaste, i, len, pasteIndex, property;
      didPaste = false;
      for (i = 0, len = items.length; i < len; i++) {
        property = items[i];
        if (property.id === listId) {
          pasteIndex = _.findIndex(property.contents, {
            id: itemId
          });
          property.contents.splice(pasteIndex, 0, this.state.clipboard.property);
          didPaste = true;
        } else {
          didPaste = this.paste(listId, itemId, _.filter(property.contents, {
            type: "section"
          }));
        }
      }
      return didPaste;
    };

    NestedListClipboardEnhancement.prototype.handlePaste = function(listId, itemId) {
      var cutIndex, didCut, didPaste, pasteIndex, value;
      if (!this.state.clipboard) {
        return;
      }
      value = _.cloneDeep(this.props.properties);
      didPaste = false;
      didCut = false;
      if (this.state.clipboard.cut) {
        cutIndex = _.findIndex(value, {
          id: this.state.clipboard.itemId
        });
        if (cutIndex > -1) {
          _.pullAt(value, cutIndex);
          didCut = true;
        } else {
          didCut = this.cut(this.state.clipboard.listId, this.state.clipboard.itemId, _.filter(value, {
            type: "section"
          }));
        }
      }
      pasteIndex = _.findIndex(value, {
        id: itemId
      });
      if (pasteIndex > -1) {
        value.splice(pasteIndex, 0, this.state.clipboard.property);
        didPaste = true;
      } else {
        didPaste = this.paste(listId, itemId, _.filter(value, {
          type: "section"
        }));
      }
      if (didPaste) {
        if (this.state.clipboard.cut && !didCut) {
          return;
        }
        this.setState({
          clipboard: null
        });
        return this.props.onChange(value);
      }
    };

    NestedListClipboardEnhancement.prototype.getChildContext = function() {
      return {
        clipboard: this.state.clipboard
      };
    };

    NestedListClipboardEnhancement.prototype.render = function() {
      var newProps;
      newProps = {
        onCut: this.handleCut,
        onCopy: this.handleCopy,
        onPaste: this.handlePaste,
        onPasteInto: this.handlePasteInto
      };
      return R(WrappedComponent, _.assign({}, this.props, newProps));
    };

    return NestedListClipboardEnhancement;

  })(React.Component);
};

},{"./PropertyListEditorComponent":367,"react":"react","uuid":1007}],366:[function(require,module,exports){
var ActionCancelModalComponent, H, LocalizedStringComponent, NestedListClipboardEnhancement, PropertyComponent, PropertyListComponent, PropertyListEditorComponent, R, React, ReorderableListComponent, SectionEditorComponent, _, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

H = React.DOM;

_ = require('lodash');

uuid = require('uuid');

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

LocalizedStringComponent = require('../LocalizedStringComponent');

PropertyListEditorComponent = require('./PropertyListEditorComponent');

SectionEditorComponent = require('./SectionEditorComponent');

NestedListClipboardEnhancement = require('./NestedListClipboardEnhancement');

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

PropertyListComponent = (function(superClass) {
  extend(PropertyListComponent, superClass);

  PropertyListComponent.propTypes = {
    properties: React.PropTypes.array.isRequired,
    onChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object,
    dataSource: React.PropTypes.object,
    table: React.PropTypes.string.isRequired,
    propertyIdGenerator: React.PropTypes.func,
    features: React.PropTypes.array,
    createRoleDisplayElem: React.PropTypes.func,
    createRoleEditElem: React.PropTypes.func,
    onCut: React.PropTypes.func,
    onCopy: React.PropTypes.func,
    onPaste: React.PropTypes.func,
    onPasteInto: React.PropTypes.func,
    listId: React.PropTypes.string
  };

  PropertyListComponent.contextTypes = {
    clipboard: React.PropTypes.object
  };

  function PropertyListComponent(props) {
    this.renderProperty = bind(this.renderProperty, this);
    this.handleNewSection = bind(this.handleNewSection, this);
    this.handleNewProperty = bind(this.handleNewProperty, this);
    this.handleDelete = bind(this.handleDelete, this);
    this.handleChange = bind(this.handleChange, this);
    PropertyListComponent.__super__.constructor.call(this, props);
    this.state = {
      addingItem: null
    };
  }

  PropertyListComponent.prototype.handleChange = function(index, property) {
    var value;
    value = this.props.properties.slice();
    value[index] = property;
    return this.props.onChange(value);
  };

  PropertyListComponent.prototype.handleDelete = function(index) {
    var value;
    value = this.props.properties.slice();
    _.pullAt(value, index);
    return this.props.onChange(value);
  };

  PropertyListComponent.prototype.handleNewProperty = function() {
    var property;
    property = {
      type: "text"
    };
    if (this.props.propertyIdGenerator) {
      property["id"] = this.props.propertyIdGenerator();
    }
    return this.setState({
      addingItem: property
    });
  };

  PropertyListComponent.prototype.handleNewSection = function() {
    var section;
    section = {
      type: "section",
      contents: []
    };
    return this.setState({
      addingItem: section
    });
  };

  PropertyListComponent.prototype.renderControls = function() {
    return H.div({
      className: "btn-group pl-controls"
    }, this.renderAddingModal(), H.button({
      key: "default_add",
      type: "button",
      className: "btn btn-xs btn-default dropdown-toggle",
      "data-toggle": "dropdown"
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " ", "Add", " ", H.span({
      className: "caret"
    })), H.ul({
      className: "dropdown-menu text-left",
      role: "menu"
    }, H.li({
      key: "property"
    }, H.a({
      onClick: this.handleNewProperty
    }, "Property")), H.li({
      key: "section"
    }, H.a({
      onClick: this.handleNewSection
    }, "Section"))));
  };

  PropertyListComponent.prototype.renderAddingModal = function() {
    if (!this.state.addingItem) {
      return null;
    }
    return R(ActionCancelModalComponent, {
      size: "large",
      title: this.state.addingItem.type === "section" ? "Add a section" : "Add a property",
      actionLabel: "Save",
      onAction: (function(_this) {
        return function() {
          var value;
          if (_this.state.addingItem) {
            value = _this.props.properties.slice();
            value.push(_this.state.addingItem);
            _this.props.onChange(value);
            return _this.setState({
              addingItem: null
            });
          }
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            addingItem: null
          });
        };
      })(this)
    }, this.state.addingItem.type === "section" ? R(SectionEditorComponent, {
      property: this.state.addingItem,
      onChange: (function(_this) {
        return function(updatedProperty) {
          return _this.setState({
            addingItem: updatedProperty
          });
        };
      })(this),
      features: this.props.features
    }) : R(PropertyListEditorComponent, {
      property: this.state.addingItem,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      onChange: (function(_this) {
        return function(updatedProperty) {
          return _this.setState({
            addingItem: updatedProperty
          });
        };
      })(this),
      features: this.props.features,
      createRoleEditElem: this.props.createRoleEditElem
    }));
  };

  PropertyListComponent.prototype.renderProperty = function(item, index, connectDragSource, connectDragPreview, connectDropTarget) {
    var elem;
    elem = H.div({
      key: index
    }, R(PropertyComponent, {
      property: item,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      features: this.props.features,
      onChange: this.handleChange.bind(null, index),
      onDelete: this.handleDelete.bind(null, index),
      onCut: this.props.onCut,
      onCopy: this.props.onCopy,
      onPaste: this.props.onPaste,
      onPasteInto: this.props.onPasteInto,
      createRoleEditElem: this.props.createRoleEditElem,
      createRoleDisplayElem: this.props.createRoleDisplayElem,
      listId: this.props.listId
    }));
    return connectDragPreview(connectDropTarget(connectDragSource(elem)));
  };

  PropertyListComponent.prototype.render = function() {
    return H.div({
      className: 'pl-editor-container'
    }, R(ReorderableListComponent, {
      items: this.props.properties,
      onReorder: (function(_this) {
        return function(list) {
          return _this.props.onChange(list);
        };
      })(this),
      renderItem: this.renderProperty,
      getItemId: (function(_this) {
        return function(item) {
          return item.id;
        };
      })(this),
      element: H.div({
        className: 'pl-container'
      })
    }), this.renderControls());
  };

  return PropertyListComponent;

})(React.Component);

PropertyComponent = (function(superClass) {
  extend(PropertyComponent, superClass);

  PropertyComponent.propTypes = {
    property: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    features: React.PropTypes.array,
    createRoleDisplayElem: React.PropTypes.func,
    createRoleEditElem: React.PropTypes.func,
    onCut: React.PropTypes.func.isRequired,
    onCopy: React.PropTypes.func.isRequired,
    onPaste: React.PropTypes.func.isRequired,
    onPasteInto: React.PropTypes.func.isRequired,
    onDelete: React.PropTypes.func.isRequired,
    listId: React.PropTypes.string
  };

  PropertyComponent.iconMap = {
    text: "fa fa-font",
    number: "fa fa-calculator",
    "enum": "fa fa-check-circle-o",
    enumset: "fa fa-check-square-o",
    date: "fa fa-calendar-check-o",
    datetime: "fa fa-calendar-check-o",
    image: "fa fa-file-image-o",
    imagelist: "fa fa-file-image-o",
    section: "fa fa-folder",
    geometry: "fa fa-map-marker",
    boolean: "fa fa-toggle-on",
    id: "fa fa-arrow-right",
    join: "fa fa-link"
  };

  PropertyComponent.contextTypes = {
    clipboard: React.PropTypes.object
  };

  function PropertyComponent(props) {
    this.renderEnumValues = bind(this.renderEnumValues, this);
    this.handleEdit = bind(this.handleEdit, this);
    PropertyComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editing: false,
      editorProperty: null
    };
  }

  PropertyComponent.prototype.handleEdit = function() {
    return this.setState({
      editing: true,
      editorProperty: this.props.property
    });
  };

  PropertyComponent.prototype.renderControls = function() {
    return H.div({
      className: "pl-item-controls"
    }, H.a({
      className: "pl-item-control",
      onClick: this.handleEdit
    }, "Edit"), H.a({
      className: "pl-item-control",
      onClick: ((function(_this) {
        return function() {
          return _this.props.onCopy(_this.props.listId, _this.props.property.id);
        };
      })(this))
    }, "Copy"), H.a({
      className: "pl-item-control",
      onClick: ((function(_this) {
        return function() {
          return _this.props.onCut(_this.props.listId, _this.props.property.id);
        };
      })(this))
    }, "Cut"), this.context.clipboard ? H.a({
      className: "pl-item-control",
      onClick: ((function(_this) {
        return function() {
          return _this.props.onPaste(_this.props.listId, _this.props.property.id);
        };
      })(this))
    }, "Paste") : void 0, this.context.clipboard && this.props.property.type === "section" ? H.a({
      className: "pl-item-control",
      onClick: ((function(_this) {
        return function() {
          return _this.props.onPasteInto(_this.props.listId, _this.props.property.id);
        };
      })(this))
    }, "Paste Into") : void 0, H.a({
      className: "pl-item-control",
      onClick: ((function(_this) {
        return function() {
          return _this.props.onDelete();
        };
      })(this))
    }, "Delete"));
  };

  PropertyComponent.prototype.renderEnumValues = function(values) {
    var names;
    names = _.map(values, function(value) {
      return value.name[value._base || "en"];
    });
    return H.span(null, "" + (names.join(" / ")));
  };

  PropertyComponent.prototype.render = function() {
    var classNames, ref;
    classNames = ["pl-property"];
    if (this.props.property.deprecated) {
      classNames.push("deprecated");
    }
    return H.div({
      className: (classNames.join(" ")) + " pl-item-type-" + this.props.property.type
    }, this.state.editing ? R(ActionCancelModalComponent, {
      size: "large",
      title: this.state.editorProperty.type === "section" ? "Edit section" : "Edit property",
      actionLabel: "Save",
      onAction: (function(_this) {
        return function() {
          if (_this.state.editorProperty) {
            _this.props.onChange(_this.state.editorProperty);
          }
          return _this.setState({
            editing: false,
            editorProperty: null
          });
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            editing: false,
            editorProperty: null
          });
        };
      })(this)
    }, this.props.property.type === "section" ? R(SectionEditorComponent, {
      property: this.state.editorProperty,
      onChange: (function(_this) {
        return function(updatedProperty) {
          return _this.setState({
            editorProperty: updatedProperty
          });
        };
      })(this),
      features: this.props.features
    }) : R(PropertyListEditorComponent, {
      property: this.state.editorProperty,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      onChange: (function(_this) {
        return function(updatedProperty) {
          return _this.setState({
            editorProperty: updatedProperty
          });
        };
      })(this),
      features: this.props.features,
      createRoleEditElem: this.props.createRoleEditElem
    })) : void 0, this.renderControls(), this.props.property.deprecated ? H.div({
      className: "pl-item-deprecated-overlay"
    }, "") : void 0, H.div({
      className: "pl-item",
      onDoubleClick: this.handleEdit
    }, H.div({
      className: "pl-item-detail"
    }, H.span({
      className: "pl-item-detail-indicator"
    }, H.i({
      className: PropertyComponent.iconMap[this.props.property.type] + " fa-fw"
    })), H.div(null, H.div({
      className: "pl-item-detail-name"
    }, _.includes(this.props.features, "idField") && this.props.property.id ? H.small(null, "[" + this.props.property.id + "] ") : void 0, R(LocalizedStringComponent, {
      value: this.props.property.name
    })), this.props.property.desc ? H.div({
      className: "pl-item-detail-description"
    }, R(LocalizedStringComponent, {
      value: this.props.property.desc
    })) : void 0, this.props.property.sql ? H.div({
      className: "pl-item-detail-sql text-muted"
    }, this.props.property.sql) : void 0, ((ref = this.props.property.type) === "enum" || ref === "enumset") && this.props.property.enumValues.length > 0 ? H.div({
      className: "pl-item-detail-enum text-muted"
    }, this.renderEnumValues(this.props.property.enumValues)) : void 0, this.props.property.roles && this.props.createRoleDisplayElem ? this.props.createRoleDisplayElem(this.props.property.roles) : void 0))), this.props.property.type === "section" ? H.div({
      className: "pl-item-section"
    }, R(PropertyListComponent, {
      properties: this.props.property.contents || [],
      features: this.props.features,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      createRoleEditElem: this.props.createRoleEditElem,
      createRoleDisplayElem: this.props.createRoleDisplayElem,
      onCut: this.props.onCut,
      onCopy: this.props.onCopy,
      onPaste: this.props.onPaste,
      onPasteInto: this.props.onPasteInto,
      listId: this.props.property.id,
      onChange: (function(_this) {
        return function(list) {
          var newProperty;
          newProperty = _.cloneDeep(_this.props.property);
          newProperty.contents = list;
          return _this.props.onChange(newProperty);
        };
      })(this)
    })) : void 0);
  };

  return PropertyComponent;

})(React.Component);

module.exports = NestedListClipboardEnhancement(PropertyListComponent);

},{"../LocalizedStringComponent":350,"./NestedListClipboardEnhancement":365,"./PropertyListEditorComponent":367,"./SectionEditorComponent":368,"lodash":"lodash","react":"react","react-library/lib/ActionCancelModalComponent":781,"react-library/lib/reorderable/ReorderableListComponent":795,"uuid":1007}],367:[function(require,module,exports){
var EnumValueEditorComponent, EnumValuesEditorComponent, ExprComponent, FormGroupComponent, H, IdFieldComponent, JoinEditorComponent, LocalizedStringEditorComp, PropertyListEditorComponent, R, React, TableSelectComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

R = React.createElement;

H = React.DOM;

_ = require('lodash');

LocalizedStringEditorComp = require('../LocalizedStringEditorComp');

ExprComponent = require('../ExprComponent');

FormGroupComponent = require('./FormGroupComponent');

IdFieldComponent = require('./IdFieldComponent');

module.exports = PropertyListEditorComponent = (function(superClass) {
  extend(PropertyListEditorComponent, superClass);

  function PropertyListEditorComponent() {
    return PropertyListEditorComponent.__super__.constructor.apply(this, arguments);
  }

  PropertyListEditorComponent.propTypes = {
    property: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    features: React.PropTypes.array,
    schema: React.PropTypes.object,
    dataSource: React.PropTypes.object,
    table: React.PropTypes.string.isRequired,
    createRoleEditElem: React.PropTypes.func
  };

  PropertyListEditorComponent.defaultProps = {
    features: []
  };

  PropertyListEditorComponent.prototype.render = function() {
    var ref, ref1;
    return H.div(null, _.includes(this.props.features, "idField") ? R(IdFieldComponent, {
      value: this.props.property.id,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            id: value
          }));
        };
      })(this)
    }) : void 0, _.includes(this.props.features, "code") ? R(FormGroupComponent, {
      label: "Code"
    }, H.input({
      type: "text",
      className: "form-control",
      value: this.props.property.code,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            code: ev.target.value
          }));
        };
      })(this)
    })) : void 0, R(FormGroupComponent, {
      label: "Name"
    }, R(LocalizedStringEditorComp, {
      value: this.props.property.name,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            name: value
          }));
        };
      })(this)
    })), R(FormGroupComponent, {
      label: "Description"
    }, R(LocalizedStringEditorComp, {
      value: this.props.property.desc,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            desc: value
          }));
        };
      })(this)
    })), R(FormGroupComponent, {
      label: "Type"
    }, H.select({
      className: "form-control",
      value: this.props.property.type,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            type: ev.target.value
          }));
        };
      })(this))
    }, H.option({
      key: "",
      value: ""
    }, ""), H.option({
      key: "text",
      value: "text"
    }, "Text"), H.option({
      key: "number",
      value: "number"
    }, "Number"), H.option({
      key: "boolean",
      value: "boolean"
    }, "Boolean"), H.option({
      key: "geometry",
      value: "geometry"
    }, "Geometry"), H.option({
      key: "enum",
      value: "enum"
    }, "Enum"), H.option({
      key: "enumset",
      value: "enumset"
    }, "Enum Set"), H.option({
      key: "date",
      value: "date"
    }, "Date"), H.option({
      key: "datetime",
      value: "datetime"
    }, "Datetime"), H.option({
      key: "text[]",
      value: "text[]"
    }, "Text Array"), H.option({
      key: "image",
      value: "image"
    }, "Image"), H.option({
      key: "imagelist",
      value: "imagelist"
    }, "Imagelist"), H.option({
      key: "json",
      value: "json"
    }, "JSON"), _.includes(this.props.features, "exprType") ? H.option({
      key: "expr",
      value: "expr"
    }, "Expression") : void 0, _.includes(this.props.features, "idType") && this.props.schema ? H.option({
      key: "id",
      value: "id"
    }, "Reference") : void 0, _.includes(this.props.features, "idType") && this.props.schema ? H.option({
      key: "id[]",
      value: "id[]"
    }, "Reference List") : void 0, _.includes(this.props.features, "joinType") ? H.option({
      key: "join",
      value: "join"
    }, "Join") : void 0)), (ref = this.props.property.type) === "enum" || ref === "enumset" ? R(FormGroupComponent, {
      label: "Values"
    }, R(EnumValuesEditorComponent, {
      value: this.props.property.enumValues,
      onChange: ((function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            enumValues: value
          }));
        };
      })(this))
    })) : void 0, this.props.property.type === "expr" ? R(FormGroupComponent, {
      label: "Expression"
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      value: this.props.property.expr,
      aggrStatuses: ["individual", "aggregate", "literal"],
      onChange: (function(_this) {
        return function(expr) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            expr: expr
          }));
        };
      })(this)
    })) : void 0, this.props.property.type === "join" ? R(FormGroupComponent, {
      label: "Join"
    }, R(JoinEditorComponent, {
      value: this.props.property.join,
      onChange: ((function(_this) {
        return function(join) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            join: join
          }));
        };
      })(this))
    })) : void 0, (ref1 = this.props.property.type) === "id" || ref1 === "id[]" ? R(FormGroupComponent, {
      label: "ID Table"
    }, R(TableSelectComponent, {
      value: this.props.property.idTable,
      schema: this.props.schema,
      onChange: ((function(_this) {
        return function(table) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            idTable: table
          }));
        };
      })(this))
    })) : void 0, R(FormGroupComponent, {
      label: "Deprecated"
    }, H.input({
      type: 'checkbox',
      checked: this.props.property.deprecated,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            deprecated: ev.target.checked
          }));
        };
      })(this))
    })), _.includes(this.props.features, "uniqueCode" && this.props.property.type === "text") ? R(FormGroupComponent, {
      label: "Unique Code?"
    }, H.input({
      type: 'checkbox',
      checked: this.props.property.uniqueCode,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            uniqueCode: ev.target.checked
          }));
        };
      })(this))
    })) : void 0, _.includes(this.props.features, "sql") ? R(FormGroupComponent, {
      label: "SQL"
    }, H.input({
      type: 'text',
      className: "form-control",
      value: this.props.property.sql,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            sql: ev.target.value
          }));
        };
      })(this))
    })) : void 0, this.props.createRoleEditElem ? R(FormGroupComponent, {
      label: "Roles"
    }, this.props.createRoleEditElem(this.props.property.roles || [], (function(_this) {
      return function(roles) {
        return _this.props.onChange(_.extend({}, _this.props.property, {
          roles: roles
        }));
      };
    })(this))) : void 0);
  };

  return PropertyListEditorComponent;

})(React.Component);

JoinEditorComponent = (function(superClass) {
  extend(JoinEditorComponent, superClass);

  function JoinEditorComponent() {
    return JoinEditorComponent.__super__.constructor.apply(this, arguments);
  }

  JoinEditorComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired
  };

  JoinEditorComponent.prototype.render = function() {
    var ref, ref1, ref2, ref3;
    return H.div(null, H.div({
      className: "row"
    }, H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "Type"
    }, H.select({
      className: "form-control",
      value: (ref = this.props.value) != null ? ref.type : void 0,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            type: ev.target.value
          }));
        };
      })(this))
    }, H.option({
      key: "",
      value: ""
    }, ""), H.option({
      key: "1-n",
      value: "1-n"
    }, "One to many"), H.option({
      key: "n-1",
      value: "n-1"
    }, "Many to one"), H.option({
      key: "n-n",
      value: "n-n"
    }, "Many to many"), H.option({
      key: "1-1",
      value: "1-1"
    }, "one to one")))), H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "To Table"
    }, H.input({
      type: 'text',
      className: "form-control",
      value: (ref1 = this.props.value) != null ? ref1.toTable : void 0,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            toTable: ev.target.value
          }));
        };
      })(this))
    }))), H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "From Column"
    }, H.input({
      type: 'text',
      className: "form-control",
      value: (ref2 = this.props.value) != null ? ref2.fromColumn : void 0,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            fromColumn: ev.target.value
          }));
        };
      })(this))
    }))), H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "To Column"
    }, H.input({
      type: 'text',
      className: "form-control",
      value: (ref3 = this.props.value) != null ? ref3.toColumn : void 0,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            toColumn: ev.target.value
          }));
        };
      })(this))
    })))));
  };

  return JoinEditorComponent;

})(React.Component);

TableSelectComponent = (function(superClass) {
  extend(TableSelectComponent, superClass);

  function TableSelectComponent() {
    return TableSelectComponent.__super__.constructor.apply(this, arguments);
  }

  TableSelectComponent.propTypes = {
    value: React.PropTypes.string,
    schema: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  TableSelectComponent.prototype.render = function() {
    return H.select({
      className: "form-control",
      value: this.props.value,
      onChange: ((function(_this) {
        return function(ev) {
          return _this.props.onChange(ev.target.value);
        };
      })(this))
    }, _.map(this.props.schema.tables, (function(_this) {
      return function(table) {
        return H.option({
          key: table.id,
          value: table.id
        }, table.name[table.name._base || "en"]);
      };
    })(this)));
  };

  return TableSelectComponent;

})(React.Component);

EnumValuesEditorComponent = (function(superClass) {
  extend(EnumValuesEditorComponent, superClass);

  function EnumValuesEditorComponent() {
    this.handleRemove = bind(this.handleRemove, this);
    this.handleAdd = bind(this.handleAdd, this);
    this.handleChange = bind(this.handleChange, this);
    return EnumValuesEditorComponent.__super__.constructor.apply(this, arguments);
  }

  EnumValuesEditorComponent.propTypes = {
    value: React.PropTypes.array,
    onChange: React.PropTypes.func.isRequired
  };

  EnumValuesEditorComponent.prototype.handleChange = function(i, item) {
    var value;
    value = (this.props.value || []).slice();
    value[i] = item;
    return this.props.onChange(value);
  };

  EnumValuesEditorComponent.prototype.handleAdd = function() {
    var value;
    value = (this.props.value || []).slice();
    value.push({
      id: "",
      name: {}
    });
    return this.props.onChange(value);
  };

  EnumValuesEditorComponent.prototype.handleRemove = function(i) {
    var value;
    value = (this.props.value || []).slice();
    value.splice(i, 1);
    return this.props.onChange(value);
  };

  EnumValuesEditorComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.value || [], (function(_this) {
      return function(value, i) {
        return R(EnumValueEditorComponent, {
          key: i,
          value: value,
          onChange: _this.handleChange.bind(null, i),
          onRemove: _this.handleRemove.bind(null, i)
        });
      };
    })(this)), H.button({
      type: "button",
      className: "btn btn-link",
      onClick: this.handleAdd
    }, "+ Add Value"));
  };

  return EnumValuesEditorComponent;

})(React.Component);

EnumValueEditorComponent = (function(superClass) {
  extend(EnumValueEditorComponent, superClass);

  function EnumValueEditorComponent() {
    return EnumValueEditorComponent.__super__.constructor.apply(this, arguments);
  }

  EnumValueEditorComponent.propTypes = {
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func
  };

  EnumValueEditorComponent.prototype.render = function() {
    return H.div(null, H.div({
      className: "row"
    }, H.div({
      className: "col-md-6"
    }, R(IdFieldComponent, {
      value: this.props.value.id,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            id: value
          }));
        };
      })(this)
    })), H.div({
      className: "col-md-6"
    }, R(FormGroupComponent, {
      label: "Code"
    }, H.input({
      type: "text",
      className: "form-control",
      placeholder: "Code",
      style: {
        width: "10em"
      },
      value: this.props.value.code,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            code: ev.target.value
          }));
        };
      })(this)
    })))), H.div({
      className: "row"
    }, H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "Name"
    }, R(LocalizedStringEditorComp, {
      value: this.props.value.name,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            name: value
          }));
        };
      })(this)
    })))), H.div({
      className: "row"
    }, H.div({
      className: "col-md-12"
    }, R(FormGroupComponent, {
      label: "Description"
    }, R(LocalizedStringEditorComp, {
      value: this.props.value.desc,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.value, {
            desc: value
          }));
        };
      })(this)
    })))), this.props.onRemove ? H.div({
      key: "remove"
    }, H.button({
      className: "btn btn-link btn-xs",
      onClick: this.props.onRemove
    }, "Remove")) : void 0);
  };

  return EnumValueEditorComponent;

})(React.Component);

},{"../ExprComponent":342,"../LocalizedStringEditorComp":351,"./FormGroupComponent":363,"./IdFieldComponent":364,"lodash":"lodash","react":"react"}],368:[function(require,module,exports){
var FormGroupComponent, H, IdFieldComponent, LocalizedStringEditorComp, PropertyListEditorComponent, R, React, SectionEditorComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

R = React.createElement;

H = React.DOM;

_ = require('lodash');

LocalizedStringEditorComp = require('../LocalizedStringEditorComp');

PropertyListEditorComponent = require('./PropertyListEditorComponent');

IdFieldComponent = require('./IdFieldComponent');

module.exports = SectionEditorComponent = (function(superClass) {
  extend(SectionEditorComponent, superClass);

  function SectionEditorComponent() {
    return SectionEditorComponent.__super__.constructor.apply(this, arguments);
  }

  SectionEditorComponent.propTypes = {
    property: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    features: React.PropTypes.array
  };

  SectionEditorComponent.defaultProps = {
    features: []
  };

  SectionEditorComponent.prototype.render = function() {
    return H.div(null, _.includes(this.props.features, "idField") ? (R(IdFieldComponent, {
      value: this.props.property.id,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            id: value
          }));
        };
      })(this)
    }), R(FormGroupComponent, {
      label: "ID"
    }, H.input({
      type: "text",
      className: "form-control",
      value: this.props.property.id,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            id: ev.target.value
          }));
        };
      })(this)
    }), H.p({
      className: "help-block"
    }, "Letters lowercase, numbers and _ only. No spaces or uppercase"))) : void 0, _.includes(this.props.features, "code") ? R(FormGroupComponent, {
      label: "Code"
    }, H.input({
      type: "text",
      className: "form-control",
      value: this.props.property.code,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            code: ev.target.value
          }));
        };
      })(this)
    })) : void 0, R(FormGroupComponent, {
      label: "Name"
    }, R(LocalizedStringEditorComp, {
      value: this.props.property.name,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            name: value
          }));
        };
      })(this)
    })), R(FormGroupComponent, {
      label: "Description"
    }, R(LocalizedStringEditorComp, {
      value: this.props.property.desc,
      onChange: (function(_this) {
        return function(value) {
          return _this.props.onChange(_.extend({}, _this.props.property, {
            desc: value
          }));
        };
      })(this)
    })));
  };

  return SectionEditorComponent;

})(React.Component);

FormGroupComponent = (function(superClass) {
  extend(FormGroupComponent, superClass);

  function FormGroupComponent() {
    return FormGroupComponent.__super__.constructor.apply(this, arguments);
  }

  FormGroupComponent.prototype.render = function() {
    return H.div({
      className: "form-group"
    }, H.label(null, this.props.label), this.props.children);
  };

  return FormGroupComponent;

})(React.Component);

},{"../LocalizedStringEditorComp":351,"./IdFieldComponent":364,"./PropertyListEditorComponent":367,"lodash":"lodash","react":"react"}],369:[function(require,module,exports){
// Gets the offset of a node within another node. Text nodes are counted a n where n is the length. Entering (or passing) an element is one offset. Exiting is 0.
getNodeOffset = function(start, dest) {
  var offset = 0;

  var node = start;
  var stack = [];

  while (true) {
    if (node === dest) {
      return offset;
    }

    // Go into children
    if (node.firstChild) {
      // Going into first one doesn't count
      if (node !== start)
        offset += 1;
      stack.push(node);
      node = node.firstChild;
    }
    // If can go to next sibling
    else if (stack.length > 0 && node.nextSibling) {
      // If text, count length (plus 1)
      if (node.nodeType === 3)
        offset += node.nodeValue.length + 1;
      else
        offset += 1;

      node = node.nextSibling;
    }
    else {
      // If text, count length
      if (node.nodeType === 3)
        offset += node.nodeValue.length + 1;
      else
        offset += 1;

      // No children or siblings, move up stack
      while (true) {
        if (stack.length <= 1)
          return offset;

        var next = stack.pop();

        // Go to sibling
        if (next.nextSibling) {
          node = next.nextSibling;
          break;
        }
      }
    }
  }
}

// Calculate the total offsets of a node
calculateNodeOffset = function(node) {
  var offset = 0;

  // If text, count length
  if (node.nodeType === 3)
    offset += node.nodeValue.length + 1;
  else
    offset += 1;

  if (node.childNodes) {
    for (var i=0;i<node.childNodes.length;i++) {
      offset += calculateNodeOffset(node.childNodes[i]);
    }
  }

  return offset;
}

// Determine total offset length from returned offset from ranges
totalOffsets = function(parentNode, offset) {
  if (parentNode.nodeType == 3)
    return offset;

  if (parentNode.nodeType == 1) {
    total = 0;
    // Get child nodes
    for (var i=0;i<offset;i++) {
      total += calculateNodeOffset(parentNode.childNodes[i]);
    }
    return total;
  }

  return 0;
}

getNodeAndOffsetAt = function(start, offset) {
  var node = start;
  var stack = [];

  while (true) {
    // If arrived
    if (offset <= 0)
      return { node: node, offset: 0 };

    // If will be within current text node
    if (node.nodeType == 3 && (offset <= node.nodeValue.length))
      return { node: node, offset: Math.min(offset, node.nodeValue.length) };

    // Go into children (first one doesn't count)
    if (node.firstChild) {
      if (node !== start)
        offset -= 1;
      stack.push(node);
      node = node.firstChild;
    }
    // If can go to next sibling
    else if (stack.length > 0 && node.nextSibling) {
      // If text, count length
      if (node.nodeType === 3)
        offset -= node.nodeValue.length + 1;
      else
        offset -= 1;

      node = node.nextSibling;
    }
    else {
      // No children or siblings, move up stack
      while (true) {
        if (stack.length <= 1) {
          // No more options, use current node
          if (node.nodeType == 3)
            return { node: node, offset: Math.min(offset, node.nodeValue.length) };
          else
            return { node: node, offset: 0 };
        }

        var next = stack.pop();

        // Go to sibling
        if (next.nextSibling) {
          // If text, count length
          if (node.nodeType === 3)
            offset -= node.nodeValue.length + 1;
          else
            offset -= 1;
          
          node = next.nextSibling;
          break;
        }
      }
    }
  }
}

exports.save = function(containerEl) {
  // Get range
  var selection = window.getSelection();
  if (selection.rangeCount > 0) {
    var range = selection.getRangeAt(0);
    return { 
      start: getNodeOffset(containerEl, range.startContainer) + totalOffsets(range.startContainer, range.startOffset), 
      end: getNodeOffset(containerEl, range.endContainer) + totalOffsets(range.endContainer, range.endOffset)
    };
  }
  else
    return null;
}
 
exports.restore = function(containerEl, savedSel) {
  if (!savedSel)
    return;
  
  range = document.createRange();

  var startNodeOffset, endNodeOffset;
  startNodeOffset = getNodeAndOffsetAt(containerEl, savedSel.start);
  endNodeOffset = getNodeAndOffsetAt(containerEl, savedSel.end);

  range.setStart(startNodeOffset.node, startNodeOffset.offset);
  range.setEnd(endNodeOffset.node, endNodeOffset.offset);

  var sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
}


},{}],370:[function(require,module,exports){
var AsyncLoadComponent, H, R, React, RotationAwareImageComponent, classNames,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

classNames = require('classnames');

module.exports = RotationAwareImageComponent = (function(superClass) {
  extend(RotationAwareImageComponent, superClass);

  function RotationAwareImageComponent() {
    return RotationAwareImageComponent.__super__.constructor.apply(this, arguments);
  }

  RotationAwareImageComponent.propTypes = {
    image: React.PropTypes.object.isRequired,
    imageManager: React.PropTypes.object.isRequired,
    thumbnail: React.PropTypes.bool,
    height: React.PropTypes.number,
    onClick: React.PropTypes.func
  };

  RotationAwareImageComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return newProps.image.id !== oldProps.image.id || newProps.thumbnail !== oldProps.thumbnail;
  };

  RotationAwareImageComponent.prototype.load = function(props, prevProps, callback) {
    if (props.thumbnail) {
      return props.imageManager.getImageThumbnailUrl(props.image.id, (function(_this) {
        return function(url) {
          return callback({
            url: url,
            error: false
          });
        };
      })(this), (function(_this) {
        return function() {
          return callback({
            error: true
          });
        };
      })(this));
    } else {
      return props.imageManager.getImageUrl(props.image.id, (function(_this) {
        return function(url) {
          return callback({
            url: url,
            error: false
          });
        };
      })(this), (function(_this) {
        return function() {
          return callback({
            error: true
          });
        };
      })(this));
    }
  };

  RotationAwareImageComponent.prototype.render = function() {
    var classes, containerClasses, containerStyle, imageStyle;
    imageStyle = {};
    containerStyle = {};
    classes = classNames({
      "img-thumbnail": this.props.thumbnail,
      "rotated": this.props.image.rotation,
      "rotate-90": this.props.image.rotation && this.props.image.rotation === 90,
      "rotate-180": this.props.image.rotation && this.props.image.rotation === 180,
      "rotate-270": this.props.image.rotation && this.props.image.rotation === 270
    });
    containerClasses = classNames({
      "rotated-image-container": true
    });
    if (this.props.thumbnail) {
      if (this.props.image.rotation === 90 || this.props.image.rotation === 270) {
        imageStyle.maxHeight = this.props.width || 160;
        imageStyle.maxWidth = this.props.height || 160;
      } else {
        imageStyle.maxHeight = this.props.height || 160;
        imageStyle.maxWidth = this.props.width || 160;
      }
      containerStyle.height = this.props.height || 160;
    } else {
      imageStyle.maxWidth = "100%";
      containerStyle.height = "100%";
    }
    if (this.state.url) {
      return H.span({
        ref: (function(_this) {
          return function(c) {
            return _this.parent = c;
          };
        })(this),
        className: containerClasses,
        style: containerStyle
      }, H.img({
        ref: (function(_this) {
          return function(c) {
            return _this.image = c;
          };
        })(this),
        src: this.state.url,
        style: imageStyle,
        className: classes,
        onClick: this.props.onClick,
        alt: this.props.image.caption || ""
      }));
    } else {
      return null;
    }
  };

  return RotationAwareImageComponent;

})(AsyncLoadComponent);

},{"classnames":118,"react":"react","react-library/lib/AsyncLoadComponent":782}],371:[function(require,module,exports){
var _, localizations, uuid;

_ = require('lodash');

localizations = require('../localizations.json');

uuid = require('uuid');

exports.createUid = function() {
  return uuid().replace(/-/g, "");
};

exports.createShortUid = function() {
  var chrs, i, id, j;
  chrs = "abcdefghjklmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ123456789";
  while (true) {
    id = "";
    for (i = j = 1; j <= 7; i = ++j) {
      id = id + chrs[_.random(0, chrs.length - 1)];
    }
    if (_.find(this.model, {
      id: id
    }) == null) {
      break;
    }
  }
  return id;
};

exports.createBase32TimeCode = function(date) {
  var base, chars, code, diff, num;
  chars = "23456789ABCDEFGHJLKMNPQRSTUVWXYZ";
  base = new Date(2013, 6, 1, 0, 0, 0, 0);
  diff = Math.floor((date.getTime() - base.getTime()) / 1000);
  code = "";
  while (diff >= 1) {
    num = diff % 32;
    diff = Math.floor(diff / 32);
    code = chars[num] + code;
  }
  return code;
};

exports.isQuestion = function(item) {
  return (item._type != null) && item._type.match(/Question$/);
};

exports.localizeString = function(str, locale) {
  if (str == null) {
    return "";
  }
  if (locale && str[locale]) {
    return str[locale];
  }
  if (str._base && str[str._base]) {
    return str[str._base] || "";
  }
  if (str.en) {
    return str.en;
  }
  return "";
};

exports.priorQuestions = function(formDesign, refItem, rosterId) {
  var appendChildren, questions;
  if (refItem == null) {
    refItem = null;
  }
  if (rosterId == null) {
    rosterId = null;
  }
  questions = [];
  appendChildren = function(parentItem, currentRosterId) {
    var child, j, len, ref, ref1;
    ref = parentItem.contents;
    for (j = 0, len = ref.length; j < len; j++) {
      child = ref[j];
      if ((refItem != null) && child._id === refItem._id) {
        return true;
      }
      if (currentRosterId === rosterId && exports.isQuestion(child)) {
        questions.push(child);
      }
      if (child.contents) {
        if ((ref1 = child._type) === "RosterGroup" || ref1 === "RosterMatrix") {
          if (appendChildren(child, child.rosterId || child._id)) {
            return true;
          }
        } else {
          if (appendChildren(child, currentRosterId)) {
            return true;
          }
        }
      }
    }
    return false;
  };
  appendChildren(formDesign, null);
  return questions;
};

exports.getRosterIds = function(formDesign) {
  var recurse, rosterIds;
  rosterIds = [];
  recurse = function(item) {
    var j, len, ref, ref1, results1, subitem;
    if ((ref = item._type) === "RosterGroup" || ref === "RosterMatrix") {
      rosterIds.push(item.rosterId || item._id);
    }
    if (item.contents) {
      ref1 = item.contents;
      results1 = [];
      for (j = 0, len = ref1.length; j < len; j++) {
        subitem = ref1[j];
        results1.push(recurse(subitem));
      }
      return results1;
    }
  };
  recurse(formDesign);
  return _.uniq(rosterIds);
};

exports.findItem = function(formDesign, itemId) {
  var found, item, j, len, ref;
  ref = formDesign.contents;
  for (j = 0, len = ref.length; j < len; j++) {
    item = ref[j];
    if (item._id === itemId) {
      return item;
    }
    if (item.contents) {
      found = exports.findItem(item, itemId);
      if (found) {
        return found;
      }
    }
  }
};

exports.allItems = function(rootItem) {
  var item, items, j, len, ref;
  items = [];
  items.push(rootItem);
  if (rootItem.contents) {
    ref = rootItem.contents;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      items = items.concat(exports.allItems(item));
    }
  }
  return items;
};

exports.prepareQuestion = function(q) {
  var j, key, knownFields, len, ref;
  _.defaults(q, {
    _id: exports.createUid(),
    text: {},
    conditions: [],
    validations: [],
    required: false
  });
  switch (q._type) {
    case "TextQuestion":
      _.defaults(q, {
        format: "singleline"
      });
      break;
    case "NumberQuestion":
    case "NumberColumnQuestion":
      _.defaults(q, {
        decimal: true
      });
      break;
    case "DropdownQuestion":
    case "RadioQuestion":
    case "MulticheckQuestion":
    case "DropdownColumnQuestion":
      _.defaults(q, {
        choices: []
      });
      break;
    case "SiteColumnQuestion":
      _.defaults(q, {
        siteType: "water_point"
      });
      break;
    case "LikertQuestion":
      _.defaults(q, {
        items: [],
        choices: []
      });
      break;
    case "DateQuestion":
      _.defaults(q, {
        format: "YYYY-MM-DD"
      });
      break;
    case "UnitsQuestion":
    case "UnitsColumnQuestion":
      _.defaults(q, {
        units: [],
        defaultUnits: null,
        unitsPosition: "suffix",
        decimal: true
      });
      break;
    case "LocationQuestion":
      _.defaults(q, {
        calculateAdminRegion: true
      });
      break;
    case "CheckQuestion":
      _.defaults(q, {
        label: {}
      });
      break;
    case "EntityQuestion":
      _.defaults(q, {
        entityFilter: {},
        displayProperties: [],
        selectionMode: "external",
        selectProperties: [],
        selectText: {
          _base: "en",
          en: "Select"
        },
        propertyLinks: []
      });
      break;
    case "LikertQuestion":
      _.defaults(q, {
        items: [],
        choices: []
      });
      break;
    case "MatrixQuestion":
      _.defaults(q, {
        items: [],
        columns: []
      });
      break;
    case "AquagenxCBTQuestion":
      _.defaults(q, {});
  }
  knownFields = ['_id', '_type', 'text', 'textExprs', 'conditions', 'conditionExpr', 'validations', 'required', 'code', 'hint', 'help', 'alternates', 'commentsField', 'recordLocation', 'recordTimestamp', 'sticky', 'exportId', 'disabled'];
  switch (q._type) {
    case "TextQuestion":
    case "DateQuestion":
      knownFields.push("format");
      break;
    case "NumberQuestion":
    case "NumberColumnQuestion":
      knownFields.push("decimal");
      break;
    case "DropdownQuestion":
    case "RadioQuestion":
    case "MulticheckQuestion":
    case "DropdownColumnQuestion":
      knownFields.push("choices");
      break;
    case "LikertQuestion":
      knownFields.push("items");
      knownFields.push("choices");
      break;
    case "UnitsQuestion":
    case "UnitsColumnQuestion":
      knownFields.push("decimal");
      knownFields.push("units");
      knownFields.push("defaultUnits");
      knownFields.push("unitsPosition");
      break;
    case "CheckQuestion":
      knownFields.push("label");
      break;
    case "SiteQuestion":
      knownFields.push("siteTypes");
      break;
    case "SiteColumnQuestion":
      knownFields.push("siteType");
      break;
    case "ImageQuestion":
    case "ImagesQuestion":
      knownFields.push("consentPrompt");
      break;
    case "EntityQuestion":
      knownFields.push("entityType");
      knownFields.push("entityFilter");
      knownFields.push("displayProperties");
      knownFields.push("selectionMode");
      knownFields.push("selectProperties");
      knownFields.push("mapProperty");
      knownFields.push("selectText");
      knownFields.push("propertyLinks");
      knownFields.push("hidden");
      knownFields.push("createEntity");
      break;
    case "AdminRegionQuestion":
      knownFields.push("defaultValue");
      break;
    case "MatrixQuestion":
      knownFields.push("items");
      knownFields.push("columns");
      break;
    case "LocationQuestion":
      knownFields.push("calculateAdminRegion");
  }
  ref = _.keys(q);
  for (j = 0, len = ref.length; j < len; j++) {
    key = ref[j];
    if (!_.contains(knownFields, key)) {
      delete q[key];
    }
  }
  return q;
};

exports.changeQuestionType = function(question, newType) {
  question.validations = [];
  delete question.format;
  question._type = newType;
  exports.prepareQuestion(question);
  return question;
};

exports.getAnswerType = function(q) {
  switch (q._type) {
    case "TextQuestion":
    case "TextColumnQuestion":
      return "text";
    case "NumberQuestion":
    case "NumberColumnQuestion":
    case "StopwatchQuestion":
      return "number";
    case "DropdownQuestion":
    case "RadioQuestion":
    case "DropdownColumnQuestion":
      return "choice";
    case "MulticheckQuestion":
      return "choices";
    case "DateQuestion":
    case "DateColumnQuestion":
      return "date";
    case "UnitsQuestion":
    case "UnitsColumnQuestion":
      return "units";
    case "CheckQuestion":
    case "CheckColumnQuestion":
      return "boolean";
    case "LocationQuestion":
      return "location";
    case "ImageQuestion":
      return "image";
    case "ImagesQuestion":
      return "images";
    case "TextListQuestion":
      return "texts";
    case "SiteQuestion":
    case "SiteColumnQuestion":
      return "site";
    case "BarcodeQuestion":
      return "text";
    case "EntityQuestion":
      return "entity";
    case "AdminRegionQuestion":
      return "admin_region";
    case "MatrixQuestion":
      return "matrix";
    case "LikertQuestion":
      return "items_choices";
    case "AquagenxCBTQuestion":
      return "aquagenx_cbt";
    default:
      throw new Error("Unknown question type " + q._type);
  }
};

exports.isSectioned = function(form) {
  return form.contents.length > 0 && _.every(form.contents, function(item) {
    return item._type === "Section";
  });
};

exports.duplicateItem = function(item, idMap) {
  var dup, j, len, question, ref, ref1;
  if (!idMap) {
    idMap = {};
  }
  if ((ref = item._type) === "Form" || ref === "Section") {
    ref1 = exports.priorQuestions(item);
    for (j = 0, len = ref1.length; j < len; j++) {
      question = ref1[j];
      if (!idMap[question._id]) {
        idMap[question._id] = exports.createUid();
      }
    }
  }
  dup = _.cloneDeep(item);
  if (dup._id) {
    dup._basedOn = dup._id;
    if (idMap && idMap[dup._id]) {
      dup._id = idMap[dup._id];
    } else {
      dup._id = exports.createUid();
    }
  }
  if (dup.conditions) {
    dup.conditions = _.filter(dup.conditions, (function(_this) {
      return function(cond) {
        if (cond.lhs && cond.lhs.question) {
          if (idMap && idMap[cond.lhs.question]) {
            cond.lhs.question = idMap[cond.lhs.question];
            return true;
          }
          return false;
        }
        return true;
      };
    })(this));
  }
  if (dup.contents) {
    dup.contents = _.map(dup.contents, (function(_this) {
      return function(item) {
        return exports.duplicateItem(item, idMap);
      };
    })(this));
  }
  return dup;
};

exports.extractLocalizedStrings = function(obj) {
  var item, j, key, len, strs, value;
  if (obj == null) {
    return [];
  }
  if (obj._base != null) {
    return [obj];
  }
  strs = [];
  if (_.isArray(obj)) {
    for (j = 0, len = obj.length; j < len; j++) {
      item = obj[j];
      strs = strs.concat(this.extractLocalizedStrings(item));
    }
  } else if (_.isObject(obj)) {
    for (key in obj) {
      value = obj[key];
      strs = strs.concat(this.extractLocalizedStrings(value));
    }
  }
  return strs;
};

exports.updateLocalizations = function(formDesign) {
  var existing, j, k, len, len1, ref, ref1, results1, str;
  formDesign.localizedStrings = formDesign.localizedStrings || [];
  existing = {};
  ref = formDesign.localizedStrings;
  for (j = 0, len = ref.length; j < len; j++) {
    str = ref[j];
    if (str.en) {
      existing[str.en] = true;
    }
  }
  ref1 = localizations.strings;
  results1 = [];
  for (k = 0, len1 = ref1.length; k < len1; k++) {
    str = ref1[k];
    if (str.en && !existing[str.en] && !str._unused) {
      formDesign.localizedStrings.push(str);
      results1.push(existing[str.en] = true);
    } else {
      results1.push(void 0);
    }
  }
  return results1;
};

exports.hasLocalizations = function(obj, locale) {
  var strs;
  strs = exports.extractLocalizedStrings(obj);
  return _.any(strs, function(str) {
    return str[locale];
  });
};

exports.findEntityQuestion = function(formDesign, entityType) {
  var question;
  question = _.find(exports.priorQuestions(formDesign), function(q) {
    var questionEntityType, siteType;
    if (q._type === "EntityQuestion" && q.entityType === entityType) {
      return q;
    }
    if (q._type === "SiteQuestion") {
      if (q.siteTypes && q.siteTypes[0]) {
        siteType = q.siteTypes[0];
      } else {
        siteType = "Water point";
      }
      questionEntityType = siteType.toLowerCase().replace(new RegExp(' ', 'g'), "_");
      if (questionEntityType === entityType) {
        return q;
      }
    }
  });
  return question;
};

exports.extractEntityReferences = function(formDesign, responseData) {
  var code, entityType, j, k, l, len, len1, len2, len3, len4, m, n, question, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results, rosterEntry, rosterId, value;
  results = [];
  ref = exports.priorQuestions(formDesign);
  for (j = 0, len = ref.length; j < len; j++) {
    question = ref[j];
    switch (exports.getAnswerType(question)) {
      case "site":
        code = (ref1 = responseData[question._id]) != null ? (ref2 = ref1.value) != null ? ref2.code : void 0 : void 0;
        entityType = question.siteTypes ? _.first(question.siteTypes).toLowerCase().replace(new RegExp(' ', 'g'), "_") : "water_point";
        if (code) {
          results.push({
            question: question._id,
            entityType: entityType,
            property: "code",
            value: code
          });
        }
        break;
      case "entity":
        value = (ref3 = responseData[question._id]) != null ? ref3.value : void 0;
        if (value) {
          results.push({
            question: question._id,
            entityType: question.entityType,
            property: "_id",
            value: value
          });
        }
    }
  }
  ref4 = exports.getRosterIds(formDesign);
  for (k = 0, len1 = ref4.length; k < len1; k++) {
    rosterId = ref4[k];
    ref5 = exports.priorQuestions(formDesign, null, rosterId);
    for (l = 0, len2 = ref5.length; l < len2; l++) {
      question = ref5[l];
      switch (exports.getAnswerType(question)) {
        case "site":
          ref6 = responseData[rosterId] || [];
          for (m = 0, len3 = ref6.length; m < len3; m++) {
            rosterEntry = ref6[m];
            code = (ref7 = rosterEntry.data[question._id]) != null ? (ref8 = ref7.value) != null ? ref8.code : void 0 : void 0;
            entityType = question.siteTypes ? _.first(question.siteTypes).toLowerCase().replace(new RegExp(' ', 'g'), "_") : "water_point";
            if (code) {
              results.push({
                question: question._id,
                roster: rosterEntry._id,
                entityType: entityType,
                property: "code",
                value: code
              });
            }
          }
          break;
        case "entity":
          ref9 = responseData[rosterId] || [];
          for (n = 0, len4 = ref9.length; n < len4; n++) {
            rosterEntry = ref9[n];
            value = (ref10 = rosterEntry.data[question._id]) != null ? ref10.value : void 0;
            if (value) {
              results.push({
                question: question._id,
                roster: rosterEntry._id,
                entityType: question.entityType,
                property: "_id",
                value: value
              });
            }
          }
      }
    }
  }
  return results;
};

},{"../localizations.json":372,"lodash":"lodash","uuid":1007}],372:[function(require,module,exports){
module.exports={
  "locales": [
    {
      "code": "en",
      "name": "English"
    }
  ],
  "strings": [
    {
      "_base": "en",
      "en": "Save"
    },
    {
      "_base": "en",
      "en": "Cancel"
    },
    {
      "_base": "en",
      "en": "Select"
    },
    {
      "_base": "en",
      "en": "Images not available on this platform",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "GPS not available"
    },
    {
      "_base": "en",
      "en": "Unspecified location"
    },
    {
      "_base": "en",
      "en": "Setting location..."
    },
    {
      "_base": "en",
      "en": "Latitude"
    },
    {
      "_base": "en",
      "en": "Longitude"
    },
    {
      "_base": "en",
      "en": "Location Set Successfully"
    },
    {
      "_base": "en",
      "en": "Use Anyway"
    },
    {
      "_base": "en",
      "en": "N"
    },
    {
      "_base": "en",
      "en": "NE"
    },
    {
      "_base": "en",
      "en": "E"
    },
    {
      "_base": "en",
      "en": "SE"
    },
    {
      "_base": "en",
      "en": "S"
    },
    {
      "_base": "en",
      "en": "SW"
    },
    {
      "_base": "en",
      "en": "W"
    },
    {
      "_base": "en",
      "en": "NW"
    },
    {
      "_base": "en",
      "en": "km"
    },
    {
      "_base": "en",
      "en": "m"
    },
    {
      "_base": "en",
      "en": "Discard"
    },
    {
      "_base": "en",
      "en": "Save for Later"
    },
    {
      "_base": "en",
      "en": "Back"
    },
    {
      "_base": "en",
      "en": "Next"
    },
    {
      "_base": "en",
      "en": "No images present"
    },
    {
      "_base": "en",
      "en": "Taking photos not supported on this platform",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Select units",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Clear"
    },
    {
      "_base": "en",
      "en": "Edit"
    },
    {
      "_base": "en",
      "en": "Comments"
    },
    {
      "_base": "en",
      "en": "Waiting for GPS..."
    },
    {
      "_base": "en",
      "en": "Cannot set location"
    },
    {
      "_base": "en",
      "en": "Use location with very low accuracy (±{0}m)?"
    },
    {
      "_base": "en",
      "en": "Not Applicable"
    },
    {
      "_base": "en",
      "en": "Current Location"
    },
    {
      "_base": "en",
      "en": "Use Map"
    },
    {
      "_base": "en",
      "en": "Submit"
    },
    {
      "_base": "en",
      "en": "Very weak GPS signal (±{0}m)..."
    },
    {
      "_base": "en",
      "en": "Weak GPS signal (±{0}m)..."
    },
    {
      "_base": "en",
      "en": "Very Low GPS Signal ±{0}m"
    },
    {
      "_base": "en",
      "en": "Low GPS Signal ±{0}m"
    },
    {
      "_base": "en",
      "en": "Good GPS Signal ±{0}m"
    },
    {
      "_base": "en",
      "en": "Not supported on this platform"
    },
    {
      "_base": "en",
      "en": "Loading..."
    },
    {
      "_base": "en",
      "en": "Scan"
    },
    {
      "_base": "en",
      "en": "Barcode scanning not supported on this platform"
    },
    {
      "_base": "en",
      "en": "Change Selection"
    },
    {
      "_base": "en",
      "en": "Clear Selection"
    },
    {
      "_base": "en",
      "en": "Edit Selection"
    },
    {
      "_base": "en",
      "en": "User"
    },
    {
      "_base": "en",
      "en": "Response Id"
    },
    {
      "_base": "en",
      "en": "Date"
    },
    {
      "_base": "en",
      "en": "Don't Know"
    },
    {
      "_base": "en",
      "en": "True"
    },
    {
      "_base": "en",
      "en": "False"
    },
    {
      "_base": "en",
      "en": "Site",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Answered"
    },
    {
      "_base": "en",
      "en": "Not found"
    },
    {
      "_base": "en",
      "en": "Drafted"
    },
    {
      "_base": "en",
      "en": "Submitted"
    },
    {
      "_base": "en",
      "en": "Approved"
    },
    {
      "_base": "en",
      "en": "Edited"
    },
    {
      "_base": "en",
      "en": "by"
    },
    {
      "_base": "en",
      "en": "on"
    },
    {
      "_base": "en",
      "en": "Admin Override"
    },
    {
      "_base": "en",
      "en": "Hide History"
    },
    {
      "_base": "en",
      "en": "Show History"
    },
    {
      "_base": "en",
      "en": "Draft"
    },
    {
      "_base": "en",
      "en": "Rejected"
    },
    {
      "_base": "en",
      "en": "Pending"
    },
    {
      "_base": "en",
      "en": "Final"
    },
    {
      "_base": "en",
      "en": "Status"
    },
    {
      "_base": "en",
      "en": "Error"
    },
    {
      "_base": "en",
      "en": "Close"
    },
    {
      "_base": "en",
      "en": "Set as Cover Image"
    },
    {
      "_base": "en",
      "en": "Remove"
    },
    {
      "_base": "en",
      "en": "Set Using GPS"
    },
    {
      "_base": "en",
      "en": "Set Using Map"
    },
    {
      "_base": "en",
      "en": "Unable to lookup location"
    },
    {
      "_base": "en",
      "en": "Unable to get location"
    },
    {
      "_base": "en",
      "en": "Working...",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Unable to connect to server"
    },
    {
      "_base": "en",
      "en": "Cancel GPS"
    },
    {
      "_base": "en",
      "en": "Add"
    },
    {
      "_base": "en",
      "en": "None"
    },
    {
      "_base": "en",
      "en": "Invalid format",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Data is stored in ",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Data is stored in {0}"
    },
    {
      "_base": "en",
      "en": "Loading History..."
    },
    {
      "_base": "en",
      "en": "Select..."
    },
    {
      "_base": "en",
      "en": "mWater ID of Site"
    },
    {
      "_base": "en",
      "en": "Either site has been deleted or you do not have permission to view it"
    },
    {
      "_base": "en",
      "en": "Start"
    },
    {
      "_base": "en",
      "en": "Stop"
    },
    {
      "_base": "en",
      "en": "Reset"
    },
    {
      "_base": "en",
      "en": "Set",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Record"
    },
    {
      "_base": "en",
      "en": " Edit",
      "_unused": true
    },
    {
      "_base": "en",
      "en": " Clear",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Click on the compartments to change color"
    },
    {
      "_base": "en",
      "en": "MPN/100ml:",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Upper 95% Confidence Interval/100ml:",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Health Risk Category Based on MPN and Confidence Interval:",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Low Risk/Safe"
    },
    {
      "_base": "en",
      "en": "Intermediate Risk/Probably Safe"
    },
    {
      "_base": "en",
      "en": "Intermediate Risk/Possibly Safe"
    },
    {
      "_base": "en",
      "en": "High Risk/Possibly Unsafe"
    },
    {
      "_base": "en",
      "en": "High Risk/Probably Unsafe"
    },
    {
      "_base": "en",
      "en": "Unsafe"
    },
    {
      "_base": "en",
      "en": "MPN/100ml"
    },
    {
      "_base": "en",
      "en": "Upper 95% Confidence Interval/100ml"
    },
    {
      "_base": "en",
      "en": "Health Risk Category Based on MPN and Confidence Interval"
    },
    {
      "_base": "en",
      "en": "Error saving data"
    },
    {
      "_base": "en",
      "en": "Upload failed: {0}"
    },
    {
      "_base": "en",
      "en": "Error uploading file",
      "_unused": true
    },
    {
      "_base": "en",
      "en": "Upload cancelled"
    },
    {
      "_base": "en",
      "en": "Image must be a jpeg file"
    },
    {
      "_base": "en",
      "en": "Uploading Image..."
    },
    {
      "_base": "en",
      "en": "Upload Image"
    },
    {
      "_base": "en",
      "en": "Error uploading file. You must be connected to the Internet for image upload to work from a web browser."
    },
    {
      "_base": "en",
      "en": "Rotate"
    },
    {
      "_base": "en",
      "en": "IP Address"
    }
  ]
}
},{}],373:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],374:[function(require,module,exports){
/* globals define */

(function (root, factory) {
  'use strict'

  /* istanbul ignore next:cant test */
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = factory()
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define([], factory)
  } else {
    // Browser globals
    root.objectPath = factory()
  }
})(this, function () {
  'use strict'
  var _hasOwnProperty = Object.prototype.hasOwnProperty

  function isEmpty (value) {
    if (!value) {
      return true
    }
    if (isArray(value) && value.length === 0) {
      return true
    } else if (!isString(value)) {
      for (var i in value) {
        if (_hasOwnProperty.call(value, i)) {
          return false
        }
      }
      return true
    }
    return false
  }

  function isNumber (value) {
    return typeof value === 'number'
  }

  function isString (obj) {
    return typeof obj === 'string'
  }

  function isArray (obj) {
    return Array.isArray(obj)
  }

  function getKey (key) {
    var intKey = parseInt(key)
    if (intKey.toString() === key) {
      return intKey
    }
    return key
  }

  var objectPathImmutable = function (src) {
    var dest = src
    var committed = false

    var transaction = Object.keys(api).reduce(function (proxy, prop) {
      /* istanbul ignore else */
      if (typeof api[prop] === 'function') {
        proxy[prop] = function () {
          var args = [dest, src].concat(Array.prototype.slice.call(arguments))

          if (committed) {
            throw new Error('Cannot call ' + prop + ' after `value`')
          }

          dest = api[prop].apply(null, args)

          return transaction
        }
      }

      return proxy
    }, {})

    transaction.value = function () {
      committed = true
      return dest
    }

    return transaction
  }

  function clone (obj, createIfEmpty, assumeArray) {
    if (obj == null) {
      if (createIfEmpty) {
        if (assumeArray) {
          return []
        }

        return {}
      }

      return obj
    } else if (isArray(obj)) {
      return obj.slice()
    }

    var res = {}
    for (var key in obj) {
      if (obj.hasOwnProperty(key)) {
        res[key] = obj[key]
      }
    }

    return res
  }

  function changeImmutable (dest, src, path, changeCallback) {
    if (isNumber(path)) {
      path = [path]
    }
    if (isEmpty(path)) {
      return src
    }
    if (isString(path)) {
      return changeImmutable(dest, src, path.split('.').map(getKey), changeCallback)
    }
    var currentPath = path[0]

    if (!dest || dest === src) {
      dest = clone(src, true, isNumber(currentPath))
    }

    if (path.length === 1) {
      return changeCallback(dest, currentPath)
    }

    if (src != null) {
      src = src[currentPath]
    }

    dest[currentPath] = changeImmutable(dest[currentPath], src, path.slice(1), changeCallback)

    return dest
  }

  var api = {}
  api.set = function set (dest, src, path, value) {
    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
      clonedObj[finalPath] = value
      return clonedObj
    })
  }

  api.push = function push (dest, src, path /*, values */) {
    var values = Array.prototype.slice.call(arguments, 3)
    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
      if (!isArray(clonedObj[finalPath])) {
        clonedObj[finalPath] = values
      } else {
        clonedObj[finalPath] = clonedObj[finalPath].concat(values)
      }
      return clonedObj
    })
  }

  api.insert = function insert (dest, src, path, value, at) {
    at = ~~at
    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
      var arr = clonedObj[finalPath]
      if (!isArray(arr)) {
        if (arr != null && typeof arr !== 'undefined') {
          throw new Error('Expected ' + path + 'to be an array. Instead got ' + typeof path)
        }
        arr = []
      }

      var first = arr.slice(0, at)
      first.push(value)
      clonedObj[finalPath] = first.concat(arr.slice(at))
      return clonedObj
    })
  }

  api.del = function del (dest, src, path, value, at) {
    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
      if (Array.isArray(clonedObj)) {
        if (clonedObj[finalPath] !== undefined) {
          clonedObj.splice(finalPath, 1)
        }
      } else {
        if (clonedObj.hasOwnProperty(finalPath)) {
          delete clonedObj[finalPath]
        }
      }
      return clonedObj
    })
  }

  api.assign = function assign (dest, src, path, source) {
    return changeImmutable(dest, src, path, function (clonedObj, finalPath) {
      source = Object(source)
      var target = clone(clonedObj[finalPath], true)

      for (var key in source) {
        if (_hasOwnProperty.call(source, key)) {
          target[key] = source[key]
        }
      }

      clonedObj[finalPath] = target
      return clonedObj
    })
  }

  return Object.keys(api).reduce(function (objectPathImmutable, method) {
    objectPathImmutable[method] = api[method].bind(null, null)

    return objectPathImmutable
  }, objectPathImmutable)
})

},{}],375:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))
},{"_process":395}],376:[function(require,module,exports){
module.exports.Vec2 = require('./lib/Vec2');
module.exports.Vec3 = require('./lib/Vec3');
module.exports.Vec4 = require('./lib/Vec4');
module.exports.Mat4 = require('./lib/Mat4');
module.exports.Quat = require('./lib/Quat');
module.exports.Path = require('./lib/Path');
module.exports.Rect = require('./lib/Rect');
module.exports.Spline3D = require('./lib/Spline3D');
module.exports.Spline2D = require('./lib/Spline2D');
module.exports.Spline1D = require('./lib/Spline1D');
module.exports.Ray = require('./lib/Ray');
module.exports.Plane = require('./lib/Plane');
module.exports.Geometry = require('./lib/Geometry');
module.exports.BoundingBox = require('./lib/BoundingBox');
module.exports.Triangle2D = require('./lib/Triangle2D');
module.exports.Triangle3D = require('./lib/Triangle3D');
module.exports.Octree = require('./lib/Octree');
module.exports.Frustum = require('./lib/Frustum');
},{"./lib/BoundingBox":377,"./lib/Frustum":378,"./lib/Geometry":379,"./lib/Mat4":380,"./lib/Octree":381,"./lib/Path":382,"./lib/Plane":383,"./lib/Quat":384,"./lib/Ray":385,"./lib/Rect":386,"./lib/Spline1D":387,"./lib/Spline2D":388,"./lib/Spline3D":389,"./lib/Triangle2D":390,"./lib/Triangle3D":391,"./lib/Vec2":392,"./lib/Vec3":393,"./lib/Vec4":394}],377:[function(require,module,exports){
//A bounding box is a box with the smallest possible measure 
//(area for 2D or volume for 3D) for a given geometry or a set of points
//
//## Example use
//     var someGeometryMin = new Vec3(0, 0, 0)
//     var someGeometryMax = new Vec3(2, 2, 2);
//     var bbox = new BoundingBox(someGeometryMin, someGeometryMax);
//     console.log(bbox.getSize());
//     console.log(bbox.getCenter());
//
//## Reference
var Vec3 = require('./Vec3');

//### BoundingBox ( min, max )
//`min` - *{ [Vec3](Vec3.html) }*  
//`max` - *{ [Vec3](Vec3.html) }*  
function BoundingBox(min, max) {
  this.min = min;
  this.max = max;
}

//### fromPositionSize ( pos, size )
//`pos`  - The position of the enclosed geometry *{ [Vec3](Vec3.html) }*  
//`size` - Size of the enclosed geometry *{ [Vec3](Vec3.html) }*  
//returns *{ BoundingBox }*
BoundingBox.fromPositionSize = function(pos, size) {
  return new BoundingBox(Vec3.create(pos.x - size.x / 2,
                                     pos.y - size.y / 2,
                                     pos.z - size.z / 2),
                                     Vec3.create(pos.x + size.x / 2,
                                                 pos.y + size.y / 2,
                                                 pos.z + size.z / 2));
};

//### fromPoints ( points )
//`points` - Points in space that the bounding box will enclose *{ Array of *{ [Vec3](Vec3.html) }* }*  
//returns *{ BoundingBox }* 
BoundingBox.fromPoints = function(points) {
  var bbox = new BoundingBox(points[0].clone(), points[0].clone());
  points.forEach(bbox.addPoint.bind(bbox));
  return bbox;
};

//### isEmpty ()
//returns *{ Boolean }*
BoundingBox.prototype.isEmpty = function() {
  if (!this.min || !this.max) return true;
  else return false;
};

//### addPoint (p)
//`p` - point to be added to the enclosing space of the bounding box *{ [Vec3](Vec3.html) }*
BoundingBox.prototype.addPoint = function(p) {
  if (this.isEmpty()) {
    this.min = p.clone();
    this.max = p.clone();
  }
  if (p.x < this.min.x) this.min.x = p.x;
  if (p.y < this.min.y) this.min.y = p.y;
  if (p.z < this.min.z) this.min.z = p.z;
  if (p.x > this.max.x) this.max.x = p.x;
  if (p.y > this.max.y) this.max.y = p.y;
  if (p.z > this.max.z) this.max.z = p.z;
};

//### getSize ()
//returns the size of the bounding box as a *{ [Vec3](Vec3.html) }*
BoundingBox.prototype.getSize = function() {
  return Vec3.create(this.max.x - this.min.x,
                     this.max.y - this.min.y,
                     this.max.z - this.min.z);
};

//### getCenter ()
//returns the center of the bounding box as a *{ [Vec3](Vec3.html) }*
BoundingBox.prototype.getCenter = function() {
  return Vec3.create(this.min.x + (this.max.x - this.min.x) / 2,
                     this.min.y + (this.max.y - this.min.y) / 2,
                     this.min.z + (this.max.z - this.min.z) / 2);
};

//### contains(p)
//returns true if point is inside the bounding box
BoundingBox.prototype.contains = function(p) {
  return p.x >= this.min.x
      && p.x <= this.max.x
      && p.y >= this.min.y
      && p.y <= this.max.y
      && p.z >= this.min.z
      && p.z <= this.max.z;
}

module.exports = BoundingBox;


},{"./Vec3":393}],378:[function(require,module,exports){
//Frustum in the world space
function Frustum(clippingPlanes) {
  this.planes = clippingPlanes;
}

Frustum.prototype.containsPoint = function(p) {
  //distanceSigned
  for(var i=0; i<this.planes.length; i++) {
    if (this.planes[i].distanceSigned(p) < 0) return false;
  }
  return true;
}

module.exports = Frustum;
},{}],379:[function(require,module,exports){
//A collection of vertices, vertex attributes and faces or edges defining a 3d shape.
//(area for 2D or volume for 3D) for a given geometry or a set of points
//
//## Example use
//      var vertices = [
//        new Vec3(0, 1, 0),
//        new Vec3(0, 0, 0),
//        new Vec3(1, 1, 0)
//      ];
//      var faces = [
//        [ 0, 1, 2 ]
//      ];
//
//      var geom = new Geometry({
//        vertices: vertices,
//        faces: faces
//      });
//      geom.computeNormals();
//
//      var material = new SolidColor();
//      var mesh = new Mesh(geom, material);
//
//Geometry can't be rendered by itself. First it has to be convertet to a Vbo. The Mesh from pex-glu class does it for us automaticaly.

//## Reference

var Vec3 = require('./Vec3');
var Ray = require('./Ray');
var BoundingBox = require('./BoundingBox');

//### Geometry(o)  
//`o` - options *{ Object }*  
//Available options  
//`vertices` - *{ Array of Vec3 }* or *{ Boolean }* = false  
//`normals` - *{ Array of Vec3 }* or *{ Boolean }* = false  
//`texCoords` - *{ Array of Vec2 }* or *{ Boolean }* = false  
//`tangents` - *{ Array of Vec3 }* or *{ Boolean }* = false  
//`colors` - *{ Array of Color }* or *{ Boolean }* = false  
//`indices` - *{ Array of Int }* = []  
//`edges` - *{ Array of [Int, Int] }* = []  
//`faces` - *{ Array of [Int, Int, ...] }* = []

function Geometry(o) {
  o = o || {};
  this.attribs = {};

  if (o.vertices) this.addAttrib('vertices', 'position', o.vertices, false);
  if (o.normals) this.addAttrib('normals', 'normal', o.normals, false);
  if (o.texCoords) this.addAttrib('texCoords', 'texCoord', o.texCoords, false);
  if (o.tangents) this.addAttrib('tangents', 'tangent', o.tangents, false);
  if (o.colors) this.addAttrib('colors', 'color', o.colors, false);
  if (o.indices) this.addIndices(o.indices);
  if (o.edges) this.addEdges(o.edges);
  if (o.faces) this.addFaces(o.faces);
}

//### generateVolumePoints(numPoints)  
//`numPoints` - number of points to generate *{ Int }* = 5000  
//Generates poins inside of the geometry
Geometry.prototype.generateVolumePoints = function(numPoints) {
  numPoints = numPoints || 5000;

  var bbox = BoundingBox.fromPoints(this.vertices);
  var xMulti = -bbox.min.x + bbox.max.x;
  var yMulti = -bbox.min.y + bbox.max.y;
  var zMulti = -bbox.min.z + bbox.max.z;

  var pointsCounter = 0;
  var hits = [];
  var generatedPoints = [];

  for (var i=0; ; i++) {

    if (pointsCounter >= numPoints) break;

    var boxFace = (Math.floor(Math.random() * 6) + 1);

    var topX = bottomX = (Math.random() - 0.5) * xMulti;
    var topY = (Math.random() + 0.5) * yMulti;
    var topZ = bottomZ= (Math.random() - 0.5) * zMulti;
    var bottomY = -topY;

    var leftX =  -(Math.random() + 0.5) * xMulti;
    var leftY = rightY = (Math.random() - 0.5) * yMulti;
    var leftZ = rightZ = (Math.random() - 0.5) * zMulti;
    var rightX = -leftX;

    var backX = frontX = (Math.random() - 0.5) * xMulti;
    var backY = frontY = (Math.random() - 0.5) * yMulti;
    var backZ = -(Math.random() + 0.5) * zMulti;
    var frontZ = -backZ;

    switch (boxFace) {
      case 1:
        // left to right
        var A = new Vec3(leftX, leftY, leftZ);
      var B = new Vec3(rightX, rightY, rightZ);
      break;

      case 2:
        // right to left
        var A = new Vec3(rightX, rightY, rightZ);
      var B = new Vec3(leftX, leftY, leftZ);
      break;

      case 3:
        // top to bottom
        var A = new Vec3(topX, topY, topZ);
      var B = new Vec3(bottomX, bottomY, bottomY);
      break;

      case 4:
        // bottom to top
        var A = new Vec3(bottomX, bottomY, bottomZ);
      var B = new Vec3(topX, topY, topZ);
      break;

      case 5:
        // back to front
        var A = new Vec3(backX, backY, backZ);
      var B = new Vec3(frontX, frontY, frontZ);
      break;

      case 6:
        // front to back
        var A = new Vec3(frontX, frontY, frontZ);
      var B = new Vec3(backX, backY, backZ);
      break;

      default:
        break;
    }

    var rayOrigin = A.dup();
    var rayDirection = B.dup().sub(A).normalize();

    var triangulatedGeom = this.clone().triangulate();
    var counter = 0;
    var pointsForRay = [];

    triangulatedGeom.faces.forEach(function(face) {

      var triangle = {};
      triangle.a = triangulatedGeom.vertices[face[0]];
      triangle.b = triangulatedGeom.vertices[face[1]];
      triangle.c = triangulatedGeom.vertices[face[2]];

      var ray = new Ray(rayOrigin, rayDirection);
      var point = ray.hitTestTriangle(triangle);
      if (isNaN(point)) {
        pointsCounter++;
        counter++;
        pointsForRay.push(point);
      }

    });

    pointsForRay.forEach(function(point) {
      if (counter % 2 !== 0) return;
      hits.push(point);
   });

    if (hits.length < 2) continue;
    var pointA = hits[hits.length - 2];
    var pointB = hits[hits.length - 1];
    var direction = pointB.dup().sub(pointA);

    var randomPoint = pointA.dup().addScaled(direction, Math.random());
    generatedPoints.push(randomPoint);
  }

  return generatedPoints;

}

//### generateSurfacePoints(numPoints)  
//`numPoints` - number of points to generate *{ Int }* = 5000  
//Generates poins on the surface of the geometry
Geometry.prototype.generateSurfacePoints = function(numPoints) {
  numPoints = numPoints || 5000;

  var faceAreas = [];
  var triangles = [];

  for (var k=0, length=this.faces.length; k<length; k++) {

    var triangle = {};

    var AVertIndex = this.faces[k][0];
    var BVertIndex = this.faces[k][1];
    var CVertIndex = this.faces[k][2];

    var A = this.vertices[AVertIndex];
    var B = this.vertices[BVertIndex];
    var C = this.vertices[CVertIndex];

    var AB = B.dup().sub(A);
    var AC = C.dup().sub(A);

    var cross = AB.cross(AC);
    var area = 0.5 * Math.sqrt(cross.x * cross.x + cross.y * cross.y + cross.z * cross.z);

    triangle.A = A;
    triangle.B = B;
    triangle.C = C;
    triangles.push(triangle);

    faceAreas.push(area);

  }

  var min = Math.min.apply( Math, faceAreas );
  var ratios = faceAreas.map(function(area) {
    return Math.ceil(area / min);
  });

  var chanceIndexes = [];
  ratios.forEach(function(ratio, i) {
    for (var k=0;k<ratio;k++) {
      chanceIndexes.push(i);
    }
  });

  var generatedPoints = [];
  for (var i=0; i<numPoints; i++) {

    var randomIndex = Math.ceil(Math.random() * chanceIndexes.length) - 1;
    var triangle = triangles[chanceIndexes[randomIndex]];
    var A = triangle.A.clone();
    var B = triangle.B.clone();
    var C = triangle.C.clone();

    var u = Math.random();
    var v = Math.random();

    if ((u + v) > 1) {
      u = 1 - u;
      v = 1 - v;
    }

    var w = 1 - (u + v);

    var newA = A.dup().scale(u);
    var newB = B.dup().scale(v);
    var newC = C.dup().scale(w);

    var s = newA.add(newB).add(newC);

    generatedPoints.push(s);

  }

  return generatedPoints;
}

//### addAttribute(propertyName, attributeName, data, dynamic)  
//`propertyName` - geometry object property name *{ String }*  
//`attributeName` - shader attribute name *{ String }*  
//`data` - *{ Array of Vec2/Vec3/Vec4/Color }*  
//`dynamic` - is data static or updated every frame (dynamic) *{ Boolean }* = false  
//`instanced` - is the attribute instanced *{ Boolean }* = false  
//Adds addtribute
Geometry.prototype.addAttrib = function(propertyName, attributeName, data, dynamic, instanced) {
  if (data == undefined) {
    data = null;
  }
  if (dynamic == undefined) {
    dynamic = false;
  }
  if (instanced == undefined) {
    instanced = false;
  }
  this[propertyName] = data && data.length ? data : [];
  this[propertyName].name = attributeName;
  this[propertyName].dirty = true;
  this[propertyName].dynamic = dynamic;
  this[propertyName].instanced = instanced;
  this.attribs[propertyName] = this[propertyName];
  return this;
};

//### addFaces(data, dynamic)  
//`data` - *{ Array of [Int, Int, .. ] }*  
//`dynamic` - is data static or updated every frame (dynamic) *{ Boolean }* = false  
//Adds faces index array
Geometry.prototype.addFaces = function(data, dynamic) {
  if (data == null) {
    data = null;
  }
  if (dynamic == null) {
    dynamic = false;
  }
  this.faces = data && data.length ? data : [];
  this.faces.dirty = true;
  this.faces.dynamic = false;
  return this;
};

//### addEdges(data, dynamic)  
//`data` - *{ Array of [Int, Int] }*  
//`dynamic` - is data static or updated every frame (dynamic) *{ Boolean }* = false  
//Adds edges index array
Geometry.prototype.addEdges = function(data, dynamic) {
  if (data == null) {
    data = null;
  }
  if (dynamic == null) {
    dynamic = false;
  }
  this.edges = data && data.length ? data : [];
  this.edges.dirty = true;
  this.edges.dynamic = false;
  return this;
};

//### addIndices(data, dynamic)  
//`data` - *{ Array of Int }*  
//`dynamic` - is data static or updated every frame (dynamic) *{ Boolean }* = false  
//Adds index array
Geometry.prototype.addIndices = function(data, dynamic) {
  if (data == null) {
    data = null;
  }
  if (dynamic == null) {
    dynamic = false;
  }
  this.indices = data && data.length ? data : [];
  this.indices.dirty = true;
  this.indices.dynamic = false;
  return this;
};

Geometry.prototype.isDirty = function(attibs) {
  var dirty = false;
  dirty || (dirty = this.faces && this.faces.dirty);
  dirty || (dirty = this.edges && this.edges.dirty);
  for (attribAlias in this.attribs) {
    var attrib = this.attribs[attribAlias];
    dirty || (dirty = attrib.dirty);
  }
  return dirty;
};

//### addEdge(a, b)  
//`a` - stating edge index *{ Int }*  
//`b` - ending edge index *{ Int }*  
//Computes unique edges from existing faces.
Geometry.prototype.addEdge = function(a, b) {
  if (!this.edges) {
    this.addEdges();
  }
  if (!this.edgeHash) {
    this.edgeHash = {};
  }
  var ab = a + '_' + b;
  var ba = b + '_' + a;
  if (!this.edgeHash[ab] && !this.edgeHash[ba]) {
    this.edges.push([a, b]);
    return this.edgeHash[ab] = this.edgeHash[ba] = true;
  }
};

//### computeEdges()
//Computes unique edges from existing faces.
Geometry.prototype.computeEdges = function() {
  if (!this.edges) {
    this.addEdges();
  }
  else {
    this.edgeHash = null;
    this.edges.length = 0;
  }

  if (this.faces && this.faces.length) {
    this.faces.forEach(function(face) {
      for(var i=0; i<face.length; i++) {
        this.addEdge(face[i], face[(i+1)%face.length]);
      }
    }.bind(this));
  }
  else {
    for (var i=0; i<this.vertices.length-1; i++) {
      this.addEdge(i, i+1);
    }
  }
};

//### computeNormals()
//Computes per vertex normal by averaging the normals of faces connected with that vertex.
Geometry.prototype.computeNormals = function() {
  if (!this.faces) {
    throw 'Geometry[2]omputeSmoothNormals no faces found';
  }
  if (!this.normals) {
    this.addAttrib('normals', 'normal', null, false);
  }

  if (this.normals.length > this.vertices.length) {
    this.normals.length = this.vertices.length;
  }
  else {
    while (this.normals.length < this.vertices.length) {
      this.normals.push(new Vec3(0, 0, 0));
    }
  }

  
  var vertices = this.vertices;
  var faces = this.faces;
  var normals = this.normals;

  var count = [];
  for(var i=0; i<vertices.length; i++) {
    count[i] = 0;
  }

  var ab = new Vec3();
  var ac = new Vec3();
  var n = new Vec3();

  for(var fi=0; fi<faces.length; fi++) {
    var f = faces[fi];
    var a = vertices[f[0]];
    var b = vertices[f[1]];
    var c = vertices[f[2]];
    ab.asSub(b, a).normalize();
    ac.asSub(c, a).normalize();
    n.asCross(ab, ac);
    for(var i=0; i<f.length; i++) {
      normals[f[i]].add(n);
      count[f[i]]++;
    }
  }

  for(var i=0; i<normals.length; i++) {
    normals[i].normalize();
  }
  this.normals.dirty = true;
};

//### toFlatGeometry
//Builds a copy of this geomety with all faces separated. Useful for flat shading.
//returns new *{ Geometry }*  
Geometry.prototype.toFlatGeometry = function() {
  var g = new Geometry({ vertices: true, faces: true });

  var vertices = this.vertices;

  this.faces.forEach(function(face) {
    var newFace = [];
    face.forEach(function(vi) {
      newFace.push(g.vertices.length);
      g.vertices.push(vertices[vi]);
    });
    g.faces.push(newFace);
  });

  return g;
}

//### clone()
//Builds a copy of this geometry.  
//Currenlty only vertices, texCoords, faces and edges are copied.  
//returns new *{ Geometry }*
Geometry.prototype.clone = function() {
  var edges = null;
  var clonedAttribs = {};
  Object.keys(this.attribs).forEach(function(attribName) {
    var attrib = this.attribs[attribName];
    clonedAttribs[attribName] = attrib.map(function(v) {
      return v.dup ? v.dup() : v;
    })
  }.bind(this));
  clonedAttribs.faces = this.faces.map(function(f) { return f.slice(0); });
  clonedAttribs.edges = this.edges ? this.edges.map(function(e) { return e.slice(0); }) : null;
  return new Geometry(clonedAttribs);
}

///### merge(g)
//Returns new combined geometry. This is not a boolean operation, faces and vertices inside the mesh will be kept.
//`g` - another geometry to merge with *{ Geometry }*
Geometry.prototype.merge = function(g) {
  var edges = null;
  var mergedAttribs = {};
  Object.keys(this.attribs).forEach(function(attribName) {
    var myAttrib = this.attribs[attribName];
    var anotherAttrib = g.attribs[attribName];
    if (anotherAttrib) {
      mergedAttribs[attribName] = [];
      myAttrib.forEach(function(v) {
        mergedAttribs[attribName].push(v.dup ? v.dup() : v);
      })
      anotherAttrib.forEach(function(v) {
        mergedAttribs[attribName].push(v.dup ? v.dup() : v);
      })
    }
  }.bind(this));
  var myVerticesLength = this.vertices.length;
  if (this.faces && g.faces) {
    mergedAttribs.faces = [];
    this.faces.forEach(function(f) {
      mergedAttribs.faces.push(f.slice(0));
    });
    g.faces.forEach(function(f) {
      var newFace = f.map(function(fi) { return fi + myVerticesLength; })
      mergedAttribs.faces.push(newFace);
    })
  }
  if (this.edges && g.edges) {
    mergedAttribs.edges = [];
    this.edges.forEach(function(f) {
      mergedAttribs.edges.push(f.slice(0));
    });
    g.edges.forEach(function(e) {
      var newEdge = e.map(function(ei) { return ei + myVerticesLength; })
      mergedAttribs.edges.push(newEdge);
    })
  }
  return new Geometry(mergedAttribs);
}

//### triangulate()
//Splits all the faces into triangles. Non destructive operation.  
//returns new *{ Geometry }*
Geometry.prototype.triangulate = function() {
  var g = this.clone();
  g.faces = [];
  this.faces.forEach(function(face) {
    g.faces.push([face[0],face[1],face[2]]);
    for(var i=2; i<face.length-1; i++) {
      g.faces.push([face[0],face[i],face[i+1]]);
    }

  });
  return g;
}

//computeHalfEdges()
//Computes half edges used for efficient geometry operations.  
//returns new *{ Array of half edge objects }*  
//Based on ideas from  
//http://fgiesen.wordpress.com/2012/04/03/half-edges-redux/
Geometry.prototype.computeHalfEdges = function() {
  var halfEdges = this.halfEdges = [];
  var faces = this.faces;

  faces.forEach(function(face, faceIndex) {
    face.halfEdges = [];
    face.forEach(function(vertexIndex, i) {
      var v0 = vertexIndex;
      var v1 = face[(i + 1) % face.length];
      var halfEdge = {
        edgeIndex: halfEdges.length,
        face: face,
        faceIndex: faceIndex,
        //vertexIndex: vertexIndex,
        slot: i,
        opposite: null,
        v0: Math.min(v0, v1),
        v1: Math.max(v0, v1)
      };
      face.halfEdges.push(halfEdge);
      halfEdges.push(halfEdge);
    });
  });

  halfEdges.sort(function(a, b) {
    if (a.v0 > b.v0) return 1;
    else if (a.v0 < b.v0) return -1;
    else if (a.v1 > b.v1) return 1;
    else if (a.v1 < b.v1) return -1;
    else return 0;
  });

  for(var i=1; i<halfEdges.length; i++) {
    var prev = halfEdges[i-1];
    var curr = halfEdges[i];
    if (prev.v0 == curr.v0 && prev.v1 == curr.v1) {
      prev.opposite = curr;
      curr.opposite = prev;
    }
  }

  return halfEdges;
}

//### subdivideEdges()
//Non destructive operation edge subdivision.  
//Subdivides geometry by adding new point in the middle of each edge.  
//returns new *{ Geometry }*
Geometry.prototype.subdivideEdges = function() {
  var vertices = this.vertices;
  var faces = this.faces;

  var halfEdges = this.computeHalfEdges();

  var newVertices = vertices.map(function(v) { return v; });
  var newFaces = [];

  //edge points are an average of both edge vertices
  var edgePoints = [];
  //console.log('halfEdges', halfEdges.length, halfEdges.map(function(e) { return '' + (e.v0) + '-' + (e.v1); }));
  halfEdges.forEach(function(e) {
    if (!edgePoints[e.edgeIndex]) {
      var midPoint = centroid([
        vertices[e.face[e.slot]],
        vertices[next(e).face[next(e).slot]]
      ]);
      edgePoints[e.edgeIndex] = midPoint;
      edgePoints[e.opposite.edgeIndex] = midPoint;
      newVertices.push(midPoint);
    }
  });

  faces.forEach(function(face) {
    var newFace = [];
    edgeLoop(face.halfEdges[0], function(edge) {
      newFace.push(newVertices.indexOf(edgePoints[edge.edgeIndex]));
    });
    newFaces.push(newFace);
  });

  var visitedVertices = [];
  var verts = 0;
  halfEdges.forEach(function(e) {
    if (visitedVertices.indexOf(e.face[e.slot]) !== -1) return;
    visitedVertices.push(e.face[e.slot]);
    var neighborPoints = [];
    vertexEdgeLoop(e, function(edge) {
      neighborPoints.push(newVertices.indexOf(edgePoints[edge.edgeIndex]));
    });
    neighborPoints.forEach(function(point, i) {
      var nextPoint = neighborPoints[(i+1)%neighborPoints.length];
      newFaces.push([e.face[e.slot], point, nextPoint]);
    });
  });

  var g = new Geometry({ vertices: newVertices, faces: newFaces });
  g.computeEdges();

  return g;
}

//### getFaceVertices()
//Returns vertices for that face
//`face` - *{ Array of Int }*
//returns new *{ Array of Vec3 }*
Geometry.prototype.getFaceVertices = function(face) {
  return face.map(function(i) { return this.vertices[i]; }.bind(this));
}

//### catmullClark()
//Non destructive Catmull-Clark subdivision
//returns new *{ Geometry }*
//
//Catmull-Clark subdivision for half-edge meshes
//Based on http://en.wikipedia.org/wiki/Catmull–Clark_subdivision_surface
//TODO: Study Doo-Sabin scheme for new vertices 1/n*F + 1/n*R + (n-2)/n*v
//http://www.cse.ohio-state.edu/~tamaldey/course/784/note20.pdf
//
//The shady part at the moment is that we put all vertices together at the end and have to manually
//calculate offsets at which each vertex, face and edge point end up
Geometry.prototype.catmullClark = function() {
  var vertices = this.vertices;
  var faces = this.faces;
  var halfEdges = this.computeHalfEdges();

  //face points are an average of all face points
  var facePoints = faces.map(this.getFaceVertices.bind(this)).map(centroid);

  //edge points are an average of both edge vertices and center points of two neighbor faces
  var edgePoints = [];
  halfEdges.forEach(function(e) {
    if (!edgePoints[e.edgeIndex]) {
      var midPoint = centroid([
        vertices[e.v0],
        vertices[e.v1],
        facePoints[e.faceIndex],
        facePoints[e.opposite.faceIndex]
      ]);
      edgePoints[e.edgeIndex] = midPoint;
      edgePoints[e.opposite.edgeIndex] = midPoint;
    }
  });

  //vertex points are and average of neighbor edges' edge points and neighbor faces' face points
  var vertexPoints = [];
  halfEdges.map(function(edge) {
    var vertexIndex = faces[edge.faceIndex][edge.slot];
    var vertex = vertices[vertexIndex];
    if (vertexPoints[vertexIndex]) return;
    var neighborFacePoints = [];
    //vertexEdgeLoop(edge).map(function(edge) { return facePoints[edge.faceIndex] } )
    //vertexEdgeLoop(edge).map(function(edge) { return edge.face.facePoint } )
    //extract(facePoints, vertexEdgeLoop(edge).map(prop('faceIndex'))
    var neighborEdgeMidPoints = [];
    vertexEdgeLoop(edge, function(edge) {
      neighborFacePoints.push(facePoints[edge.faceIndex]);
      neighborEdgeMidPoints.push(centroid([vertices[edge.v0], vertices[edge.v1]]));
    });
    var facesCentroid = centroid(neighborFacePoints);
    var edgesCentroid = centroid(neighborEdgeMidPoints);

    var n = neighborFacePoints.length;
    var v = new Vec3(0, 0, 0);
    v.add(facesCentroid);
    v.add(edgesCentroid.dup().scale(2));
    v.add(vertex.dup().scale(n - 3));
    v.scale(1/n);

    vertexPoints[vertexIndex] = v;
  });

  //create list of points for the new mesh
  //vertx poitns and face points are unique
  var newVertices = vertexPoints.concat(facePoints);

  //halfEdge mid points are not (each one is doubled)
  halfEdges.forEach(function(e) {
    if (e.added > -1) return;
    e.added = newVertices.length;
    e.opposite.added = newVertices.length;
    newVertices.push(edgePoints[e.edgeIndex]);
  })

  var newFaces = [];
  var newEdges = [];

  //construct new faces from face point, two edges mid points and a vertex between them
  faces.forEach(function(face, faceIndex) {
    var facePointIndex = faceIndex + vertexPoints.length;
    edgeLoop(face.halfEdges[0], function(edge) {
      var edgeMidPointsIndex = edge.added;
      var nextEdge = next(edge);
      var nextEdgeVertexIndex = face[nextEdge.slot];
      var nextEdgeMidPointIndex = nextEdge.added;
      newEdges.push([facePointIndex, edgeMidPointsIndex]);
      newEdges.push([edgeMidPointsIndex, nextEdgeVertexIndex]);
      newFaces.push([facePointIndex, edgeMidPointsIndex, nextEdgeVertexIndex, nextEdgeMidPointIndex])
    });
  });

  return new Geometry({ vertices: newVertices, faces: newFaces, edges: newEdges });
}

//### catmullClark()
//Non destructive Doo-Sabin subdivision  
//`depth` - edge inset depth *{ Number }*  
//returns new *{ Geometry }*  
//Doo-Sabin subdivision as desribed in WIRE AND COLUMN MODELING
//http://repository.tamu.edu/bitstream/handle/1969.1/548/etd-tamu-2004A-VIZA-mandal-1.pdf  
Geometry.prototype.dooSabin = function(depth) {
  var vertices = this.vertices;
  var faces = this.faces;
  var halfEdges = this.computeHalfEdges();

  var newVertices = [];
  var newFaces = [];
  var newEdges = [];

  depth = depth || 0.1;

  var facePointsByFace = [];

  var self = this;

  faces.forEach(function(face, faceIndex) {
    var facePoints = facePointsByFace[faceIndex] = [];
    edgeLoop(face.halfEdges[0], function(edge) {
      var v = vertices[edge.face[edge.slot]];
      var p = centroid([
        v,
        centroid(elements(vertices, edge.face)),
        centroid(elements(vertices, [edge.v0, edge.v1])),
        centroid(elements(vertices, [prev(edge).v0, prev(edge).v1]))
      ]);
      facePoints.push(newVertices.length);
      newVertices.push(move(v, p, depth));
      //newVertices.push(p);
    });
    return facePoints;
  });

  //face face
  faces.forEach(function(face, faceIndex) {
    newFaces.push(facePointsByFace[faceIndex]);
  });

  halfEdges.forEach(function(edge, edgeIndex) {
    if (edge.edgeVisited) return;

    edge.edgeVisited = true;
    edge.opposite.edgeVisited = true;

    //edge face
    var e0 = edge;
    var e1 = next(e0.opposite);
    var e2 = e0.opposite;
    var e3 = next(e0);
    var newFace = [
      facePointsByFace[e0.faceIndex][e0.slot],
      facePointsByFace[e1.faceIndex][e1.slot],
      facePointsByFace[e2.faceIndex][e2.slot],
      facePointsByFace[e3.faceIndex][e3.slot]
    ];
    newFaces.push(newFace);
    newEdges.push([newFace[0], newFace[3]]);
    newEdges.push([newFace[1], newFace[2]]);
  });

  halfEdges.forEach(function(edge, edgeIndex) {
    if (edge.vertexVisited) return;

    //vertex face
    var vertexFace = [];
    vertexEdgeLoop(edge, function(e) {
      e.vertexVisited = true;
      vertexFace.push(facePointsByFace[e.faceIndex][e.slot])
    });
    newFaces.push(vertexFace)
    vertexFace.forEach(function(i, index) {
      newEdges.push([i, vertexFace[(index+1)%vertexFace.length]]);
    });
  });

  return new Geometry({ vertices: newVertices, faces: newFaces, edges: newEdges });
}

//### catmullClark(edgeDepth, insetDepth)
//Non destructive wire modelling.
//`edgeDepth` - how thick should be the edge *{ Number }*
//`insetDepth` - how deeply inside should be the edge *{ Number }*
//returns new *{ Geometry }*
//Mesh wire modelling as described in where each edge is replaced by a column
//http://repository.tamu.edu/bitstream/handle/1969.1/548/etd-tamu-2004A-VIZA-mandal-1.pdf  
Geometry.prototype.wire = function(edgeDepth, insetDepth) {
  insetDepth = (insetDepth != null) ? insetDepth : (edgeDepth || 0.1);
  edgeDepth = edgeDepth || 0.1;
  var newGeom = this.dooSabin(edgeDepth);
  newGeom.computeNormals();
  var halfEdges = newGeom.computeHalfEdges();
  var innerGeom = this.dooSabin(edgeDepth);
  innerGeom.computeNormals();

  //shrink the inner geometry
  innerGeom.vertices.forEach(function(v, vi) {
    v.sub(innerGeom.normals[vi].dup().scale(insetDepth));
  });

  //remove middle faces
  var cutFaces = newGeom.faces.splice(0, this.faces.length);
  innerGeom.faces.splice(0, this.faces.length);

  var vertexOffset = newGeom.vertices.length;

  //add inner vertices to new geom
  innerGeom.vertices.forEach(function(v, vi) {
    newGeom.vertices.push(v);
  });

  //add inner faces to new geom
  innerGeom.faces.forEach(function(f) {
    newGeom.faces.push(f.map(function(vi) {
      return vi + vertexOffset;
    }).reverse());
  });

  //add inner edges to new geom
  innerGeom.edges.forEach(function(e) {
    newGeom.edges.push(e.map(function(vi) {
      return vi + vertexOffset;
    }));
  });

  cutFaces.forEach(function(face) {
    edgeLoop(face.halfEdges[0], function(e) {
      var pe = prev(e);
      newGeom.faces.push([
        pe.face[pe.slot],
        e.face[e.slot],
        e.face[e.slot] + vertexOffset,
        pe.face[pe.slot] + vertexOffset
      ]);

      newGeom.edges.push([
        pe.face[pe.slot],
        pe.face[pe.slot] + vertexOffset
      ]);

      newGeom.edges.push([
        e.face[e.slot],
        e.face[e.slot] + vertexOffset
      ]);
    });
  });

  return newGeom;
}

//### extrude(height, faceIndices, shrink)
//Non destructive face extrusion.
//, faceIndices, shrink
//`height` - how much to extrude along the normal *{ Number }*  
//`faceIndices` - indices of faces to extrude *{ Array of Int }*  
//`shrink` - how much to shring new extruded face, 0 - at all, 1 - will create point *{ Number }*  
//returns new *{ Geometry }*
Geometry.prototype.extrude = function(height, faceIndices, shrink) {
  height = height || 0.1;
  shrink = shrink || 0;
  if (!faceIndices) faceIndices = this.faces.map(function(face, faceIndex) { return faceIndex; });
  var g = this.clone();
  var halfEdges = g.computeHalfEdges();

  var ab = new Vec3();
  var ac = new Vec3();
  var faceNormal = new Vec3();
  var tmp = new Vec3();

  faceIndices.forEach(function(faceIndex) {
    var face = g.faces[faceIndex];
    var faceVerts = elements(g.vertices, face);
    var faceTexCoords = g.texCoords ? elements(g.texCoords, face) : null;

    var a = faceVerts[0];
    var b = faceVerts[1];
    var c = faceVerts[2];
    ab.asSub(b, a).normalize();
    ac.asSub(c, a).normalize();
    faceNormal.asCross(ab, ac).normalize();
    faceNormal.scale(height);

    var newVerts = faceVerts.map(function(v) {
      return v.dup().add(faceNormal);
    });

    var newVertsIndices = [];

    newVerts.forEach(function(nv) {
      newVertsIndices.push(g.vertices.length);
      g.vertices.push(nv);
    });

    if (faceTexCoords) {
      var newTexCoords = faceTexCoords.map(function(tc) {
        return tc.dup();
      });

      newTexCoords.forEach(function(tc) {
        g.texCoords.push(tc);
      });
    }

    if (shrink) {
      var c = centroid(newVerts);
      newVerts.forEach(function(nv) {
        tmp.asSub(c, nv);
        tmp.scale(shrink);
        nv.add(tmp);
      })
    }

    //add new face for each extruded edge
    edgeLoop(face.halfEdges[0], function(e) {
      g.faces.push([
        face[e.slot],
        face[next(e).slot],
        newVertsIndices[next(e).slot],
        newVertsIndices[e.slot]
      ]);
    });

    //add edges
    if (g.edges) {
      newVertsIndices.forEach(function(i, index) {
        g.edges.push([i, face[index]]);
      });
      newVertsIndices.forEach(function(i, index) {
        g.edges.push([i, newVertsIndices[(index+1)%newVertsIndices.length]]);
      });
    }

    //push the old face outside
    newVertsIndices.forEach(function(nvi, i) {
      face[i] = nvi;
    });
  });

  return g;
}

///### transform(m)
//Returns new geometry with all vertices transform with the given matrix
//`m` - transformation matrix *{ Mat4 }*
Geometry.prototype.transform = function(m) {
  var g = this.clone();
  for(var i=0; i<g.vertices.length; i++) {
    g.vertices[i].transformMat4(m);
  }
  if (g.normals) {
    g.computeNormals();
  }
  return g;
}

//## Private utility functions

//where does this should go? geom.Utils expanded to geom?
function centroid(points) {
  var n = points.length;
  var center = points.reduce(function(center, p) {
    return center.add(p);
  }, new Vec3(0, 0, 0));
  center.scale(1 / points.length);
  return center;
}

function edgeLoop(edge, cb) {
  var curr = edge;

  var i = 0;
  do {
    cb(curr, i++);
    curr = next(curr);
  }
  while(curr != edge);
}

function vertexEdgeLoop(edge, cb) {
  var curr = edge;

  do {
    cb(curr);
    curr = prev(curr).opposite;
  }
  while(curr != edge);
}

function next(edge) {
  return edge.face.halfEdges[(edge.slot + 1) % edge.face.length]
}

function prev(edge) {
  return edge.face.halfEdges[(edge.slot - 1 + edge.face.length) % edge.face.length]
}

function elements(list, indices) {
  return indices.map(function(i) { return list[i]; })
}

function move(a, b, t) {
  return b.dup().sub(a).normalize().scale(t).add(a);
}

module.exports = Geometry;

},{"./BoundingBox":377,"./Ray":385,"./Vec3":393}],380:[function(require,module,exports){
//A 4 by 4 Matrix
//## Example use
//     var mat4 = new Mat4()
//     console.log(mat4)
//     // returns the matrix [1, 0, 0, 0,
//     //                     0, 1, 0, 0,
//     //                     0, 0, 1, 0,
//     //                     0, 0, 0, 1]
//
//## Reference
var Vec3 = require('./Vec3');

//### Mat4 ()
function Mat4(a11, a12, a13, a14,
              a21, a22, a23, a24,
              a31, a32, a33, a34,
              a41, a42, a43, a44) {
  this.a11 = a11;
  this.a12 = a12;
  this.a13 = a13;
  this.a14 = a14;
  this.a21 = a21;
  this.a22 = a22;
  this.a23 = a23;
  this.a24 = a24;
  this.a31 = a31;
  this.a32 = a32;
  this.a33 = a33;
  this.a34 = a34;
  this.a41 = a41;
  this.a42 = a42;
  this.a43 = a43;
  this.a44 = a44;

  if (typeof(this.a11) == 'undefined') {
    this.reset();
  }
}

//### create ()
//returns new *{ Mat4 }*
Mat4.create = function() {
  return new Mat4();
};

//### equals (m, tolerance)
//`m` - matrix for equals check *{ Mat4 }*  
//`tolerance` - the tolerance of comparance *{ Number }* = 0.0000001  
//returns *{ Boolean }*
Mat4.prototype.equals = function(m, tolerance) {
  if (tolerance == null) {
    tolerance = 0.0000001;
  }
  return (Math.abs(m.a11 - this.a11) <= tolerance)
  && (Math.abs(m.a12 - this.a12) <= tolerance)
  && (Math.abs(m.a13 - this.a13) <= tolerance)
  && (Math.abs(m.a14 - this.a14) <= tolerance)
  && (Math.abs(m.a21 - this.a21) <= tolerance)
  && (Math.abs(m.a22 - this.a22) <= tolerance)
  && (Math.abs(m.a23 - this.a23) <= tolerance)
  && (Math.abs(m.a24 - this.a24) <= tolerance)
  && (Math.abs(m.a31 - this.a31) <= tolerance)
  && (Math.abs(m.a32 - this.a32) <= tolerance)
  && (Math.abs(m.a33 - this.a33) <= tolerance)
  && (Math.abs(m.a34 - this.a34) <= tolerance)
  && (Math.abs(m.a41 - this.a41) <= tolerance)
  && (Math.abs(m.a42 - this.a42) <= tolerance)
  && (Math.abs(m.a43 - this.a43) <= tolerance)
  && (Math.abs(m.a44 - this.a44) <= tolerance);
};

//### hash ()
//returns the hash of the matrix as *{ Number }*
Mat4.prototype.hash = function() {
  return this.a11 * 0.01 + this.a12 * 0.02
  + this.a13 * 0.03 + this.a14 * 0.04
  + this.a21 * 0.05 + this.a22 * 0.06
  + this.a23 * 0.07 + this.a24 * 0.08
  + this.a31 * 0.09 + this.a32 * 0.10
  + this.a33 * 0.11 + this.a34 * 0.12
  + this.a41 * 0.13 + this.a42 * 0.14
  + this.a43 * 0.15 + this.a44 * 0.16;
};

//### set4x4r ( a11 .. a44 )
//`a11` .. `a44` - all elements of the matrix *{ Number }*  
//returns the matrix *{ Mat4 }*
Mat4.prototype.set4x4r = function(a11, a12, a13, a14,
                                  a21, a22, a23, a24,
                                  a31, a32, a33, a34,
                                  a41, a42, a43, a44) {
  this.a11 = a11;
  this.a12 = a12;
  this.a13 = a13;
  this.a14 = a14;
  this.a21 = a21;
  this.a22 = a22;
  this.a23 = a23;
  this.a24 = a24;
  this.a31 = a31;
  this.a32 = a32;
  this.a33 = a33;
  this.a34 = a34;
  this.a41 = a41;
  this.a42 = a42;
  this.a43 = a43;
  this.a44 = a44;
  return this;
};

//### copy ( m )
//`m` - the matrix to be copied onto this one *{ Mat4}*  
//returns the matrix *{ Mat4 }*
Mat4.prototype.copy = function(m) {
  this.a11 = m.a11;
  this.a12 = m.a12;
  this.a13 = m.a13;
  this.a14 = m.a14;
  this.a21 = m.a21;
  this.a22 = m.a22;
  this.a23 = m.a23;
  this.a24 = m.a24;
  this.a31 = m.a31;
  this.a32 = m.a32;
  this.a33 = m.a33;
  this.a34 = m.a34;
  this.a41 = m.a41;
  this.a42 = m.a42;
  this.a43 = m.a43;
  this.a44 = m.a44;
  return this;
};

//### dup ()
//returns a new copy of this matrix *{ Mat4 }*
Mat4.prototype.dup = function() {
  return Mat4.create().copy(this);
};

//### reset ()
//returns the matrix with reset values *{ Mat4 }*
Mat4.prototype.reset = function() {
  this.set4x4r(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
  return this;
};

//### identity ()
//returns the matrix with reset values *{ Mat4 }*
Mat4.prototype.identity = function() {
  this.reset();
  return this;
};

//### mul4x4r ( b11 .. b44 )
//`b11` .. `b44` - multipliers *{ Number }*  
//returns the matrix with the new values after the multiplication *{ Mat4 }*
Mat4.prototype.mul4x4r = function(b11, b12, b13, b14,
                                  b21, b22, b23, b24,
                                  b31, b32, b33, b34,
                                  b41, b42, b43, b44) {
  var a11 = this.a11;
  var a12 = this.a12;
  var a13 = this.a13;
  var a14 = this.a14;
  var a21 = this.a21;
  var a22 = this.a22;
  var a23 = this.a23;
  var a24 = this.a24;
  var a31 = this.a31;
  var a32 = this.a32;
  var a33 = this.a33;
  var a34 = this.a34;
  var a41 = this.a41;
  var a42 = this.a42;
  var a43 = this.a43;
  var a44 = this.a44;
  this.a11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  this.a12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  this.a13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  this.a14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
  this.a21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  this.a22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  this.a23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  this.a24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
  this.a31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  this.a32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  this.a33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  this.a34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
  this.a41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  this.a42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  this.a43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  this.a44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
  return this;
};

//### frustum(l, r, b, t, n, f)
//`l` - left edge of the frustum volume *{ Number}*  
//`r` - right edge of the frustum volume *{ Number}*  
//`b` - bottom edge of the frustum volume *{ Number}*  
//`t` - top edge of the frustum volume *{ Number}*  
//`n` - near clipping plane distance *{ Number }*  
//`f` - far clipping plane distance *{ Number }*  
//returns the matrix *{ Mat4 }*  
//![](http://www.felixgers.de/teaching/jogl/frustrum.gif)
//[Source:](http://www.felixgers.de/teaching/jogl/perspectiveProjection.html)  
Mat4.prototype.frustum = function(l, r, b, t, n, f) {
  this.mul4x4r(
      (n+n)/(r-l),           0, (r+l)/(r-l),             0,
                0, (n+n)/(t-b), (t+b)/(t-b),             0,
                0,           0, (f+n)/(n-f), (2*f*n)/(n-f),
                0,           0,          -1,             0);

  return this;
};

//### perspective ( fovy, aspect, znear, zfar )
//`fovy` - field of view *{ Number }*  
//`aspect` - aspect ratio *{ Number }*  
//`znear` - near clipping plane distance *{ Number }*  
//`zfar` - far clipping plane distance *{ Number }*  
//returns the matrix *{ Mat4 }*  
Mat4.prototype.perspective = function(fovy, aspect, znear, zfar) {
  var f = 1.0 / Math.tan(fovy / 180 * Math.PI / 2);
  var nf = 1.0 / (zfar - znear);
  this.mul4x4r(f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0,
               -(zfar + znear) * nf,
               -2 * zfar * znear * nf, 0, 0, -1, 0);
  return this;
};

//### ortho ( l, r, b, t, n, f )
//`l` - left edge of the frustum volume *{ Number}*  
//`r` - right edge of the frustum volume *{ Number}*  
//`b` - bottom edge of the frustum volume *{ Number}*  
//`t` - top edge of the frustum volume *{ Number}*  
//`n` - near clipping plane distance *{ Number }*  
//`f` - far clipping plane distance *{ Number }*  
//returns the matrix *{ Mat4 }*  
Mat4.prototype.ortho = function(l, r, b, t, n, f) {
  this.mul4x4r(2 / (r - l), 0, 0, (r + l) / (l - r), 0, 2 / (t - b),
               0, (t + b) / (b - t), 0, 0, 2 / (n - f), (f + n) / (n - f),
               0, 0, 0, 1);
  return this;
};

//### lookAt ( eye, target, up )
//`eye` - the eye to look from as a *{ [Vec3](Vec3.html) }*  
//`target` - the target to be looking at as a *{ [Vec3](Vec3.html) }*  
//`up` - the up vector *{ [Vec3](Vec3.html) }*  
//returns the matrix *{ Mat4 }*
Mat4.prototype.lookAt = function(eye, target, up) {
  var z = (Vec3.create(eye.x - target.x, eye.y - target.y, eye.z - target.z)).normalize();
  var x = (Vec3.create(up.x, up.y, up.z)).cross(z).normalize();
  var y = Vec3.create().copy(z).cross(x).normalize();
  this.mul4x4r(x.x, x.y, x.z, 0, y.x, y.y, y.z, 0, z.x, z.y, z.z, 0, 0, 0, 0, 1);
  this.translate(-eye.x, -eye.y, -eye.z);
  return this;
};

//### translate ( dx, dy, dz )
//`dx` - *{ Number }*  
//`dy` - *{ Number }*  
//`dz` - *{ Number }*  
//returns the matrix *{ Mat4 }*
Mat4.prototype.translate = function(dx, dy, dz) {
  this.mul4x4r(1, 0, 0, dx, 0, 1, 0, dy, 0, 0, 1, dz, 0, 0, 0, 1);
  return this;
};

//### rotate ( theta, x ,y , z )
//theta - rotation angle *{ Number }*  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//returns the matrix *{ Mat4 }*
Mat4.prototype.rotate = function(theta, x, y, z) {
  var s = Math.sin(theta);
  var c = Math.cos(theta);
  this.mul4x4r(x * x * (1 - c) + c, x * y * (1 - c) - z * s, x * z * (1 - c) + y * s,
               0, y * x * (1 - c) + z * s, y * y * (1 - c) + c, y * z * (1 - c) - x * s,
               0, x * z * (1 - c) - y * s, y * z * (1 - c) + x * s, z * z * (1 - c) + c,
               0, 0, 0, 0, 1);
  return this;
};

//### asMul ( a, b )
//`a` - the first matrix used in the multiplication *{ Mat4 }*  
//`b` - the second matrix used in the multiplication *{ Mat4 }*  
//returns the matrix with its values being  
//the result of the multiplied a and b matrices *{ Mat4 }*
Mat4.prototype.asMul = function(a, b) {
  var a11 = a.a11;
  var a12 = a.a12;
  var a13 = a.a13;
  var a14 = a.a14;
  var a21 = a.a21;
  var a22 = a.a22;
  var a23 = a.a23;
  var a24 = a.a24;
  var a31 = a.a31;
  var a32 = a.a32;
  var a33 = a.a33;
  var a34 = a.a34;
  var a41 = a.a41;
  var a42 = a.a42;
  var a43 = a.a43;
  var a44 = a.a44;
  var b11 = b.a11;
  var b12 = b.a12;
  var b13 = b.a13;
  var b14 = b.a14;
  var b21 = b.a21;
  var b22 = b.a22;
  var b23 = b.a23;
  var b24 = b.a24;
  var b31 = b.a31;
  var b32 = b.a32;
  var b33 = b.a33;
  var b34 = b.a34;
  var b41 = b.a41;
  var b42 = b.a42;
  var b43 = b.a43;
  var b44 = b.a44;
  this.a11 = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
  this.a12 = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
  this.a13 = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
  this.a14 = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
  this.a21 = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
  this.a22 = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
  this.a23 = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
  this.a24 = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
  this.a31 = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
  this.a32 = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
  this.a33 = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
  this.a34 = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
  this.a41 = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
  this.a42 = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
  this.a43 = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
  this.a44 = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
  return this;
};

//### mul ( b )
//`b` - the matrix to be multipled by *{ Mat4 }*  
//returns the matrix multiplied by b *{ Mat4 }*
Mat4.prototype.mul = function(b) {
  return this.asMul(this, b);
};

//### scale ( sx, sy, sz )
//`sx` = *{ Number }*  
//`sy` = *{ Number }*  
//`sz` = *{ Number }*  
//returns the matrix scaled *{ Mat4 }*
Mat4.prototype.scale = function(sx, sy, sz) {
  this.mul4x4r(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
  return this;
};



//### invert ()
//returns the matrix inverted *{ Mat4 }*
Mat4.prototype.invert = function() {
  var x0 = this.a11;
  var x1 = this.a12;
  var x2 = this.a13;
  var x3 = this.a14;
  var x4 = this.a21;
  var x5 = this.a22;
  var x6 = this.a23;
  var x7 = this.a24;
  var x8 = this.a31;
  var x9 = this.a32;
  var x10 = this.a33;
  var x11 = this.a34;
  var x12 = this.a41;
  var x13 = this.a42;
  var x14 = this.a43;
  var x15 = this.a44;
  var a0 = x0 * x5 - x1 * x4;
  var a1 = x0 * x6 - x2 * x4;
  var a2 = x0 * x7 - x3 * x4;
  var a3 = x1 * x6 - x2 * x5;
  var a4 = x1 * x7 - x3 * x5;
  var a5 = x2 * x7 - x3 * x6;
  var b0 = x8 * x13 - x9 * x12;
  var b1 = x8 * x14 - x10 * x12;
  var b2 = x8 * x15 - x11 * x12;
  var b3 = x9 * x14 - x10 * x13;
  var b4 = x9 * x15 - x11 * x13;
  var b5 = x10 * x15 - x11 * x14;
  var invdet = 1 / (a0 * b5 - a1 * b4 + a2 * b3 + a3 * b2 - a4 * b1 + a5 * b0);
  this.a11 = (+x5 * b5 - x6 * b4 + x7 * b3) * invdet;
  this.a12 = (-x1 * b5 + x2 * b4 - x3 * b3) * invdet;
  this.a13 = (+x13 * a5 - x14 * a4 + x15 * a3) * invdet;
  this.a14 = (-x9 * a5 + x10 * a4 - x11 * a3) * invdet;
  this.a21 = (-x4 * b5 + x6 * b2 - x7 * b1) * invdet;
  this.a22 = (+x0 * b5 - x2 * b2 + x3 * b1) * invdet;
  this.a23 = (-x12 * a5 + x14 * a2 - x15 * a1) * invdet;
  this.a24 = (+x8 * a5 - x10 * a2 + x11 * a1) * invdet;
  this.a31 = (+x4 * b4 - x5 * b2 + x7 * b0) * invdet;
  this.a32 = (-x0 * b4 + x1 * b2 - x3 * b0) * invdet;
  this.a33 = (+x12 * a4 - x13 * a2 + x15 * a0) * invdet;
  this.a34 = (-x8 * a4 + x9 * a2 - x11 * a0) * invdet;
  this.a41 = (-x4 * b3 + x5 * b1 - x6 * b0) * invdet;
  this.a42 = (+x0 * b3 - x1 * b1 + x2 * b0) * invdet;
  this.a43 = (-x12 * a3 + x13 * a1 - x14 * a0) * invdet;
  this.a44 = (+x8 * a3 - x9 * a1 + x10 * a0) * invdet;
  return this;
};

//### transpose ()
//returns the matrix transposed *{ Mat4 }*
Mat4.prototype.transpose = function() {
  var a11 = this.a11;
  var a12 = this.a12;
  var a13 = this.a13;
  var a14 = this.a14;
  var a21 = this.a21;
  var a22 = this.a22;
  var a23 = this.a23;
  var a24 = this.a24;
  var a31 = this.a31;
  var a32 = this.a32;
  var a33 = this.a33;
  var a34 = this.a34;
  var a41 = this.a41;
  var a42 = this.a42;
  var a43 = this.a43;
  var a44 = this.a44;
  this.a11 = a11;
  this.a12 = a21;
  this.a13 = a31;
  this.a14 = a41;
  this.a21 = a12;
  this.a22 = a22;
  this.a23 = a32;
  this.a24 = a42;
  this.a31 = a13;
  this.a32 = a23;
  this.a33 = a33;
  this.a34 = a43;
  this.a41 = a14;
  this.a42 = a24;
  this.a43 = a34;
  this.a44 = a44;
  return this;
};

//### toArray ()
//returns the matrix as an array [a11 ... a44] *{ Array }*
Mat4.prototype.toArray = function() {
  return [
      this.a11, this.a21, this.a31, this.a41,
      this.a12, this.a22, this.a32, this.a42,
      this.a13, this.a23, this.a33, this.a43,
      this.a14, this.a24, this.a34, this.a44];
};

//### fromArray ()
//`a` - the array providing the values for the matrix *{ Array }*
//returns the matrix with values taken from the array *{ Mat4 }*
Mat4.prototype.fromArray = function(a) {
  this.a11 = a[0](this.a21 = a[1](this.a31 = a[2](this.a41 = a[3])));
  this.a12 = a[4](this.a22 = a[5](this.a32 = a[6](this.a42 = a[7])));
  this.a13 = a[8](this.a23 = a[9](this.a33 = a[10](this.a43 = a[11])));
  this.a14 = a[12](this.a24 = a[13](this.a34 = a[14](this.a44 = a[15])));
  return this;
};

module.exports = Mat4;


},{"./Vec3":393}],381:[function(require,module,exports){
//3D Three data structure for fast spatial point indexing
//## Example use
//      var octree = new Octree(new Vec3(-1,-1,1), new Vec3(2,2,2));
//
//      octree.add(new Vec3(0.2, 0, 0));
//      octree.add(new Vec3(0.5, 0, 0));
//      octree.add(new Vec3(0, 0.12, 0));
//      octree.add(new Vec3(0, 0, -0.23));
//
//      octree.findNearestPoint(new Vec3(0, 0, 0));

//## Reference
var geom = require('pex-geom');

var Vec3 = geom.Vec3;

//### Octree(position, size, accuracy)  
//`position` - far bottom left corner position of the octree bounding box *{ Vec3 }*  
//`size` - size of the octree bounding box *{ Vec3 }*  
//`accuracy` - precision at which two points are considered the same *{ Number/Float = 0 }*  
function Octree(position, size, accuracy) {
  this.maxDistance = Math.max(size.x, Math.max(size.y, size.z));
  this.accuracy = 0;
  this.root = new Octree.Cell(this, position, size, 0);
}

//### fromBoundingBox(bbox)  
//`bbox` - octree bounding box *{ BoundingBox }*  
Octree.fromBoundingBox = function (bbox) {
  return new Octree(bbox.min.clone(), bbox.getSize().clone());
};

//### Max octree depth level
Octree.MaxLevel = 8;

//### add(p, data)  
//Add point to octree  
//`p` - point to add *{ Vec3 }*  
//`data` - optional data to attach to the point *{ Any }*  
Octree.prototype.add = function (p, data) {
  this.root.add(p, data);
};

//### has(p)  
//Checks if the point has beed already added to the octreee  
//`p` - point to add *{ Vec3 }*  
Octree.prototype.has = function (p) {
  return this.root.has(p);
};

//### findNearestPoint(p, options)  
//Finds closest point to the given one  
//`p` - point that we are searching around *{ Vec3 }*  
//`o` - options *{ Object }*  
//Available options  
//`includeData` - return both point and it's data *{ bool = false }*  
//`maxDist` - don't include points further than maxDist, defaults to *{ Number = Inifinity }*  
//`notSelf` - return point only if different than submited point *{ bool = false }*  
//Returns:  
//*{ point:Vec3, data:Any }* - object with both point and it's data if includeData is true  
//*Vec3* - just the point otherwise
Octree.prototype.findNearestPoint = function (p, options) {
  options.includeData = options.includeData ? options.includeData : false;
  options.bestDist = options.maxDist ? options.maxDist : Infinity;
  options.notSelf = options.notSelf ? options.notSelf : false;

  var result = this.root.findNearestPoint(p, options);
  if (result) {
    if (options.includeData) return result;
    else return result.point;
  }
  else return null;
};

//### findNearbyPoints(p, r, options)  
//Finds nearby points to the given one within radius r  
//`p` - point that we are searching around *{ Vec3 }*  
//`r` - search radius *{ Number }*  
//`o` - options *{ Object }*  
//Available options  
//`includeData` - return both point and it's data *{ bool = false }*  
//`maxDist` - don't include points further than maxDist, defaults to *{ Number = Inifinity }*  
//`notSelf` - return point only if different than submited point *{ bool = false }*  
//Returns:  
//*{ points: Array of Vec3, data: Array of Any }* - object with both point and it's data if includeData is true  
Octree.prototype.findNearbyPoints = function (p, r, options) {
  options = options || { };
  var result = { points: [], data: [] };
  this.root.findNearbyPoints(p, r, result, options);
  return result;
};

//### getAllCellsAtLevel(level)  
//Return all octree cells at given level  
//`level` - level of cells to retrieve, e.g. root is 0 *{ Number/Int }*  
//
//Note: the function parameter list is (cell, level, result) as it will be called recursively but the usage is simply getAllCellsAtLevel(n);  
//Returns *{ Array of Cell objects }*, each cell has *points* property with all the points withing the cell
Octree.prototype.getAllCellsAtLevel = function (cell, level, result) {
  if (typeof level == 'undefined') {
    level = cell;
    cell = this.root;
  }
  result = result || [];
  if (cell.level == level) {
    if (cell.points.length > 0) {
      result.push(cell);
    }
    return result;
  } else {
    cell.children.forEach(function (child) {
      this.getAllCellsAtLevel(child, level, result);
    }.bind(this));
    return result;
  }
};

//## Octree cell implementation
Octree.Cell = function (tree, position, size, level) {
  this.tree = tree;
  this.position = position;
  this.size = size;
  this.level = level;
  this.points = [];
  this.data = [];
  this.temp = new Vec3(); //temp vector for distance calculation
  this.children = [];
};

Octree.Cell.prototype.has = function (p) {
  if (!this.contains(p))
    return null;
  if (this.children.length > 0) {
    for (var i = 0; i < this.children.length; i++) {
      var duplicate = this.children[i].has(p);
      if (duplicate) {
        return duplicate;
      }
    }
    return null;
  } else {
    var minDistSqrt = this.tree.accuracy * this.tree.accuracy;
    for (var i = 0; i < this.points.length; i++) {
      var o = this.points[i];
      var distSq = p.squareDistance(o);
      if (distSq <= minDistSqrt) {
        return o;
      }
    }
    return null;
  }
};

Octree.Cell.prototype.add = function (p, data) {
  this.points.push(p);
  this.data.push(data);
  if (this.children.length > 0) {
    this.addToChildren(p, data);
  } else {
    if (this.points.length > 1 && this.level < Octree.MaxLevel) {
      this.split();
    }
  }
};

Octree.Cell.prototype.addToChildren = function (p, data) {
  for (var i = 0; i < this.children.length; i++) {
    if (this.children[i].contains(p)) {
      this.children[i].add(p, data);
      break;
    }
  }
};

Octree.Cell.prototype.contains = function (p) {
  return p.x >= this.position.x - this.tree.accuracy
      && p.y >= this.position.y - this.tree.accuracy
      && p.z >= this.position.z - this.tree.accuracy
      && p.x < this.position.x + this.size.x + this.tree.accuracy
      && p.y < this.position.y + this.size.y + this.tree.accuracy
      && p.z < this.position.z + this.size.z + this.tree.accuracy;
};

// 1 2 3 4
// 5 6 7 8
Octree.Cell.prototype.split = function () {
  var x = this.position.x;
  var y = this.position.y;
  var z = this.position.z;
  var w2 = this.size.x / 2;
  var h2 = this.size.y / 2;
  var d2 = this.size.z / 2;
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x, y, z), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x + w2, y, z), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x, y, z + d2), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x + w2, y, z + d2), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x, y + h2, z), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x + w2, y + h2, z), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x, y + h2, z + d2), Vec3.create(w2, h2, d2), this.level + 1));
  this.children.push(new Octree.Cell(this.tree, Vec3.create(x + w2, y + h2, z + d2), Vec3.create(w2, h2, d2), this.level + 1));
  for (var i = 0; i < this.points.length; i++) {
    this.addToChildren(this.points[i], this.data[i]);
  }
};

Octree.Cell.prototype.squareDistanceToCenter = function(p) {
  var dx = p.x - (this.position.x + this.size.x / 2);
  var dy = p.y - (this.position.y + this.size.y / 2);
  var dz = p.z - (this.position.z + this.size.z / 2);
  return dx * dx + dy * dy + dz * dz;
}

Octree.Cell.prototype.findNearestPoint = function (p, options) {
  var nearest = null;
  var nearestData = null;
  var bestDist = options.bestDist;

  if (this.points.length > 0 && this.children.length == 0) {
    for (var i = 0; i < this.points.length; i++) {
      var dist = this.points[i].distance(p);
      if (dist <= bestDist) {
        if (dist == 0 && options.notSelf)
          continue;
        bestDist = dist;
        nearest = this.points[i];
        nearestData = this.data[i];
      }
    }
  }

  var children = this.children;

  //traverse children in order from closest to furthest
  var children = this.children
    .map(function(child) { return { child: child, dist: child.squareDistanceToCenter(p) } })
    .sort(function(a, b) { return a.dist - b.dist; })
    .map(function(c) { return c.child; });

  if (children.length > 0) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.points.length > 0) {
        if (p.x < child.position.x - bestDist || p.x > child.position.x + child.size.x + bestDist ||
            p.y < child.position.y - bestDist || p.y > child.position.y + child.size.y + bestDist ||
            p.z < child.position.z - bestDist || p.z > child.position.z + child.size.z + bestDist
          ) {
          continue;
        }
        var childNearest = child.findNearestPoint(p, options);
        if (!childNearest || !childNearest.point) {
          continue;
        }
        var childNearestDist = childNearest.point.distance(p);
        if (childNearestDist < bestDist) {
          nearest = childNearest.point;
          bestDist = childNearestDist;
          nearestData = childNearest.data;
        }
      }
    }
  }
  return {
    point: nearest,
    data: nearestData
  }
};

Octree.Cell.prototype.findNearbyPoints = function (p, r, result, options) {
  if (this.points.length > 0 && this.children.length == 0) {
    for (var i = 0; i < this.points.length; i++) {
      var dist = this.points[i].distance(p);
      if (dist <= r) {
        if (dist == 0 && options.notSelf)
          continue;
        result.points.push(this.points[i]);
        if (options.includeData) result.data.push(this.data[i]);
      }
    }
  }

  //children order doesn't matter
  var children = this.children;

  if (children.length > 0) {
    for (var i = 0; i < children.length; i++) {
      var child = children[i];
      if (child.points.length > 0) {
        if (p.x < child.position.x - r || p.x > child.position.x + child.size.x + r ||
            p.y < child.position.y - r || p.y > child.position.y + child.size.y + r ||
            p.z < child.position.z - r || p.z > child.position.z + child.size.z + r
          ) {
          continue;
        }
        child.findNearbyPoints(p, r, result, options);
      }
    }
  }
};

module.exports = Octree;

},{"pex-geom":376}],382:[function(require,module,exports){
//Path of points
//
//## Example use
//     var points = [
//       new Vec3(-1.5, -1.0, 0),
//       new Vec3(-0.5, -0.7, 0),
//       new Vec3( 0.5,  0.7, 0),
//       new Vec3( 1.5,  1.0, 0)
//     ]
//
//     var path = new Path(points)
//
//## Reference
var Vec3 = require('./Vec3');

//### Path ( points, closed )
//`points` - Array of points *{ Array of [Vec3](Vec3.html) }*  
//`closed` - is it a closed path or not? *{ Boolean }*
function Path(points, closed) {
  this.points = points || [];
  this.dirtyLength = true;
  this.closed = closed || false;
  this.samplesCount = 1000;
}

//### addPoint ( p )
//`p` - point as a *{ [Vec3](Vec3.html) }*  
//returns 
Path.prototype.addPoint = function(p) {
  return this.points.push(p);
  // shouldnt this return `this`?
};

//### getPoint ( t, debug )
//`t` -  
//`debug` -  what is this lol  
//returns point as a *{ [Vec3](Vec3.html) }*
Path.prototype.getPoint = function(t, debug) {
  var point = t * (this.points.length - 1);
  var intPoint = Math.floor(point);
  var weight = point - intPoint;
  var c0 = intPoint;
  var c1 = intPoint + 1;
  if (intPoint === this.points.length - 1) {
    c0 = intPoint;
    c1 = intPoint;
  }
  var vec = new Vec3();
  vec.x = this.points[c0].x + (this.points[c1].x - this.points[c0].x) * weight;
  vec.y = this.points[c0].y + (this.points[c1].y - this.points[c0].y) * weight;
  vec.z = this.points[c0].z + (this.points[c1].z - this.points[c0].z) * weight;
  return vec;
};

//### getPointAt ( d )
//`d` - ?  
//returns point as a *{ [Vec3](Vec3.html) }*
Path.prototype.getPointAt = function(d) {
  if (!this.closed) {
    d = Math.max(0, Math.min(d, 1));
  }
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var k = 0;
  for (var i=0; i<this.accumulatedLengthRatios.length; i++) {
    if (this.accumulatedLengthRatios[i] > d - 1/this.samplesCount) {
      k = this.accumulatedRatios[i];
      break;
    }
  }
  return this.getPoint(k, true);
};

//naive implementation
//### getClosestPoint ( point )
//Finds closest point to given point  
//`point` - point as a *{ [Vec3](Vec3.html) }*  
//returns point as a *{ [Vec3](Vec3.html) }*
Path.prototype.getClosestPoint = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p };
    }
    else return best;
  }, { dist: Infinity, point: null });
  return closesPoint.point;
}

//### getClosestPointRatio ( point )
//`point` - point as a *{ [Vec3](Vec3.html) }*  
//returns 
Path.prototype.getClosestPointRatio = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p, pIndex) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p, index: pIndex };
    }
    else return best;
  }, { dist: Infinity, point: null, index: -1 });
  return this.accumulatedLengthRatios[closesPoint.index];
}

//### close ()
//
Path.prototype.close = function() {
  return this.closed = true;
};

//### isClosed ()
//returns *{ Boolean }*
Path.prototype.isClosed = function() {
  return this.closed;
};

//### reverse ()
//
Path.prototype.reverse = function() {
  this.points = this.points.reverse();
  return this.dirtyLength = true;
};

//### precalculateLength ()
//
Path.prototype.precalculateLength = function() {
  this.accumulatedRatios = [];
  this.accumulatedLengthRatios = [];
  this.accumulatedLengths = [];
  this.precalculatedPoints = [];

  var step = 1 / this.samplesCount;
  var k = 0;
  var totalLength = 0;
  var point = null;
  var prevPoint = null;

  for (var i=0; i<this.samplesCount; i++) {
    prevPoint = point;
    point = this.getPoint(k);
    if (i > 0) {
      totalLength += point.dup().sub(prevPoint).length();;
    }
    this.accumulatedRatios.push(k);
    this.accumulatedLengths.push(totalLength);
    this.precalculatedPoints.push(point);
    k += step;
  }
  for (var i=0; i<this.accumulatedLengths.length - 1; i++) {
    this.accumulatedLengthRatios.push(this.accumulatedLengths[i] / totalLength);
  }
  this.length = totalLength;
  return this.dirtyLength = false;
};

module.exports = Path;


},{"./Vec3":393}],383:[function(require,module,exports){
//A plane represented by a point and a normal vector perpendicular to the plane's surface.
//
//Methematical construct not a 3d geometry mesh.

//## Example use
//      var plane = new Plane(new Vec3(0, 0, 0), new Vec3(0, 1, 0))
//
//      var projectedPoint = plane.project(new Vec3(1,2,3));

//## Reference

var Vec2 = require('./Vec2');
var Vec3 = require('./Vec3');

//### Plane(point, normal)
//Create plane at given point and normal  
//`point` - *{ Vec3 }*  
//`normal` - *{ Vec3 }*  
function Plane(point, normal) {
  this.point = point;
  this.normal = normal;
  this.u = new Vec3(); //?
  this.v = new Vec3(); //?
  this.updateUV();
}

//### set(point, normal)
//`point` - *{ Vec3 }*  
//`normal` - *{ Vec3 }*  
Plane.prototype.set = function(point, normal) {
  this.point = point;
  this.normal = normal;
  this.updateUV();
}

//### setPoint(point)
//`point` - *{ Vec3 }*  
Plane.prototype.setPoint = function(point) {
  this.point = point;
  this.updateUV();
}

//### setNormal(normal)
//`normal` - *{ Vec3 }*  
Plane.prototype.setNormal = function(normal) {
  this.normal = normal;
  this.updateUV();
}

//### project(p)
//Projects point onto the plane  
//`p` - a point to project*{ Vec3 }*  
Plane.prototype.project = function(p) {
  var D = Vec3.create().asSub(p, this.point);
  var scale = D.dot(this.normal);
  var scaled = this.normal.clone().scale(scale);
  var projected = p.clone().sub(scaled);
  return projected;
}

//### intersectRay(ray)  
//Test ray plane intersection  
//`ray` - *{ Ray }*  
//Returns array with one element - the intersection point, or empty array if the ray is parallel to the plane  
Plane.prototype.intersectRay = function(ray) {
  return ray.hitTestPlane(this.point, this.normal)[0];
}

//### rebase(p)  
//Represent 3d point on the plane in 2d coordinates  
//`p` - point *{ Vec3 }*  
Plane.prototype.rebase = function(p) {
  var diff = p.dup().sub(this.point);
  var x = this.u.dot(diff);
  var y = this.v.dot(diff);
  return new Vec2(x, y);
}

//### distanceSigned(p)  
//Returns signed distance to the plane  
//`p` - point *{ Vec3 }*  
Plane.prototype.distanceSigned = function(p) {
  var projectedPoint = this.project(p);
  var dist = projectedPoint.distance(p);
  var dir = p.dup().sub(projectedPoint).normalize();
  var sign = this.normal.dot(dir) > 0 ? 1 : -1;
  return dist * sign;
}

//### fromPoints(a, b, c)
//Creates new plane containing points a, b, c  
//`a` - point *{ Vec3 }*  
//`b` - point *{ Vec3 }*  
//`c` - point *{ Vec3 }*  
Plane.fromPoints = function(a, b, c) {
    var x = (a.x + b.x + c.x) / 3;
    var y = (a.y + b.y + c.y) / 3;
    var z = (a.z + b.z + c.z) / 3;

    var e0x = b.x - a.x;
    var e0y = b.y - a.y;
    var e0z = b.z - a.z;
    var e1x = c.x - a.x;
    var e1y = c.y - a.y;
    var e1z = c.z - a.z;

    var nx = e0y * e1z - e1y * e0z;
    var ny = e0z * e1x - e1z * e0x;
    var nz = e0x * e1y - e1x * e0y;

    return new Plane(new Vec3(x, y, z), new Vec3(nx, ny, nz));
}

//## Internal methods

//### updateUV
//Updates interal uv coordinates for expressing 3d on the plane points as 2d
Plane.prototype.updateUV = function() {
  if (Math.abs(this.normal.x) > Math.abs(this.normal.y)) {
    var invLen = 1 / Math.sqrt(this.normal.x * this.normal.x + this.normal.z * this.normal.z);
    this.u.set( this.normal.x * invLen, 0, -this.normal.z * invLen);
  }
  else {
    var invLen = 1 / Math.sqrt(this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    this.u.set( 0, this.normal.z * invLen, -this.normal.y * invLen);
  }

  this.v.setVec3(this.normal).cross(this.u);
}

module.exports = Plane;
},{"./Vec2":392,"./Vec3":393}],384:[function(require,module,exports){
//A Quaternion (x, y, z, w)
//## Example use
//     var q = new Quat().fromDirection(new Vec3(1, 1, 1));
//     var v = new Vec3(0, 0, 1);
//     v.transformQuat(q);
//
//## Reference

var Mat4 = require('./Mat4');
var Vec3 = require('./Vec3');
var kEpsilon = Math.pow(2, -24);

//### Quat(x, y, z, w)
//Constructor  
//`x` - *{ Number }* = 0  
//`y` - *{ Number }* = 0  
//`z` - *{ Number }* = 0  
//`w` - *{ Number }* = 1  
function Quat(x, y, z, w) {
  this.x = x != null ? x : 0;
  this.y = y != null ? y : 0;
  this.z = z != null ? z : 0;
  this.w = w != null ? w : 1;
}

//### create(x, y, z, w)
//Creates new Quaternion  
//`x` - *{ Number }* = 0  
//`y` - *{ Number }* = 0  
//`z` - *{ Number }* = 0  
//`w` - *{ Number }* = 1  
//returns *{ Quat }*  
Quat.create = function(x, y, z, w) {
  return new Quat(x, y, z, w);
};

//### create(x, y, z, w)
//Creates new Quaternion from an array  
//`a` - *{ Array of Number}*  
//returns *{ Quat }*
Quat.fromArray = function(a) {
  return new Quat(a[0], a[1], a[2], a[3]);
}

//### identity()
//Resets Quaternion to it's inital state (0, 0, 0, 1), with no rotation
Quat.prototype.identity = function() {
  this.set(0, 0, 0, 1);
  return this;
};

//### equals(q, tolerance)
//Compares two quaternions with given tolerance  
//`q` - *{ Quat }*  
//`tolerance` - *{ Number }* = 0.0000001  
Quat.prototype.equals = function(q, tolerance) {
  if (tolerance == null) {
    tolerance = 0.0000001;
  }
  return (Math.abs(q.x - this.x) <= tolerance) && (Math.abs(q.y - this.y) <= tolerance) && (Math.abs(q.z - this.z) <= tolerance) && (Math.abs(q.w - this.w) <= tolerance);
};


//### hash()
//Returns naive hash string representation of this quaternion
Quat.prototype.hash = function() {
  return 1 * this.x + 12 * this.y + 123 * this.z + 1234 * this.w;
};

//### copy()
//Copies x, y, z, w from another quaternion to this one  
//`q` - *{ Quat }*
Quat.prototype.copy = function(q) {
  this.x = q.x;
  this.y = q.y;
  this.z = q.z;
  this.w = q.w;
  return this;
};

//### clone()
//Returns new quaternion with x, y, z, w the same as this one
Quat.prototype.clone = function() {
  return new Quat(this.x, this.y, this.z, this.w);
};

//### dup()
//Alias of clone. Returns new quaternion with x, y, z, w the same as this one
Quat.prototype.dup = function() {
  return this.clone();
};

//### setAxisAngle(v, z)
//Sets x, y, z, w of the Quaternion representing rotation around given axis
//`v` - *{ Vec3 }*
//`a` - angle in degrees *{ Number }*
Quat.prototype.setAxisAngle = function(v, a) {
  a = a * 0.5;
  var s = Math.sin(a / 180 * Math.PI);
  this.x = s * v.x;
  this.y = s * v.y;
  this.z = s * v.z;
  this.w = Math.cos(a / 180 * Math.PI);
  return this;
};

//### set(q)
//Sets x, y, z, w from another Quat  
//`q` - *{ Quat }*  
Quat.prototype.setQuat = function(q) {
  this.x = q.x;
  this.y = q.y;
  this.z = q.z;
  this.w = q.w;
  return this;
};

//### setEuler(yaw, pitch, roll)  
//http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToQuaternion/  
//`yaw` - angle in radians *{ Number }*  
//`pitch` - angle in radians *{ Number }*  
//`roll` - angle in radians *{ Number }*  
Quat.prototype.setEuler = function(yaw, pitch, roll) {
  var c1 = Math.cos(yaw/2);
  var s1 = Math.sin(yaw/2);
  var c2 = Math.cos(pitch/2);
  var s2 = Math.sin(pitch/2);
  var c3 = Math.cos(roll/2);
  var s3 = Math.sin(roll/2);
  var c1c2 = c1*c2;
  var s1s2 = s1*s2;
  this.w = c1c2*c3 - s1s2*s3;
  this.x = c1c2*s3 + s1s2*c3;
  this.y = s1*c2*c3 + c1*s2*s3;
  this.z = c1*s2*c3 - s1*c2*s3;
  return this;
};

//### set(x, y, z, w)
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//`w` - *{ Number }*  
Quat.prototype.set = function(x, y, z, w) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;
  return this;
};

//### asMul(p, q)
//Sets x, y, z, w of this quaternion to the result of multiplying two other quaternions  
//`p` - *{ Quat }*  
//`q` - *{ Quat }*  
Quat.prototype.asMul = function(p, q) {
  var px = p.x;
  var py = p.y;
  var pz = p.z;
  var pw = p.w;
  var qx = q.x;
  var qy = q.y;
  var qz = q.z;
  var qw = q.w;
  this.x = px * qw + pw * qx + py * qz - pz * qy;
  this.y = py * qw + pw * qy + pz * qx - px * qz;
  this.z = pz * qw + pw * qz + px * qy - py * qx;
  this.w = pw * qw - px * qx - py * qy - pz * qz;
  return this;
};

//### mul(q)
//Multiply this quaternion by another quaternion  
//`q` - *{ Quat }*  
Quat.prototype.mul = function(q) {
  this.asMul(this, q);
  return this;
};

//### mul3(q)
//Multiply this quaternion by another quaternion represented by x, y, z, w  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//`w` - *{ Number }*  
Quat.prototype.mul4 = function(x, y, z, w) {
  var ax = this.x;
  var ay = this.y;
  var az = this.z;
  var aw = this.w;
  this.x = w * ax + x * aw + y * az - z * ay;
  this.y = w * ay + y * aw + z * ax - x * az;
  this.z = w * az + z * aw + x * ay - y * ax;
  this.w = w * aw - x * ax - y * ay - z * az;
  return this;
};

//### length()
//Returns length of this quaternion *{ Number }*  
Quat.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
};

//### normalize()
//Sets length of this quaternion to 1  
Quat.prototype.normalize = function() {
  var len = this.length();
  if (len > kEpsilon) {
    this.x /= len;
    this.y /= len;
    this.z /= len;
    this.w /= len;
  }
  return this;
};

//### toMat4()
//Returns this quaternion represented as 4x4 matrix  
//`out` - optional matrix to write data into *{ Mat4 }*  
Quat.prototype.toMat4 = function(out) {
  var xs = this.x + this.x;
  var ys = this.y + this.y;
  var zs = this.z + this.z;
  var wx = this.w * xs;
  var wy = this.w * ys;
  var wz = this.w * zs;
  var xx = this.x * xs;
  var xy = this.x * ys;
  var xz = this.x * zs;
  var yy = this.y * ys;
  var yz = this.y * zs;
  var zz = this.z * zs;
  var m = out || new Mat4();
  return m.set4x4r(1 - (yy + zz), xy - wz, xz + wy, 0, xy + wz, 1 - (xx + zz), yz - wx, 0, xz - wy, yz + wx, 1 - (xx + yy), 0, 0, 0, 0, 1);
};

//### setDirection(direction)
//Sets x, y, z, w of this quaternion to represent rotation of Z axis towards given vector  
//`direction` - *{ Vec3 }*  
Quat.prototype.setDirection = function(direction) {
  var dir = Vec3.create().copy(direction).normalize();

  var up = Vec3.create(0, 1, 0);

  var right = Vec3.create().asCross(up, dir);

  if (right.length() == 0) {
    up.set(1, 0, 0)
    right.asCross(up, dir);
  }

  up.asCross(dir, right);
  right.normalize();
  up.normalize();

  var m = new Mat4();
  m.set4x4r(
    right.x, right.y, right.z, 0,
    up.x, up.y, up.z, 0,
    dir.x, dir.y, dir.z, 0,
    0, 0, 0, 1
  );

  //Step 3. Build a quaternion from the matrix
  var q = new Quat()
  if (1.0 + m.a11 + m.a22 + m.a33 < 0.001) {
    dir = direction.dup();
    dir.z *= -1;
    dir.normalize();
    up.set(0, 1, 0);
    right.asCross(up, dir);
    up.asCross(dir, right);
    right.normalize();
    up.normalize();
    m = new Mat4();
    m.set4x4r(
      right.x, right.y, right.z, 0,
      up.x, up.y, up.z, 0,
      dir.x, dir.y, dir.z, 0,
      0, 0, 0, 1
    );
    q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
    var dfWScale = q.w * 4.0;
    q.x = ((m.a23 - m.a32) / dfWScale);
    q.y = ((m.a31 - m.a13) / dfWScale);
    q.z = ((m.a12 - m.a21) / dfWScale);

    q2 = new Quat();
    q2.setAxisAngle(new Vec3(0,1,0), 180)
    q2.mul(q);
    this.copy(q2);
    return this;
  }
  q.w = Math.sqrt(1.0 + m.a11 + m.a22 + m.a33) / 2.0;
  dfWScale = q.w * 4.0;
  q.x = ((m.a23 - m.a32) / dfWScale);
  q.y = ((m.a31 - m.a13) / dfWScale);
  q.z = ((m.a12 - m.a21) / dfWScale);

  this.copy(q);
  return this;
}

//### setUV(u, v)
//Rotate between vectors  
//http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors  
//`u` - vector orientation we are rotating from *{ Vec3 }*  
//`v` - vector orientation we are rotating to *{ Vec3 }*  
Quat.prototype.setUV = function(u, v) {
  var m = Math.sqrt(2.0 + 2.0 * u.dot(v));
  var w = u.dup().cross(v);

  w.scale( (1.0 / m) );

  this.w = 0.5 * m;
  this.x = w.x;
  this.y = w.y;
  this.z = w.z;

  return this;
}

//### slerp(qb, t)
//Spherical linear interpolation of this quaternion towards another quaternion  
//`q` - quaternion to rotate towards *{ Quat }*  
//`t` - interpolation fraction aka 'time' *{ Number }*  
Quat.prototype.slerp = function(qb, t) {
  var qa = this;

  // Calculate angle between the quaternions
  var cosHalfTheta = qa.w * qb.w + qa.x * qb.x + qa.y * qb.y + qa.z * qb.z;

  // If qa=qb or qa=-qb then theta = 0 and we can return qa
  if (Math.abs(cosHalfTheta) >= 1.0){
    return this;
  }

  var halfTheta = Math.acos(cosHalfTheta);
  var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta*cosHalfTheta);

  // If theta = 180 degrees then result is not fully defined
  // we could rotate around any axis normal to qa or qb
  if (Math.abs(sinHalfTheta) < 0.001){ // fabs is floating point absolute
    this.w = (qa.w * 0.5 + qb.w * 0.5);
    this.x = (qa.x * 0.5 + qb.x * 0.5);
    this.y = (qa.y * 0.5 + qb.y * 0.5);
    this.z = (qa.z * 0.5 + qb.z * 0.5);
    return this;
  }

  var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
  var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

  this.w = (qa.w * ratioA + qb.w * ratioB);
  this.x = (qa.x * ratioA + qb.x * ratioB);
  this.y = (qa.y * ratioA + qb.y * ratioB);
  this.z = (qa.z * ratioA + qb.z * ratioB);
  return this;
}

//### Quat.fromAxisAngle(v, a)
//Creates new quaternion Quaternion representing rotation around given axis  
//`v` - *{ Vec3 }*  
//`a` - angle in degrees *{ Number }*  
Quat.fromAxisAngle = function(v, a) {
  return new Quat().setAxisAngle(v, a);
}

//### Quat.fromDirection(direction)
//Creates new quaternion Quaternion representing rotation of Z axis towards given vector  
//`direction` - *{ Vec3 }*  
Quat.fromDirection = function(direction) {
  return new Quat().setDirection(direction);
}

Quat.fromEuler = function(yaw, pitch, roll) {
  return new Quat().setEuler(yaw, pitch, roll);
}

Quat.fromUV = function(u, v) {
  return new Quat().setUV(u, v);
}


module.exports = Quat;

},{"./Mat4":380,"./Vec3":393}],385:[function(require,module,exports){
//A ray.
//
//Consists of the starting point *origin* and the *direction* vector.  

//## Example use
//     var ray = new Ray(new Vec3(0, 0, 0), new Vec3(0, 0, -1));
//     ray.hitTestSphere(new Vec3(0, 0, -10), 0.5)

//## Reference

var Vec3 = require('./Vec3');

var EPSILON = 0.0001;

//### Ray()
//Constructor  
//`origin` - *{ Vec3 }*  
//`direction` - *{ Vec3 }*
function Ray(origin, direction) {
  this.origin = origin || new Vec3(0, 0, 0);
  this.direction = direction || new Vec3(0, 0, 1);
}

//### hitTestSphere(pos, r)
//Ray - Sphere intersection test  
//`pos` - sphere center *{ Vec3 }*  
//`r` - sphere radius *{ Number }*  
//returns *{ Array of Vec3 }* with the intersection points:  
//0 points if there is no intersection  
//1 point if the ray lays a line tangent to the sphere  
//2 points if the ray lays on a line crossing the sphere  
//http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection  
Ray.prototype.hitTestSphere = function (pos, r) {
  var hits = [];
  var d = this.direction;
  var o = this.origin;
  var osp = o.dup().sub(pos);
  var A = d.dot(d);
  if (A == 0) {
    return hits;
  }
  var B = 2 * osp.dot(d);
  var C = osp.dot(osp) - r * r;
  var sq = Math.sqrt(B * B - 4 * A * C);
  if (isNaN(sq)) {
    return hits;
  }
  var t0 = (-B - sq) / (2 * A);
  var t1 = (-B + sq) / (2 * A);
  hits.push(o.dup().add(d.dup().scale(t0)));
  if (t0 != t1) {
    hits.push(o.dup().add(d.dup().scale(t1)));
  }
  return hits;
};

//### hitTestPlane(pos, normal)
//Ray - Plane intersection test  
//`pos` - point on the plane *{ Vec3 }*  
//`normal` - plane normal *{ Number }*  
//returns *{ Array of Vec3 }* with the intersection points:  
//0 points if there is no intersection, ray lays on a line parallel to the plane   
//1 point if the ray lays on a line crossing the plane  
//http://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm  
//http://cgafaq.info/wiki/Ray_Plane_Intersection  
Ray.prototype.hitTestPlane = function (pos, normal) {
  if (this.direction.dot(normal) == 0) {
    return [];
  }
  var t = normal.dup().scale(-1).dot(this.origin.dup().sub(pos)) / this.direction.dot(normal);
  return [this.origin.dup().add(this.direction.dup().scale(t))];
};

//### hitTestBoundingBox(bbox)
//Ray - Plane intersection test  
//`bbox` - *{ BoundingBox }*  
//returns *{ Array of Vec3 }* with the intersection points:  
//0 points if there is no intersection   
//1 point if the ray lays on a line touching the boundig box corner  
//2 points if the ray lays on a line crossing the bounding box  
Ray.prototype.hitTestBoundingBox = function (bbox) {
  var hits = [];
  var self = this;
  function testFace(pos, size, normal, u, v) {
    var faceHits = self.hitTestPlane(pos, normal);
    if (faceHits.length > 0) {
      var hit = faceHits[0];
      if (hit[u] > pos[u] - size[u] / 2 && hit[u] < pos[u] + size[u] / 2 && hit[v] > pos[v] - size[v] / 2 && hit[v] < pos[v] + size[v] / 2) {
        hits.push(hit);
      }
    }
  }
  var bboxCenter = bbox.getCenter();
  var bboxSize = bbox.getSize();
  testFace(bboxCenter.dup().add(new Vec3(0, 0, bboxSize.z / 2)), bboxSize, new Vec3(0, 0, 1), 'x', 'y');
  testFace(bboxCenter.dup().add(new Vec3(0, 0, -bboxSize.z / 2)), bboxSize, new Vec3(0, 0, -1), 'x', 'y');
  testFace(bboxCenter.dup().add(new Vec3(bboxSize.x / 2, 0, 0)), bboxSize, new Vec3(1, 0, 0), 'y', 'z');
  testFace(bboxCenter.dup().add(new Vec3(-bboxSize.x / 2, 0, 0)), bboxSize, new Vec3(-1, 0, 0), 'y', 'z');
  testFace(bboxCenter.dup().add(new Vec3(0, bboxSize.y / 2, 0)), bboxSize, new Vec3(0, 1, 0), 'x', 'z');
  testFace(bboxCenter.dup().add(new Vec3(0, -bboxSize.y / 2, 0)), bboxSize, new Vec3(0, -1, 0), 'x', 'z');

  hits.forEach(function (hit) {
    hit._distance = hit.distance(self.origin);
  });

  hits.sort(function (a, b) {
    return a._distance - b._distance;
  });

  hits.forEach(function (hit) {
    delete hit._distance;
  });

  if (hits.length > 0) {
    hits = [hits[0]];
  }

  return hits;
};

//### hitTestTriangle(triangle)
//Ray - Plane intersection test  
//`triangle` - *{ Triangle3D }*  
//returns *{ Vec3 }* if there is intersection or a negatie *{ Number }* error code otherwise  
//http://geomalgorithms.com/a06-_intersect-2.html#intersect3D_RayTriangle()
Ray.prototype.hitTestTriangle = function(triangle) {
  //Vector    u, v, n;              // triangle vectors
  //Vector    dir, w0, w;           // ray vectors
  //float     r, a, b;              // params to calc ray-plane intersect

  var ray = this;

  //// get triangle edge vectors and plane normal
  //u = T.V1 - T.V0;
  //v = T.V2 - T.V0;
  var u = triangle.b.dup().sub(triangle.a);
  var v = triangle.c.dup().sub(triangle.a);
  //n = u * v;              // cross product
  var n = Vec3.create().asCross(u, v);
  //if (n == (Vector)0)             // triangle is degenerate
  //    return -1;                  // do not deal with this case

  if (n.length() < EPSILON) return -1;

  //dir = R.P1 - R.P0;              // ray direction vector
  //w0 = R.P0 - T.V0;
  var w0 = ray.origin.dup().sub(triangle.a);

  //a = -dot(n,w0);
  //b = dot(n,dir);
  var a = -n.dot(w0);
  var b = n.dot(ray.direction);

  //if (fabs(b) < SMALL_NUM) {     // ray is  parallel to triangle plane
  //    if (a == 0)                 // ray lies in triangle plane
  //        return 2;
  //    else return 0;              // ray disjoint from plane
  //}
  if (Math.abs(b) < EPSILON) {
    if (a == 0) return -2;
    else return -3;
  }

  //// get intersect point of ray with triangle plane
  //r = a / b;
  //if (r < 0.0)                    // ray goes away from triangle
  //    return 0;                   // => no intersect
  //// for a segment, also test if (r > 1.0) => no intersect
  var r = a / b;
  if (r < -EPSILON) {
    return -4;
  }

  //*I = R.P0 + r * dir;            // intersect point of ray and plane
  var I = ray.origin.dup().add(ray.direction.dup().scale(r));

  //// is I inside T?
  //float    uu, uv, vv, wu, wv, D;
  //uu = dot(u,u);
  //uv = dot(u,v);
  //vv = dot(v,v);
  var uu = u.dot(u);
  var uv = u.dot(v);
  var vv = v.dot(v);

  //w = *I - T.V0;
  var w = I.dup().sub(triangle.a);

  //wu = dot(w,u);
  //wv = dot(w,v);
  var wu = w.dot(u);
  var wv = w.dot(v);

  //D = uv * uv - uu * vv;
  var D = uv * uv - uu * vv;

  //// get and test parametric coords
  //float s, t;
  //s = (uv * wv - vv * wu) / D;
  var s = (uv * wv - vv * wu) / D;

  //if (s < 0.0 || s > 1.0)         // I is outside T
  //    return 0;
  if (s < -EPSILON || s > 1.0 + EPSILON) return -5;

  //t = (uv * wu - uu * wv) / D;
  var t = (uv * wu - uu * wv) / D;

  //if (t < 0.0 || (s + t) > 1.0)  // I is outside T
  //    return 0;
  if (t < -EPSILON || (s + t) > 1.0 + EPSILON) {
    return -6;
  }

  //return { s: s, t : t};                       // I is in T

  return u.scale(s).add(v.scale(t)).add(triangle.a);
}

module.exports = Ray;

},{"./Vec3":393}],386:[function(require,module,exports){
//2D Rect (x, y, width, height) or (min, max)
//## Example use
//      var rect = new Rect(new Vec2(-1, -1), new Vec2(1, 1));
//      var point = new Vec2(0.2, 0.9);
//      rect.contains(point); //=> true

//## Reference

var geom = require('pex-geom');
var Vec2 = geom.Vec2;


//## Properties

//### .x - *{ Number }*
//### .y - *{ Number }*
//### .width - *{ Number }*
//### .height - *{ Number }*
//### .min - *{ Vec2 }*
//### .max - *{ Vec2 }*

//### Rect ( min, max )
//`min` - bottom left corner *{ Vec3 }* = ( Infinity, Infinity)  
//`max` - top right corner *{ Vec3 }* = ( -Infinity, -Infinity)  
//
//alternative version of the constructor  
//### Rect ( x, y, width, height )  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`width` - *{ Number }*  
//`height` - *{ Number }*  
function Rect(min, max) {
  if (arguments.length == 0) {
    this.min = new Vec2( Infinity, Infinity);
    this.max = new Vec2(-Infinity, -Infinity);
  }
  else if (arguments.length == 2) {
    this.min = min;
    this.max = max;
  }
  else if (arguments.length == 4) {
    var x = arguments[0];
    var y = arguments[1];
    var w = arguments[2];
    var h = arguments[3];

    this.min = new Vec2(x, y);
    this.max = new Vec2(x + w, y + h);
  }

  Object.defineProperty(this, 'x', {
    set: function(x) {
      var w = this.max.x - this.min.x;
      this.min.x = x;
      this.max.x = x + w;
    },
    get: function() {
      return this.min.x;
    }
  });

  Object.defineProperty(this, 'y', {
    set: function(y) {
      var h = this.max.y - this.min.y;
      this.min.y = y;
      this.max.y = y + h;
    },
    get: function() {
      return this.min.y;
    }
  });

  Object.defineProperty(this, 'width', {
    set: function(w) {
      this.max.x = this.min.x + w;
    },
    get: function() {
      return this.max.x - this.min.x;
    }
  });

  Object.defineProperty(this, 'height', {
    set: function(h) {
      this.max.y = this.min.y + h;
    },
    get: function() {
      return this.max.y - this.min.y;
    }
  });
}

//### set(x, y, width, height)
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`width` - *{ Number }*  
//`height` - *{ Number }*  
Rect.prototype.set = function(x, y, width, height) {
  this.min.x = x;
  this.min.y = y;
  this.max.x = x + width;
  this.max.y = y + height;
};

//### contains(p)
//Returns true if point is inside rectangle, false otherwise  
//`p` - *{ Vec2 }*
Rect.prototype.contains = function(point) {
  return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;
};

//### getCenter(out)
//Returns center of the rectangle  
//`out` - optional vector to save the center to *{ Vec2 }*
Rect.prototype.getCenter = function(out) {
  out = out || new Vec2();
  out.asAdd(this.min, this.max).scale(1/2);
  return out;
}

//### getSize(out)
//Returns size {width, height} of the rectangle  
//`out` - optional vector to save the size to *{ Vec2 }*
Rect.prototype.getSize = function(out) {
  out = out || new Vec2();
  out.asSub(this.max, this.min);
  return out;
}


//### fromPoints(points)
//Creates bounding rectangle from a list of points  
//`points` - *{ Array of Vec2 }*
Rect.fromPoints = function(points) {
  var rect = new Rect();
  var min = rect.min;
  var max = rect.max;
  for(var i=0; i<points.length; i++) {
    var p = points[i];
    min.x = Math.min(min.x, p.x);
    min.y = Math.min(min.y, p.y);
    max.x = Math.max(max.x, p.x);
    max.y = Math.max(max.y, p.y);
  }
  return rect;
}

module.exports = Rect;
},{"pex-geom":376}],387:[function(require,module,exports){
//Camtull-Rom spline implementation  
//Inspired by code from [Tween.js][1]
//[1]: http://sole.github.com/tween.js/examples/05_spline.html

//## Example use 
//
//     var points = [ 
//       -2, 
//       -1, 
//        1, 
//        2
//     ];
//
//     var spline = new Spline1D(points);
//
//     spline.getPointAt(0.25);

//## Reference

//### Spline1D ( points, [ closed ] )
//`points` - *{ Array of Vec3 }* = [ ]  
//`closed` - is the spline a closed loop? *{ Boolean }* = false
function Spline1D(points, closed) {
  this.points = points || [];
  this.dirtyLength = true;
  this.closed = closed || false;
  this.samplesCount = 2000;
}

//### getPoint ( t )
//Gets position based on t-value.
//It is fast, but resulting points will not be evenly distributed.
//
//`t` - *{ Number } <0, 1>*
Spline1D.prototype.getPoint = function ( t ) {
  if (this.closed) {
    t = (t + 1 ) % 1;
  }
  else {
    t = Math.max(0, Math.min(t, 1));
  }

  var points = this.points;
  var len = this.closed ? points.length : points.length - 1;
  var point = t * len;
  var intPoint = Math.floor( point );
  var weight = point - intPoint;

  var c0, c1, c2, c3;
  if (this.closed) {
    c0 = (intPoint - 1 + points.length ) % points.length;
    c1 = intPoint % points.length;
    c2 = (intPoint + 1 ) % points.length;
    c3 = (intPoint + 2 ) % points.length;
  }
  else {
    c0 = intPoint == 0 ? intPoint : intPoint - 1;
    c1 = intPoint;
    c2 = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c3 = intPoint > points.length - 3 ? intPoint : intPoint + 2;
  }

  return this.interpolate( points[ c0 ], points[ c1 ], points[ c2 ], points[ c3 ], weight );
}

//### addPoint ( p )
//Adds point to the spline
//
//`p` - point to be added *{ Vec3 }* 
Spline1D.prototype.addPoint = function ( p ) {
  this.dirtyLength = true;
  this.points.push(p)
}

//### getPointAt ( d )
//Gets position based on d-th of total length of the curve.
//Precise but might be slow at the first use due to need to precalculate length.
//
//`d` - *{ Number } <0, 1>*
Spline1D.prototype.getPointAt = function ( d ) {
  if (this.closed) {
    d = (d + 1 ) % 1;
  }
  else {
    d = Math.max(0, Math.min(d, 1));
  }

  if (this.dirtyLength) {
    this.precalculateLength();
  }

  //TODO: try binary search
  var k = 0;
  for(var i=0; i<this.accumulatedLengthRatios.length; i++) {
    if (this.accumulatedLengthRatios[i] > d - 1/this.samplesCount) {
      k = this.accumulatedRatios[i];
      break;
    }
  }

  return this.getPoint(k);
}

//### getPointAtIndex ( i )
//Returns position of i-th point forming the curve
//
//`i` - *{ Number } <0, Spline1D.points.length)*
Spline1D.prototype.getPointAtIndex = function ( i ) {
  if (i < this.points.length) {
    return this.points[i];
  }
  else {
    return null;
  }
}

//### getNumPoints ( )
//Return number of base points in the spline
Spline1D.prototype.getNumPoints = function() {
  return this.points.length;
}

//### getLength ( )
//Returns the total length of the spline.
Spline1D.prototype.getLength = function() {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  return this.length;
}

//### precalculateLength ( )
//Goes through all the segments of the curve and calculates total length and
//the ratio of each segment.
Spline1D.prototype.precalculateLength = function() {
  var step = 1/this.samplesCount;
  var k = 0;
  var totalLength = 0;
  this.accumulatedRatios = [];
  this.accumulatedLengthRatios = [];
  this.accumulatedLengths = [];

  var point;
  var prevPoint;
  var k = 0;
  for(var i=0; i<this.samplesCount; i++) {
    prevPoint = point;
    point = this.getPoint(k);

    if (i > 0) {
      var len = Math.sqrt(1 + (point - prevPoint)*(point - prevPoint));
      totalLength += len;
    }

    this.accumulatedRatios.push(k);
    this.accumulatedLengths.push(totalLength)

    k += step;
  }

  for(var i=0; i<this.samplesCount; i++) {
    this.accumulatedLengthRatios.push(this.accumulatedLengths[i] / totalLength);
  }

  this.length = totalLength;
  this.dirtyLength = false;
}

//### close ( )
//Closes the spline. It will form a closed now.
Spline1D.prototype.close = function( ) {
  this.closed = true;
}

//### isClosed ( )
//Returns true if spline is closed (forms a closed) *{ Boolean }*
Spline1D.prototype.isClosed = function() {
  return this.closed;
}

//### interpolate ( p0, p1, p2, p3, t)
//Helper function to calculate Catmul-Rom spline equation  
//
//`p0` - previous value *{ Number }*  
//`p1` - current value *{ Number }*  
//`p2` - next value *{ Number }*  
//`p3` - next next value *{ Number }*  
//`t` - parametric distance between p1 and p2 *{ Number } <0, 1>*
Spline1D.prototype.interpolate = function(p0, p1, p2, p3, t) {
  var v0 = ( p2 - p0 ) * 0.5;
  var v1 = ( p3 - p1 ) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
}

module.exports = Spline1D;

},{}],388:[function(require,module,exports){
//Camtull-Rom spline implementation  
//Inspired by code from [Tween.js][1]
//[1]: http://sole.github.com/tween.js/examples/05_spline.html
//## Example use 
//
//     var points = [ 
//       new Vec2(-2,  0), 
//       new Vec2(-1,  0), 
//       new Vec2( 1,  1), 
//       new Vec2( 2, -1) 
//     ];
//
//     var spline = new Spline2D(points);
//
//     spline.getPointAt(0.25);
//## Reference

var Vec2 = require('./Vec2');

//### Spline2D ( points, [ closed ] )
//`points` - *{ Array of Vec2 }* = [ ]  
//`closed` - is the spline a closed loop? *{ Boolean }* = false
function Spline2D(points, closed) {
  this.points = points || [];
  this.dirtyLength = true;
  this.closed = closed || false;
  this.samplesCount = 100;
}
//### getPoint ( t )
//Gets position based on t-value.
//It is fast, but resulting points will not be evenly distributed.
//
//`t` - *{ Number } <0, 1>*
//returns [Vec2](Vec2.html)
Spline2D.prototype.getPoint = function (t) {
  if (this.closed) {
    t = (t + 1) % 1;
  } else {
    t = Math.max(0, Math.min(t, 1));
  }
  var points = this.points;
  var len = this.closed ? points.length : points.length - 1;
  var point = t * len;
  var intPoint = Math.floor(point);
  var weight = point - intPoint;
  var c0, c1, c2, c3;
  if (this.closed) {
    c0 = (intPoint - 1 + points.length) % points.length;
    c1 = intPoint % points.length;
    c2 = (intPoint + 1) % points.length;
    c3 = (intPoint + 2) % points.length;
  } else {
    c0 = intPoint == 0 ? intPoint : intPoint - 1;
    c1 = intPoint;
    c2 = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c3 = intPoint > points.length - 3 ? intPoint : intPoint + 2;
  }
  var vec = new Vec2();
  vec.x = this.interpolate(points[c0].x, points[c1].x, points[c2].x, points[c3].x, weight);
  vec.y = this.interpolate(points[c0].y, points[c1].y, points[c2].y, points[c3].y, weight);
  return vec;
};
//### addPoint ( p )
//Adds point to the spline
//
//`p` - point to be added *{ Vec2 }* 
Spline2D.prototype.addPoint = function (p) {
  this.dirtyLength = true;
  this.points.push(p);
};
//### getPointAt ( d )
//Gets position based on d-th of total length of the curve.
//Precise but might be slow at the first use due to need to precalculate length.
//
//`d` - *{ Number } <0, 1>*
Spline2D.prototype.getPointAt = function (d) {
  if (this.closed) {
    d = (d + 1) % 1;
  } else {
    d = Math.max(0, Math.min(d, 1));
  }
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  //TODO: try binary search
  var k = 0;
  for (var i = 0; i < this.accumulatedLengthRatios.length; i++) {
    if (this.accumulatedLengthRatios[i] > d - 1/this.samplesCount) {
      k = this.accumulatedRatios[i];
      break;
    }
  }
  return this.getPoint(k);
};

//naive implementation
Spline2D.prototype.getClosestPoint = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p };
    }
    else return best;
  }, { dist: Infinity, point: null });
  return closesPoint.point;
}

Spline2D.prototype.getClosestPointRatio = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p, pIndex) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p, index: pIndex };
    }
    else return best;
  }, { dist: Infinity, point: null, index: -1 });
  return this.accumulatedLengthRatios[closesPoint.index];
}

//### getPointAtIndex ( i )
//Returns position of i-th point forming the curve
//
//`i` - *{ Number } <0, Spline2D.points.length)*
Spline2D.prototype.getPointAtIndex = function (i) {
  if (i < this.points.length) {
    return this.points[i];
  } else {
    return null;
  }
};
//### getNumPoints ( )
//Return number of base points in the spline
Spline2D.prototype.getNumPoints = function () {
  return this.points.length;
};
//### getLength ( )
//Returns the total length of the spline.
Spline2D.prototype.getLength = function () {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  return this.length;
};
//### precalculateLength ( )
//Goes through all the segments of the curve and calculates total length and
//the ratio of each segment.
Spline2D.prototype.precalculateLength = function () {
  var step = 1 / this.samplesCount;
  var k = 0;
  var totalLength = 0;
  this.accumulatedRatios = [];
  this.accumulatedLengthRatios = [];
  this.accumulatedLengths = [];
  this.precalculatedPoints = [];
  var point;
  var prevPoint;
  for (var i = 0; i < this.samplesCount; i++) {
    prevPoint = point;
    point = this.getPoint(k);
    if (i > 0) {
      var len = point.dup().sub(prevPoint).length();
      totalLength += len;
    }
    this.accumulatedRatios.push(k);
    this.accumulatedLengths.push(totalLength);
    this.precalculatedPoints.push(point);
    k += step;
  }
  for (var i = 0; i < this.samplesCount; i++) {
    this.accumulatedLengthRatios.push(this.accumulatedLengths[i] / totalLength);
  }
  this.length = totalLength;
  this.dirtyLength = false;
};
//### close ( )
//Closes the spline. It will form a closed now.
Spline2D.prototype.close = function () {
  this.closed = true;
};
//### isClosed ( )
//Returns true if spline is closed (forms a closed) *{ Boolean }*
Spline2D.prototype.isClosed = function () {
  return this.closed;
};
//### interpolate ( p0, p1, p2, p3, t)
//Helper function to calculate Catmul-Rom spline equation  
//
//`p0` - previous value *{ Number }*  
//`p1` - current value *{ Number }*  
//`p2` - next value *{ Number }*  
//`p3` - next next value *{ Number }*  
//`t` - parametric distance between p1 and p2 *{ Number } <0, 1>*
Spline2D.prototype.interpolate = function (p0, p1, p2, p3, t) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = Spline2D;
},{"./Vec2":392}],389:[function(require,module,exports){
//Camtull-Rom spline implementation  
//Inspired by code from [Tween.js][1]
//[1]: http://sole.github.com/tween.js/examples/05_spline.html
//## Example use 
//
//     var points = [ 
//       new Vec3(-2,  0, 0), 
//       new Vec3(-1,  0, 0), 
//       new Vec3( 1,  1, 0), 
//       new Vec3( 2, -1, 0) 
//     ];
//
//     var spline = new Spline3D(points);
//
//     spline.getPointAt(0.25);
//## Reference

var Vec3 = require('./Vec3');

//### Spline3D ( points, [ closed ] )
//`points` - *{ Array of Vec3 }* = [ ]  
//`closed` - is the spline a closed loop? *{ Boolean }* = false
function Spline3D(points, closed) {
  this.points = points || [];
  this.dirtyLength = true;
  this.closed = closed || false;
  this.samplesCount = 1000;
}
//### getPoint ( t )
//Gets position based on t-value.
//It is fast, but resulting points will not be evenly distributed.
//
//`t` - *{ Number } <0, 1>*
//returns [Vec3](Vec3.html)
Spline3D.prototype.getPoint = function (t) {
  if (this.closed) {
    t = (t + 1) % 1;
  } else {
    t = Math.max(0, Math.min(t, 1));
  }
  var points = this.points;
  var len = this.closed ? points.length : points.length - 1;
  var point = t * len;
  var intPoint = Math.floor(point);
  var weight = point - intPoint;
  var c0, c1, c2, c3;
  if (this.closed) {
    c0 = (intPoint - 1 + points.length) % points.length;
    c1 = intPoint % points.length;
    c2 = (intPoint + 1) % points.length;
    c3 = (intPoint + 2) % points.length;
  } else {
    c0 = intPoint == 0 ? intPoint : intPoint - 1;
    c1 = intPoint;
    c2 = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c3 = intPoint > points.length - 3 ? intPoint : intPoint + 2;
  }
  var vec = new Vec3();
  vec.x = this.interpolate(points[c0].x, points[c1].x, points[c2].x, points[c3].x, weight);
  vec.y = this.interpolate(points[c0].y, points[c1].y, points[c2].y, points[c3].y, weight);
  vec.z = this.interpolate(points[c0].z, points[c1].z, points[c2].z, points[c3].z, weight);
  return vec;
};
//### addPoint ( p )
//Adds point to the spline
//
//`p` - point to be added *{ Vec3 }* 
Spline3D.prototype.addPoint = function (p) {
  this.dirtyLength = true;
  this.points.push(p);
};
//### getPointAt ( d )
//Gets position based on d-th of total length of the curve.
//Precise but might be slow at the first use due to need to precalculate length.
//
//`d` - *{ Number } <0, 1>*
Spline3D.prototype.getPointAt = function (d) {
  if (this.closed) {
    d = (d + 1) % 1;
  } else {
    d = Math.max(0, Math.min(d, 1));
  }
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  //TODO: try binary search
  var k = 0;
  for (var i = 0; i < this.accumulatedLengthRatios.length; i++) {
    if (this.accumulatedLengthRatios[i] > d - 1/this.samplesCount) {
      k = this.accumulatedRatios[i];
      break;
    }
  }
  return this.getPoint(k);
};

//naive implementation
Spline3D.prototype.getClosestPoint = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p };
    }
    else return best;
  }, { dist: Infinity, point: null });
  return closesPoint.point;
}

Spline3D.prototype.getClosestPointRatio = function(point) {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  var closesPoint = this.precalculatedPoints.reduce(function(best, p, pIndex) {
    var dist = point.squareDistance(p);
    if (dist < best.dist) {
      return { dist: dist, point: p, index: pIndex };
    }
    else return best;
  }, { dist: Infinity, point: null, index: -1 });
  return this.accumulatedLengthRatios[closesPoint.index];
}

//### getTangentAt ( t )
Spline3D.prototype.getTangentAt = function(t) {
  var currT = (t < 0.99) ? t : t - 0.01;
  var nextT  = (t < 0.99) ? t + 0.01 : t;
  var p = this.getPointAt(currT);
  var np = this.getPointAt(nextT);
  return Vec3.create().asSub(np, p).normalize();
};
//### getPointAtIndex ( i )
//Returns position of i-th point forming the curve
//
//`i` - *{ Number } <0, Spline3D.points.length)*
Spline3D.prototype.getPointAtIndex = function (i) {
  if (i < this.points.length) {
    return this.points[i];
  } else {
    return null;
  }
};
//### getNumPoints ( )
//Return number of base points in the spline
Spline3D.prototype.getNumPoints = function () {
  return this.points.length;
};
//### getLength ( )
//Returns the total length of the spline.
Spline3D.prototype.getLength = function () {
  if (this.dirtyLength) {
    this.precalculateLength();
  }
  return this.length;
};
//### precalculateLength ( )
//Goes through all the segments of the curve and calculates total length and
//the ratio of each segment.
Spline3D.prototype.precalculateLength = function () {
  var step = 1 / this.samplesCount;
  var k = 0;
  var totalLength = 0;
  this.accumulatedRatios = [];
  this.accumulatedLengthRatios = [];
  this.accumulatedLengths = [];
  this.precalculatedPoints = [];
  var point;
  var prevPoint;
  for (var i = 0; i < this.samplesCount; i++) {
    prevPoint = point;
    point = this.getPoint(k);
    if (i > 0) {
      var len = point.dup().sub(prevPoint).length();
      totalLength += len;
    }
    this.accumulatedRatios.push(k);
    this.accumulatedLengths.push(totalLength);
    this.precalculatedPoints.push(point);
    k += step;
  }
  for (var i = 0; i < this.samplesCount; i++) {
    this.accumulatedLengthRatios.push(this.accumulatedLengths[i] / totalLength);
  }
  this.length = totalLength;
  this.dirtyLength = false;
};
//### close ( )
//Closes the spline. It will form a closed now.
Spline3D.prototype.close = function () {
  this.closed = true;
};
//### isClosed ( )
//Returns true if spline is closed (forms a closed) *{ Boolean }*
Spline3D.prototype.isClosed = function () {
  return this.closed;
};
//### interpolate ( p0, p1, p2, p3, t)
//Helper function to calculate Catmul-Rom spline equation  
//
//`p0` - previous value *{ Number }*  
//`p1` - current value *{ Number }*  
//`p2` - next value *{ Number }*  
//`p3` - next next value *{ Number }*  
//`t` - parametric distance between p1 and p2 *{ Number } <0, 1>*
Spline3D.prototype.interpolate = function (p0, p1, p2, p3, t) {
  var v0 = (p2 - p0) * 0.5;
  var v1 = (p3 - p1) * 0.5;
  var t2 = t * t;
  var t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
};

module.exports = Spline3D;
},{"./Vec3":393}],390:[function(require,module,exports){
//2D triangle.
//
//Consists of three 2D points: a, b, c

//## Example use
//     var triangle = new Triangle2D(new Vec2(0, 0, 0), new Vec2(1, 0, 0), new Vec2(1, 1, 0));

//## Reference

//### Triangle2D(a, b, c)
//Constructor  
//`a` - *{ Vec2 }*  
//`b` - *{ Vec2 }*  
//`a` - *{ Vec2 }*  
function Triangle2D(a, b, c) {
  this.a = a;
  this.b = b;
  this.c = c;
}

//### contains(p)
//Returs true if point lies inside the triangle, false otherwise  
//http://stackoverflow.com/a/2049593  
//WARNING doesn't properly handle points on the edge of the triangle  
Triangle2D.prototype.contains = function (p) {
  var signAB = sign(this.a, this.b, p) < 0;
  var signBC = sign(this.b, this.c, p) < 0;
  var signCA = sign(this.c, this.a, p) < 0;
  return signAB == signBC && signBC == signCA;
};

//### getArea()
//Calculates triangle area using Heron's formula  
//http://en.wikipedia.org/wiki/Triangle#Using_Heron.27s_formula  
Triangle2D.prototype.getArea = function() {
  var ab = this.a.distance(this.b);
  var ac = this.a.distance(this.c);
  var bc = this.b.distance(this.c);

  var s = (ab + ac + bc) / 2; //perimeter
  return Math.sqrt(s * (s - ab) * (s - ac) * (s - bc));
}

//Utility function returns *{ Number }* > 0 if point C is on the left side of the AB line, negative if on the right side
function sign(a, b, c) {
  return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);
}

module.exports = Triangle2D;
},{}],391:[function(require,module,exports){
//3D triangle.
//
//Consists of three 3D points: a, b, c

//## Example use
//     var triangle = new Triangle2D(new Vec2(0, 0, 0), new Vec2(1, 0, 0), new Vec2(1, 1, 0));

//## Reference

//### Triangle3D(a, b, c)
//Constructor  
//`a` - *{ Vec3 }*  
//`b` - *{ Vec3 }*  
//`a` - *{ Vec3 }*  
function Triangle3D(a, b, c) {
  this.a = a;
  this.b = b;
  this.c = c;
}

//### getArea()
//Calculates triangle area using Heron's formula
//http://en.wikipedia.org/wiki/Triangle#Using_Heron.27s_formula
Triangle3D.prototype.getArea = function() {
  var ab = this.a.distance(this.b);
  var ac = this.a.distance(this.c);
  var bc = this.b.distance(this.c);

  var s = (ab + ac + bc) / 2; //perimeter
  return Math.sqrt(s * (s - ab) * (s - ac) * (s - bc));
}

module.exports = Triangle3D;
},{}],392:[function(require,module,exports){
//2D Vector (x, y)
//## Example use
//      var position = new Vec2(0, 0);
//      var speed = new Vec2(1, 0);
//      position.addScaled(speed, Time.delta);

//## Reference

//### Vec2(x, y)
//Constructor  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
function Vec2(x, y) {
  this.x = x != null ? x : 0;
  this.y = y != null ? y : 0;
}

//### create(x, y)
//Creates new Vec2 vector x, y numbers 
//`x` - *{ Number }*  
//`y` - *{ Number }*  
Vec2.create = function(x, y) {
  return new Vec2(x, y);
};

//### fromArray(a)
//Creates new Vec2 from an array  
//`a` - *{ Array of Number }*  
Vec2.fromArray = function(a) {
  return new Vec2(a[0], a[1]);
}

//### fromDirection(a)
//Creates new Vec2 from direction  
//`angle` - *{ Number }*  
//`dist` - distance / length of the vector *{ Number }*  
Vec2.fromDirection = function(angle, dist) {
  return new Vec2().setDirection(angle, dist);
}


//### set(x, y, z)
//`x` - *{ Number }*  
//`y` - *{ Number }*  
Vec2.prototype.set = function(x, y) {
  this.x = x;
  this.y = y;
  return this;
};

//### set(v)
//Sets x, y from another Vec2  
//`v` - *{ Vec2 }*  
Vec2.prototype.setVec2 = function(v) {
  this.x = v.x;
  this.y = v.y;
  return this;
};

//### setDirection(a)
//Sets vectors x and y from direction  
//`angle` - *{ Number }*  
//`dist` - distance / length of the vector *{ Number }*  
Vec2.prototype.setDirection = function(angle, dist) {
  dist = dist || 1;

  this.x = dist * Math.cos(angle / 360 * Math.PI * 2);
  this.y = dist * Math.sin(angle / 360 * Math.PI * 2);

  return this;
};

//### equals(v, tolerance)
//Compares this vector to another one with given precision tolerance  
//`v` - *{ Vec2 }*  
//`tolerance` - *{ Number = 0.0000001 }*  
//Returns true if distance between two vectores less than tolerance
Vec2.prototype.equals = function(v, tolerance) {
  if (tolerance == null) {
    tolerance = 0.0000001;
  }
  return (Math.abs(v.x - this.x) <= tolerance) && (Math.abs(v.y - this.y) <= tolerance);
};

//### add(v)
//Add another Vec2 to this one  
//`v` - *{ Vec2 }*
Vec2.prototype.add = function(v) {
  this.x += v.x;
  this.y += v.y;
  return this;
};

//### sub(v)
//Subtracts another vector from this one  
//`v` - *{ Vec2 }*
Vec2.prototype.sub = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  return this;
};

//### sub(v)
//Scales this vector
//`f` - *{ Number }*
Vec2.prototype.scale = function(f) {
  this.x *= f;
  this.y *= f;
  return this;
};

//### distance(v)
//Calculates distance to another vector  
//`v` - *{ Vec2 }*
Vec2.prototype.distance = function(v) {
  var dx = v.x - this.x;
  var dy = v.y - this.y;
  return Math.sqrt(dx * dx + dy * dy);
};

//### squareDistance(v)
//Calculates distance^2 to another vector  
//`v` - *{ Vec2 }*
Vec2.prototype.squareDistance = function(v) {
  var dx = v.x - this.x;
  var dy = v.y - this.y;
  return dx * dx + dy * dy;
};

//### simpleDistance(v)
//Calculates distance to another vecor on the shortest axis  
//`v` - *{ Vec2 }*
Vec2.prototype.simpleDistance = function(v) {
  var dx = Math.abs(v.x - this.x);
  var dy = Math.abs(v.y - this.y);
  return Math.min(dx, dy);
};

//### copy()
//Copies x, y from another vector to this one  
//`v` - *{ Vec2 }*
Vec2.prototype.copy = function(v) {
  this.x = v.x;
  this.y = v.y;
  return this;
};

//### clone()
//Returns new vector with x, y the same as this one
Vec2.prototype.clone = function() {
  return new Vec2(this.x, this.y);
};

//### dup()
//Alias of clone. Returns new vector with x, y the same as this one
Vec2.prototype.dup = function() {
  return this.clone();
};

//### dot(v)
//Computes dot product with another vector  
//`v` - *{ Vec2 }*
//Returns Number
Vec2.prototype.dot = function(b) {
  return this.x * b.x + this.y * b.y;
};

//### asAdd(a, b)
//Sets x, y of this vector to the result of adding two other vectors  
//`a` - *{ Vec2 }*  
//`b` - *{ Vec2 }*  
Vec2.prototype.asAdd = function(a, b) {
  this.x = a.x + b.x;
  this.y = a.y + b.y;
  return this;
};

//### asSub(a, b)
//Sets x, y of this vector to the result of subtracting two other vectors  
//`a` - *{ Vec2 }*  
//`b` - *{ Vec2 }*  
Vec2.prototype.asSub = function(a, b) {
  this.x = a.x - b.x;
  this.y = a.y - b.y;
  return this;
};

//### addScaled(a, f)
//Add another vector with scaling it first  
//`a` - *{ Vec2}*  
//`f` - *{ Number }*  
Vec2.prototype.addScaled = function(a, f) {
  this.x += a.x * f;
  this.y += a.y * f;
  return this;
};

//### add
Vec2.prototype.direction = function() {
  var rad = Math.atan2(this.y, this.x);
  var deg = rad * 180 / Math.PI;
  if (deg < 0) deg = 360 + deg;

  return deg;
};

//### length()
//Computes length of this vector
Vec2.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y);
};

//### lengthSquared()
//Computes length^2 of this vector
Vec2.prototype.lengthSquared = function() {
  return this.x * this.x + this.y * this.y;
};

//### normalize()
//Normalizes this vector (sets length to 1)
Vec2.prototype.normalize = function() {
  var len = this.length();
  if (len > 0) {
    this.scale(1 / len);
  }
  return this;
};

//### normalize()
//Sets length of this vector to a given number  
//`s` - *{ Number }*
Vec2.prototype.limit = function(s) {
  var len = this.length();

  if (len > s && len > 0) {
    this.scale(s / len);
  }

  return this;
};

//### lerp(a, f)
//Interpolates between this and another vector by given factor  
//`v` - *{ Vec2 }*  
//`f` - *{ Number }*  
Vec2.prototype.lerp = function(v, t) {
  this.x = this.x + (v.x - this.x) * t;
  this.y = this.y + (v.y - this.y) * t;
  return this;
}

//### toString()
//Returns string representation of this vector
Vec2.prototype.toString = function() {
  return "{" + Math.floor(this.x*1000)/1000 + ", " + Math.floor(this.y*1000)/1000 + "}";
};

//### hash()
//Returns naive hash string representation of this vector
Vec2.prototype.hash = function() {
  return 1 * this.x + 12 * this.y;
};

Vec2.Zero = new Vec2(0, 0);
Vec2.One  = new Vec2(1, 1);

module.exports = Vec2;

},{}],393:[function(require,module,exports){
//3D Vector (x, y, z)
//## Example use
//      var right = new Vec3(0, 1, 0);
//      var forward = new Vec3(0, 0, -1);
//      var up = Vec3.create().asCross(right, foward);

//## Reference

//### Vec3(x, y, z)
//Constructor  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
function Vec3(x, y, z) {
  this.x = x != null ? x : 0;
  this.y = y != null ? y : 0;
  this.z = z != null ? z : 0;
}

//### create(x, y, z)
//Creates new Vec3 vector from x, y, z numbers  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
Vec3.create = function(x, y, z) {
  return new Vec3(x, y, z);
};

//### fromArray(a)
//Creates new Vec3 from an array  
//`a` - *{ Array of Number }*  
Vec3.fromArray = function(a) {
  return new Vec3(a[0], a[1], a[2]);
}

//### set(x, y, z)
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
Vec3.prototype.set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
  return this;
};

//### set(v)
//Sets x, y, z from another Vec3  
//`v` - *{ Vec3 }*  
Vec3.prototype.setVec3 = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z;
  return this;
};

//### equals(v, tolerance)
//Compares this vector to another one with given precision tolerance  
//`v` - *{ Vec3 }*  
//`tolerance` - *{ Number = 0.0000001 }*  
//Returns true if distance between two vectores less than tolerance
Vec3.prototype.equals = function(v, tolerance) {
  if (tolerance == undefined) {
    tolerance = 0.0000001;
  }
  return (Math.abs(v.x - this.x) <= tolerance) && (Math.abs(v.y - this.y) <= tolerance) && (Math.abs(v.z - this.z) <= tolerance);
};

//### add(v)
//Add another Vec3 to this one  
//`v` - *{ Vec3 }*
Vec3.prototype.add = function(v) {
  this.x += v.x;
  this.y += v.y;
  this.z += v.z;
  return this;
};

//### sub(v)
//Subtracts another vector from this one  
//`v` - *{ Vec3 }*
Vec3.prototype.sub = function(v) {
  this.x -= v.x;
  this.y -= v.y;
  this.z -= v.z;
  return this;
};

//### sub(v)
//Scales this vector
//`f` - *{ Number }*
Vec3.prototype.scale = function(f) {
  this.x *= f;
  this.y *= f;
  this.z *= f;
  return this;
};

//### distance(v)
//Calculates distance to another vector  
//`v` - *{ Vec3 }*
Vec3.prototype.distance = function(v) {
  var dx = v.x - this.x;
  var dy = v.y - this.y;
  var dz = v.z - this.z;
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
};

//### squareDistance(v)
//Calculates distance^2 to another vector  
//`v` - *{ Vec3 }*
Vec3.prototype.squareDistance = function(v) {
  var dx = v.x - this.x;
  var dy = v.y - this.y;
  var dz = v.z - this.z;
  return dx * dx + dy * dy + dz * dz;
};

//### simpleDistance(v)
//Calculates distance to another vecor on the shortest axis  
//`v` - *{ Vec3 }*
Vec3.prototype.simpleDistance = function(v) {
  var dx = Math.abs(v.x - this.x);
  var dy = Math.abs(v.y - this.y);
  var dz = Math.abs(v.z - this.z);
  return Math.min(dx, dy, dz);
};

//### copy()
//Copies x, y from another vector to this one  
//`v` - *{ Vec3 }*
Vec3.prototype.copy = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z;
  return this;
};

//### clone()
//Returns new vector with x, y the same as this one
Vec3.prototype.clone = function() {
  return new Vec3(this.x, this.y, this.z);
};

//### dup()
//Alias of clone. Returns new vector with x, y the same as this one
Vec3.prototype.dup = function() {
  return this.clone();
};

//### dot(v)
//Computes dot product with another vector  
//`v` - *{ Vec3 }*  
//Returns Number
Vec3.prototype.dot = function(b) {
  return this.x * b.x + this.y * b.y + this.z * b.z;
};

//### cross(v)
//Computes cross product with another vector  
//`v` - *{ Vec3 }*  
//Returns Vec3
Vec3.prototype.cross = function(v) {
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var vx = v.x;
  var vy = v.y;
  var vz = v.z;
  this.x = y * vz - z * vy;
  this.y = z * vx - x * vz;
  this.z = x * vy - y * vx;
  return this;
};

//### asAdd(a, b)
//Sets x, y, z of this vector to the result of adding two other vectors  
//`a` - *{ Vec3 }*  
//`b` - *{ Vec3 }*  
Vec3.prototype.asAdd = function(a, b) {
  this.x = a.x + b.x;
  this.y = a.y + b.y;
  this.z = a.z + b.z;
  return this;
};

//### asSub(a, b)
//Sets x, y, z of this vector to the result of subtracting two other vectors  
//`a` - *{ Vec3 }*  
//`b` - *{ Vec3 }*  
Vec3.prototype.asSub = function(a, b) {
  this.x = a.x - b.x;
  this.y = a.y - b.y;
  this.z = a.z - b.z;
  return this;
};

//### asCross(a, b)
//Sets x, y, z of this vector to the result of cross product of two other vectors  
//`a` - *{ Vec3 }*  
//`b` - *{ Vec3 }*  
Vec3.prototype.asCross = function(a, b) {
  return this.copy(a).cross(b);
};

//### addScaled(a, f)
//Add another vector with scaling it first  
//`a` - *{ Vec3 }*  
//`f` - *{ Number }*  
Vec3.prototype.addScaled = function(a, f) {
  this.x += a.x * f;
  this.y += a.y * f;
  this.z += a.z * f;
  return this;
};

//### length()
//Computes length of this vector
Vec3.prototype.length = function() {
  return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
};

//### lengthSquared()
//Computes length^2 of this vector
Vec3.prototype.lengthSquared = function() {
  return this.x * this.x + this.y * this.y + this.z * this.z;
};

//### normalize()
//Normalizes this vector (sets length to 1)
Vec3.prototype.normalize = function() {
  var len = this.length();
  if (len > 0) {
    this.scale(1 / len);
  }
  return this;
};

//### normalize()
//Sets length of this vector to a given number  
//`s` - *{ Number }*
Vec3.prototype.limit = function(s) {
  var len = this.length();

  if (len > s && len > 0) {
    this.scale(s / len);
  }

  return this;
};

//### lerp(a, f)
//Interpolates between this and another vector by given factor  
//`v` - *{ Vec3 }*  
//`f` - *{ Number }*  
Vec3.prototype.lerp = function(v, t) {
  this.x = this.x + (v.x - this.x) * t;
  this.y = this.y + (v.y - this.y) * t;
  this.z = this.z + (v.z - this.z) * t;
  return this;
}

//### transformMat4
//Transforms this vector by given matrix  
//`m` - *{ Mat4 }*
Vec3.prototype.transformMat4 = function(m) {
  var x = m.a14 + m.a11 * this.x + m.a12 * this.y + m.a13 * this.z;
  var y = m.a24 + m.a21 * this.x + m.a22 * this.y + m.a23 * this.z;
  var z = m.a34 + m.a31 * this.x + m.a32 * this.y + m.a33 * this.z;
  this.x = x;
  this.y = y;
  this.z = z;
  return this;
};

//### transformQuat
//Transforms this vector by given quaternion  
//`m` - *{ Quat }*
Vec3.prototype.transformQuat = function(q) {
  var x = this.x;
  var y = this.y;
  var z = this.z;
  var qx = q.x;
  var qy = q.y;
  var qz = q.z;
  var qw = q.w;
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  return this;
};

//### toString()
//Returns string representation of this vector
Vec3.prototype.toString = function() {
  return "{" + Math.floor(this.x*1000)/1000 + ", " + Math.floor(this.y*1000)/1000 + ", " + Math.floor(this.z*1000)/1000 + "}";
};

//### hash()
//Returns naive hash string representation of this vector
Vec3.prototype.hash = function() {
  return 1 * this.x + 12 * this.y + 123 * this.z;
};

Vec3.Zero = new Vec3(0, 0, 0);
Vec3.One  = new Vec3(1, 1, 1);

module.exports = Vec3;

},{}],394:[function(require,module,exports){
//4D Vector (x, y, z, w)
//## Example use
//      var a = new Vec4(0.2, 0.4, 3.3, 1.0);

//## Reference

//### Vec4(x, y, z, w)
//Constructor  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//`w` - *{ Number }*  
function Vec4(x, y, z, w) {
  this.x = x != null ? x : 0;
  this.y = y != null ? y : 0;
  this.z = z != null ? z : 0;
  this.w = w != null ? w : 0;
}

//### create(x, y, z)
//Creates new Vec4 vector x, y, z, w numbers  
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//`w` - *{ Number }*  
Vec4.create = function(x, y, z, w) {
  return new Vec4(x, y, z, w);
};

//### fromArray(a)
//Creates new Vec4 from an array  
//`a` - *{ Array of Number }*  
Vec4.fromArray = function(a) {
  return new Vec4(a[0], a[1], a[2], a[3]);
}

//### set(x, y, z, w)
//`x` - *{ Number }*  
//`y` - *{ Number }*  
//`z` - *{ Number }*  
//`w` - *{ Number }*  
Vec4.prototype.set = function(x, y, z, w) {
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;
  return this;
};

//### set(v)
//Sets x, y, z, w from another Vec4  
//`v` - *{ Vec4 }*  
Vec4.prototype.setVec4 = function(v) {
  this.x = v.x;
  this.y = v.y;
  this.z = v.z;
  this.w = v.w;
  return this;
};

//### equals(v, tolerance)
//Compares this vector to another one with given precision tolerance  
//`v` - *{ Vec4 }*  
//`tolerance` - *{ Number = 0.0000001 }*  
//Returns true if distance between two vectores less than tolerance
Vec4.prototype.equals = function(v, tolerance) {
  if (tolerance == null) {
    tolerance = 0.0000001;
  }
  return (Math.abs(v.x - this.x) <= tolerance) && (Math.abs(v.y - this.y) <= tolerance) && (Math.abs(v.z - this.z) <= tolerance) && (Math.abs(v.w - this.w) <= tolerance);
};

//### transformMat4
//Transforms this vector by given matrix  
//`m` - *{ Mat4 }*
Vec4.prototype.transformMat4 = function(m) {
  var x = m.a14 * this.w + m.a11 * this.x + m.a12 * this.y + m.a13 * this.z;
  var y = m.a24 * this.w + m.a21 * this.x + m.a22 * this.y + m.a23 * this.z;
  var z = m.a34 * this.w + m.a31 * this.x + m.a32 * this.y + m.a33 * this.z;
  var w = m.a44 * this.w + m.a41 * this.x + m.a42 * this.y + m.a43 * this.z;
  this.x = x;
  this.y = y;
  this.z = z;
  this.w = w;
  return this;
};

//### toString()
//Returns string representation of this vector
Vec4.prototype.toString = function() {
  return "{" + Math.floor(this.x*1000)/1000 + ", " + Math.floor(this.y*1000)/1000 + ", " + Math.floor(this.z*1000)/1000 + ", " + Math.floor(this.w*1000)/1000 + "}";
};

//### hash()
//Returns naive hash string representation of this vector
Vec4.prototype.hash = function() {
  return 1 * this.x + 12 * this.y + 123 * this.z + 1234 * this.w;
};

Vec4.Zero = new Vec4(0, 0, 0, 0);
Vec4.One  = new Vec4(1, 1, 1, 1);

module.exports = Vec4;

},{}],395:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],396:[function(require,module,exports){
arguments[4][20][0].apply(exports,arguments)
},{"./pseudomap":397,"_process":395,"dup":20}],397:[function(require,module,exports){
arguments[4][21][0].apply(exports,arguments)
},{"dup":21}],398:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],399:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],400:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":398,"./encode":399}],401:[function(require,module,exports){
(function (global){
var now = require('performance-now')
  , root = typeof window === 'undefined' ? global : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = root['request' + suffix]
  , caf = root['cancel' + suffix] || root['cancelRequest' + suffix]

for(var i = 0; !raf && i < vendors.length; i++) {
  raf = root[vendors[i] + 'Request' + suffix]
  caf = root[vendors[i] + 'Cancel' + suffix]
      || root[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  return raf.call(root, fn)
}
module.exports.cancel = function() {
  caf.apply(root, arguments)
}
module.exports.polyfill = function() {
  root.requestAnimationFrame = raf
  root.cancelAnimationFrame = caf
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"performance-now":375}],402:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domAlign = require('dom-align');

var _domAlign2 = _interopRequireDefault(_domAlign);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _isWindow = require('./isWindow');

var _isWindow2 = _interopRequireDefault(_isWindow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function buffer(fn, ms) {
  var timer = void 0;

  function clear() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }

  function bufferFn() {
    clear();
    timer = setTimeout(fn, ms);
  }

  bufferFn.clear = clear;

  return bufferFn;
}

var Align = _react2["default"].createClass({
  displayName: 'Align',

  propTypes: {
    childrenProps: _react.PropTypes.object,
    align: _react.PropTypes.object.isRequired,
    target: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    monitorBufferTime: _react.PropTypes.number,
    monitorWindowResize: _react.PropTypes.bool,
    disabled: _react.PropTypes.bool,
    children: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      target: function target() {
        return window;
      },
      onAlign: function onAlign() {},

      monitorBufferTime: 50,
      monitorWindowResize: false,
      disabled: false
    };
  },
  componentDidMount: function componentDidMount() {
    var props = this.props;
    // if parent ref not attached .... use document.getElementById
    this.forceAlign();
    if (!props.disabled && props.monitorWindowResize) {
      this.startMonitorWindowResize();
    }
  },
  componentDidUpdate: function componentDidUpdate(prevProps) {
    var reAlign = false;
    var props = this.props;

    if (!props.disabled) {
      if (prevProps.disabled || prevProps.align !== props.align) {
        reAlign = true;
      } else {
        var lastTarget = prevProps.target();
        var currentTarget = props.target();
        if ((0, _isWindow2["default"])(lastTarget) && (0, _isWindow2["default"])(currentTarget)) {
          reAlign = false;
        } else if (lastTarget !== currentTarget) {
          reAlign = true;
        }
      }
    }

    if (reAlign) {
      this.forceAlign();
    }

    if (props.monitorWindowResize && !props.disabled) {
      this.startMonitorWindowResize();
    } else {
      this.stopMonitorWindowResize();
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.stopMonitorWindowResize();
  },
  startMonitorWindowResize: function startMonitorWindowResize() {
    if (!this.resizeHandler) {
      this.bufferMonitor = buffer(this.forceAlign, this.props.monitorBufferTime);
      this.resizeHandler = (0, _addEventListener2["default"])(window, 'resize', this.bufferMonitor);
    }
  },
  stopMonitorWindowResize: function stopMonitorWindowResize() {
    if (this.resizeHandler) {
      this.bufferMonitor.clear();
      this.resizeHandler.remove();
      this.resizeHandler = null;
    }
  },
  forceAlign: function forceAlign() {
    var props = this.props;
    if (!props.disabled) {
      var source = _reactDom2["default"].findDOMNode(this);
      props.onAlign(source, (0, _domAlign2["default"])(source, props.target(), props.align));
    }
  },
  render: function render() {
    var _props = this.props,
        childrenProps = _props.childrenProps,
        children = _props.children;

    var child = _react2["default"].Children.only(children);
    if (childrenProps) {
      var newProps = {};
      for (var prop in childrenProps) {
        if (childrenProps.hasOwnProperty(prop)) {
          newProps[prop] = this.props[childrenProps[prop]];
        }
      }
      return _react2["default"].cloneElement(child, newProps);
    }
    return child;
  }
});

exports["default"] = Align;
module.exports = exports['default'];
},{"./isWindow":404,"dom-align":250,"rc-util/lib/Dom/addEventListener":405,"react":"react","react-dom":"react-dom"}],403:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Align = require('./Align');

var _Align2 = _interopRequireDefault(_Align);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

exports["default"] = _Align2["default"]; // export this package's api

module.exports = exports['default'];
},{"./Align":402}],404:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isWindow;
function isWindow(obj) {
  /* eslint no-eq-null: 0 */
  /* eslint eqeqeq: 0 */
  return obj != null && obj == obj.window;
}
module.exports = exports['default'];
},{}],405:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = addEventListenerWrap;

var _addDomEventListener = require('add-dom-event-listener');

var _addDomEventListener2 = _interopRequireDefault(_addDomEventListener);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function addEventListenerWrap(target, eventType, cb) {
  /* eslint camelcase: 2 */
  var callback = _reactDom2["default"].unstable_batchedUpdates ? function run(e) {
    _reactDom2["default"].unstable_batchedUpdates(cb, e);
  } : cb;
  return (0, _addDomEventListener2["default"])(target, eventType, callback);
}
module.exports = exports['default'];
},{"add-dom-event-listener":25,"react-dom":"react-dom"}],406:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _ChildrenUtils = require('./ChildrenUtils');

var _AnimateChild = require('./AnimateChild');

var _AnimateChild2 = _interopRequireDefault(_AnimateChild);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var defaultKey = 'rc_animate_' + Date.now();


function getChildrenFromProps(props) {
  var children = props.children;
  if (_react2["default"].isValidElement(children)) {
    if (!children.key) {
      return _react2["default"].cloneElement(children, {
        key: defaultKey
      });
    }
  }
  return children;
}

function noop() {}

var Animate = _react2["default"].createClass({
  displayName: 'Animate',

  propTypes: {
    component: _react2["default"].PropTypes.any,
    animation: _react2["default"].PropTypes.object,
    transitionName: _react2["default"].PropTypes.oneOfType([_react2["default"].PropTypes.string, _react2["default"].PropTypes.object]),
    transitionEnter: _react2["default"].PropTypes.bool,
    transitionAppear: _react2["default"].PropTypes.bool,
    exclusive: _react2["default"].PropTypes.bool,
    transitionLeave: _react2["default"].PropTypes.bool,
    onEnd: _react2["default"].PropTypes.func,
    onEnter: _react2["default"].PropTypes.func,
    onLeave: _react2["default"].PropTypes.func,
    onAppear: _react2["default"].PropTypes.func,
    showProp: _react2["default"].PropTypes.string
  },

  getDefaultProps: function getDefaultProps() {
    return {
      animation: {},
      component: 'span',
      transitionEnter: true,
      transitionLeave: true,
      transitionAppear: false,
      onEnd: noop,
      onEnter: noop,
      onLeave: noop,
      onAppear: noop
    };
  },
  getInitialState: function getInitialState() {
    this.currentlyAnimatingKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
    return {
      children: (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(this.props))
    };
  },
  componentDidMount: function componentDidMount() {
    var _this = this;

    var showProp = this.props.showProp;
    var children = this.state.children;
    if (showProp) {
      children = children.filter(function (child) {
        return !!child.props[showProp];
      });
    }
    children.forEach(function (child) {
      if (child) {
        _this.performAppear(child.key);
      }
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    var _this2 = this;

    this.nextProps = nextProps;
    var nextChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(nextProps));
    var props = this.props;
    // exclusive needs immediate response
    if (props.exclusive) {
      Object.keys(this.currentlyAnimatingKeys).forEach(function (key) {
        _this2.stop(key);
      });
    }
    var showProp = props.showProp;
    var currentlyAnimatingKeys = this.currentlyAnimatingKeys;
    // last props children if exclusive
    var currentChildren = props.exclusive ? (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props)) : this.state.children;
    // in case destroy in showProp mode
    var newChildren = [];
    if (showProp) {
      currentChildren.forEach(function (currentChild) {
        var nextChild = currentChild && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, currentChild.key);
        var newChild = void 0;
        if ((!nextChild || !nextChild.props[showProp]) && currentChild.props[showProp]) {
          newChild = _react2["default"].cloneElement(nextChild || currentChild, _defineProperty({}, showProp, true));
        } else {
          newChild = nextChild;
        }
        if (newChild) {
          newChildren.push(newChild);
        }
      });
      nextChildren.forEach(function (nextChild) {
        if (!nextChild || !(0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, nextChild.key)) {
          newChildren.push(nextChild);
        }
      });
    } else {
      newChildren = (0, _ChildrenUtils.mergeChildren)(currentChildren, nextChildren);
    }

    // need render to avoid update
    this.setState({
      children: newChildren
    });

    nextChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasPrev = child && (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
      if (showProp) {
        var showInNext = child.props[showProp];
        if (hasPrev) {
          var showInNow = (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
          if (!showInNow && showInNext) {
            _this2.keysToEnter.push(key);
          }
        } else if (showInNext) {
          _this2.keysToEnter.push(key);
        }
      } else if (!hasPrev) {
        _this2.keysToEnter.push(key);
      }
    });

    currentChildren.forEach(function (child) {
      var key = child && child.key;
      if (child && currentlyAnimatingKeys[key]) {
        return;
      }
      var hasNext = child && (0, _ChildrenUtils.findChildInChildrenByKey)(nextChildren, key);
      if (showProp) {
        var showInNow = child.props[showProp];
        if (hasNext) {
          var showInNext = (0, _ChildrenUtils.findShownChildInChildrenByKey)(nextChildren, key, showProp);
          if (!showInNext && showInNow) {
            _this2.keysToLeave.push(key);
          }
        } else if (showInNow) {
          _this2.keysToLeave.push(key);
        }
      } else if (!hasNext) {
        _this2.keysToLeave.push(key);
      }
    });
  },
  componentDidUpdate: function componentDidUpdate() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);
    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  },
  performEnter: function performEnter(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillEnter(this.handleDoneAdding.bind(this, key, 'enter'));
    }
  },
  performAppear: function performAppear(key) {
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillAppear(this.handleDoneAdding.bind(this, key, 'appear'));
    }
  },
  handleDoneAdding: function handleDoneAdding(key, type) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    if (!this.isValidChildByKey(currentChildren, key)) {
      // exclusive will not need this
      this.performLeave(key);
    } else {
      if (type === 'appear') {
        if (_util2["default"].allowAppearCallback(props)) {
          props.onAppear(key);
          props.onEnd(key, true);
        }
      } else {
        if (_util2["default"].allowEnterCallback(props)) {
          props.onEnter(key);
          props.onEnd(key, true);
        }
      }
    }
  },
  performLeave: function performLeave(key) {
    // may already remove by exclusive
    if (this.refs[key]) {
      this.currentlyAnimatingKeys[key] = true;
      this.refs[key].componentWillLeave(this.handleDoneLeaving.bind(this, key));
    }
  },
  handleDoneLeaving: function handleDoneLeaving(key) {
    var props = this.props;
    delete this.currentlyAnimatingKeys[key];
    // if update on exclusive mode, skip check
    if (props.exclusive && props !== this.nextProps) {
      return;
    }
    var currentChildren = (0, _ChildrenUtils.toArrayChildren)(getChildrenFromProps(props));
    // in case state change is too fast
    if (this.isValidChildByKey(currentChildren, key)) {
      this.performEnter(key);
    } else {
      var end = function end() {
        if (_util2["default"].allowLeaveCallback(props)) {
          props.onLeave(key);
          props.onEnd(key, false);
        }
      };
      /* eslint react/no-is-mounted:0 */
      if (this.isMounted() && !(0, _ChildrenUtils.isSameChildren)(this.state.children, currentChildren, props.showProp)) {
        this.setState({
          children: currentChildren
        }, end);
      } else {
        end();
      }
    }
  },
  isValidChildByKey: function isValidChildByKey(currentChildren, key) {
    var showProp = this.props.showProp;
    if (showProp) {
      return (0, _ChildrenUtils.findShownChildInChildrenByKey)(currentChildren, key, showProp);
    }
    return (0, _ChildrenUtils.findChildInChildrenByKey)(currentChildren, key);
  },
  stop: function stop(key) {
    delete this.currentlyAnimatingKeys[key];
    var component = this.refs[key];
    if (component) {
      component.stop();
    }
  },
  render: function render() {
    var props = this.props;
    this.nextProps = props;
    var stateChildren = this.state.children;
    var children = null;
    if (stateChildren) {
      children = stateChildren.map(function (child) {
        if (child === null || child === undefined) {
          return child;
        }
        if (!child.key) {
          throw new Error('must set key for <rc-animate> children');
        }
        return _react2["default"].createElement(
          _AnimateChild2["default"],
          {
            key: child.key,
            ref: child.key,
            animation: props.animation,
            transitionName: props.transitionName,
            transitionEnter: props.transitionEnter,
            transitionAppear: props.transitionAppear,
            transitionLeave: props.transitionLeave
          },
          child
        );
      });
    }
    var Component = props.component;
    if (Component) {
      var passedProps = props;
      if (typeof Component === 'string') {
        passedProps = {
          className: props.className,
          style: props.style
        };
      }
      return _react2["default"].createElement(
        Component,
        passedProps,
        children
      );
    }
    return children[0] || null;
  }
});

exports["default"] = Animate;
module.exports = exports['default'];
},{"./AnimateChild":407,"./ChildrenUtils":408,"./util":410,"react":"react"}],407:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _cssAnimation = require('css-animation');

var _cssAnimation2 = _interopRequireDefault(_cssAnimation);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var transitionMap = {
  enter: 'transitionEnter',
  appear: 'transitionAppear',
  leave: 'transitionLeave'
};

var AnimateChild = _react2["default"].createClass({
  displayName: 'AnimateChild',

  propTypes: {
    children: _react2["default"].PropTypes.any
  },

  componentWillUnmount: function componentWillUnmount() {
    this.stop();
  },
  componentWillEnter: function componentWillEnter(done) {
    if (_util2["default"].isEnterSupported(this.props)) {
      this.transition('enter', done);
    } else {
      done();
    }
  },
  componentWillAppear: function componentWillAppear(done) {
    if (_util2["default"].isAppearSupported(this.props)) {
      this.transition('appear', done);
    } else {
      done();
    }
  },
  componentWillLeave: function componentWillLeave(done) {
    if (_util2["default"].isLeaveSupported(this.props)) {
      this.transition('leave', done);
    } else {
      // always sync, do not interupt with react component life cycle
      // update hidden -> animate hidden ->
      // didUpdate -> animate leave -> unmount (if animate is none)
      done();
    }
  },
  transition: function transition(animationType, finishCallback) {
    var _this = this;

    var node = _reactDom2["default"].findDOMNode(this);
    var props = this.props;
    var transitionName = props.transitionName;
    var nameIsObj = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) === 'object';
    this.stop();
    var end = function end() {
      _this.stopper = null;
      finishCallback();
    };
    if ((_cssAnimation.isCssAnimationSupported || !props.animation[animationType]) && transitionName && props[transitionMap[animationType]]) {
      var name = nameIsObj ? transitionName[animationType] : transitionName + '-' + animationType;
      var activeName = name + '-active';
      if (nameIsObj && transitionName[animationType + 'Active']) {
        activeName = transitionName[animationType + 'Active'];
      }
      this.stopper = (0, _cssAnimation2["default"])(node, {
        name: name,
        active: activeName
      }, end);
    } else {
      this.stopper = props.animation[animationType](node, end);
    }
  },
  stop: function stop() {
    var stopper = this.stopper;
    if (stopper) {
      this.stopper = null;
      stopper.stop();
    }
  },
  render: function render() {
    return this.props.children;
  }
});

exports["default"] = AnimateChild;
module.exports = exports['default'];
},{"./util":410,"css-animation":129,"react":"react","react-dom":"react-dom"}],408:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toArrayChildren = toArrayChildren;
exports.findChildInChildrenByKey = findChildInChildrenByKey;
exports.findShownChildInChildrenByKey = findShownChildInChildrenByKey;
exports.findHiddenChildInChildrenByKey = findHiddenChildInChildrenByKey;
exports.isSameChildren = isSameChildren;
exports.mergeChildren = mergeChildren;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function toArrayChildren(children) {
  var ret = [];
  _react2["default"].Children.forEach(children, function (child) {
    ret.push(child);
  });
  return ret;
}

function findChildInChildrenByKey(children, key) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (ret) {
        return;
      }
      if (child && child.key === key) {
        ret = child;
      }
    });
  }
  return ret;
}

function findShownChildInChildrenByKey(children, key, showProp) {
  var ret = null;
  if (children) {
    children.forEach(function (child) {
      if (child && child.key === key && child.props[showProp]) {
        if (ret) {
          throw new Error('two child with same key for <rc-animate> children');
        }
        ret = child;
      }
    });
  }
  return ret;
}

function findHiddenChildInChildrenByKey(children, key, showProp) {
  var found = 0;
  if (children) {
    children.forEach(function (child) {
      if (found) {
        return;
      }
      found = child && child.key === key && !child.props[showProp];
    });
  }
  return found;
}

function isSameChildren(c1, c2, showProp) {
  var same = c1.length === c2.length;
  if (same) {
    c1.forEach(function (child, index) {
      var child2 = c2[index];
      if (child && child2) {
        if (child && !child2 || !child && child2) {
          same = false;
        } else if (child.key !== child2.key) {
          same = false;
        } else if (showProp && child.props[showProp] !== child2.props[showProp]) {
          same = false;
        }
      }
    });
  }
  return same;
}

function mergeChildren(prev, next) {
  var ret = [];

  // For each key of `next`, the list of keys to insert before that key in
  // the combined list
  var nextChildrenPending = {};
  var pendingChildren = [];
  prev.forEach(function (child) {
    if (child && findChildInChildrenByKey(next, child.key)) {
      if (pendingChildren.length) {
        nextChildrenPending[child.key] = pendingChildren;
        pendingChildren = [];
      }
    } else {
      pendingChildren.push(child);
    }
  });

  next.forEach(function (child) {
    if (child && nextChildrenPending.hasOwnProperty(child.key)) {
      ret = ret.concat(nextChildrenPending[child.key]);
    }
    ret.push(child);
  });

  ret = ret.concat(pendingChildren);

  return ret;
}
},{"react":"react"}],409:[function(require,module,exports){
'use strict';

// export this package's api
module.exports = require('./Animate');
},{"./Animate":406}],410:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var util = {
  isAppearSupported: function isAppearSupported(props) {
    return props.transitionName && props.transitionAppear || props.animation.appear;
  },
  isEnterSupported: function isEnterSupported(props) {
    return props.transitionName && props.transitionEnter || props.animation.enter;
  },
  isLeaveSupported: function isLeaveSupported(props) {
    return props.transitionName && props.transitionLeave || props.animation.leave;
  },
  allowAppearCallback: function allowAppearCallback(props) {
    return props.transitionAppear || props.animation.appear;
  },
  allowEnterCallback: function allowEnterCallback(props) {
    return props.transitionEnter || props.animation.enter;
  },
  allowLeaveCallback: function allowLeaveCallback(props) {
    return props.transitionLeave || props.animation.leave;
  }
};
exports["default"] = util;
module.exports = exports['default'];
},{}],411:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcTooltip = require('rc-tooltip');

var _rcTooltip2 = _interopRequireDefault(_rcTooltip);

var Handle = (function (_React$Component) {
  _inherits(Handle, _React$Component);

  function Handle(props) {
    _classCallCheck(this, Handle);

    _get(Object.getPrototypeOf(Handle.prototype), 'constructor', this).call(this, props);

    this.state = {
      isTooltipVisible: false
    };
  }

  _createClass(Handle, [{
    key: 'showTooltip',
    value: function showTooltip() {
      this.setState({
        isTooltipVisible: true
      });
    }
  }, {
    key: 'hideTooltip',
    value: function hideTooltip() {
      this.setState({
        isTooltipVisible: false
      });
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props;
      var prefixCls = _props.prefixCls;
      var className = _props.className;
      var tipTransitionName = _props.tipTransitionName;
      var tipFormatter = _props.tipFormatter;
      var vertical = _props.vertical;
      var offset = _props.offset;
      var value = _props.value;
      var dragging = _props.dragging;
      var noTip = _props.noTip;

      var style = vertical ? { bottom: offset + '%' } : { left: offset + '%' };
      var handle = _react2['default'].createElement('div', { className: className, style: style,
        onMouseUp: this.showTooltip.bind(this),
        onMouseEnter: this.showTooltip.bind(this),
        onMouseLeave: this.hideTooltip.bind(this)
      });

      if (noTip) {
        return handle;
      }

      var isTooltipVisible = dragging || this.state.isTooltipVisible;
      return _react2['default'].createElement(
        _rcTooltip2['default'],
        {
          prefixCls: prefixCls.replace('slider', 'tooltip'),
          placement: 'top',
          visible: isTooltipVisible,
          overlay: _react2['default'].createElement(
            'span',
            null,
            tipFormatter(value)
          ),
          delay: 0,
          transitionName: tipTransitionName
        },
        handle
      );
    }
  }]);

  return Handle;
})(_react2['default'].Component);

exports['default'] = Handle;

Handle.propTypes = {
  prefixCls: _react2['default'].PropTypes.string,
  className: _react2['default'].PropTypes.string,
  vertical: _react2['default'].PropTypes.bool,
  offset: _react2['default'].PropTypes.number,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  value: _react2['default'].PropTypes.number,
  dragging: _react2['default'].PropTypes.bool,
  noTip: _react2['default'].PropTypes.bool
};
module.exports = exports['default'];
},{"rc-tooltip":418,"react":"react"}],412:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var Marks = function Marks(_ref) {
  var className = _ref.className;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var included = _ref.included;
  var upperBound = _ref.upperBound;
  var lowerBound = _ref.lowerBound;
  var max = _ref.max;
  var min = _ref.min;

  var marksKeys = Object.keys(marks);
  var marksCount = marksKeys.length;
  var unit = 100 / (marksCount - 1);
  var markWidth = unit * 0.9;

  var range = max - min;
  var elements = marksKeys.map(parseFloat).sort(function (a, b) {
    return a - b;
  }).map(function (point) {
    var _classNames;

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var markClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, className + '-text', true), _defineProperty(_classNames, className + '-text-active', isActived), _classNames));

    var bottomStyle = {
      // height: markWidth + '%',
      marginBottom: '-200' + '%',
      bottom: (point - min) / range * 100 + '%'
    };

    var leftStyle = {
      width: markWidth + '%',
      marginLeft: -markWidth / 2 + '%',
      left: (point - min) / range * 100 + '%'
    };

    var style = vertical ? bottomStyle : leftStyle;

    var markPoint = marks[point];
    var markPointIsObject = typeof markPoint === 'object' && !_react2['default'].isValidElement(markPoint);
    var markLabel = markPointIsObject ? markPoint.label : markPoint;
    var markStyle = markPointIsObject ? _extends({}, style, markPoint.style) : style;
    return _react2['default'].createElement(
      'span',
      { className: markClassName, style: markStyle, key: point },
      markLabel
    );
  });

  return _react2['default'].createElement(
    'div',
    { className: className },
    elements
  );
};

exports['default'] = Marks;
module.exports = exports['default'];
},{"classnames":118,"react":"react"}],413:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _rcUtilLibDomAddEventListener = require('rc-util/lib/Dom/addEventListener');

var _rcUtilLibDomAddEventListener2 = _interopRequireDefault(_rcUtilLibDomAddEventListener);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Track = require('./Track');

var _Track2 = _interopRequireDefault(_Track);

var _Handle = require('./Handle');

var _Handle2 = _interopRequireDefault(_Handle);

var _Steps = require('./Steps');

var _Steps2 = _interopRequireDefault(_Steps);

var _Marks = require('./Marks');

var _Marks2 = _interopRequireDefault(_Marks);

function noop() {}

function isNotTouchEvent(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === 'touchend' && e.touches.length > 0;
}

function getTouchPosition(vertical, e) {
  return vertical ? e.touches[0].clientY : e.touches[0].pageX;
}

function getMousePosition(vertical, e) {
  return vertical ? e.clientY : e.pageX;
}

function pauseEvent(e) {
  e.stopPropagation();
  e.preventDefault();
}

var Slider = (function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this, props);

    var range = props.range;
    var min = props.min;
    var max = props.max;

    var initialValue = range ? [min, min] : min;
    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;
    var value = props.value !== undefined ? props.value : defaultValue;

    var upperBound = undefined;
    var lowerBound = undefined;
    if (props.range) {
      lowerBound = this.trimAlignValue(value[0]);
      upperBound = this.trimAlignValue(value[1]);
    } else {
      upperBound = this.trimAlignValue(value);
    }

    var recent = undefined;
    if (props.range && upperBound === lowerBound) {
      recent = lowerBound === max ? 'lowerBound' : 'upperBound';
    } else {
      recent = 'upperBound';
    }

    this.state = {
      handle: null,
      recent: recent,
      upperBound: upperBound,
      // If Slider is not range, set `lowerBound` equal to `min`.
      lowerBound: lowerBound || min
    };
  }

  _createClass(Slider, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;

      var _state = this.state;
      var lowerBound = _state.lowerBound;
      var upperBound = _state.upperBound;

      if (nextProps.range) {
        var value = nextProps.value || [lowerBound, upperBound];
        var nextUpperBound = this.trimAlignValue(value[1], nextProps);
        var nextLowerBound = this.trimAlignValue(value[0], nextProps);
        if (nextLowerBound === lowerBound && nextUpperBound === upperBound) return;

        this.setState({
          upperBound: nextUpperBound,
          lowerBound: nextLowerBound
        });
        if (this.isValueOutOfBounds(upperBound, nextProps) || this.isValueOutOfBounds(lowerBound, nextProps)) {
          this.props.onChange([nextLowerBound, nextUpperBound]);
        }
      } else {
        var value = nextProps.value !== undefined ? nextProps.value : upperBound;
        var nextValue = this.trimAlignValue(value, nextProps);
        if (nextValue === upperBound && lowerBound === nextProps.min) return;

        this.setState({
          upperBound: nextValue,
          lowerBound: nextProps.min
        });
        if (this.isValueOutOfBounds(upperBound, nextProps)) {
          this.props.onChange(nextValue);
        }
      }
    }
  }, {
    key: 'onChange',
    value: function onChange(state) {
      var props = this.props;
      var isNotControlled = !('value' in props);
      if (isNotControlled) {
        this.setState(state);
      } else if (state.handle) {
        this.setState({ handle: state.handle });
      }

      var data = _extends({}, this.state, state);
      var changedValue = props.range ? [data.lowerBound, data.upperBound] : data.upperBound;
      props.onChange(changedValue);
    }
  }, {
    key: 'onMouseMove',
    value: function onMouseMove(e) {
      var position = getMousePosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(e) {
      if (isNotTouchEvent(e)) {
        this.end('touch');
        return;
      }

      var position = getTouchPosition(this.props.vertical, e);
      this.onMove(e, position);
    }
  }, {
    key: 'onMove',
    value: function onMove(e, position) {
      pauseEvent(e);
      var props = this.props;
      var state = this.state;

      var diffPosition = position - this.startPosition;
      diffPosition = this.props.vertical ? -diffPosition : diffPosition;
      var diffValue = diffPosition / this.getSliderLength() * (props.max - props.min);

      var value = this.trimAlignValue(this.startValue + diffValue);
      var oldValue = state[state.handle];
      if (value === oldValue) return;

      if (props.allowCross && value < state.lowerBound && state.handle === 'upperBound') {
        this.onChange({
          handle: 'lowerBound',
          lowerBound: value,
          upperBound: this.state.lowerBound
        });
        return;
      }
      if (props.allowCross && value > state.upperBound && state.handle === 'lowerBound') {
        this.onChange({
          handle: 'upperBound',
          upperBound: value,
          lowerBound: this.state.upperBound
        });
        return;
      }

      this.onChange(_defineProperty({}, state.handle, value));
    }
  }, {
    key: 'onTouchStart',
    value: function onTouchStart(e) {
      if (isNotTouchEvent(e)) return;

      var position = getTouchPosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('touch');
      pauseEvent(e);
    }
  }, {
    key: 'onMouseDown',
    value: function onMouseDown(e) {
      if (e.button !== 0) {
        return;
      }
      var position = getMousePosition(this.props.vertical, e);
      this.onStart(position);
      this.addDocumentEvents('mouse');
      pauseEvent(e);
    }
  }, {
    key: 'onStart',
    value: function onStart(position) {
      var props = this.props;
      props.onBeforeChange(this.getValue());

      var value = this.calcValueByPos(position);
      this.startValue = value;
      this.startPosition = position;

      var state = this.state;
      var upperBound = state.upperBound;
      var lowerBound = state.lowerBound;

      var valueNeedChanging = 'upperBound';
      if (this.props.range) {
        var isLowerBoundCloser = Math.abs(upperBound - value) > Math.abs(lowerBound - value);
        if (isLowerBoundCloser) {
          valueNeedChanging = 'lowerBound';
        }

        var isAtTheSamePoint = upperBound === lowerBound;
        if (isAtTheSamePoint) {
          valueNeedChanging = state.recent;
        }

        if (isAtTheSamePoint && value !== upperBound) {
          valueNeedChanging = value < upperBound ? 'lowerBound' : 'upperBound';
        }
      }

      this.setState({
        handle: valueNeedChanging,
        recent: valueNeedChanging
      });

      var oldValue = state[valueNeedChanging];
      if (value === oldValue) return;

      this.onChange(_defineProperty({}, valueNeedChanging, value));
    }
  }, {
    key: 'getValue',
    value: function getValue() {
      var _state2 = this.state;
      var lowerBound = _state2.lowerBound;
      var upperBound = _state2.upperBound;

      return this.props.range ? [lowerBound, upperBound] : upperBound;
    }
  }, {
    key: 'getSliderLength',
    value: function getSliderLength() {
      var slider = this.refs.slider;
      if (!slider) {
        return 0;
      }

      return this.props.vertical ? slider.clientHeight : slider.clientWidth;
    }
  }, {
    key: 'getSliderStart',
    value: function getSliderStart() {
      var slider = this.refs.slider;
      var rect = slider.getBoundingClientRect();

      return this.props.vertical ? rect.top : rect.left;
    }
  }, {
    key: 'getPrecision',
    value: function getPrecision(step) {
      var stepString = step.toString();
      var precision = 0;
      if (stepString.indexOf('.') >= 0) {
        precision = stepString.length - stepString.indexOf('.') - 1;
      }
      return precision;
    }
  }, {
    key: 'isValueOutOfBounds',
    value: function isValueOutOfBounds(value, props) {
      return value < props.min || value > props.max;
    }
  }, {
    key: 'trimAlignValue',
    value: function trimAlignValue(v, nextProps) {
      var state = this.state || {};
      var handle = state.handle;
      var lowerBound = state.lowerBound;
      var upperBound = state.upperBound;

      var _extends2 = _extends({}, this.props, nextProps || {});

      var marks = _extends2.marks;
      var step = _extends2.step;
      var min = _extends2.min;
      var max = _extends2.max;
      var allowCross = _extends2.allowCross;

      var val = v;
      if (val <= min) {
        val = min;
      }
      if (val >= max) {
        val = max;
      }
      if (!allowCross && handle === 'upperBound' && val <= lowerBound) {
        val = lowerBound;
      }
      if (!allowCross && handle === 'lowerBound' && val >= upperBound) {
        val = upperBound;
      }

      var points = Object.keys(marks).map(parseFloat);
      if (step !== null) {
        var closestStep = Math.round((val - min) / step) * step + min;
        points.push(closestStep);
      }

      var diffs = points.map(function (point) {
        return Math.abs(val - point);
      });
      var closestPoint = points[diffs.indexOf(Math.min.apply(Math, diffs))];

      return step !== null ? parseFloat(closestPoint.toFixed(this.getPrecision(step))) : closestPoint;
    }
  }, {
    key: 'calcOffset',
    value: function calcOffset(value) {
      var _props = this.props;
      var min = _props.min;
      var max = _props.max;

      var ratio = (value - min) / (max - min);
      return ratio * 100;
    }
  }, {
    key: 'calcValue',
    value: function calcValue(offset) {
      var _props2 = this.props;
      var vertical = _props2.vertical;
      var min = _props2.min;
      var max = _props2.max;

      var ratio = Math.abs(offset / this.getSliderLength());
      var value = vertical ? (1 - ratio) * (max - min) + min : ratio * (max - min) + min;
      return value;
    }
  }, {
    key: 'calcValueByPos',
    value: function calcValueByPos(position) {
      var pixelOffset = position - this.getSliderStart();
      var nextValue = this.trimAlignValue(this.calcValue(pixelOffset));
      return nextValue;
    }
  }, {
    key: 'addDocumentEvents',
    value: function addDocumentEvents(type) {
      if (type === 'touch') {
        // just work for chrome iOS Safari and Android Browser
        this.onTouchMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchmove', this.onTouchMove.bind(this));
        this.onTouchUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'touchend', this.end.bind(this, 'touch'));
      } else if (type === 'mouse') {
        this.onMouseMoveListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mousemove', this.onMouseMove.bind(this));
        this.onMouseUpListener = (0, _rcUtilLibDomAddEventListener2['default'])(document, 'mouseup', this.end.bind(this, 'mouse'));
      }
    }
  }, {
    key: 'removeEvents',
    value: function removeEvents(type) {
      if (type === 'touch') {
        this.onTouchMoveListener.remove();
        this.onTouchUpListener.remove();
      } else if (type === 'mouse') {
        this.onMouseMoveListener.remove();
        this.onMouseUpListener.remove();
      }
    }
  }, {
    key: 'end',
    value: function end(type) {
      this.removeEvents(type);
      this.props.onAfterChange(this.getValue());
      this.setState({ handle: null });
    }
  }, {
    key: 'render',
    value: function render() {
      var _classNames, _classNames2, _classNames3;

      var _state3 = this.state;
      var handle = _state3.handle;
      var upperBound = _state3.upperBound;
      var lowerBound = _state3.lowerBound;
      var _props3 = this.props;
      var className = _props3.className;
      var prefixCls = _props3.prefixCls;
      var disabled = _props3.disabled;
      var vertical = _props3.vertical;
      var dots = _props3.dots;
      var included = _props3.included;
      var range = _props3.range;
      var step = _props3.step;
      var marks = _props3.marks;
      var max = _props3.max;
      var min = _props3.min;
      var tipTransitionName = _props3.tipTransitionName;
      var tipFormatter = _props3.tipFormatter;
      var children = _props3.children;

      var customHandle = this.props.handle;

      var upperOffset = this.calcOffset(upperBound);
      var lowerOffset = this.calcOffset(lowerBound);

      var handleClassName = prefixCls + '-handle';

      var upperClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-upper', true), _classNames));

      var lowerClassName = (0, _classnames2['default'])((_classNames2 = {}, _defineProperty(_classNames2, handleClassName, true), _defineProperty(_classNames2, handleClassName + '-lower', true), _classNames2));

      var isNoTip = step === null || tipFormatter === null;

      var commonHandleProps = {
        prefixCls: prefixCls,
        noTip: isNoTip,
        tipTransitionName: tipTransitionName,
        tipFormatter: tipFormatter,
        vertical: vertical
      };

      var upper = (0, _react.cloneElement)(customHandle, _extends({}, commonHandleProps, {
        className: upperClassName,
        value: upperBound,
        offset: upperOffset,
        dragging: handle === 'upperBound'
      }));

      var lower = null;
      if (range) {
        lower = (0, _react.cloneElement)(customHandle, _extends({}, commonHandleProps, {
          className: lowerClassName,
          value: lowerBound,
          offset: lowerOffset,
          dragging: handle === 'lowerBound'
        }));
      }

      var sliderClassName = (0, _classnames2['default'])((_classNames3 = {}, _defineProperty(_classNames3, prefixCls, true), _defineProperty(_classNames3, prefixCls + '-disabled', disabled), _defineProperty(_classNames3, className, !!className), _defineProperty(_classNames3, prefixCls + '-vertical', this.props.vertical), _classNames3));
      var isIncluded = included || range;
      return _react2['default'].createElement(
        'div',
        { ref: 'slider', className: sliderClassName,
          onTouchStart: disabled ? noop : this.onTouchStart.bind(this),
          onMouseDown: disabled ? noop : this.onMouseDown.bind(this)
        },
        upper,
        lower,
        _react2['default'].createElement(_Track2['default'], { className: prefixCls + '-track', vertical: vertical, included: isIncluded,
          offset: lowerOffset, length: upperOffset - lowerOffset }),
        _react2['default'].createElement(_Steps2['default'], { prefixCls: prefixCls, vertical: vertical, marks: marks, dots: dots, step: step,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        _react2['default'].createElement(_Marks2['default'], { className: prefixCls + '-mark', vertical: vertical, marks: marks,
          included: isIncluded, lowerBound: lowerBound,
          upperBound: upperBound, max: max, min: min }),
        children
      );
    }
  }]);

  return Slider;
})(_react2['default'].Component);

Slider.propTypes = {
  min: _react2['default'].PropTypes.number,
  max: _react2['default'].PropTypes.number,
  step: _react2['default'].PropTypes.number,
  defaultValue: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  value: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.arrayOf(_react2['default'].PropTypes.number)]),
  marks: _react2['default'].PropTypes.object,
  included: _react2['default'].PropTypes.bool,
  className: _react2['default'].PropTypes.string,
  prefixCls: _react2['default'].PropTypes.string,
  disabled: _react2['default'].PropTypes.bool,
  children: _react2['default'].PropTypes.any,
  onBeforeChange: _react2['default'].PropTypes.func,
  onChange: _react2['default'].PropTypes.func,
  onAfterChange: _react2['default'].PropTypes.func,
  handle: _react2['default'].PropTypes.element,
  tipTransitionName: _react2['default'].PropTypes.string,
  tipFormatter: _react2['default'].PropTypes.func,
  dots: _react2['default'].PropTypes.bool,
  range: _react2['default'].PropTypes.bool,
  vertical: _react2['default'].PropTypes.bool,
  allowCross: _react2['default'].PropTypes.bool
};

Slider.defaultProps = {
  prefixCls: 'rc-slider',
  className: '',
  tipTransitionName: '',
  min: 0,
  max: 100,
  step: 1,
  marks: {},
  handle: _react2['default'].createElement(_Handle2['default'], null),
  onBeforeChange: noop,
  onChange: noop,
  onAfterChange: noop,
  tipFormatter: function tipFormatter(value) {
    return value;
  },
  included: true,
  disabled: false,
  dots: false,
  range: false,
  vertical: false,
  allowCross: true
};

exports['default'] = Slider;
module.exports = exports['default'];
},{"./Handle":411,"./Marks":412,"./Steps":414,"./Track":415,"classnames":118,"rc-util/lib/Dom/addEventListener":429,"react":"react"}],414:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

function calcPoints(vertical, marks, dots, step, min, max) {
  (0, _warning2['default'])(dots ? step > 0 : true, '`Slider[step]` should be a positive number in order to make Slider[dots] work.');
  var points = Object.keys(marks).map(parseFloat);
  if (dots) {
    for (var i = min; i <= max; i = i + step) {
      if (points.indexOf(i) >= 0) continue;
      points.push(i);
    }
  }
  return points;
}

var Steps = function Steps(_ref) {
  var prefixCls = _ref.prefixCls;
  var vertical = _ref.vertical;
  var marks = _ref.marks;
  var dots = _ref.dots;
  var step = _ref.step;
  var included = _ref.included;
  var lowerBound = _ref.lowerBound;
  var upperBound = _ref.upperBound;
  var max = _ref.max;
  var min = _ref.min;

  var range = max - min;
  var elements = calcPoints(vertical, marks, dots, step, min, max).map(function (point) {
    var _classNames;

    var offset = Math.abs(point - min) / range * 100 + '%';
    var style = vertical ? { bottom: offset } : { left: offset };

    var isActived = !included && point === upperBound || included && point <= upperBound && point >= lowerBound;
    var pointClassName = (0, _classnames2['default'])((_classNames = {}, _defineProperty(_classNames, prefixCls + '-dot', true), _defineProperty(_classNames, prefixCls + '-dot-active', isActived), _classNames));

    return _react2['default'].createElement('span', { className: pointClassName, style: style, key: point });
  });

  return _react2['default'].createElement(
    'div',
    { className: prefixCls + '-step' },
    elements
  );
};

exports['default'] = Steps;
module.exports = exports['default'];
},{"classnames":118,"react":"react","warning":1012}],415:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var Track = function Track(_ref) {
  var className = _ref.className;
  var included = _ref.included;
  var vertical = _ref.vertical;
  var offset = _ref.offset;
  var length = _ref.length;

  var style = {
    visibility: included ? 'visible' : 'hidden'
  };
  if (vertical) {
    style.bottom = offset + '%';
    style.height = length + '%';
  } else {
    style.left = offset + '%';
    style.width = length + '%';
  }
  return _react2['default'].createElement('div', { className: className, style: style });
};

exports['default'] = Track;
module.exports = exports['default'];
},{"react":"react"}],416:[function(require,module,exports){
'use strict';

module.exports = require('./Slider');
},{"./Slider":413}],417:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _placements = require('./placements');

var _rcTrigger = require('rc-trigger');

var _rcTrigger2 = _interopRequireDefault(_rcTrigger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var Tooltip = _react2["default"].createClass({
  displayName: 'Tooltip',

  propTypes: {
    trigger: _react.PropTypes.any,
    children: _react.PropTypes.any,
    defaultVisible: _react.PropTypes.bool,
    visible: _react.PropTypes.bool,
    placement: _react.PropTypes.string,
    transitionName: _react.PropTypes.string,
    animation: _react.PropTypes.any,
    onVisibleChange: _react.PropTypes.func,
    afterVisibleChange: _react.PropTypes.func,
    overlay: _react.PropTypes.oneOfType([_react2["default"].PropTypes.node, _react2["default"].PropTypes.func]).isRequired,
    overlayStyle: _react.PropTypes.object,
    overlayClassName: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    getTooltipContainer: _react.PropTypes.func,
    destroyTooltipOnHide: _react.PropTypes.bool,
    align: _react.PropTypes.object,
    arrowContent: _react.PropTypes.any
  },

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-tooltip',
      mouseEnterDelay: 0,
      destroyTooltipOnHide: false,
      mouseLeaveDelay: 0.1,
      align: {},
      placement: 'right',
      trigger: ['hover'],
      arrowContent: null
    };
  },
  getPopupElement: function getPopupElement() {
    var _props = this.props;
    var arrowContent = _props.arrowContent;
    var overlay = _props.overlay;
    var prefixCls = _props.prefixCls;

    return [_react2["default"].createElement(
      'div',
      { className: prefixCls + '-arrow', key: 'arrow' },
      arrowContent
    ), _react2["default"].createElement(
      'div',
      { className: prefixCls + '-inner', key: 'content' },
      typeof overlay === 'function' ? overlay() : overlay
    )];
  },
  getPopupDomNode: function getPopupDomNode() {
    return this.refs.trigger.getPopupDomNode();
  },
  render: function render() {
    var _props2 = this.props;
    var overlayClassName = _props2.overlayClassName;
    var trigger = _props2.trigger;
    var mouseEnterDelay = _props2.mouseEnterDelay;
    var mouseLeaveDelay = _props2.mouseLeaveDelay;
    var overlayStyle = _props2.overlayStyle;
    var prefixCls = _props2.prefixCls;
    var children = _props2.children;
    var onVisibleChange = _props2.onVisibleChange;
    var transitionName = _props2.transitionName;
    var animation = _props2.animation;
    var placement = _props2.placement;
    var align = _props2.align;
    var destroyTooltipOnHide = _props2.destroyTooltipOnHide;
    var defaultVisible = _props2.defaultVisible;
    var getTooltipContainer = _props2.getTooltipContainer;

    var restProps = _objectWithoutProperties(_props2, ['overlayClassName', 'trigger', 'mouseEnterDelay', 'mouseLeaveDelay', 'overlayStyle', 'prefixCls', 'children', 'onVisibleChange', 'transitionName', 'animation', 'placement', 'align', 'destroyTooltipOnHide', 'defaultVisible', 'getTooltipContainer']);

    var extraProps = _extends({}, restProps);
    if ('visible' in this.props) {
      extraProps.popupVisible = this.props.visible;
    }
    return _react2["default"].createElement(
      _rcTrigger2["default"],
      _extends({
        popupClassName: overlayClassName,
        ref: 'trigger',
        prefixCls: prefixCls,
        popup: this.getPopupElement,
        action: trigger,
        builtinPlacements: _placements.placements,
        popupPlacement: placement,
        popupAlign: align,
        getPopupContainer: getTooltipContainer,
        onPopupVisibleChange: onVisibleChange,
        popupTransitionName: transitionName,
        popupAnimation: animation,
        defaultPopupVisible: defaultVisible,
        destroyPopupOnHide: destroyTooltipOnHide,
        mouseLeaveDelay: mouseLeaveDelay,
        popupStyle: overlayStyle,
        mouseEnterDelay: mouseEnterDelay
      }, extraProps),
      children
    );
  }
});

exports["default"] = Tooltip;
module.exports = exports['default'];
},{"./placements":419,"rc-trigger":424,"react":"react"}],418:[function(require,module,exports){
'use strict';

module.exports = require('./Tooltip');
},{"./Tooltip":417}],419:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var autoAdjustOverflow = {
  adjustX: 1,
  adjustY: 1
};

var targetOffset = [0, 0];

var placements = exports.placements = {
  left: {
    points: ['cr', 'cl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  right: {
    points: ['cl', 'cr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  top: {
    points: ['bc', 'tc'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  bottom: {
    points: ['tc', 'bc'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  topLeft: {
    points: ['bl', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  leftTop: {
    points: ['tr', 'tl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  },
  topRight: {
    points: ['br', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [0, -4],
    targetOffset: targetOffset
  },
  rightTop: {
    points: ['tl', 'tr'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomRight: {
    points: ['tr', 'br'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  rightBottom: {
    points: ['bl', 'br'],
    overflow: autoAdjustOverflow,
    offset: [4, 0],
    targetOffset: targetOffset
  },
  bottomLeft: {
    points: ['tl', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [0, 4],
    targetOffset: targetOffset
  },
  leftBottom: {
    points: ['br', 'bl'],
    overflow: autoAdjustOverflow,
    offset: [-4, 0],
    targetOffset: targetOffset
  }
};

exports["default"] = placements;
},{}],420:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var LazyRenderBox = _react2["default"].createClass({
  displayName: 'LazyRenderBox',

  propTypes: {
    children: _react.PropTypes.any,
    className: _react.PropTypes.string,
    visible: _react.PropTypes.bool,
    hiddenClassName: _react.PropTypes.string
  },
  shouldComponentUpdate: function shouldComponentUpdate(nextProps) {
    return nextProps.hiddenClassName || nextProps.visible;
  },
  render: function render() {
    var _props = this.props,
        hiddenClassName = _props.hiddenClassName,
        visible = _props.visible,
        props = (0, _objectWithoutProperties3["default"])(_props, ['hiddenClassName', 'visible']);


    if (hiddenClassName || _react2["default"].Children.count(props.children) > 1) {
      if (!visible && hiddenClassName) {
        props.className += ' ' + hiddenClassName;
      }
      return _react2["default"].createElement('div', props);
    }

    return _react2["default"].Children.only(props.children);
  }
});

exports["default"] = LazyRenderBox;
module.exports = exports['default'];
},{"babel-runtime/helpers/objectWithoutProperties":39,"react":"react"}],421:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _rcAlign = require('rc-align');

var _rcAlign2 = _interopRequireDefault(_rcAlign);

var _rcAnimate = require('rc-animate');

var _rcAnimate2 = _interopRequireDefault(_rcAnimate);

var _PopupInner = require('./PopupInner');

var _PopupInner2 = _interopRequireDefault(_PopupInner);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var Popup = _react2["default"].createClass({
  displayName: 'Popup',

  propTypes: {
    visible: _react.PropTypes.bool,
    style: _react.PropTypes.object,
    getClassNameFromAlign: _react.PropTypes.func,
    onAlign: _react.PropTypes.func,
    getRootDomNode: _react.PropTypes.func,
    onMouseEnter: _react.PropTypes.func,
    align: _react.PropTypes.any,
    destroyPopupOnHide: _react.PropTypes.bool,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseLeave: _react.PropTypes.func
  },

  componentDidMount: function componentDidMount() {
    this.rootNode = this.getPopupDomNode();
  },
  onAlign: function onAlign(popupDomNode, align) {
    var props = this.props;
    var alignClassName = props.getClassNameFromAlign(props.align);
    var currentAlignClassName = props.getClassNameFromAlign(align);
    if (alignClassName !== currentAlignClassName) {
      this.currentAlignClassName = currentAlignClassName;
      popupDomNode.className = this.getClassName(currentAlignClassName);
    }
    props.onAlign(popupDomNode, align);
  },
  getPopupDomNode: function getPopupDomNode() {
    return _reactDom2["default"].findDOMNode(this.refs.popup);
  },
  getTarget: function getTarget() {
    return this.props.getRootDomNode();
  },
  getMaskTransitionName: function getMaskTransitionName() {
    var props = this.props;
    var transitionName = props.maskTransitionName;
    var animation = props.maskAnimation;
    if (!transitionName && animation) {
      transitionName = props.prefixCls + '-' + animation;
    }
    return transitionName;
  },
  getTransitionName: function getTransitionName() {
    var props = this.props;
    var transitionName = props.transitionName;
    if (!transitionName && props.animation) {
      transitionName = props.prefixCls + '-' + props.animation;
    }
    return transitionName;
  },
  getClassName: function getClassName(currentAlignClassName) {
    return this.props.prefixCls + ' ' + this.props.className + ' ' + currentAlignClassName;
  },
  getPopupElement: function getPopupElement() {
    var props = this.props;
    var align = props.align,
        style = props.style,
        visible = props.visible,
        prefixCls = props.prefixCls,
        destroyPopupOnHide = props.destroyPopupOnHide;

    var className = this.getClassName(this.currentAlignClassName || props.getClassNameFromAlign(align));
    var hiddenClassName = prefixCls + '-hidden';
    if (!visible) {
      this.currentAlignClassName = null;
    }
    var newStyle = (0, _extends3["default"])({}, style, this.getZIndexStyle());
    var popupInnerProps = {
      className: className,
      prefixCls: prefixCls,
      ref: 'popup',
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      style: newStyle
    };
    if (destroyPopupOnHide) {
      return _react2["default"].createElement(
        _rcAnimate2["default"],
        {
          component: '',
          exclusive: true,
          transitionAppear: true,
          transitionName: this.getTransitionName()
        },
        visible ? _react2["default"].createElement(
          _rcAlign2["default"],
          {
            target: this.getTarget,
            key: 'popup',
            ref: this.saveAlign,
            monitorWindowResize: true,
            align: align,
            onAlign: this.onAlign
          },
          _react2["default"].createElement(
            _PopupInner2["default"],
            (0, _extends3["default"])({
              visible: true
            }, popupInnerProps),
            props.children
          )
        ) : null
      );
    }
    return _react2["default"].createElement(
      _rcAnimate2["default"],
      {
        component: '',
        exclusive: true,
        transitionAppear: true,
        transitionName: this.getTransitionName(),
        showProp: 'xVisible'
      },
      _react2["default"].createElement(
        _rcAlign2["default"],
        {
          target: this.getTarget,
          key: 'popup',
          ref: this.saveAlign,
          monitorWindowResize: true,
          xVisible: visible,
          childrenProps: { visible: 'xVisible' },
          disabled: !visible,
          align: align,
          onAlign: this.onAlign
        },
        _react2["default"].createElement(
          _PopupInner2["default"],
          (0, _extends3["default"])({
            hiddenClassName: hiddenClassName
          }, popupInnerProps),
          props.children
        )
      )
    );
  },
  getZIndexStyle: function getZIndexStyle() {
    var style = {};
    var props = this.props;
    if (props.zIndex !== undefined) {
      style.zIndex = props.zIndex;
    }
    return style;
  },
  getMaskElement: function getMaskElement() {
    var props = this.props;
    var maskElement = void 0;
    if (props.mask) {
      var maskTransition = this.getMaskTransitionName();
      maskElement = _react2["default"].createElement(_LazyRenderBox2["default"], {
        style: this.getZIndexStyle(),
        key: 'mask',
        className: props.prefixCls + '-mask',
        hiddenClassName: props.prefixCls + '-mask-hidden',
        visible: props.visible
      });
      if (maskTransition) {
        maskElement = _react2["default"].createElement(
          _rcAnimate2["default"],
          {
            key: 'mask',
            showProp: 'visible',
            transitionAppear: true,
            component: '',
            transitionName: maskTransition
          },
          maskElement
        );
      }
    }
    return maskElement;
  },
  saveAlign: function saveAlign(align) {
    this.alignInstance = align;
  },
  render: function render() {
    return _react2["default"].createElement(
      'div',
      null,
      this.getMaskElement(),
      this.getPopupElement()
    );
  }
});

exports["default"] = Popup;
module.exports = exports['default'];
},{"./LazyRenderBox":420,"./PopupInner":422,"babel-runtime/helpers/extends":37,"rc-align":403,"rc-animate":409,"react":"react","react-dom":"react-dom"}],422:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _LazyRenderBox = require('./LazyRenderBox');

var _LazyRenderBox2 = _interopRequireDefault(_LazyRenderBox);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var PopupInner = _react2["default"].createClass({
  displayName: 'PopupInner',

  propTypes: {
    hiddenClassName: _react.PropTypes.string,
    className: _react.PropTypes.string,
    prefixCls: _react.PropTypes.string,
    onMouseEnter: _react.PropTypes.func,
    onMouseLeave: _react.PropTypes.func,
    children: _react.PropTypes.any
  },
  render: function render() {
    var props = this.props;
    var className = props.className;
    if (!props.visible) {
      className += ' ' + props.hiddenClassName;
    }
    return _react2["default"].createElement(
      'div',
      {
        className: className,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        style: props.style
      },
      _react2["default"].createElement(
        _LazyRenderBox2["default"],
        { className: props.prefixCls + '-content', visible: props.visible },
        props.children
      )
    );
  }
});

exports["default"] = PopupInner;
module.exports = exports['default'];
},{"./LazyRenderBox":420,"react":"react"}],423:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _contains = require('rc-util/lib/Dom/contains');

var _contains2 = _interopRequireDefault(_contains);

var _addEventListener = require('rc-util/lib/Dom/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _Popup = require('./Popup');

var _Popup2 = _interopRequireDefault(_Popup);

var _utils = require('./utils');

var _getContainerRenderMixin = require('rc-util/lib/getContainerRenderMixin');

var _getContainerRenderMixin2 = _interopRequireDefault(_getContainerRenderMixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function noop() {}

function returnEmptyString() {
  return '';
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur'];

var Trigger = _react2["default"].createClass({
  displayName: 'Trigger',

  propTypes: {
    children: _react.PropTypes.any,
    action: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.arrayOf(_react.PropTypes.string)]),
    showAction: _react.PropTypes.any,
    hideAction: _react.PropTypes.any,
    getPopupClassNameFromAlign: _react.PropTypes.any,
    onPopupVisibleChange: _react.PropTypes.func,
    afterPopupVisibleChange: _react.PropTypes.func,
    popup: _react.PropTypes.oneOfType([_react.PropTypes.node, _react.PropTypes.func]).isRequired,
    popupStyle: _react.PropTypes.object,
    prefixCls: _react.PropTypes.string,
    popupClassName: _react.PropTypes.string,
    popupPlacement: _react.PropTypes.string,
    builtinPlacements: _react.PropTypes.object,
    popupTransitionName: _react.PropTypes.string,
    popupAnimation: _react.PropTypes.any,
    mouseEnterDelay: _react.PropTypes.number,
    mouseLeaveDelay: _react.PropTypes.number,
    zIndex: _react.PropTypes.number,
    focusDelay: _react.PropTypes.number,
    blurDelay: _react.PropTypes.number,
    getPopupContainer: _react.PropTypes.func,
    destroyPopupOnHide: _react.PropTypes.bool,
    mask: _react.PropTypes.bool,
    maskClosable: _react.PropTypes.bool,
    onPopupAlign: _react.PropTypes.func,
    popupAlign: _react.PropTypes.object,
    popupVisible: _react.PropTypes.bool,
    maskTransitionName: _react.PropTypes.string,
    maskAnimation: _react.PropTypes.string
  },

  mixins: [(0, _getContainerRenderMixin2["default"])({
    autoMount: false,

    isVisible: function isVisible(instance) {
      return instance.state.popupVisible;
    },
    getContainer: function getContainer(instance) {
      var popupContainer = document.createElement('div');
      var mountNode = instance.props.getPopupContainer ? instance.props.getPopupContainer((0, _reactDom.findDOMNode)(instance)) : document.body;
      mountNode.appendChild(popupContainer);
      return popupContainer;
    }
  })],

  getDefaultProps: function getDefaultProps() {
    return {
      prefixCls: 'rc-trigger-popup',
      getPopupClassNameFromAlign: returnEmptyString,
      onPopupVisibleChange: noop,
      afterPopupVisibleChange: noop,
      onPopupAlign: noop,
      popupClassName: '',
      mouseEnterDelay: 0,
      mouseLeaveDelay: 0.1,
      focusDelay: 0,
      blurDelay: 0.15,
      popupStyle: {},
      destroyPopupOnHide: false,
      popupAlign: {},
      defaultPopupVisible: false,
      mask: false,
      maskClosable: true,
      action: [],
      showAction: [],
      hideAction: []
    };
  },
  getInitialState: function getInitialState() {
    var props = this.props;
    var popupVisible = void 0;
    if ('popupVisible' in props) {
      popupVisible = !!props.popupVisible;
    } else {
      popupVisible = !!props.defaultPopupVisible;
    }
    return {
      popupVisible: popupVisible
    };
  },
  componentWillMount: function componentWillMount() {
    var _this = this;

    ALL_HANDLERS.forEach(function (h) {
      _this['fire' + h] = function (e) {
        _this.fireEvents(h, e);
      };
    });
  },
  componentDidMount: function componentDidMount() {
    this.componentDidUpdate({}, {
      popupVisible: this.state.popupVisible
    });
  },
  componentWillReceiveProps: function componentWillReceiveProps(_ref) {
    var popupVisible = _ref.popupVisible;

    if (popupVisible !== undefined) {
      this.setState({
        popupVisible: popupVisible
      });
    }
  },
  componentDidUpdate: function componentDidUpdate(_, prevState) {
    var props = this.props;
    var state = this.state;
    this.renderComponent(null, function () {
      if (prevState.popupVisible !== state.popupVisible) {
        props.afterPopupVisibleChange(state.popupVisible);
      }
    });
    if (this.isClickToHide()) {
      if (state.popupVisible) {
        if (!this.clickOutsideHandler) {
          this.clickOutsideHandler = (0, _addEventListener2["default"])(document, 'mousedown', this.onDocumentClick);
          this.touchOutsideHandler = (0, _addEventListener2["default"])(document, 'touchstart', this.onDocumentClick);
        }
        return;
      }
    }
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.touchOutsideHandler.remove();
      this.clickOutsideHandler = null;
      this.touchOutsideHandler = null;
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this.clearDelayTimer();
    if (this.clickOutsideHandler) {
      this.clickOutsideHandler.remove();
      this.touchOutsideHandler.remove();
      this.clickOutsideHandler = null;
      this.touchOutsideHandler = null;
    }
  },
  onMouseEnter: function onMouseEnter(e) {
    this.fireEvents('onMouseEnter', e);
    this.delaySetPopupVisible(true, this.props.mouseEnterDelay);
  },
  onMouseLeave: function onMouseLeave(e) {
    this.fireEvents('onMouseLeave', e);
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  },
  onPopupMouseEnter: function onPopupMouseEnter() {
    this.clearDelayTimer();
  },
  onPopupMouseLeave: function onPopupMouseLeave(e) {
    // https://github.com/react-component/trigger/pull/13
    // react bug?
    if (e.relatedTarget && !e.relatedTarget.setTimeout && this._component && (0, _contains2["default"])(this._component.getPopupDomNode(), e.relatedTarget)) {
      return;
    }
    this.delaySetPopupVisible(false, this.props.mouseLeaveDelay);
  },
  onFocus: function onFocus(e) {
    this.fireEvents('onFocus', e);
    // incase focusin and focusout
    this.clearDelayTimer();
    if (this.isFocusToShow()) {
      this.focusTime = Date.now();
      this.delaySetPopupVisible(true, this.props.focusDelay);
    }
  },
  onMouseDown: function onMouseDown(e) {
    this.fireEvents('onMouseDown', e);
    this.preClickTime = Date.now();
  },
  onTouchStart: function onTouchStart(e) {
    this.fireEvents('onTouchStart', e);
    this.preTouchTime = Date.now();
  },
  onBlur: function onBlur(e) {
    this.fireEvents('onBlur', e);
    this.clearDelayTimer();
    if (this.isBlurToHide()) {
      this.delaySetPopupVisible(false, this.props.blurDelay);
    }
  },
  onClick: function onClick(event) {
    this.fireEvents('onClick', event);
    // focus will trigger click
    if (this.focusTime) {
      var preTime = void 0;
      if (this.preClickTime && this.preTouchTime) {
        preTime = Math.min(this.preClickTime, this.preTouchTime);
      } else if (this.preClickTime) {
        preTime = this.preClickTime;
      } else if (this.preTouchTime) {
        preTime = this.preTouchTime;
      }
      if (Math.abs(preTime - this.focusTime) < 20) {
        return;
      }
      this.focusTime = 0;
    }
    this.preClickTime = 0;
    this.preTouchTime = 0;
    event.preventDefault();
    var nextVisible = !this.state.popupVisible;
    if (this.isClickToHide() && !nextVisible || nextVisible && this.isClickToShow()) {
      this.setPopupVisible(!this.state.popupVisible);
    }
  },
  onDocumentClick: function onDocumentClick(event) {
    if (this.props.mask && !this.props.maskClosable) {
      return;
    }
    var target = event.target;
    var root = (0, _reactDom.findDOMNode)(this);
    var popupNode = this.getPopupDomNode();
    if (!(0, _contains2["default"])(root, target) && !(0, _contains2["default"])(popupNode, target)) {
      this.close();
    }
  },
  getPopupDomNode: function getPopupDomNode() {
    // for test
    if (this._component) {
      return this._component.isMounted() ? this._component.getPopupDomNode() : null;
    }
    return null;
  },
  getRootDomNode: function getRootDomNode() {
    return _reactDom2["default"].findDOMNode(this);
  },
  getPopupClassNameFromAlign: function getPopupClassNameFromAlign(align) {
    var className = [];
    var props = this.props;
    var popupPlacement = props.popupPlacement,
        builtinPlacements = props.builtinPlacements,
        prefixCls = props.prefixCls;

    if (popupPlacement && builtinPlacements) {
      className.push((0, _utils.getPopupClassNameFromAlign)(builtinPlacements, prefixCls, align));
    }
    if (props.getPopupClassNameFromAlign) {
      className.push(props.getPopupClassNameFromAlign(align));
    }
    return className.join(' ');
  },
  getPopupAlign: function getPopupAlign() {
    var props = this.props;
    var popupPlacement = props.popupPlacement,
        popupAlign = props.popupAlign,
        builtinPlacements = props.builtinPlacements;

    if (popupPlacement && builtinPlacements) {
      return (0, _utils.getAlignFromPlacement)(builtinPlacements, popupPlacement, popupAlign);
    }
    return popupAlign;
  },
  getComponent: function getComponent() {
    var props = this.props,
        state = this.state;

    var mouseProps = {};
    if (this.isMouseEnterToShow()) {
      mouseProps.onMouseEnter = this.onPopupMouseEnter;
    }
    if (this.isMouseLeaveToHide()) {
      mouseProps.onMouseLeave = this.onPopupMouseLeave;
    }
    return _react2["default"].createElement(
      _Popup2["default"],
      (0, _extends3["default"])({
        prefixCls: props.prefixCls,
        destroyPopupOnHide: props.destroyPopupOnHide,
        visible: state.popupVisible,
        className: props.popupClassName,
        action: props.action,
        align: this.getPopupAlign(),
        onAlign: props.onPopupAlign,
        animation: props.popupAnimation,
        getClassNameFromAlign: this.getPopupClassNameFromAlign
      }, mouseProps, {
        getRootDomNode: this.getRootDomNode,
        style: props.popupStyle,
        mask: props.mask,
        zIndex: props.zIndex,
        transitionName: props.popupTransitionName,
        maskAnimation: props.maskAnimation,
        maskTransitionName: props.maskTransitionName
      }),
      typeof props.popup === 'function' ? props.popup() : props.popup
    );
  },
  setPopupVisible: function setPopupVisible(popupVisible) {
    this.clearDelayTimer();
    if (this.state.popupVisible !== popupVisible) {
      if (!('popupVisible' in this.props)) {
        this.setState({
          popupVisible: popupVisible
        });
      }
      this.props.onPopupVisibleChange(popupVisible);
    }
  },
  delaySetPopupVisible: function delaySetPopupVisible(visible, delayS) {
    var _this2 = this;

    var delay = delayS * 1000;
    this.clearDelayTimer();
    if (delay) {
      this.delayTimer = setTimeout(function () {
        _this2.setPopupVisible(visible);
        _this2.clearDelayTimer();
      }, delay);
    } else {
      this.setPopupVisible(visible);
    }
  },
  clearDelayTimer: function clearDelayTimer() {
    if (this.delayTimer) {
      clearTimeout(this.delayTimer);
      this.delayTimer = null;
    }
  },
  createTwoChains: function createTwoChains(event) {
    var childPros = this.props.children.props;
    var props = this.props;
    if (childPros[event] && props[event]) {
      return this['fire' + event];
    }
    return childPros[event] || props[event];
  },
  isClickToShow: function isClickToShow() {
    var _props = this.props,
        action = _props.action,
        showAction = _props.showAction;

    return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
  },
  isClickToHide: function isClickToHide() {
    var _props2 = this.props,
        action = _props2.action,
        hideAction = _props2.hideAction;

    return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
  },
  isMouseEnterToShow: function isMouseEnterToShow() {
    var _props3 = this.props,
        action = _props3.action,
        showAction = _props3.showAction;

    return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
  },
  isMouseLeaveToHide: function isMouseLeaveToHide() {
    var _props4 = this.props,
        action = _props4.action,
        hideAction = _props4.hideAction;

    return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
  },
  isFocusToShow: function isFocusToShow() {
    var _props5 = this.props,
        action = _props5.action,
        showAction = _props5.showAction;

    return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
  },
  isBlurToHide: function isBlurToHide() {
    var _props6 = this.props,
        action = _props6.action,
        hideAction = _props6.hideAction;

    return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
  },
  forcePopupAlign: function forcePopupAlign() {
    if (this.state.popupVisible && this.popupInstance && this.popupInstance.alignInstance) {
      this.popupInstance.alignInstance.forceAlign();
    }
  },
  fireEvents: function fireEvents(type, e) {
    var childCallback = this.props.children.props[type];
    if (childCallback) {
      childCallback(e);
    }
    var callback = this.props[type];
    if (callback) {
      callback(e);
    }
  },
  close: function close() {
    this.setPopupVisible(false);
  },
  render: function render() {
    var props = this.props;
    var children = props.children;
    var child = _react2["default"].Children.only(children);
    var newChildProps = {};

    if (this.isClickToHide() || this.isClickToShow()) {
      newChildProps.onClick = this.onClick;
      newChildProps.onMouseDown = this.onMouseDown;
      newChildProps.onTouchStart = this.onTouchStart;
    } else {
      newChildProps.onClick = this.createTwoChains('onClick');
      newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
      newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
    }
    if (this.isMouseEnterToShow()) {
      newChildProps.onMouseEnter = this.onMouseEnter;
    } else {
      newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
    }
    if (this.isMouseLeaveToHide()) {
      newChildProps.onMouseLeave = this.onMouseLeave;
    } else {
      newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
    }
    if (this.isFocusToShow() || this.isBlurToHide()) {
      newChildProps.onFocus = this.onFocus;
      newChildProps.onBlur = this.onBlur;
    } else {
      newChildProps.onFocus = this.createTwoChains('onFocus');
      newChildProps.onBlur = this.createTwoChains('onBlur');
    }

    return _react2["default"].cloneElement(child, newChildProps);
  }
});

exports["default"] = Trigger;
module.exports = exports['default'];
},{"./Popup":421,"./utils":425,"babel-runtime/helpers/extends":37,"rc-util/lib/Dom/addEventListener":426,"rc-util/lib/Dom/contains":427,"rc-util/lib/getContainerRenderMixin":428,"react":"react","react-dom":"react-dom"}],424:[function(require,module,exports){
'use strict';

module.exports = require('./Trigger');
},{"./Trigger":423}],425:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.getAlignFromPlacement = getAlignFromPlacement;
exports.getPopupClassNameFromAlign = getPopupClassNameFromAlign;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function isPointsEq(a1, a2) {
  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return (0, _extends3["default"])({}, baseAlign, align);
}

function getPopupClassNameFromAlign(builtinPlacements, prefixCls, align) {
  var points = align.points;
  for (var placement in builtinPlacements) {
    if (builtinPlacements.hasOwnProperty(placement)) {
      if (isPointsEq(builtinPlacements[placement].points, points)) {
        return prefixCls + '-placement-' + placement;
      }
    }
  }
  return '';
}
},{"babel-runtime/helpers/extends":37}],426:[function(require,module,exports){
arguments[4][405][0].apply(exports,arguments)
},{"add-dom-event-listener":25,"dup":405,"react-dom":"react-dom"}],427:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = contains;
function contains(root, n) {
  var node = n;
  while (node) {
    if (node === root) {
      return true;
    }
    node = node.parentNode;
  }

  return false;
}
module.exports = exports['default'];
},{}],428:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports["default"] = getContainerRenderMixin;

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function defaultGetContainer() {
  var container = document.createElement('div');
  document.body.appendChild(container);
  return container;
}

function getContainerRenderMixin(config) {
  var _config$autoMount = config.autoMount,
      autoMount = _config$autoMount === undefined ? true : _config$autoMount,
      _config$autoDestroy = config.autoDestroy,
      autoDestroy = _config$autoDestroy === undefined ? true : _config$autoDestroy,
      isVisible = config.isVisible,
      getComponent = config.getComponent,
      _config$getContainer = config.getContainer,
      getContainer = _config$getContainer === undefined ? defaultGetContainer : _config$getContainer;


  var mixin = void 0;

  function _renderComponent(instance, componentArg, ready) {
    if (!isVisible || instance._component || isVisible(instance)) {
      if (!instance._container) {
        instance._container = getContainer(instance);
      }
      var component = void 0;
      if (instance.getComponent) {
        component = instance.getComponent(componentArg);
      } else {
        component = getComponent(instance, componentArg);
      }
      _reactDom2["default"].unstable_renderSubtreeIntoContainer(instance, component, instance._container, function callback() {
        instance._component = this;
        if (ready) {
          ready.call(this);
        }
      });
    }
  }

  if (autoMount) {
    mixin = _extends({}, mixin, {
      componentDidMount: function componentDidMount() {
        _renderComponent(this);
      },
      componentDidUpdate: function componentDidUpdate() {
        _renderComponent(this);
      }
    });
  }

  if (!autoMount || !autoDestroy) {
    mixin = _extends({}, mixin, {
      renderComponent: function renderComponent(componentArg, ready) {
        _renderComponent(this, componentArg, ready);
      }
    });
  }

  function _removeContainer(instance) {
    if (instance._container) {
      var container = instance._container;
      _reactDom2["default"].unmountComponentAtNode(container);
      container.parentNode.removeChild(container);
      instance._container = null;
    }
  }

  if (autoDestroy) {
    mixin = _extends({}, mixin, {
      componentWillUnmount: function componentWillUnmount() {
        _removeContainer(this);
      }
    });
  } else {
    mixin = _extends({}, mixin, {
      removeContainer: function removeContainer() {
        _removeContainer(this);
      }
    });
  }

  return mixin;
}
module.exports = exports['default'];
},{"react-dom":"react-dom"}],429:[function(require,module,exports){
arguments[4][405][0].apply(exports,arguments)
},{"add-dom-event-listener":25,"dup":405,"react-dom":"react-dom"}],430:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Transition = require('react-overlays/lib/Transition');

var _Transition2 = _interopRequireDefault(_Transition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var propTypes = {
  /**
   * Show the component; triggers the fade in or fade out animation
   */
  'in': _react2['default'].PropTypes.bool,

  /**
   * Wait until the first "enter" transition to mount the component (add it to the DOM)
   */
  mountOnEnter: _react2['default'].PropTypes.bool,

  /**
   * Unmount the component (remove it from the DOM) when it is faded out
   */
  unmountOnExit: _react2['default'].PropTypes.bool,

  /**
   * Run the fade in animation when the component mounts, if it is initially
   * shown
   */
  transitionAppear: _react2['default'].PropTypes.bool,

  /**
   * Duration of the fade animation in milliseconds, to ensure that finishing
   * callbacks are fired even if the original browser transition end events are
   * canceled
   */
  timeout: _react2['default'].PropTypes.number,

  /**
   * Callback fired before the component fades in
   */
  onEnter: _react2['default'].PropTypes.func,
  /**
   * Callback fired after the component starts to fade in
   */
  onEntering: _react2['default'].PropTypes.func,
  /**
   * Callback fired after the has component faded in
   */
  onEntered: _react2['default'].PropTypes.func,
  /**
   * Callback fired before the component fades out
   */
  onExit: _react2['default'].PropTypes.func,
  /**
   * Callback fired after the component starts to fade out
   */
  onExiting: _react2['default'].PropTypes.func,
  /**
   * Callback fired after the component has faded out
   */
  onExited: _react2['default'].PropTypes.func
};

var defaultProps = {
  'in': false,
  timeout: 300,
  mountOnEnter: false,
  unmountOnExit: false,
  transitionAppear: false
};

var Fade = function (_React$Component) {
  (0, _inherits3['default'])(Fade, _React$Component);

  function Fade() {
    (0, _classCallCheck3['default'])(this, Fade);
    return (0, _possibleConstructorReturn3['default'])(this, _React$Component.apply(this, arguments));
  }

  Fade.prototype.render = function render() {
    return _react2['default'].createElement(_Transition2['default'], (0, _extends3['default'])({}, this.props, {
      className: (0, _classnames2['default'])(this.props.className, 'fade'),
      enteredClassName: 'in',
      enteringClassName: 'in'
    }));
  };

  return Fade;
}(_react2['default'].Component);

Fade.propTypes = propTypes;
Fade.defaultProps = defaultProps;

exports['default'] = Fade;
module.exports = exports['default'];
},{"babel-runtime/helpers/classCallCheck":36,"babel-runtime/helpers/extends":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/possibleConstructorReturn":40,"classnames":118,"react":"react","react-overlays/lib/Transition":441}],431:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Overlay = require('react-overlays/lib/Overlay');

var _Overlay2 = _interopRequireDefault(_Overlay);

var _elementType = require('react-prop-types/lib/elementType');

var _elementType2 = _interopRequireDefault(_elementType);

var _Fade = require('./Fade');

var _Fade2 = _interopRequireDefault(_Fade);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var propTypes = (0, _extends3['default'])({}, _Overlay2['default'].propTypes, {

  /**
   * Set the visibility of the Overlay
   */
  show: _react2['default'].PropTypes.bool,
  /**
   * Specify whether the overlay should trigger onHide when the user clicks outside the overlay
   */
  rootClose: _react2['default'].PropTypes.bool,
  /**
   * A callback invoked by the overlay when it wishes to be hidden. Required if
   * `rootClose` is specified.
   */
  onHide: _react2['default'].PropTypes.func,

  /**
   * Use animation
   */
  animation: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.bool, _elementType2['default']]),

  /**
   * Callback fired before the Overlay transitions in
   */
  onEnter: _react2['default'].PropTypes.func,

  /**
   * Callback fired as the Overlay begins to transition in
   */
  onEntering: _react2['default'].PropTypes.func,

  /**
   * Callback fired after the Overlay finishes transitioning in
   */
  onEntered: _react2['default'].PropTypes.func,

  /**
   * Callback fired right before the Overlay transitions out
   */
  onExit: _react2['default'].PropTypes.func,

  /**
   * Callback fired as the Overlay begins to transition out
   */
  onExiting: _react2['default'].PropTypes.func,

  /**
   * Callback fired after the Overlay finishes transitioning out
   */
  onExited: _react2['default'].PropTypes.func,

  /**
   * Sets the direction of the Overlay.
   */
  placement: _react2['default'].PropTypes.oneOf(['top', 'right', 'bottom', 'left'])
});

var defaultProps = {
  animation: _Fade2['default'],
  rootClose: false,
  show: false,
  placement: 'right'
};

var Overlay = function (_React$Component) {
  (0, _inherits3['default'])(Overlay, _React$Component);

  function Overlay() {
    (0, _classCallCheck3['default'])(this, Overlay);
    return (0, _possibleConstructorReturn3['default'])(this, _React$Component.apply(this, arguments));
  }

  Overlay.prototype.render = function render() {
    var _props = this.props,
        animation = _props.animation,
        children = _props.children,
        props = (0, _objectWithoutProperties3['default'])(_props, ['animation', 'children']);


    var transition = animation === true ? _Fade2['default'] : animation || null;

    var child = void 0;

    if (!transition) {
      child = (0, _react.cloneElement)(children, {
        className: (0, _classnames2['default'])(children.props.className, 'in')
      });
    } else {
      child = children;
    }

    return _react2['default'].createElement(
      _Overlay2['default'],
      (0, _extends3['default'])({}, props, {
        transition: transition
      }),
      child
    );
  };

  return Overlay;
}(_react2['default'].Component);

Overlay.propTypes = propTypes;
Overlay.defaultProps = defaultProps;

exports['default'] = Overlay;
module.exports = exports['default'];
},{"./Fade":430,"babel-runtime/helpers/classCallCheck":36,"babel-runtime/helpers/extends":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/objectWithoutProperties":39,"babel-runtime/helpers/possibleConstructorReturn":40,"classnames":118,"react":"react","react-overlays/lib/Overlay":437,"react-prop-types/lib/elementType":814}],432:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _contains = require('dom-helpers/query/contains');

var _contains2 = _interopRequireDefault(_contains);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _warning = require('warning');

var _warning2 = _interopRequireDefault(_warning);

var _Overlay = require('./Overlay');

var _Overlay2 = _interopRequireDefault(_Overlay);

var _createChainedFunction = require('./utils/createChainedFunction');

var _createChainedFunction2 = _interopRequireDefault(_createChainedFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Check if value one is inside or equal to the of value
 *
 * @param {string} one
 * @param {string|array} of
 * @returns {boolean}
 */
function isOneOf(one, of) {
  if (Array.isArray(of)) {
    return of.indexOf(one) >= 0;
  }
  return one === of;
}

var triggerType = _react2['default'].PropTypes.oneOf(['click', 'hover', 'focus']);

var propTypes = (0, _extends3['default'])({}, _Overlay2['default'].propTypes, {

  /**
  * Specify which action or actions trigger Overlay visibility
  */
  trigger: _react2['default'].PropTypes.oneOfType([triggerType, _react2['default'].PropTypes.arrayOf(triggerType)]),

  /**
   * A millisecond delay amount to show and hide the Overlay once triggered
   */
  delay: _react2['default'].PropTypes.number,
  /**
   * A millisecond delay amount before showing the Overlay once triggered.
   */
  delayShow: _react2['default'].PropTypes.number,
  /**
   * A millisecond delay amount before hiding the Overlay once triggered.
   */
  delayHide: _react2['default'].PropTypes.number,

  // FIXME: This should be `defaultShow`.
  /**
   * The initial visibility state of the Overlay. For more nuanced visibility
   * control, consider using the Overlay component directly.
   */
  defaultOverlayShown: _react2['default'].PropTypes.bool,

  /**
   * An element or text to overlay next to the target.
   */
  overlay: _react2['default'].PropTypes.node.isRequired,

  /**
   * @private
   */
  onBlur: _react2['default'].PropTypes.func,
  /**
   * @private
   */
  onClick: _react2['default'].PropTypes.func,
  /**
   * @private
   */
  onFocus: _react2['default'].PropTypes.func,
  /**
   * @private
   */
  onMouseOut: _react2['default'].PropTypes.func,
  /**
   * @private
   */
  onMouseOver: _react2['default'].PropTypes.func,

  // Overridden props from `<Overlay>`.
  /**
   * @private
   */
  target: _react2['default'].PropTypes.oneOf([null]),
  /**
  * @private
  */
  onHide: _react2['default'].PropTypes.oneOf([null]),
  /**
   * @private
   */
  show: _react2['default'].PropTypes.oneOf([null])
});

var defaultProps = {
  defaultOverlayShown: false,
  trigger: ['hover', 'focus']
};

var OverlayTrigger = function (_React$Component) {
  (0, _inherits3['default'])(OverlayTrigger, _React$Component);

  function OverlayTrigger(props, context) {
    (0, _classCallCheck3['default'])(this, OverlayTrigger);

    var _this = (0, _possibleConstructorReturn3['default'])(this, _React$Component.call(this, props, context));

    _this.handleToggle = _this.handleToggle.bind(_this);
    _this.handleDelayedShow = _this.handleDelayedShow.bind(_this);
    _this.handleDelayedHide = _this.handleDelayedHide.bind(_this);
    _this.handleHide = _this.handleHide.bind(_this);

    _this.handleMouseOver = function (e) {
      return _this.handleMouseOverOut(_this.handleDelayedShow, e);
    };
    _this.handleMouseOut = function (e) {
      return _this.handleMouseOverOut(_this.handleDelayedHide, e);
    };

    _this._mountNode = null;

    _this.state = {
      show: props.defaultOverlayShown
    };
    return _this;
  }

  OverlayTrigger.prototype.componentDidMount = function componentDidMount() {
    this._mountNode = document.createElement('div');
    this.renderOverlay();
  };

  OverlayTrigger.prototype.componentDidUpdate = function componentDidUpdate() {
    this.renderOverlay();
  };

  OverlayTrigger.prototype.componentWillUnmount = function componentWillUnmount() {
    _reactDom2['default'].unmountComponentAtNode(this._mountNode);
    this._mountNode = null;

    clearTimeout(this._hoverShowDelay);
    clearTimeout(this._hoverHideDelay);
  };

  OverlayTrigger.prototype.handleToggle = function handleToggle() {
    if (this.state.show) {
      this.hide();
    } else {
      this.show();
    }
  };

  OverlayTrigger.prototype.handleDelayedShow = function handleDelayedShow() {
    var _this2 = this;

    if (this._hoverHideDelay != null) {
      clearTimeout(this._hoverHideDelay);
      this._hoverHideDelay = null;
      return;
    }

    if (this.state.show || this._hoverShowDelay != null) {
      return;
    }

    var delay = this.props.delayShow != null ? this.props.delayShow : this.props.delay;

    if (!delay) {
      this.show();
      return;
    }

    this._hoverShowDelay = setTimeout(function () {
      _this2._hoverShowDelay = null;
      _this2.show();
    }, delay);
  };

  OverlayTrigger.prototype.handleDelayedHide = function handleDelayedHide() {
    var _this3 = this;

    if (this._hoverShowDelay != null) {
      clearTimeout(this._hoverShowDelay);
      this._hoverShowDelay = null;
      return;
    }

    if (!this.state.show || this._hoverHideDelay != null) {
      return;
    }

    var delay = this.props.delayHide != null ? this.props.delayHide : this.props.delay;

    if (!delay) {
      this.hide();
      return;
    }

    this._hoverHideDelay = setTimeout(function () {
      _this3._hoverHideDelay = null;
      _this3.hide();
    }, delay);
  };

  // Simple implementation of mouseEnter and mouseLeave.
  // React's built version is broken: https://github.com/facebook/react/issues/4251
  // for cases when the trigger is disabled and mouseOut/Over can cause flicker
  // moving from one child element to another.


  OverlayTrigger.prototype.handleMouseOverOut = function handleMouseOverOut(handler, e) {
    var target = e.currentTarget;
    var related = e.relatedTarget || e.nativeEvent.toElement;

    if (!related || related !== target && !(0, _contains2['default'])(target, related)) {
      handler(e);
    }
  };

  OverlayTrigger.prototype.handleHide = function handleHide() {
    this.hide();
  };

  OverlayTrigger.prototype.show = function show() {
    this.setState({ show: true });
  };

  OverlayTrigger.prototype.hide = function hide() {
    this.setState({ show: false });
  };

  OverlayTrigger.prototype.makeOverlay = function makeOverlay(overlay, props) {
    return _react2['default'].createElement(
      _Overlay2['default'],
      (0, _extends3['default'])({}, props, {
        show: this.state.show,
        onHide: this.handleHide,
        target: this
      }),
      overlay
    );
  };

  OverlayTrigger.prototype.renderOverlay = function renderOverlay() {
    _reactDom2['default'].unstable_renderSubtreeIntoContainer(this, this._overlay, this._mountNode);
  };

  OverlayTrigger.prototype.render = function render() {
    var _props = this.props,
        trigger = _props.trigger,
        overlay = _props.overlay,
        children = _props.children,
        onBlur = _props.onBlur,
        onClick = _props.onClick,
        onFocus = _props.onFocus,
        onMouseOut = _props.onMouseOut,
        onMouseOver = _props.onMouseOver,
        props = (0, _objectWithoutProperties3['default'])(_props, ['trigger', 'overlay', 'children', 'onBlur', 'onClick', 'onFocus', 'onMouseOut', 'onMouseOver']);


    delete props.delay;
    delete props.delayShow;
    delete props.delayHide;
    delete props.defaultOverlayShown;

    var child = _react2['default'].Children.only(children);
    var childProps = child.props;
    var triggerProps = {};

    if (this.state.show) {
      triggerProps['aria-describedby'] = overlay.props.id;
    }

    // FIXME: The logic here for passing through handlers on this component is
    // inconsistent. We shouldn't be passing any of these props through.

    triggerProps.onClick = (0, _createChainedFunction2['default'])(childProps.onClick, onClick);

    if (isOneOf('click', trigger)) {
      triggerProps.onClick = (0, _createChainedFunction2['default'])(triggerProps.onClick, this.handleToggle);
    }

    if (isOneOf('hover', trigger)) {
      process.env.NODE_ENV !== 'production' ? (0, _warning2['default'])(!(trigger === 'hover'), '[react-bootstrap] Specifying only the `"hover"` trigger limits the ' + 'visibility of the overlay to just mouse users. Consider also ' + 'including the `"focus"` trigger so that touch and keyboard only ' + 'users can see the overlay as well.') : void 0;

      triggerProps.onMouseOver = (0, _createChainedFunction2['default'])(childProps.onMouseOver, onMouseOver, this.handleMouseOver);
      triggerProps.onMouseOut = (0, _createChainedFunction2['default'])(childProps.onMouseOut, onMouseOut, this.handleMouseOut);
    }

    if (isOneOf('focus', trigger)) {
      triggerProps.onFocus = (0, _createChainedFunction2['default'])(childProps.onFocus, onFocus, this.handleDelayedShow);
      triggerProps.onBlur = (0, _createChainedFunction2['default'])(childProps.onBlur, onBlur, this.handleDelayedHide);
    }

    this._overlay = this.makeOverlay(overlay, props);

    return (0, _react.cloneElement)(child, triggerProps);
  };

  return OverlayTrigger;
}(_react2['default'].Component);

OverlayTrigger.propTypes = propTypes;
OverlayTrigger.defaultProps = defaultProps;

exports['default'] = OverlayTrigger;
module.exports = exports['default'];
}).call(this,require('_process'))
},{"./Overlay":431,"./utils/createChainedFunction":436,"_process":395,"babel-runtime/helpers/classCallCheck":36,"babel-runtime/helpers/extends":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/objectWithoutProperties":39,"babel-runtime/helpers/possibleConstructorReturn":40,"dom-helpers/query/contains":256,"react":"react","react-dom":"react-dom","warning":1012}],433:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends3 = require('babel-runtime/helpers/extends');

var _extends4 = _interopRequireDefault(_extends3);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _isRequiredForA11y = require('react-prop-types/lib/isRequiredForA11y');

var _isRequiredForA11y2 = _interopRequireDefault(_isRequiredForA11y);

var _bootstrapUtils = require('./utils/bootstrapUtils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var propTypes = {
  /**
   * An html id attribute, necessary for accessibility
   * @type {string}
   * @required
   */
  id: (0, _isRequiredForA11y2['default'])(_react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.string, _react2['default'].PropTypes.number])),

  /**
   * Sets the direction the Popover is positioned towards.
   */
  placement: _react2['default'].PropTypes.oneOf(['top', 'right', 'bottom', 'left']),

  /**
   * The "top" position value for the Popover.
   */
  positionTop: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.string]),
  /**
   * The "left" position value for the Popover.
   */
  positionLeft: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.string]),

  /**
   * The "top" position value for the Popover arrow.
   */
  arrowOffsetTop: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.string]),
  /**
   * The "left" position value for the Popover arrow.
   */
  arrowOffsetLeft: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.number, _react2['default'].PropTypes.string]),

  /**
   * Title content
   */
  title: _react2['default'].PropTypes.node
};

var defaultProps = {
  placement: 'right'
};

var Popover = function (_React$Component) {
  (0, _inherits3['default'])(Popover, _React$Component);

  function Popover() {
    (0, _classCallCheck3['default'])(this, Popover);
    return (0, _possibleConstructorReturn3['default'])(this, _React$Component.apply(this, arguments));
  }

  Popover.prototype.render = function render() {
    var _extends2;

    var _props = this.props,
        placement = _props.placement,
        positionTop = _props.positionTop,
        positionLeft = _props.positionLeft,
        arrowOffsetTop = _props.arrowOffsetTop,
        arrowOffsetLeft = _props.arrowOffsetLeft,
        title = _props.title,
        className = _props.className,
        style = _props.style,
        children = _props.children,
        props = (0, _objectWithoutProperties3['default'])(_props, ['placement', 'positionTop', 'positionLeft', 'arrowOffsetTop', 'arrowOffsetLeft', 'title', 'className', 'style', 'children']);

    var _splitBsProps = (0, _bootstrapUtils.splitBsProps)(props),
        bsProps = _splitBsProps[0],
        elementProps = _splitBsProps[1];

    var classes = (0, _extends4['default'])({}, (0, _bootstrapUtils.getClassSet)(bsProps), (_extends2 = {}, _extends2[placement] = true, _extends2));

    var outerStyle = (0, _extends4['default'])({
      display: 'block',
      top: positionTop,
      left: positionLeft
    }, style);

    var arrowStyle = {
      top: arrowOffsetTop,
      left: arrowOffsetLeft
    };

    return _react2['default'].createElement(
      'div',
      (0, _extends4['default'])({}, elementProps, {
        role: 'tooltip',
        className: (0, _classnames2['default'])(className, classes),
        style: outerStyle
      }),
      _react2['default'].createElement('div', { className: 'arrow', style: arrowStyle }),
      title && _react2['default'].createElement(
        'h3',
        { className: (0, _bootstrapUtils.prefix)(bsProps, 'title') },
        title
      ),
      _react2['default'].createElement(
        'div',
        { className: (0, _bootstrapUtils.prefix)(bsProps, 'content') },
        children
      )
    );
  };

  return Popover;
}(_react2['default'].Component);

Popover.propTypes = propTypes;
Popover.defaultProps = defaultProps;

exports['default'] = (0, _bootstrapUtils.bsClass)('popover', Popover);
module.exports = exports['default'];
},{"./utils/bootstrapUtils":435,"babel-runtime/helpers/classCallCheck":36,"babel-runtime/helpers/extends":37,"babel-runtime/helpers/inherits":38,"babel-runtime/helpers/objectWithoutProperties":39,"babel-runtime/helpers/possibleConstructorReturn":40,"classnames":118,"react":"react","react-prop-types/lib/isRequiredForA11y":815}],434:[function(require,module,exports){
'use strict';

exports.__esModule = true;
var Size = exports.Size = {
  LARGE: 'large',
  SMALL: 'small',
  XSMALL: 'xsmall'
};

var SIZE_MAP = exports.SIZE_MAP = {
  large: 'lg',
  medium: 'md',
  small: 'sm',
  xsmall: 'xs',
  lg: 'lg',
  md: 'md',
  sm: 'sm',
  xs: 'xs'
};

var DEVICE_SIZES = exports.DEVICE_SIZES = ['lg', 'md', 'sm', 'xs'];

var State = exports.State = {
  SUCCESS: 'success',
  WARNING: 'warning',
  DANGER: 'danger',
  INFO: 'info'
};

var Style = exports.Style = {
  DEFAULT: 'default',
  PRIMARY: 'primary',
  LINK: 'link',
  INVERSE: 'inverse'
};
},{}],435:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports._curry = exports.bsSizes = exports.bsStyles = exports.bsClass = undefined;

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

exports.prefix = prefix;
exports.getClassSet = getClassSet;
exports.splitBsProps = splitBsProps;
exports.splitBsPropsAndOmit = splitBsPropsAndOmit;
exports.addStyle = addStyle;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

var _StyleConfig = require('./StyleConfig');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function curry(fn) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var last = args[args.length - 1];
    if (typeof last === 'function') {
      return fn.apply(undefined, args);
    }
    return function (Component) {
      return fn.apply(undefined, args.concat([Component]));
    };
  };
} // TODO: The publicly exposed parts of this should be in lib/BootstrapUtils.

function prefix(props, variant) {
  !(props.bsClass != null) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2['default'])(false, 'A `bsClass` prop is required for this component') : (0, _invariant2['default'])(false) : void 0;
  return props.bsClass + (variant ? '-' + variant : '');
}

var bsClass = exports.bsClass = curry(function (defaultClass, Component) {
  var propTypes = Component.propTypes || (Component.propTypes = {});
  var defaultProps = Component.defaultProps || (Component.defaultProps = {});

  propTypes.bsClass = _react.PropTypes.string;
  defaultProps.bsClass = defaultClass;

  return Component;
});

var bsStyles = exports.bsStyles = curry(function (styles, defaultStyle, Component) {
  if (typeof defaultStyle !== 'string') {
    Component = defaultStyle;
    defaultStyle = undefined;
  }

  var existing = Component.STYLES || [];
  var propTypes = Component.propTypes || {};

  styles.forEach(function (style) {
    if (existing.indexOf(style) === -1) {
      existing.push(style);
    }
  });

  var propType = _react.PropTypes.oneOf(existing);

  // expose the values on the propType function for documentation
  Component.STYLES = propType._values = existing;

  Component.propTypes = (0, _extends3['default'])({}, propTypes, {
    bsStyle: propType
  });

  if (defaultStyle !== undefined) {
    var defaultProps = Component.defaultProps || (Component.defaultProps = {});
    defaultProps.bsStyle = defaultStyle;
  }

  return Component;
});

var bsSizes = exports.bsSizes = curry(function (sizes, defaultSize, Component) {
  if (typeof defaultSize !== 'string') {
    Component = defaultSize;
    defaultSize = undefined;
  }

  var existing = Component.SIZES || [];
  var propTypes = Component.propTypes || {};

  sizes.forEach(function (size) {
    if (existing.indexOf(size) === -1) {
      existing.push(size);
    }
  });

  var values = [];
  existing.forEach(function (size) {
    var mappedSize = _StyleConfig.SIZE_MAP[size];
    if (mappedSize && mappedSize !== size) {
      values.push(mappedSize);
    }

    values.push(size);
  });

  var propType = _react.PropTypes.oneOf(values);
  propType._values = values;

  // expose the values on the propType function for documentation
  Component.SIZES = existing;

  Component.propTypes = (0, _extends3['default'])({}, propTypes, {
    bsSize: propType
  });

  if (defaultSize !== undefined) {
    if (!Component.defaultProps) {
      Component.defaultProps = {};
    }
    Component.defaultProps.bsSize = defaultSize;
  }

  return Component;
});

function getClassSet(props) {
  var _classes;

  var classes = (_classes = {}, _classes[prefix(props)] = true, _classes);

  if (props.bsSize) {
    var bsSize = _StyleConfig.SIZE_MAP[props.bsSize] || props.bsSize;
    classes[prefix(props, bsSize)] = true;
  }

  if (props.bsStyle) {
    classes[prefix(props, props.bsStyle)] = true;
  }

  return classes;
}

function getBsProps(props) {
  return {
    bsClass: props.bsClass,
    bsSize: props.bsSize,
    bsStyle: props.bsStyle,
    bsRole: props.bsRole
  };
}

function isBsProp(propName) {
  return propName === 'bsClass' || propName === 'bsSize' || propName === 'bsStyle' || propName === 'bsRole';
}

function splitBsProps(props) {
  var elementProps = {};
  (0, _entries2['default'])(props).forEach(function (_ref) {
    var propName = _ref[0],
        propValue = _ref[1];

    if (!isBsProp(propName)) {
      elementProps[propName] = propValue;
    }
  });

  return [getBsProps(props), elementProps];
}

function splitBsPropsAndOmit(props, omittedPropNames) {
  var isOmittedProp = {};
  omittedPropNames.forEach(function (propName) {
    isOmittedProp[propName] = true;
  });

  var elementProps = {};
  (0, _entries2['default'])(props).forEach(function (_ref2) {
    var propName = _ref2[0],
        propValue = _ref2[1];

    if (!isBsProp(propName) && !isOmittedProp[propName]) {
      elementProps[propName] = propValue;
    }
  });

  return [getBsProps(props), elementProps];
}

/**
 * Add a style variant to a Component. Mutates the propTypes of the component
 * in order to validate the new variant.
 */
function addStyle(Component) {
  for (var _len2 = arguments.length, styleVariant = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    styleVariant[_key2 - 1] = arguments[_key2];
  }

  bsStyles(styleVariant, Component);
}

var _curry = exports._curry = curry;
}).call(this,require('_process'))
},{"./StyleConfig":434,"_process":395,"babel-runtime/core-js/object/entries":32,"babel-runtime/helpers/extends":37,"invariant":327,"react":"react"}],436:[function(require,module,exports){
'use strict';

exports.__esModule = true;
/**
 * Safe chained function
 *
 * Will only create a new function if needed,
 * otherwise will pass back existing functions or null.
 *
 * @param {function} functions to chain
 * @returns {function|null}
 */
function createChainedFunction() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return funcs.filter(function (f) {
    return f != null;
  }).reduce(function (acc, f) {
    if (typeof f !== 'function') {
      throw new Error('Invalid Argument Type, must only provide functions, undefined, or null.');
    }

    if (acc === null) {
      return f;
    }

    return function chainedFunction() {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      acc.apply(this, args);
      f.apply(this, args);
    };
  }, null);
}

exports['default'] = createChainedFunction;
module.exports = exports['default'];
},{}],437:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Portal = require('./Portal');

var _Portal2 = _interopRequireDefault(_Portal);

var _Position = require('./Position');

var _Position2 = _interopRequireDefault(_Position);

var _RootCloseWrapper = require('./RootCloseWrapper');

var _RootCloseWrapper2 = _interopRequireDefault(_RootCloseWrapper);

var _elementType = require('react-prop-types/lib/elementType');

var _elementType2 = _interopRequireDefault(_elementType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Built on top of `<Position/>` and `<Portal/>`, the overlay component is great for custom tooltip overlays.
 */
var Overlay = function (_React$Component) {
  _inherits(Overlay, _React$Component);

  function Overlay(props, context) {
    _classCallCheck(this, Overlay);

    var _this = _possibleConstructorReturn(this, (Overlay.__proto__ || Object.getPrototypeOf(Overlay)).call(this, props, context));

    _this.state = { exited: !props.show };
    _this.onHiddenListener = _this.handleHidden.bind(_this);
    return _this;
  }

  _createClass(Overlay, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.show) {
        this.setState({ exited: false });
      } else if (!nextProps.transition) {
        // Otherwise let handleHidden take care of marking exited.
        this.setState({ exited: true });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          container = _props.container,
          containerPadding = _props.containerPadding,
          target = _props.target,
          placement = _props.placement,
          shouldUpdatePosition = _props.shouldUpdatePosition,
          rootClose = _props.rootClose,
          children = _props.children,
          Transition = _props.transition,
          props = _objectWithoutProperties(_props, ['container', 'containerPadding', 'target', 'placement', 'shouldUpdatePosition', 'rootClose', 'children', 'transition']);

      // Don't un-render the overlay while it's transitioning out.


      var mountOverlay = props.show || Transition && !this.state.exited;
      if (!mountOverlay) {
        // Don't bother showing anything if we don't have to.
        return null;
      }

      var child = children;

      // Position is be inner-most because it adds inline styles into the child,
      // which the other wrappers don't forward correctly.
      child = _react2.default.createElement(
        _Position2.default,
        { container: container, containerPadding: containerPadding, target: target, placement: placement, shouldUpdatePosition: shouldUpdatePosition },
        child
      );

      if (Transition) {
        var onExit = props.onExit,
            onExiting = props.onExiting,
            onEnter = props.onEnter,
            onEntering = props.onEntering,
            onEntered = props.onEntered;

        // This animates the child node by injecting props, so it must precede
        // anything that adds a wrapping div.

        child = _react2.default.createElement(
          Transition,
          {
            'in': props.show,
            transitionAppear: true,
            onExit: onExit,
            onExiting: onExiting,
            onExited: this.onHiddenListener,
            onEnter: onEnter,
            onEntering: onEntering,
            onEntered: onEntered
          },
          child
        );
      }

      // This goes after everything else because it adds a wrapping div.
      if (rootClose) {
        child = _react2.default.createElement(
          _RootCloseWrapper2.default,
          { onRootClose: props.onHide },
          child
        );
      }

      return _react2.default.createElement(
        _Portal2.default,
        { container: container },
        child
      );
    }
  }, {
    key: 'handleHidden',
    value: function handleHidden() {
      this.setState({ exited: true });

      if (this.props.onExited) {
        var _props2;

        (_props2 = this.props).onExited.apply(_props2, arguments);
      }
    }
  }]);

  return Overlay;
}(_react2.default.Component);

Overlay.propTypes = _extends({}, _Portal2.default.propTypes, _Position2.default.propTypes, {

  /**
   * Set the visibility of the Overlay
   */
  show: _react2.default.PropTypes.bool,

  /**
   * Specify whether the overlay should trigger `onHide` when the user clicks outside the overlay
   */
  rootClose: _react2.default.PropTypes.bool,

  /**
   * A Callback fired by the Overlay when it wishes to be hidden.
   *
   * __required__ when `rootClose` is `true`.
   *
   * @type func
   */
  onHide: function onHide(props) {
    var propType = _react2.default.PropTypes.func;
    if (props.rootClose) {
      propType = propType.isRequired;
    }

    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return propType.apply(undefined, [props].concat(args));
  },


  /**
   * A `<Transition/>` component used to animate the overlay changes visibility.
   */
  transition: _elementType2.default,

  /**
   * Callback fired before the Overlay transitions in
   */
  onEnter: _react2.default.PropTypes.func,

  /**
   * Callback fired as the Overlay begins to transition in
   */
  onEntering: _react2.default.PropTypes.func,

  /**
   * Callback fired after the Overlay finishes transitioning in
   */
  onEntered: _react2.default.PropTypes.func,

  /**
   * Callback fired right before the Overlay transitions out
   */
  onExit: _react2.default.PropTypes.func,

  /**
   * Callback fired as the Overlay begins to transition out
   */
  onExiting: _react2.default.PropTypes.func,

  /**
   * Callback fired after the Overlay finishes transitioning out
   */
  onExited: _react2.default.PropTypes.func
});

exports.default = Overlay;
module.exports = exports['default'];
},{"./Portal":438,"./Position":439,"./RootCloseWrapper":440,"react":"react","react-prop-types/lib/elementType":814}],438:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _componentOrElement = require('react-prop-types/lib/componentOrElement');

var _componentOrElement2 = _interopRequireDefault(_componentOrElement);

var _ownerDocument = require('./utils/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

var _getContainer = require('./utils/getContainer');

var _getContainer2 = _interopRequireDefault(_getContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The `<Portal/>` component renders its children into a new "subtree" outside of current component hierarchy.
 * You can think of it as a declarative `appendChild()`, or jQuery's `$.fn.appendTo()`.
 * The children of `<Portal/>` component will be appended to the `container` specified.
 */
var Portal = _react2.default.createClass({

  displayName: 'Portal',

  propTypes: {
    /**
     * A Node, Component instance, or function that returns either. The `container` will have the Portal children
     * appended to it.
     */
    container: _react2.default.PropTypes.oneOfType([_componentOrElement2.default, _react2.default.PropTypes.func])
  },

  componentDidMount: function componentDidMount() {
    this._renderOverlay();
  },
  componentDidUpdate: function componentDidUpdate() {
    this._renderOverlay();
  },
  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
    if (this._overlayTarget && nextProps.container !== this.props.container) {
      this._portalContainerNode.removeChild(this._overlayTarget);
      this._portalContainerNode = (0, _getContainer2.default)(nextProps.container, (0, _ownerDocument2.default)(this).body);
      this._portalContainerNode.appendChild(this._overlayTarget);
    }
  },
  componentWillUnmount: function componentWillUnmount() {
    this._unrenderOverlay();
    this._unmountOverlayTarget();
  },
  _mountOverlayTarget: function _mountOverlayTarget() {
    if (!this._overlayTarget) {
      this._overlayTarget = document.createElement('div');
      this._portalContainerNode = (0, _getContainer2.default)(this.props.container, (0, _ownerDocument2.default)(this).body);
      this._portalContainerNode.appendChild(this._overlayTarget);
    }
  },
  _unmountOverlayTarget: function _unmountOverlayTarget() {
    if (this._overlayTarget) {
      this._portalContainerNode.removeChild(this._overlayTarget);
      this._overlayTarget = null;
    }
    this._portalContainerNode = null;
  },
  _renderOverlay: function _renderOverlay() {

    var overlay = !this.props.children ? null : _react2.default.Children.only(this.props.children);

    // Save reference for future access.
    if (overlay !== null) {
      this._mountOverlayTarget();
      this._overlayInstance = _reactDom2.default.unstable_renderSubtreeIntoContainer(this, overlay, this._overlayTarget);
    } else {
      // Unrender if the component is null for transitions to null
      this._unrenderOverlay();
      this._unmountOverlayTarget();
    }
  },
  _unrenderOverlay: function _unrenderOverlay() {
    if (this._overlayTarget) {
      _reactDom2.default.unmountComponentAtNode(this._overlayTarget);
      this._overlayInstance = null;
    }
  },
  render: function render() {
    return null;
  },
  getMountNode: function getMountNode() {
    return this._overlayTarget;
  },
  getOverlayDOMNode: function getOverlayDOMNode() {
    if (!this.isMounted()) {
      throw new Error('getOverlayDOMNode(): A component must be mounted to have a DOM node.');
    }

    if (this._overlayInstance) {
      return _reactDom2.default.findDOMNode(this._overlayInstance);
    }

    return null;
  }
});

exports.default = Portal;
module.exports = exports['default'];
},{"./utils/getContainer":444,"./utils/ownerDocument":445,"react":"react","react-dom":"react-dom","react-prop-types/lib/componentOrElement":813}],439:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _componentOrElement = require('react-prop-types/lib/componentOrElement');

var _componentOrElement2 = _interopRequireDefault(_componentOrElement);

var _calculatePosition = require('./utils/calculatePosition');

var _calculatePosition2 = _interopRequireDefault(_calculatePosition);

var _getContainer = require('./utils/getContainer');

var _getContainer2 = _interopRequireDefault(_getContainer);

var _ownerDocument = require('./utils/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * The Position component calculates the coordinates for its child, to position
 * it relative to a `target` component or node. Useful for creating callouts
 * and tooltips, the Position component injects a `style` props with `left` and
 * `top` values for positioning your component.
 *
 * It also injects "arrow" `left`, and `top` values for styling callout arrows
 * for giving your components a sense of directionality.
 */
var Position = function (_React$Component) {
  _inherits(Position, _React$Component);

  function Position(props, context) {
    _classCallCheck(this, Position);

    var _this = _possibleConstructorReturn(this, (Position.__proto__ || Object.getPrototypeOf(Position)).call(this, props, context));

    _this.state = {
      positionLeft: 0,
      positionTop: 0,
      arrowOffsetLeft: null,
      arrowOffsetTop: null
    };

    _this._needsFlush = false;
    _this._lastTarget = null;
    return _this;
  }

  _createClass(Position, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updatePosition(this.getTarget());
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      this._needsFlush = true;
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this._needsFlush) {
        this._needsFlush = false;
        this.maybeUpdatePosition(this.props.placement !== prevProps.placement);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          children = _props.children,
          className = _props.className,
          props = _objectWithoutProperties(_props, ['children', 'className']);

      var _state = this.state,
          positionLeft = _state.positionLeft,
          positionTop = _state.positionTop,
          arrowPosition = _objectWithoutProperties(_state, ['positionLeft', 'positionTop']);

      // These should not be forwarded to the child.


      delete props.target;
      delete props.container;
      delete props.containerPadding;
      delete props.shouldUpdatePosition;

      var child = _react2.default.Children.only(children);
      return (0, _react.cloneElement)(child, _extends({}, props, arrowPosition, {
        // FIXME: Don't forward `positionLeft` and `positionTop` via both props
        // and `props.style`.
        positionLeft: positionLeft,
        positionTop: positionTop,
        className: (0, _classnames2.default)(className, child.props.className),
        style: _extends({}, child.props.style, {
          left: positionLeft,
          top: positionTop
        })
      }));
    }
  }, {
    key: 'getTarget',
    value: function getTarget() {
      var target = this.props.target;

      var targetElement = typeof target === 'function' ? target() : target;
      return targetElement && _reactDom2.default.findDOMNode(targetElement) || null;
    }
  }, {
    key: 'maybeUpdatePosition',
    value: function maybeUpdatePosition(placementChanged) {
      var target = this.getTarget();

      if (!this.props.shouldUpdatePosition && target === this._lastTarget && !placementChanged) {
        return;
      }

      this.updatePosition(target);
    }
  }, {
    key: 'updatePosition',
    value: function updatePosition(target) {
      this._lastTarget = target;

      if (!target) {
        this.setState({
          positionLeft: 0,
          positionTop: 0,
          arrowOffsetLeft: null,
          arrowOffsetTop: null
        });

        return;
      }

      var overlay = _reactDom2.default.findDOMNode(this);
      var container = (0, _getContainer2.default)(this.props.container, (0, _ownerDocument2.default)(this).body);

      this.setState((0, _calculatePosition2.default)(this.props.placement, overlay, target, container, this.props.containerPadding));
    }
  }]);

  return Position;
}(_react2.default.Component);

Position.propTypes = {
  /**
   * A node, element, or function that returns either. The child will be
   * be positioned next to the `target` specified.
   */
  target: _react2.default.PropTypes.oneOfType([_componentOrElement2.default, _react2.default.PropTypes.func]),

  /**
   * "offsetParent" of the component
   */
  container: _react2.default.PropTypes.oneOfType([_componentOrElement2.default, _react2.default.PropTypes.func]),
  /**
   * Minimum spacing in pixels between container border and component border
   */
  containerPadding: _react2.default.PropTypes.number,
  /**
   * How to position the component relative to the target
   */
  placement: _react2.default.PropTypes.oneOf(['top', 'right', 'bottom', 'left']),
  /**
   * Whether the position should be changed on each update
   */
  shouldUpdatePosition: _react2.default.PropTypes.bool
};

Position.displayName = 'Position';

Position.defaultProps = {
  containerPadding: 0,
  placement: 'right',
  shouldUpdatePosition: false
};

exports.default = Position;
module.exports = exports['default'];
},{"./utils/calculatePosition":443,"./utils/getContainer":444,"./utils/ownerDocument":445,"classnames":118,"react":"react","react-dom":"react-dom","react-prop-types/lib/componentOrElement":813}],440:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _contains = require('dom-helpers/query/contains');

var _contains2 = _interopRequireDefault(_contains);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _addEventListener = require('./utils/addEventListener');

var _addEventListener2 = _interopRequireDefault(_addEventListener);

var _ownerDocument = require('./utils/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var escapeKeyCode = 27;

function isLeftClickEvent(event) {
  return event.button === 0;
}

function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}

/**
 * The `<RootCloseWrapper/>` component registers your callback on the document
 * when rendered. Powers the `<Overlay/>` component. This is used achieve modal
 * style behavior where your callback is triggered when the user tries to
 * interact with the rest of the document or hits the `esc` key.
 */

var RootCloseWrapper = function (_React$Component) {
  _inherits(RootCloseWrapper, _React$Component);

  function RootCloseWrapper(props, context) {
    _classCallCheck(this, RootCloseWrapper);

    var _this = _possibleConstructorReturn(this, (RootCloseWrapper.__proto__ || Object.getPrototypeOf(RootCloseWrapper)).call(this, props, context));

    _this.handleMouseCapture = function (e) {
      _this.preventMouseRootClose = isModifiedEvent(e) || !isLeftClickEvent(e) || (0, _contains2.default)(_reactDom2.default.findDOMNode(_this), e.target);
    };

    _this.handleMouse = function (e) {
      if (!_this.preventMouseRootClose && _this.props.onRootClose) {
        _this.props.onRootClose(e);
      }
    };

    _this.handleKeyUp = function (e) {
      if (e.keyCode === escapeKeyCode && _this.props.onRootClose) {
        _this.props.onRootClose(e);
      }
    };

    _this.preventMouseRootClose = false;
    return _this;
  }

  _createClass(RootCloseWrapper, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (!this.props.disabled) {
        this.addEventListeners();
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (!this.props.disabled && prevProps.disabled) {
        this.addEventListeners();
      } else if (this.props.disabled && !prevProps.disabled) {
        this.removeEventListeners();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (!this.props.disabled) {
        this.removeEventListeners();
      }
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners() {
      var event = this.props.event;

      var doc = (0, _ownerDocument2.default)(this);

      // Use capture for this listener so it fires before React's listener, to
      // avoid false positives in the contains() check below if the target DOM
      // element is removed in the React mouse callback.
      this.documentMouseCaptureListener = (0, _addEventListener2.default)(doc, event, this.handleMouseCapture, true);

      this.documentMouseListener = (0, _addEventListener2.default)(doc, event, this.handleMouse);

      this.documentKeyupListener = (0, _addEventListener2.default)(doc, 'keyup', this.handleKeyUp);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners() {
      if (this.documentMouseCaptureListener) {
        this.documentMouseCaptureListener.remove();
      }

      if (this.documentMouseListener) {
        this.documentMouseListener.remove();
      }

      if (this.documentKeyupListener) {
        this.documentKeyupListener.remove();
      }
    }
  }, {
    key: 'render',
    value: function render() {
      return this.props.children;
    }
  }]);

  return RootCloseWrapper;
}(_react2.default.Component);

RootCloseWrapper.displayName = 'RootCloseWrapper';

RootCloseWrapper.propTypes = {
  /**
   * Callback fired after click or mousedown. Also triggers when user hits `esc`.
   */
  onRootClose: _react2.default.PropTypes.func,
  /**
   * Children to render.
   */
  children: _react2.default.PropTypes.element,
  /**
   * Disable the the RootCloseWrapper, preventing it from triggering `onRootClose`.
   */
  disabled: _react2.default.PropTypes.bool,
  /**
   * Choose which document mouse event to bind to.
   */
  event: _react2.default.PropTypes.oneOf(['click', 'mousedown'])
};

RootCloseWrapper.defaultProps = {
  event: 'click'
};

exports.default = RootCloseWrapper;
module.exports = exports['default'];
},{"./utils/addEventListener":442,"./utils/ownerDocument":445,"dom-helpers/query/contains":256,"react":"react","react-dom":"react-dom"}],441:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _on = require('dom-helpers/events/on');

var _on2 = _interopRequireDefault(_on);

var _properties = require('dom-helpers/transition/properties');

var _properties2 = _interopRequireDefault(_properties);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var transitionEndEvent = _properties2.default.end;

var UNMOUNTED = exports.UNMOUNTED = 0;
var EXITED = exports.EXITED = 1;
var ENTERING = exports.ENTERING = 2;
var ENTERED = exports.ENTERED = 3;
var EXITING = exports.EXITING = 4;

/**
 * The Transition component lets you define and run css transitions with a simple declarative api.
 * It works similar to React's own [CSSTransitionGroup](http://facebook.github.io/react/docs/animation.html#high-level-api-reactcsstransitiongroup)
 * but is specifically optimized for transitioning a single child "in" or "out".
 *
 * You don't even need to use class based css transitions if you don't want to (but it is easiest).
 * The extensive set of lifecycle callbacks means you have control over
 * the transitioning now at each step of the way.
 */

var Transition = function (_React$Component) {
  _inherits(Transition, _React$Component);

  function Transition(props, context) {
    _classCallCheck(this, Transition);

    var _this = _possibleConstructorReturn(this, (Transition.__proto__ || Object.getPrototypeOf(Transition)).call(this, props, context));

    var initialStatus = void 0;
    _this.nextStatus = null;

    if (props.in) {
      if (props.transitionAppear) {
        initialStatus = EXITED;
        _this.nextStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = { status: initialStatus };

    _this.nextCallback = null;
    return _this;
  }

  _createClass(Transition, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateStatus();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var status = this.state.status;


      if (nextProps.in) {
        if (status === UNMOUNTED) {
          this.setState({ status: EXITED });
        }
        if (status !== ENTERING && status !== ENTERED) {
          this.nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          this.nextStatus = EXITING;
        }
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateStatus();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.cancelNextCallback();
    }
  }, {
    key: 'updateStatus',
    value: function updateStatus() {
      var _this2 = this;

      if (this.nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();
        var node = _reactDom2.default.findDOMNode(this);

        if (this.nextStatus === ENTERING) {
          this.props.onEnter(node);

          this.safeSetState({ status: ENTERING }, function () {
            _this2.props.onEntering(node);

            _this2.onTransitionEnd(node, function () {
              _this2.safeSetState({ status: ENTERED }, function () {
                _this2.props.onEntered(node);
              });
            });
          });
        } else {
          this.props.onExit(node);

          this.safeSetState({ status: EXITING }, function () {
            _this2.props.onExiting(node);

            _this2.onTransitionEnd(node, function () {
              _this2.safeSetState({ status: EXITED }, function () {
                _this2.props.onExited(node);
              });
            });
          });
        }

        this.nextStatus = null;
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({ status: UNMOUNTED });
      }
    }
  }, {
    key: 'cancelNextCallback',
    value: function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    }
  }, {
    key: 'safeSetState',
    value: function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      this.setState(nextState, this.setNextCallback(callback));
    }
  }, {
    key: 'setNextCallback',
    value: function setNextCallback(callback) {
      var _this3 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this3.nextCallback = null;

          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    }
  }, {
    key: 'onTransitionEnd',
    value: function onTransitionEnd(node, handler) {
      this.setNextCallback(handler);

      if (node) {
        (0, _on2.default)(node, transitionEndEvent, this.nextCallback);
        setTimeout(this.nextCallback, this.props.timeout);
      } else {
        setTimeout(this.nextCallback, 0);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }

      var _props = this.props,
          children = _props.children,
          className = _props.className,
          childProps = _objectWithoutProperties(_props, ['children', 'className']);

      Object.keys(Transition.propTypes).forEach(function (key) {
        return delete childProps[key];
      });

      var transitionClassName = void 0;
      if (status === EXITED) {
        transitionClassName = this.props.exitedClassName;
      } else if (status === ENTERING) {
        transitionClassName = this.props.enteringClassName;
      } else if (status === ENTERED) {
        transitionClassName = this.props.enteredClassName;
      } else if (status === EXITING) {
        transitionClassName = this.props.exitingClassName;
      }

      var child = _react2.default.Children.only(children);
      return _react2.default.cloneElement(child, _extends({}, childProps, {
        className: (0, _classnames2.default)(child.props.className, className, transitionClassName)
      }));
    }
  }]);

  return Transition;
}(_react2.default.Component);

Transition.propTypes = {
  /**
   * Show the component; triggers the enter or exit animation
   */
  in: _react2.default.PropTypes.bool,

  /**
   * Wait until the first "enter" transition to mount the component (add it to the DOM)
   */
  mountOnEnter: _react2.default.PropTypes.bool,

  /**
   * Unmount the component (remove it from the DOM) when it is not shown
   */
  unmountOnExit: _react2.default.PropTypes.bool,

  /**
   * Run the enter animation when the component mounts, if it is initially
   * shown
   */
  transitionAppear: _react2.default.PropTypes.bool,

  /**
   * A Timeout for the animation, in milliseconds, to ensure that a node doesn't
   * transition indefinately if the browser transitionEnd events are
   * canceled or interrupted.
   *
   * By default this is set to a high number (5 seconds) as a failsafe. You should consider
   * setting this to the duration of your animation (or a bit above it).
   */
  timeout: _react2.default.PropTypes.number,

  /**
   * CSS class or classes applied when the component is exited
   */
  exitedClassName: _react2.default.PropTypes.string,
  /**
   * CSS class or classes applied while the component is exiting
   */
  exitingClassName: _react2.default.PropTypes.string,
  /**
   * CSS class or classes applied when the component is entered
   */
  enteredClassName: _react2.default.PropTypes.string,
  /**
   * CSS class or classes applied while the component is entering
   */
  enteringClassName: _react2.default.PropTypes.string,

  /**
   * Callback fired before the "entering" classes are applied
   */
  onEnter: _react2.default.PropTypes.func,
  /**
   * Callback fired after the "entering" classes are applied
   */
  onEntering: _react2.default.PropTypes.func,
  /**
   * Callback fired after the "enter" classes are applied
   */
  onEntered: _react2.default.PropTypes.func,
  /**
   * Callback fired before the "exiting" classes are applied
   */
  onExit: _react2.default.PropTypes.func,
  /**
   * Callback fired after the "exiting" classes are applied
   */
  onExiting: _react2.default.PropTypes.func,
  /**
   * Callback fired after the "exited" classes are applied
   */
  onExited: _react2.default.PropTypes.func
};

// Name the function so it is clearer in the documentation
function noop() {}

Transition.displayName = 'Transition';

Transition.defaultProps = {
  in: false,
  unmountOnExit: false,
  transitionAppear: false,

  timeout: 5000,

  onEnter: noop,
  onEntering: noop,
  onEntered: noop,

  onExit: noop,
  onExiting: noop,
  onExited: noop
};

exports.default = Transition;
},{"classnames":118,"dom-helpers/events/on":254,"dom-helpers/transition/properties":267,"react":"react","react-dom":"react-dom"}],442:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (node, event, handler, capture) {
  (0, _on2.default)(node, event, handler, capture);

  return {
    remove: function remove() {
      (0, _off2.default)(node, event, handler, capture);
    }
  };
};

var _on = require('dom-helpers/events/on');

var _on2 = _interopRequireDefault(_on);

var _off = require('dom-helpers/events/off');

var _off2 = _interopRequireDefault(_off);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
},{"dom-helpers/events/off":253,"dom-helpers/events/on":254}],443:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = calculatePosition;

var _offset = require('dom-helpers/query/offset');

var _offset2 = _interopRequireDefault(_offset);

var _position = require('dom-helpers/query/position');

var _position2 = _interopRequireDefault(_position);

var _scrollTop = require('dom-helpers/query/scrollTop');

var _scrollTop2 = _interopRequireDefault(_scrollTop);

var _ownerDocument = require('./ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getContainerDimensions(containerNode) {
  var width = void 0,
      height = void 0,
      scroll = void 0;

  if (containerNode.tagName === 'BODY') {
    width = window.innerWidth;
    height = window.innerHeight;

    scroll = (0, _scrollTop2.default)((0, _ownerDocument2.default)(containerNode).documentElement) || (0, _scrollTop2.default)(containerNode);
  } else {
    var _getOffset = (0, _offset2.default)(containerNode);

    width = _getOffset.width;
    height = _getOffset.height;

    scroll = (0, _scrollTop2.default)(containerNode);
  }

  return { width: width, height: height, scroll: scroll };
}

function getTopDelta(top, overlayHeight, container, padding) {
  var containerDimensions = getContainerDimensions(container);
  var containerScroll = containerDimensions.scroll;
  var containerHeight = containerDimensions.height;

  var topEdgeOffset = top - padding - containerScroll;
  var bottomEdgeOffset = top + padding - containerScroll + overlayHeight;

  if (topEdgeOffset < 0) {
    return -topEdgeOffset;
  } else if (bottomEdgeOffset > containerHeight) {
    return containerHeight - bottomEdgeOffset;
  } else {
    return 0;
  }
}

function getLeftDelta(left, overlayWidth, container, padding) {
  var containerDimensions = getContainerDimensions(container);
  var containerWidth = containerDimensions.width;

  var leftEdgeOffset = left - padding;
  var rightEdgeOffset = left + padding + overlayWidth;

  if (leftEdgeOffset < 0) {
    return -leftEdgeOffset;
  } else if (rightEdgeOffset > containerWidth) {
    return containerWidth - rightEdgeOffset;
  }

  return 0;
}

function calculatePosition(placement, overlayNode, target, container, padding) {
  var childOffset = container.tagName === 'BODY' ? (0, _offset2.default)(target) : (0, _position2.default)(target, container);

  var _getOffset2 = (0, _offset2.default)(overlayNode),
      overlayHeight = _getOffset2.height,
      overlayWidth = _getOffset2.width;

  var positionLeft = void 0,
      positionTop = void 0,
      arrowOffsetLeft = void 0,
      arrowOffsetTop = void 0;

  if (placement === 'left' || placement === 'right') {
    positionTop = childOffset.top + (childOffset.height - overlayHeight) / 2;

    if (placement === 'left') {
      positionLeft = childOffset.left - overlayWidth;
    } else {
      positionLeft = childOffset.left + childOffset.width;
    }

    var topDelta = getTopDelta(positionTop, overlayHeight, container, padding);

    positionTop += topDelta;
    arrowOffsetTop = 50 * (1 - 2 * topDelta / overlayHeight) + '%';
    arrowOffsetLeft = void 0;
  } else if (placement === 'top' || placement === 'bottom') {
    positionLeft = childOffset.left + (childOffset.width - overlayWidth) / 2;

    if (placement === 'top') {
      positionTop = childOffset.top - overlayHeight;
    } else {
      positionTop = childOffset.top + childOffset.height;
    }

    var leftDelta = getLeftDelta(positionLeft, overlayWidth, container, padding);

    positionLeft += leftDelta;
    arrowOffsetLeft = 50 * (1 - 2 * leftDelta / overlayWidth) + '%';
    arrowOffsetTop = void 0;
  } else {
    throw new Error('calcOverlayPosition(): No such placement of "' + placement + '" found.');
  }

  return { positionLeft: positionLeft, positionTop: positionTop, arrowOffsetLeft: arrowOffsetLeft, arrowOffsetTop: arrowOffsetTop };
}
module.exports = exports['default'];
},{"./ownerDocument":445,"dom-helpers/query/offset":258,"dom-helpers/query/position":260,"dom-helpers/query/scrollTop":262}],444:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getContainer;

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getContainer(container, defaultContainer) {
  container = typeof container === 'function' ? container() : container;
  return _reactDom2.default.findDOMNode(container) || defaultContainer;
}
module.exports = exports['default'];
},{"react-dom":"react-dom"}],445:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (componentOrElement) {
  return (0, _ownerDocument2.default)(_reactDom2.default.findDOMNode(componentOrElement));
};

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _ownerDocument = require('dom-helpers/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = exports['default'];
},{"dom-helpers/ownerDocument":255,"react-dom":"react-dom"}],446:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _AlphaPointer = require('./AlphaPointer');

var _AlphaPointer2 = _interopRequireDefault(_AlphaPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPicker = exports.AlphaPicker = function AlphaPicker(_ref) {
  var rgb = _ref.rgb,
      hsl = _ref.hsl,
      width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      direction = _ref.direction,
      style = _ref.style,
      renderers = _ref.renderers,
      pointer = _ref.pointer;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      alpha: {
        radius: '2px',
        style: style
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'alpha-picker' },
    _react2.default.createElement(_common.Alpha, _extends({}, styles.alpha, {
      rgb: rgb,
      hsl: hsl,
      pointer: pointer,
      renderers: renderers,
      onChange: onChange,
      direction: direction
    }))
  );
};

AlphaPicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _AlphaPointer2.default
};

exports.default = (0, _common.ColorWrap)(AlphaPicker);
},{"../common":463,"./AlphaPointer":447,"react":"react","reactcss":825}],447:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlphaPointer = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AlphaPointer = exports.AlphaPointer = function AlphaPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = AlphaPointer;
},{"react":"react","reactcss":825}],448:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Block = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _common = require('../common');

var _BlockSwatches = require('./BlockSwatches');

var _BlockSwatches2 = _interopRequireDefault(_BlockSwatches);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Block = exports.Block = function Block(_ref) {
  var onChange = _ref.onChange,
      hex = _ref.hex,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle;

  var handleChange = function handleChange(hexCode, e) {
    _color2.default.isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: 'hex'
    }, e);
  };

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        boxShadow: '0 1px rgba(0,0,0,.1)',
        borderRadius: '6px',
        position: 'relative'
      },
      head: {
        height: '110px',
        background: hex,
        borderRadius: '6px 6px 0 0',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      body: {
        padding: '10px'
      },
      label: {
        fontSize: '18px',
        color: '#fff'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 10px 10px 10px',
        borderColor: 'transparent transparent ' + hex + ' transparent',
        position: 'absolute',
        top: '-10px',
        left: '50%',
        marginLeft: '-10px'
      },
      input: {
        width: '100%',
        fontSize: '12px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '22px',
        boxShadow: 'inset 0 0 0 1px #ddd',
        borderRadius: '4px',
        padding: '0 7px',
        boxSizing: 'border-box'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      }
    }
  }, { 'hide-triangle': triangle === 'hide' });

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'block-picker' },
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.head },
      _react2.default.createElement(
        'div',
        { style: styles.label },
        hex
      )
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(_BlockSwatches2.default, { colors: colors, onClick: handleChange }),
      _react2.default.createElement(_common.EditableInput, {
        placeholder: 'Hex Code',
        style: { input: styles.input },
        value: '',
        onChange: handleChange
      })
    )
  );
};

Block.defaultProps = {
  width: '170px',
  colors: ['#D9E3F0', '#F47373', '#697689', '#37D67A', '#2CCCE4', '#555555', '#dce775', '#ff8a65', '#ba68c8'],
  triangle: 'top'
};

exports.default = (0, _common.ColorWrap)(Block);
},{"../../helpers/color":491,"../common":463,"./BlockSwatches":449,"react":"react","reactcss":825}],449:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BlockSwatches = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BlockSwatches = exports.BlockSwatches = function BlockSwatches(_ref) {
  var colors = _ref.colors,
      onClick = _ref.onClick;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginRight: '-10px'
      },
      swatch: {
        width: '22px',
        height: '22px',
        float: 'left',
        marginRight: '10px',
        marginBottom: '10px',
        borderRadius: '4px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_common.Swatch, {
        key: c,
        color: c,
        style: styles.swatch,
        onClick: onClick
      });
    }),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = BlockSwatches;
},{"../common":463,"lodash/map":623,"react":"react","reactcss":825}],450:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Chrome = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _ChromeFields = require('./ChromeFields');

var _ChromeFields2 = _interopRequireDefault(_ChromeFields);

var _ChromePointer = require('./ChromePointer');

var _ChromePointer2 = _interopRequireDefault(_ChromePointer);

var _ChromePointerCircle = require('./ChromePointerCircle');

var _ChromePointerCircle2 = _interopRequireDefault(_ChromePointerCircle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chrome = exports.Chrome = function Chrome(_ref) {
  var onChange = _ref.onChange,
      disableAlpha = _ref.disableAlpha,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hsv = _ref.hsv,
      hex = _ref.hex,
      renderers = _ref.renderers;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        background: '#fff',
        borderRadius: '2px',
        boxShadow: '0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)',
        boxSizing: 'initial',
        width: '225px',
        fontFamily: 'Menlo'
      },
      saturation: {
        width: '100%',
        paddingBottom: '55%',
        position: 'relative',
        borderRadius: '2px 2px 0 0',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '2px 2px 0 0'
      },
      body: {
        padding: '16px 16px 12px'
      },
      controls: {
        display: 'flex'
      },
      color: {
        width: '32px'
      },
      swatch: {
        marginTop: '6px',
        width: '16px',
        height: '16px',
        borderRadius: '8px',
        position: 'relative',
        overflow: 'hidden'
      },
      active: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '8px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.1)',
        background: 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + rgb.a + ')',
        zIndex: '2'
      },
      toggles: {
        flex: '1'
      },
      hue: {
        height: '10px',
        position: 'relative',
        marginBottom: '8px'
      },
      Hue: {
        radius: '2px'
      },
      alpha: {
        height: '10px',
        position: 'relative'
      },
      Alpha: {
        radius: '2px'
      }
    },
    'disableAlpha': {
      color: {
        width: '22px'
      },
      alpha: {
        display: 'none'
      },
      hue: {
        marginBottom: '0px'
      },
      swatch: {
        width: '10px',
        height: '10px',
        marginTop: '0px'
      }
    }
  }, { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'chrome-picker' },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        pointer: _ChromePointerCircle2.default,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      _react2.default.createElement(
        'div',
        { style: styles.controls, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.color },
          _react2.default.createElement(
            'div',
            { style: styles.swatch },
            _react2.default.createElement('div', { style: styles.active }),
            _react2.default.createElement(_common.Checkboard, { renderers: renderers })
          )
        ),
        _react2.default.createElement(
          'div',
          { style: styles.toggles },
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              style: styles.Hue,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              onChange: onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.Alpha, {
              style: styles.Alpha,
              rgb: rgb,
              hsl: hsl,
              pointer: _ChromePointer2.default,
              renderers: renderers,
              onChange: onChange
            })
          )
        )
      ),
      _react2.default.createElement(_ChromeFields2.default, {
        rgb: rgb,
        hsl: hsl,
        hex: hex,
        onChange: onChange,
        disableAlpha: disableAlpha
      })
    )
  );
};

exports.default = (0, _common.ColorWrap)(Chrome);
},{"../common":463,"./ChromeFields":451,"./ChromePointer":452,"./ChromePointerCircle":453,"react":"react","reactcss":825}],451:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromeFields = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint-disable react/no-did-mount-set-state, no-param-reassign */

var ChromeFields = exports.ChromeFields = function (_React$Component) {
  _inherits(ChromeFields, _React$Component);

  function ChromeFields() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, ChromeFields);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = ChromeFields.__proto__ || Object.getPrototypeOf(ChromeFields)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
      view: ''
    }, _this.toggleViews = function () {
      if (_this.state.view === 'hex') {
        _this.setState({ view: 'rgb' });
      } else if (_this.state.view === 'rgb') {
        _this.setState({ view: 'hsl' });
      } else if (_this.state.view === 'hsl') {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: 'hex' });
        } else {
          _this.setState({ view: 'rgb' });
        }
      }
    }, _this.handleChange = function (data, e) {
      if (data.hex) {
        _color2.default.isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: 'hex'
        }, e);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: 'rgb'
        }, e);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }

        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: 'rgb'
        }, e);
      } else if (data.h || data.s || data.l) {
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: data.s && data.s.replace('%', '') || _this.props.hsl.s,
          l: data.l && data.l.replace('%', '') || _this.props.hsl.l,
          source: 'hsl'
        }, e);
      }
    }, _this.showHighlight = function (e) {
      e.target.style.background = '#eee';
    }, _this.hideHighlight = function (e) {
      e.target.style.background = 'transparent';
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(ChromeFields, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.hsl.a === 1 && this.state.view !== 'hex') {
        this.setState({ view: 'hex' });
      } else if (this.state.view !== 'rgb' && this.state.view !== 'hsl') {
        this.setState({ view: 'rgb' });
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.hsl.a !== 1 && this.state.view === 'hex') {
        this.setState({ view: 'rgb' });
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            paddingTop: '16px',
            display: 'flex'
          },
          fields: {
            flex: '1',
            display: 'flex',
            marginLeft: '-6px'
          },
          field: {
            paddingLeft: '6px',
            width: '100%'
          },
          alpha: {
            paddingLeft: '6px',
            width: '100%'
          },
          toggle: {
            width: '32px',
            textAlign: 'right',
            position: 'relative'
          },
          icon: {
            marginRight: '-4px',
            marginTop: '12px',
            cursor: 'pointer',
            position: 'relative'
          },
          iconHighlight: {
            position: 'absolute',
            width: '24px',
            height: '28px',
            background: '#eee',
            borderRadius: '4px',
            top: '10px',
            left: '12px',
            display: 'none'
          },
          input: {
            fontSize: '11px',
            color: '#333',
            width: '100%',
            borderRadius: '2px',
            border: 'none',
            boxShadow: 'inset 0 0 0 1px #dadada',
            height: '21px',
            textAlign: 'center'
          },
          label: {
            textTransform: 'uppercase',
            fontSize: '11px',
            lineHeight: '11px',
            color: '#969696',
            textAlign: 'center',
            display: 'block',
            marginTop: '12px'
          },
          svg: {
            width: '24px',
            height: '24px',
            border: '1px transparent solid',
            borderRadius: '5px'
          }
        },
        'disableAlpha': {
          alpha: {
            display: 'none'
          }
        }
      }, this.props, this.state);

      var fields = void 0;
      if (this.state.view === 'hex') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'hex', value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'rgb') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'r',
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'g',
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'b',
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === 'hsl') {
        fields = _react2.default.createElement(
          'div',
          { style: styles.fields, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'h',
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 's',
              value: Math.round(this.props.hsl.s * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.field },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'l',
              value: Math.round(this.props.hsl.l * 100) + '%',
              onChange: this.handleChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.alpha },
            _react2.default.createElement(_common.EditableInput, {
              style: { input: styles.input, label: styles.label },
              label: 'a',
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }

      return _react2.default.createElement(
        'div',
        { style: styles.wrap, className: 'flexbox-fix' },
        fields,
        _react2.default.createElement(
          'div',
          { style: styles.toggle },
          _react2.default.createElement(
            'div',
            { style: styles.icon, onClick: this.toggleViews, ref: 'icon' },
            _react2.default.createElement(
              'svg',
              {
                style: styles.svg,
                viewBox: '0 0 24 24',
                onMouseOver: this.showHighlight,
                onMouseEnter: this.showHighlight,
                onMouseOut: this.hideHighlight
              },
              _react2.default.createElement('path', {
                ref: 'iconUp',
                fill: '#333',
                d: 'M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z'
              }),
              _react2.default.createElement('path', {
                ref: 'iconDown',
                fill: '#333',
                d: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15Z'
              })
            )
          )
        )
      );
    }
  }]);

  return ChromeFields;
}(_react2.default.Component);

exports.default = ChromeFields;
},{"../../helpers/color":491,"../common":463,"react":"react","reactcss":825}],452:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointer = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointer = exports.ChromePointer = function ChromePointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        transform: 'translate(-6px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointer;
},{"react":"react","reactcss":825}],453:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChromePointerCircle = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ChromePointerCircle = exports.ChromePointerCircle = function ChromePointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = ChromePointerCircle;
},{"react":"react","reactcss":825}],454:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Circle = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _materialColors = require('material-colors');

var material = _interopRequireWildcard(_materialColors);

var _common = require('../common');

var _CircleSwatch = require('./CircleSwatch');

var _CircleSwatch2 = _interopRequireDefault(_CircleSwatch);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Circle = exports.Circle = function Circle(_ref) {
  var width = _ref.width,
      onChange = _ref.onChange,
      colors = _ref.colors,
      hex = _ref.hex,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        display: 'flex',
        flexWrap: 'wrap',
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  });

  var handleChange = function handleChange(hexCode, e) {
    return onChange({ hex: hexCode, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'circle-picker' },
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_CircleSwatch2.default, {
        key: c,
        color: c,
        onClick: handleChange,
        active: hex === c.toLowerCase(),
        circleSize: circleSize,
        circleSpacing: circleSpacing
      });
    })
  );
};

Circle.defaultProps = {
  width: '252px',
  circleSize: 28,
  circleSpacing: 14,
  colors: [material.red['500'], material.pink['500'], material.purple['500'], material.deepPurple['500'], material.indigo['500'], material.blue['500'], material.lightBlue['500'], material.cyan['500'], material.teal['500'], material.green['500'], material.lightGreen['500'], material.lime['500'], material.yellow['500'], material.amber['500'], material.orange['500'], material.deepOrange['500'], material.brown['500'], material.blueGrey['500']]
};

exports.default = (0, _common.ColorWrap)(Circle);
},{"../common":463,"./CircleSwatch":455,"lodash/map":623,"material-colors":336,"react":"react","reactcss":825}],455:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CircleSwatch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CircleSwatch = exports.CircleSwatch = function CircleSwatch(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      hover = _ref.hover,
      active = _ref.active,
      circleSize = _ref.circleSize,
      circleSpacing = _ref.circleSpacing;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: 'scale(1)',
        transition: '100ms transform ease'
      },
      Swatch: {
        borderRadius: '50%',
        background: 'transparent',
        boxShadow: 'inset 0 0 0 ' + circleSize / 2 + 'px ' + color,
        transition: '100ms box-shadow ease'
      }
    },
    'hover': {
      swatch: {
        transform: 'scale(1.2)'
      }
    },
    'active': {
      Swatch: {
        boxShadow: 'inset 0 0 0 3px ' + color
      }
    }
  }, { hover: hover, active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, { style: styles.Swatch, color: color, onClick: onClick })
  );
};

CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};

exports.default = (0, _reactcss.handleHover)(CircleSwatch);
},{"../common":463,"react":"react","reactcss":825}],456:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Alpha = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _alpha = require('../../helpers/alpha');

var alpha = _interopRequireWildcard(_alpha);

var _Checkboard = require('./Checkboard');

var _Checkboard2 = _interopRequireDefault(_Checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Alpha = exports.Alpha = function (_ref) {
  _inherits(Alpha, _ref);

  function Alpha() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Alpha);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha.__proto__ || Object.getPrototypeOf(Alpha)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e, skip) {
      var change = alpha.calculateChange(e, skip, _this.props, _this.refs.container);
      change && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleChange);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Alpha, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var rgb = this.props.rgb;
      var styles = (0, _reactcss2.default)({
        'default': {
          alpha: {
            absolute: '0px 0px 0px 0px',
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: '0px 0px 0px 0px',
            overflow: 'hidden'
          },
          gradient: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)',
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: 'relative',
            height: '100%',
            margin: '0 3px'
          },
          pointer: {
            position: 'absolute',
            left: rgb.a * 100 + '%'
          },
          slider: {
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            marginTop: '1px',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          gradient: {
            background: 'linear-gradient(to bottom, rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 0) 0%,\n           rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ', 1) 100%)'
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + '%'
          }
        },
        'overwrite': _extends({}, this.props.style)
      }, {
        vertical: this.props.direction === 'vertical',
        overwrite: true
      });

      return _react2.default.createElement(
        'div',
        { style: styles.alpha },
        _react2.default.createElement(
          'div',
          { style: styles.checkboard },
          _react2.default.createElement(_Checkboard2.default, { renderers: this.props.renderers })
        ),
        _react2.default.createElement('div', { style: styles.gradient }),
        _react2.default.createElement(
          'div',
          {
            style: styles.container,
            ref: 'container',
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Alpha;
}(_react.PureComponent || _react.Component);

exports.default = Alpha;
},{"../../helpers/alpha":489,"./Checkboard":457,"react":"react","reactcss":825}],457:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkboard = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _checkboard = require('../../helpers/checkboard');

var checkboard = _interopRequireWildcard(_checkboard);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Checkboard = exports.Checkboard = function Checkboard(_ref) {
  var white = _ref.white,
      grey = _ref.grey,
      size = _ref.size,
      renderers = _ref.renderers;

  var styles = (0, _reactcss2.default)({
    'default': {
      grid: {
        absolute: '0px 0px 0px 0px',
        background: 'url(' + checkboard.get(white, grey, size, renderers.canvas) + ') center left'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.grid });
};

Checkboard.defaultProps = {
  size: 8,
  white: 'transparent',
  grey: 'rgba(0,0,0,.08)',
  renderers: {}
};

exports.default = Checkboard;
},{"../../helpers/checkboard":490,"react":"react","reactcss":825}],458:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ColorWrap = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _debounce = require('lodash/debounce');

var _debounce2 = _interopRequireDefault(_debounce);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ColorWrap = exports.ColorWrap = function ColorWrap(Picker) {
  var ColorPicker = function (_ref) {
    _inherits(ColorPicker, _ref);

    function ColorPicker(props) {
      _classCallCheck(this, ColorPicker);

      var _this = _possibleConstructorReturn(this, (ColorPicker.__proto__ || Object.getPrototypeOf(ColorPicker)).call(this));

      _this.handleChange = function (data, event) {
        var isValidColor = _color2.default.simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = _color2.default.toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };

      _this.state = _extends({}, _color2.default.toState(props.color, 0), {
        visible: props.display
      });

      _this.debounce = (0, _debounce2.default)(function (fn, data, event) {
        fn(data, event);
      }, 100);
      return _this;
    }

    _createClass(ColorPicker, [{
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.setState(_extends({}, _color2.default.toState(nextProps.color, this.state.oldHue), {
          visible: nextProps.display
        }));
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(Picker, _extends({}, this.props, this.state, { onChange: this.handleChange }));
      }
    }]);

    return ColorPicker;
  }(_react.PureComponent || _react.Component);

  ColorPicker.defaultProps = {
    color: {
      h: 250,
      s: 0.50,
      l: 0.20,
      a: 1
    }
  };

  return ColorPicker;
};

exports.default = ColorWrap;
},{"../../helpers/color":491,"lodash/debounce":604,"react":"react"}],459:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EditableInput = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EditableInput = exports.EditableInput = function (_ref) {
  _inherits(EditableInput, _ref);

  function EditableInput(props) {
    _classCallCheck(this, EditableInput);

    var _this = _possibleConstructorReturn(this, (EditableInput.__proto__ || Object.getPrototypeOf(EditableInput)).call(this));

    _this.handleBlur = function () {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };

    _this.handleChange = function (e) {
      if (!!_this.props.label) {
        _this.props.onChange(_defineProperty({}, _this.props.label, e.target.value), e);
      } else {
        _this.props.onChange(e.target.value, e);
      }

      _this.setState({ value: e.target.value });
    };

    _this.handleKeyDown = function (e) {
      var number = Number(e.target.value);
      if (!isNaN(number)) {
        var amount = _this.props.arrowOffset || 1;

        // Up
        if (e.keyCode === 38) {
          if (_this.props.label !== null) {
            _this.props.onChange(_defineProperty({}, _this.props.label, number + amount), e);
          } else {
            _this.props.onChange(number + amount, e);
          }

          _this.setState({ value: number + amount });
        }

        // Down
        if (e.keyCode === 40) {
          if (_this.props.label !== null) {
            _this.props.onChange(_defineProperty({}, _this.props.label, number - amount), e);
          } else {
            _this.props.onChange(number - amount, e);
          }

          _this.setState({ value: number - amount });
        }
      }
    };

    _this.handleDrag = function (e) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange(_defineProperty({}, _this.props.label, newValue), e);
        }
      }
    };

    _this.handleMouseDown = function (e) {
      if (_this.props.dragLabel) {
        e.preventDefault();
        _this.handleDrag(e);
        window.addEventListener('mousemove', _this.handleDrag);
        window.addEventListener('mouseup', _this.handleMouseUp);
      }
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.unbindEventListeners = function () {
      window.removeEventListener('mousemove', _this.handleDrag);
      window.removeEventListener('mouseup', _this.handleMouseUp);
    };

    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    return _this;
  }

  _createClass(EditableInput, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var input = this.refs.input;
      if (nextProps.value !== this.state.value) {
        if (input === document.activeElement) {
          this.setState({ blurValue: String(nextProps.value).toUpperCase() });
        } else {
          this.setState({ value: String(nextProps.value).toUpperCase() });
        }
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'render',
    value: function render() {
      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            position: 'relative'
          }
        },
        'user-override': {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        'dragLabel-true': {
          label: {
            cursor: 'ew-resize'
          }
        }
      }, {
        'user-override': true
      }, this.props);

      return _react2.default.createElement(
        'div',
        { style: styles.wrap },
        _react2.default.createElement('input', {
          style: styles.input,
          ref: 'input',
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder
        }),
        this.props.label ? _react2.default.createElement(
          'span',
          { style: styles.label, onMouseDown: this.handleMouseDown },
          this.props.label
        ) : null
      );
    }
  }]);

  return EditableInput;
}(_react.PureComponent || _react.Component);

exports.default = EditableInput;
},{"react":"react","reactcss":825}],460:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Hue = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _hue = require('../../helpers/hue');

var hue = _interopRequireWildcard(_hue);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Hue = exports.Hue = function (_ref) {
  _inherits(Hue, _ref);

  function Hue() {
    var _ref2;

    var _temp, _this, _ret;

    _classCallCheck(this, Hue);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Hue.__proto__ || Object.getPrototypeOf(Hue)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function (e, skip) {
      var change = hue.calculateChange(e, skip, _this.props, _this.refs.container);
      change && _this.props.onChange(change, e);
    }, _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    }, _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Hue, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var styles = (0, _reactcss2.default)({
        'default': {
          hue: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, #f00 0%, #ff0 17%, #0f0 33%,\n            #0ff 50%, #00f 67%, #f0f 83%, #f00 100%)',
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            margin: '0 2px',
            position: 'relative',
            height: '100%'
          },
          pointer: {
            position: 'absolute',
            left: this.props.hsl.h * 100 / 360 + '%'
          },
          slider: {
            marginTop: '1px',
            width: '4px',
            borderRadius: '1px',
            height: '8px',
            boxShadow: '0 0 2px rgba(0, 0, 0, .6)',
            background: '#fff',
            transform: 'translateX(-2px)'
          }
        },
        'vertical': {
          hue: {
            background: 'linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n            #0ff 50%, #00f 67%, #f0f 83%, #f00 100%)'
          },
          pointer: {
            left: '0px',
            top: -(this.props.hsl.h * 100 / 360) + 100 + '%'
          }
        }
      }, { vertical: this.props.direction === 'vertical' });

      return _react2.default.createElement(
        'div',
        { style: styles.hue },
        _react2.default.createElement(
          'div',
          {
            style: styles.container,
            ref: 'container',
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.slider })
          )
        )
      );
    }
  }]);

  return Hue;
}(_react.PureComponent || _react.Component);

exports.default = Hue;
},{"../../helpers/hue":492,"react":"react","reactcss":825}],461:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Saturation = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _saturation = require('../../helpers/saturation');

var saturation = _interopRequireWildcard(_saturation);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Saturation = exports.Saturation = function (_ref) {
  _inherits(Saturation, _ref);

  function Saturation(props) {
    _classCallCheck(this, Saturation);

    var _this = _possibleConstructorReturn(this, (Saturation.__proto__ || Object.getPrototypeOf(Saturation)).call(this, props));

    _this.handleChange = function (e, skip) {
      _this.throttle(_this.props.onChange, saturation.calculateChange(e, skip, _this.props, _this.refs.container), e);
    };

    _this.handleMouseDown = function (e) {
      _this.handleChange(e, true);
      window.addEventListener('mousemove', _this.handleChange);
      window.addEventListener('mouseup', _this.handleMouseUp);
    };

    _this.handleMouseUp = function () {
      _this.unbindEventListeners();
    };

    _this.throttle = (0, _throttle2.default)(function (fn, data, e) {
      fn(data, e);
    }, 50);
    return _this;
  }

  _createClass(Saturation, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: 'unbindEventListeners',
    value: function unbindEventListeners() {
      window.removeEventListener('mousemove', this.handleChange);
      window.removeEventListener('mouseup', this.handleMouseUp);
    }
  }, {
    key: 'render',
    value: function render() {
      var _ref2 = this.props.style || {},
          color = _ref2.color,
          white = _ref2.white,
          black = _ref2.black,
          pointer = _ref2.pointer,
          circle = _ref2.circle;

      var styles = (0, _reactcss2.default)({
        'default': {
          color: {
            absolute: '0px 0px 0px 0px',
            background: 'hsl(' + this.props.hsl.h + ',100%, 50%)',
            borderRadius: this.props.radius
          },
          white: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to right, #fff, rgba(255,255,255,0))'
          },
          black: {
            absolute: '0px 0px 0px 0px',
            background: 'linear-gradient(to top, #000, rgba(0,0,0,0))',
            boxShadow: this.props.shadow
          },
          pointer: {
            position: 'absolute',
            top: -(this.props.hsv.v * 100) + 100 + '%',
            left: this.props.hsv.s * 100 + '%',
            cursor: 'default'
          },
          circle: {
            width: '4px',
            height: '4px',
            boxShadow: '0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)',
            borderRadius: '50%',
            cursor: 'hand',
            transform: 'translate(-2px, -2px)'
          }
        },
        'custom': {
          color: color,
          white: white,
          black: black,
          pointer: pointer,
          circle: circle
        }
      }, { 'custom': !!this.props.style });

      return _react2.default.createElement(
        'div',
        {
          style: styles.color,
          ref: 'container',
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        _react2.default.createElement(
          'div',
          { style: styles.white },
          _react2.default.createElement('div', { style: styles.black }),
          _react2.default.createElement(
            'div',
            { style: styles.pointer },
            this.props.pointer ? _react2.default.createElement(this.props.pointer, this.props) : _react2.default.createElement('div', { style: styles.circle })
          )
        )
      );
    }
  }]);

  return Saturation;
}(_react.PureComponent || _react.Component);

exports.default = Saturation;
},{"../../helpers/saturation":493,"lodash/throttle":629,"react":"react","reactcss":825}],462:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Swatch = exports.Swatch = function Swatch(_ref) {
  var color = _ref.color,
      style = _ref.style,
      onClick = _ref.onClick,
      _ref$title = _ref.title,
      title = _ref$title === undefined ? color : _ref$title;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        background: color,
        height: '100%',
        width: '100%',
        cursor: 'pointer'
      }
    },
    'custom': {
      swatch: style
    }
  }, 'custom');

  var handleClick = function handleClick(e) {
    return onClick(color, e);
  };

  return _react2.default.createElement('div', { style: styles.swatch, onClick: handleClick, title: title });
};

exports.default = Swatch;
},{"react":"react","reactcss":825}],463:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Alpha = require('./Alpha');

Object.defineProperty(exports, 'Alpha', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Checkboard = require('./Checkboard');

Object.defineProperty(exports, 'Checkboard', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Checkboard).default;
  }
});

var _EditableInput = require('./EditableInput');

Object.defineProperty(exports, 'EditableInput', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_EditableInput).default;
  }
});

var _Hue = require('./Hue');

Object.defineProperty(exports, 'Hue', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Saturation = require('./Saturation');

Object.defineProperty(exports, 'Saturation', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Saturation).default;
  }
});

var _ColorWrap = require('./ColorWrap');

Object.defineProperty(exports, 'ColorWrap', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Swatch = require('./Swatch');

Object.defineProperty(exports, 'Swatch', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatch).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./Alpha":456,"./Checkboard":457,"./ColorWrap":458,"./EditableInput":459,"./Hue":460,"./Saturation":461,"./Swatch":462}],464:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Compact = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _reactMaterialDesign = require('../../../modules/react-material-design');

var _common = require('../common');

var _CompactColor = require('./CompactColor');

var _CompactColor2 = _interopRequireDefault(_CompactColor);

var _CompactFields = require('./CompactFields');

var _CompactFields2 = _interopRequireDefault(_CompactFields);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Compact = exports.Compact = function Compact(_ref) {
  var onChange = _ref.onChange,
      colors = _ref.colors,
      hex = _ref.hex,
      rgb = _ref.rgb;

  var styles = (0, _reactcss2.default)({
    'default': {
      Compact: {
        background: '#f6f6f6',
        radius: '4px'
      },
      compact: {
        paddingTop: '5px',
        paddingLeft: '5px',
        boxSizing: 'initial',
        width: '240px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else {
      onChange(data, e);
    }
  };

  return _react2.default.createElement(
    _reactMaterialDesign.Raised,
    { style: styles.Compact },
    _react2.default.createElement(
      'div',
      { style: styles.compact, className: 'compact-picker' },
      _react2.default.createElement(
        'div',
        null,
        (0, _map2.default)(colors, function (c) {
          return _react2.default.createElement(_CompactColor2.default, {
            key: c,
            color: c,
            active: c.toLowerCase() === hex,
            onClick: handleChange
          });
        }),
        _react2.default.createElement('div', { style: styles.clear })
      ),
      _react2.default.createElement(_CompactFields2.default, { hex: hex, rgb: rgb, onChange: handleChange })
    )
  );
};

Compact.defaultProps = {
  colors: ['#4D4D4D', '#999999', '#FFFFFF', '#F44E3B', '#FE9200', '#FCDC00', '#DBDF00', '#A4DD00', '#68CCCA', '#73D8FF', '#AEA1FF', '#FDA1FF', '#333333', '#808080', '#cccccc', '#D33115', '#E27300', '#FCC400', '#B0BC00', '#68BC00', '#16A5A5', '#009CE0', '#7B64FF', '#FA28FF', '#000000', '#666666', '#B3B3B3', '#9F0500', '#C45100', '#FB9E00', '#808900', '#194D33', '#0C797D', '#0062B1', '#653294', '#AB149E']
};

exports.default = (0, _common.ColorWrap)(Compact);
},{"../../../modules/react-material-design":495,"../../helpers/color":491,"../common":463,"./CompactColor":465,"./CompactFields":466,"lodash/map":623,"react":"react","reactcss":825}],465:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactColor = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactColor = exports.CompactColor = function CompactColor(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        background: color,
        width: '15px',
        height: '15px',
        float: 'left',
        marginRight: '5px',
        marginBottom: '5px',
        position: 'relative',
        cursor: 'pointer'
      },
      dot: {
        absolute: '5px 5px 5px 5px',
        background: '#fff',
        borderRadius: '50%',
        opacity: '0'
      }
    },
    'active': {
      dot: {
        opacity: '1'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      dot: {
        background: '#000'
      }
    }
  }, { active: active, 'color-#FFFFFF': color === '#FFFFFF' });

  var handleClick = function handleClick(e) {
    return onClick({ hex: color }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.color, onClick: handleClick },
    _react2.default.createElement('div', { style: styles.dot })
  );
};

exports.default = CompactColor;
},{"react":"react","reactcss":825}],466:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CompactFields = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CompactFields = exports.CompactFields = function CompactFields(_ref) {
  var hex = _ref.hex,
      rgb = _ref.rgb,
      onChange = _ref.onChange;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingBottom: '6px',
        paddingRight: '5px',
        position: 'relative'
      },
      active: {
        position: 'absolute',
        top: '6px',
        left: '5px',
        height: '9px',
        width: '9px',
        background: hex
      },
      HEXwrap: {
        flex: '6',
        position: 'relative'
      },
      HEXinput: {
        width: '80%',
        padding: '0px',
        paddingLeft: '20%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      HEXlabel: {
        display: 'none'
      },
      RGBwrap: {
        flex: '3',
        position: 'relative'
      },
      RGBinput: {
        width: '70%',
        padding: '0px',
        paddingLeft: '30%',
        border: 'none',
        outline: 'none',
        background: 'none',
        fontSize: '12px',
        color: '#333',
        height: '16px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '3px',
        left: '0px',
        lineHeight: '16px',
        textTransform: 'uppercase',
        fontSize: '12px',
        color: '#999'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else {
      onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement('div', { style: styles.active }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: 'hex',
      value: hex,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    })
  );
};

exports.default = CompactFields;
},{"../common":463,"react":"react","reactcss":825}],467:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Github = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _common = require('../common');

var _GithubSwatch = require('./GithubSwatch');

var _GithubSwatch2 = _interopRequireDefault(_GithubSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Github = exports.Github = function Github(_ref) {
  var width = _ref.width,
      colors = _ref.colors,
      onChange = _ref.onChange,
      triangle = _ref.triangle;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '1px solid rgba(0,0,0,0.2)',
        boxShadow: '0 3px 12px rgba(0,0,0,0.15)',
        borderRadius: '4px',
        position: 'relative',
        padding: '5px',
        display: 'flex',
        flexWrap: 'wrap'
      },
      triangle: {
        position: 'absolute',
        border: '7px solid transparent',
        borderBottomColor: '#fff'
      },
      triangleShadow: {
        position: 'absolute',
        border: '8px solid transparent',
        borderBottomColor: 'rgba(0,0,0,0.15)'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-14px',
        left: '10px'
      },
      triangleShadow: {
        top: '-16px',
        left: '9px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-14px',
        right: '10px'
      },
      triangleShadow: {
        top: '-16px',
        right: '9px'
      }
    }
  }, {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right'
  });

  var handleChange = function handleChange(hex, e) {
    return onChange({ hex: hex, source: 'hex' }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'github-picker' },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    (0, _map2.default)(colors, function (c) {
      return _react2.default.createElement(_GithubSwatch2.default, { color: c, key: c, onClick: handleChange });
    })
  );
};

Github.defaultProps = {
  width: '200px',
  colors: ['#B80000', '#DB3E00', '#FCCB00', '#008B02', '#006B76', '#1273DE', '#004DCF', '#5300EB', '#EB9694', '#FAD0C3', '#FEF3BD', '#C1E1C5', '#BEDADC', '#C4DEF6', '#BED3F3', '#D4C4FB'],
  triangle: 'top-left'
};

exports.default = (0, _common.ColorWrap)(Github);
},{"../common":463,"./GithubSwatch":468,"lodash/map":623,"react":"react","reactcss":825}],468:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GithubSwatch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GithubSwatch = exports.GithubSwatch = function GithubSwatch(_ref) {
  var hover = _ref.hover,
      color = _ref.color,
      onClick = _ref.onClick;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        width: '25px',
        height: '25px'
      }
    },
    'hover': {
      swatch: {
        position: 'relative',
        zIndex: '2',
        outline: '2px solid #fff',
        boxShadow: '0 0 5px 2px rgba(0,0,0,0.25)'
      }
    }
  }, { hover: hover });

  return _react2.default.createElement(
    'div',
    { style: styles.swatch },
    _react2.default.createElement(_common.Swatch, { color: color, onClick: onClick })
  );
};

exports.default = (0, _reactcss.handleHover)(GithubSwatch);
},{"../common":463,"react":"react","reactcss":825}],469:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HuePicker = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _HuePointer = require('./HuePointer');

var _HuePointer2 = _interopRequireDefault(_HuePointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var HuePicker = exports.HuePicker = function HuePicker(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      hsl = _ref.hsl,
      direction = _ref.direction,
      pointer = _ref.pointer;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        position: 'relative',
        width: width,
        height: height
      },
      hue: {
        radius: '2px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'hue-picker' },
    _react2.default.createElement(_common.Hue, _extends({}, styles.hue, {
      hsl: hsl,
      pointer: pointer,
      onChange: onChange,
      direction: direction
    }))
  );
};

HuePicker.defaultProps = {
  width: '316px',
  height: '16px',
  direction: 'horizontal',
  pointer: _HuePointer2.default
};

exports.default = (0, _common.ColorWrap)(HuePicker);
},{"../common":463,"./HuePointer":470,"react":"react","reactcss":825}],470:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer(_ref) {
  var direction = _ref.direction;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '18px',
        height: '18px',
        borderRadius: '50%',
        transform: 'translate(-9px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    },
    'vertical': {
      picker: {
        transform: 'translate(-3px, -9px)'
      }
    }
  }, { vertical: direction === 'vertical' });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;
},{"react":"react","reactcss":825}],471:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Material = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _reactMaterialDesign = require('../../../modules/react-material-design');

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Material = exports.Material = function Material(_ref) {
  var onChange = _ref.onChange,
      hex = _ref.hex,
      rgb = _ref.rgb;

  var styles = (0, _reactcss2.default)({
    'default': {
      material: {
        width: '98px',
        height: '98px',
        padding: '16px',
        fontFamily: 'Roboto'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '2px solid ' + hex,
        outline: 'none',
        height: '30px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        width: '100%',
        marginTop: '12px',
        fontSize: '15px',
        color: '#333',
        padding: '0px',
        border: '0px',
        borderBottom: '1px solid #eee',
        outline: 'none',
        height: '30px'
      },
      RGBlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        fontSize: '11px',
        color: '#999999',
        textTransform: 'capitalize'
      },
      split: {
        display: 'flex',
        marginRight: '-10px',
        paddingTop: '11px'
      },
      third: {
        flex: '1',
        paddingRight: '10px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    _reactMaterialDesign.Raised,
    null,
    _react2.default.createElement(
      'div',
      { style: styles.material, className: 'material-picker' },
      _react2.default.createElement(_common.EditableInput, {
        style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
        label: 'hex',
        value: hex,
        onChange: handleChange
      }),
      _react2.default.createElement(
        'div',
        { style: styles.split, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'r', value: rgb.r,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'g',
            value: rgb.g,
            onChange: handleChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.third },
          _react2.default.createElement(_common.EditableInput, {
            style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
            label: 'b',
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};

exports.default = (0, _common.ColorWrap)(Material);
},{"../../../modules/react-material-design":495,"../../helpers/color":491,"../common":463,"react":"react","reactcss":825}],472:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Photoshop = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _PhotoshopFields = require('./PhotoshopFields');

var _PhotoshopFields2 = _interopRequireDefault(_PhotoshopFields);

var _PhotoshopPointerCircle = require('./PhotoshopPointerCircle');

var _PhotoshopPointerCircle2 = _interopRequireDefault(_PhotoshopPointerCircle);

var _PhotoshopPointer = require('./PhotoshopPointer');

var _PhotoshopPointer2 = _interopRequireDefault(_PhotoshopPointer);

var _PhotoshopButton = require('./PhotoshopButton');

var _PhotoshopButton2 = _interopRequireDefault(_PhotoshopButton);

var _PhotoshopPreviews = require('./PhotoshopPreviews');

var _PhotoshopPreviews2 = _interopRequireDefault(_PhotoshopPreviews);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Photoshop = exports.Photoshop = function (_React$Component) {
  _inherits(Photoshop, _React$Component);

  function Photoshop(props) {
    _classCallCheck(this, Photoshop);

    var _this = _possibleConstructorReturn(this, (Photoshop.__proto__ || Object.getPrototypeOf(Photoshop)).call(this));

    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }

  _createClass(Photoshop, [{
    key: 'render',
    value: function render() {
      var styles = (0, _reactcss2.default)({
        'default': {
          picker: {
            background: '#DCDCDC',
            borderRadius: '4px',
            boxShadow: '0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)',
            boxSizing: 'initial',
            width: '513px'
          },
          head: {
            backgroundImage: 'linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)',
            borderBottom: '1px solid #B1B1B1',
            boxShadow: 'inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)',
            height: '23px',
            lineHeight: '24px',
            borderRadius: '4px 4px 0 0',
            fontSize: '13px',
            color: '#4D4D4D',
            textAlign: 'center'
          },
          body: {
            padding: '15px 15px 0',
            display: 'flex'
          },
          saturation: {
            width: '256px',
            height: '256px',
            position: 'relative',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0',
            overflow: 'hidden'
          },
          hue: {
            position: 'relative',
            height: '256px',
            width: '19px',
            marginLeft: '10px',
            border: '2px solid #B3B3B3',
            borderBottom: '2px solid #F0F0F0'
          },
          controls: {
            width: '180px',
            marginLeft: '10px'
          },
          top: {
            display: 'flex'
          },
          previews: {
            width: '60px'
          },
          actions: {
            flex: '1',
            marginLeft: '20px'
          }
        }
      });

      return _react2.default.createElement(
        'div',
        { style: styles.picker, className: 'photoshop-picker' },
        _react2.default.createElement(
          'div',
          { style: styles.head },
          this.props.header
        ),
        _react2.default.createElement(
          'div',
          { style: styles.body, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.saturation },
            _react2.default.createElement(_common.Saturation, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: _PhotoshopPointerCircle2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.hue },
            _react2.default.createElement(_common.Hue, {
              direction: 'vertical',
              hsl: this.props.hsl,
              pointer: _PhotoshopPointer2.default,
              onChange: this.props.onChange
            })
          ),
          _react2.default.createElement(
            'div',
            { style: styles.controls },
            _react2.default.createElement(
              'div',
              { style: styles.top, className: 'flexbox-fix' },
              _react2.default.createElement(
                'div',
                { style: styles.previews },
                _react2.default.createElement(_PhotoshopPreviews2.default, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              _react2.default.createElement(
                'div',
                { style: styles.actions },
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'OK', onClick: this.props.onAccept, active: true }),
                _react2.default.createElement(_PhotoshopButton2.default, { label: 'Cancel', onClick: this.props.onCancel }),
                _react2.default.createElement(_PhotoshopFields2.default, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);

  return Photoshop;
}(_react2.default.Component);

Photoshop.defaultProps = {
  header: 'Color Picker'
};

exports.default = (0, _common.ColorWrap)(Photoshop);
},{"../common":463,"./PhotoshopButton":473,"./PhotoshopFields":474,"./PhotoshopPointer":475,"./PhotoshopPointerCircle":476,"./PhotoshopPreviews":477,"react":"react","reactcss":825}],473:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopBotton = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopBotton = exports.PhotoshopBotton = function PhotoshopBotton(_ref) {
  var onClick = _ref.onClick,
      label = _ref.label,
      children = _ref.children,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      button: {
        backgroundImage: 'linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)',
        border: '1px solid #878787',
        borderRadius: '2px',
        height: '20px',
        boxShadow: '0 1px 0 0 #EAEAEA',
        fontSize: '14px',
        color: '#000',
        lineHeight: '20px',
        textAlign: 'center',
        marginBottom: '10px',
        cursor: 'pointer'
      }
    },
    'active': {
      button: {
        boxShadow: '0 0 0 1px #878787'
      }
    }
  }, { active: active });

  return _react2.default.createElement(
    'div',
    { style: styles.button, onClick: onClick },
    label || children
  );
};

exports.default = PhotoshopBotton;
},{"react":"react","reactcss":825}],474:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPicker = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPicker = exports.PhotoshopPicker = function PhotoshopPicker(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsv = _ref.hsv,
      hex = _ref.hex;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        paddingTop: '5px',
        paddingBottom: '9px',
        width: '80px',
        position: 'relative'
      },
      divider: {
        height: '5px'
      },
      RGBwrap: {
        position: 'relative'
      },
      RGBinput: {
        marginLeft: '40%',
        width: '40%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '5px',
        fontSize: '13px',
        paddingLeft: '3px',
        marginRight: '10px'
      },
      RGBlabel: {
        left: '0px',
        width: '34px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px',
        position: 'absolute'
      },
      HEXwrap: {
        position: 'relative'
      },
      HEXinput: {
        marginLeft: '20%',
        width: '80%',
        height: '18px',
        border: '1px solid #888888',
        boxShadow: 'inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC',
        marginBottom: '6px',
        fontSize: '13px',
        paddingLeft: '3px'
      },
      HEXlabel: {
        position: 'absolute',
        top: '0px',
        left: '0px',
        width: '14px',
        textTransform: 'uppercase',
        fontSize: '13px',
        height: '18px',
        lineHeight: '22px'
      },
      fieldSymbols: {
        position: 'absolute',
        top: '5px',
        right: '-7px',
        fontSize: '13px'
      },
      symbol: {
        height: '20px',
        lineHeight: '22px',
        paddingBottom: '7px'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    if (data['#']) {
      _color2.default.isValidHex(data['#']) && onChange({
        hex: data['#'],
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: 'rgb'
      }, e);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: 'hsv'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields },
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'h',
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 's',
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'v',
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'r',
      value: rgb.r,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'g',
      value: rgb.g,
      onChange: handleChange
    }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.RGBwrap, input: styles.RGBinput, label: styles.RGBlabel },
      label: 'b',
      value: rgb.b,
      onChange: handleChange
    }),
    _react2.default.createElement('div', { style: styles.divider }),
    _react2.default.createElement(_common.EditableInput, {
      style: { wrap: styles.HEXwrap, input: styles.HEXinput, label: styles.HEXlabel },
      label: '#',
      value: hex.replace('#', ''),
      onChange: handleChange
    }),
    _react2.default.createElement(
      'div',
      { style: styles.fieldSymbols },
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '\xB0'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      ),
      _react2.default.createElement(
        'div',
        { style: styles.symbol },
        '%'
      )
    )
  );
};

exports.default = PhotoshopPicker;
},{"../../helpers/color":491,"../common":463,"react":"react","reactcss":825}],475:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle() {
  var styles = (0, _reactcss2.default)({
    'default': {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '4px 0 4px 6px',
        borderColor: 'transparent transparent transparent #fff',
        position: 'absolute',
        top: '1px',
        left: '1px'
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: 'solid',
        borderWidth: '5px 0 5px 8px',
        borderColor: 'transparent transparent transparent #555'
      },

      left: {
        Extend: 'triangleBorder',
        transform: 'translate(-13px, -4px)'
      },
      leftInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      },

      right: {
        Extend: 'triangleBorder',
        transform: 'translate(20px, -14px) rotate(180deg)'
      },
      rightInside: {
        Extend: 'triangle',
        transform: 'translate(-8px, -5px)'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.pointer },
    _react2.default.createElement(
      'div',
      { style: styles.left },
      _react2.default.createElement('div', { style: styles.leftInside })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.right },
      _react2.default.createElement('div', { style: styles.rightInside })
    )
  );
};

exports.default = PhotoshopPointerCircle;
},{"react":"react","reactcss":825}],476:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPointerCircle = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPointerCircle = exports.PhotoshopPointerCircle = function PhotoshopPointerCircle(_ref) {
  var hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '12px',
        height: '12px',
        borderRadius: '6px',
        boxShadow: 'inset 0 0 0 1px #fff',
        transform: 'translate(-6px, -6px)'
      }
    },
    'black-outline': {
      picker: {
        boxShadow: 'inset 0 0 0 1px #000'
      }
    }
  }, { 'black-outline': hsl.l > 0.5 });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = PhotoshopPointerCircle;
},{"react":"react","reactcss":825}],477:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PhotoshopPreviews = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PhotoshopPreviews = exports.PhotoshopPreviews = function PhotoshopPreviews(_ref) {
  var rgb = _ref.rgb,
      currentColor = _ref.currentColor;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        border: '1px solid #B3B3B3',
        borderBottom: '1px solid #F0F0F0',
        marginBottom: '2px',
        marginTop: '1px'
      },
      new: {
        height: '34px',
        background: 'rgb(' + rgb.r + ',' + rgb.g + ', ' + rgb.b + ')',
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000'
      },
      current: {
        height: '34px',
        background: currentColor,
        boxShadow: 'inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000'
      },
      label: {
        fontSize: '14px',
        color: '#000',
        textAlign: 'center'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    null,
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'new'
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement('div', { style: styles.new }),
      _react2.default.createElement('div', { style: styles.current })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.label },
      'current'
    )
  );
};

exports.default = PhotoshopPreviews;
},{"react":"react","reactcss":825}],478:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sketch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _SketchFields = require('./SketchFields');

var _SketchFields2 = _interopRequireDefault(_SketchFields);

var _SketchPresetColors = require('./SketchPresetColors');

var _SketchPresetColors2 = _interopRequireDefault(_SketchPresetColors);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Sketch = exports.Sketch = function Sketch(_ref) {
  var width = _ref.width,
      rgb = _ref.rgb,
      hex = _ref.hex,
      hsv = _ref.hsv,
      hsl = _ref.hsl,
      onChange = _ref.onChange,
      disableAlpha = _ref.disableAlpha,
      presetColors = _ref.presetColors,
      renderers = _ref.renderers;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: width,
        padding: '10px 10px 0',
        boxSizing: 'initial',
        background: '#fff',
        borderRadius: '4px',
        boxShadow: '0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)'
      },
      saturation: {
        width: '100%',
        paddingBottom: '75%',
        position: 'relative',
        overflow: 'hidden'
      },
      Saturation: {
        radius: '3px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      controls: {
        display: 'flex'
      },
      sliders: {
        padding: '4px 0',
        flex: '1'
      },
      color: {
        width: '24px',
        height: '24px',
        position: 'relative',
        marginTop: '4px',
        marginLeft: '4px',
        borderRadius: '3px'
      },
      activeColor: {
        absolute: '0px 0px 0px 0px',
        borderRadius: '2px',
        background: 'rgba(' + rgb.r + ',' + rgb.g + ',' + rgb.b + ',' + rgb.a + ')',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },
      hue: {
        position: 'relative',
        height: '10px',
        overflow: 'hidden'
      },
      Hue: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      },

      alpha: {
        position: 'relative',
        height: '10px',
        marginTop: '4px',
        overflow: 'hidden'
      },
      Alpha: {
        radius: '2px',
        shadow: 'inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)'
      }
    },
    'disableAlpha': {
      color: {
        height: '10px'
      },
      hue: {
        height: '10px'
      },
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'sketch-picker' },
    _react2.default.createElement(
      'div',
      { style: styles.saturation },
      _react2.default.createElement(_common.Saturation, {
        style: styles.Saturation,
        hsl: hsl,
        hsv: hsv,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.controls, className: 'flexbox-fix' },
      _react2.default.createElement(
        'div',
        { style: styles.sliders },
        _react2.default.createElement(
          'div',
          { style: styles.hue },
          _react2.default.createElement(_common.Hue, {
            style: styles.Hue,
            hsl: hsl,
            onChange: onChange
          })
        ),
        _react2.default.createElement(
          'div',
          { style: styles.alpha },
          _react2.default.createElement(_common.Alpha, {
            style: styles.Alpha,
            rgb: rgb,
            hsl: hsl,
            renderers: renderers,
            onChange: onChange
          })
        )
      ),
      _react2.default.createElement(
        'div',
        { style: styles.color },
        _react2.default.createElement(_common.Checkboard, null),
        _react2.default.createElement('div', { style: styles.activeColor })
      )
    ),
    _react2.default.createElement(_SketchFields2.default, {
      rgb: rgb,
      hsl: hsl,
      hex: hex,
      onChange: onChange,
      disableAlpha: disableAlpha
    }),
    _react2.default.createElement(_SketchPresetColors2.default, { colors: presetColors, onClick: onChange })
  );
};

Sketch.defaultProps = {
  presetColors: ['#D0021B', '#F5A623', '#F8E71C', '#8B572A', '#7ED321', '#417505', '#BD10E0', '#9013FE', '#4A90E2', '#50E3C2', '#B8E986', '#000000', '#4A4A4A', '#9B9B9B', '#FFFFFF'],
  width: 200
};

exports.default = (0, _common.ColorWrap)(Sketch);
},{"../common":463,"./SketchFields":479,"./SketchPresetColors":480,"react":"react","reactcss":825}],479:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ShetchFields = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-param-reassign */

var ShetchFields = exports.ShetchFields = function ShetchFields(_ref) {
  var onChange = _ref.onChange,
      rgb = _ref.rgb,
      hsl = _ref.hsl,
      hex = _ref.hex,
      disableAlpha = _ref.disableAlpha;

  var styles = (0, _reactcss2.default)({
    'default': {
      fields: {
        display: 'flex',
        paddingTop: '4px'
      },
      single: {
        flex: '1',
        paddingLeft: '6px'
      },
      alpha: {
        flex: '1',
        paddingLeft: '6px'
      },
      double: {
        flex: '2'
      },
      input: {
        width: '80%',
        padding: '4px 10% 3px',
        border: 'none',
        boxShadow: 'inset 0 0 0 1px #ccc',
        fontSize: '11px'
      },
      label: {
        display: 'block',
        textAlign: 'center',
        fontSize: '11px',
        color: '#222',
        paddingTop: '3px',
        paddingBottom: '4px',
        textTransform: 'capitalize'
      }
    },
    'disableAlpha': {
      alpha: {
        display: 'none'
      }
    }
  }, { disableAlpha: disableAlpha });

  var handleChange = function handleChange(data, e) {
    if (data.hex) {
      _color2.default.isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: 'hex'
      }, e);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: 'rgb'
      }, e);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }

      data.a = data.a / 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: 'rgb'
      }, e);
    }
  };

  return _react2.default.createElement(
    'div',
    { style: styles.fields, className: 'flexbox-fix' },
    _react2.default.createElement(
      'div',
      { style: styles.double },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'hex',
        value: hex.replace('#', ''),
        onChange: handleChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'r',
        value: rgb.r,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'g',
        value: rgb.g,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.single },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'b',
        value: rgb.b,
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '255'
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.alpha },
      _react2.default.createElement(_common.EditableInput, {
        style: { input: styles.input, label: styles.label },
        label: 'a',
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: 'true',
        dragMax: '100'
      })
    )
  );
};

exports.default = ShetchFields;
},{"../../helpers/color":491,"../common":463,"react":"react","reactcss":825}],480:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SketchPresetColors = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SketchPresetColors = exports.SketchPresetColors = function SketchPresetColors(_ref) {
  var colors = _ref.colors,
      onClick = _ref.onClick;

  var styles = (0, _reactcss2.default)({
    'default': {
      colors: {
        margin: '0 -10px',
        padding: '10px 0 0 10px',
        borderTop: '1px solid #eee',
        display: 'flex',
        flexWrap: 'wrap',
        position: 'relative'
      },
      swatchWrap: {
        width: '16px',
        height: '16px',
        margin: '0 10px 10px 0'
      },
      swatch: {
        borderRadius: '3px',
        boxShadow: 'inset 0 0 0 1px rgba(0,0,0,.15)'
      }
    },
    'no-presets': {
      colors: {
        display: 'none'
      }
    }
  }, {
    'no-presets': !colors || !colors.length
  });

  var handleClick = function handleClick(hex, e) {
    onClick({
      hex: hex,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.colors, className: 'flexbox-fix' },
    colors.map(function (colorObjOrString) {
      var c = typeof colorObjOrString === 'string' ? { color: colorObjOrString } : colorObjOrString;
      return _react2.default.createElement(
        'div',
        { key: c.color, style: styles.swatchWrap },
        _react2.default.createElement(_common.Swatch, _extends({}, c, {
          style: styles.swatch,
          onClick: handleClick
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.oneOfType([_react2.default.PropTypes.string, _react2.default.PropTypes.shape({
    color: _react2.default.PropTypes.string,
    title: _react2.default.PropTypes.string
  })]))
};

exports.default = SketchPresetColors;
},{"../common":463,"react":"react","reactcss":825}],481:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Slider = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _common = require('../common');

var _SliderSwatches = require('./SliderSwatches');

var _SliderSwatches2 = _interopRequireDefault(_SliderSwatches);

var _SliderPointer = require('./SliderPointer');

var _SliderPointer2 = _interopRequireDefault(_SliderPointer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Slider = exports.Slider = function Slider(_ref) {
  var hsl = _ref.hsl,
      onChange = _ref.onChange,
      pointer = _ref.pointer;

  var styles = (0, _reactcss2.default)({
    'default': {
      hue: {
        height: '12px',
        position: 'relative'
      },
      Hue: {
        radius: '2px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { className: 'slider-picker' },
    _react2.default.createElement(
      'div',
      { style: styles.hue },
      _react2.default.createElement(_common.Hue, {
        style: styles.Hue,
        hsl: hsl,
        pointer: pointer,
        onChange: onChange
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatches },
      _react2.default.createElement(_SliderSwatches2.default, { hsl: hsl, onClick: onChange })
    )
  );
};

Slider.defaultProps = {
  pointer: _SliderPointer2.default
};

exports.default = (0, _common.ColorWrap)(Slider);
},{"../common":463,"./SliderPointer":482,"./SliderSwatches":484,"react":"react","reactcss":825}],482:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderPointer = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderPointer = exports.SliderPointer = function SliderPointer() {
  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: '14px',
        height: '14px',
        borderRadius: '6px',
        transform: 'translate(-7px, -1px)',
        backgroundColor: 'rgb(248, 248, 248)',
        boxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.37)'
      }
    }
  });

  return _react2.default.createElement('div', { style: styles.picker });
};

exports.default = SliderPointer;
},{"react":"react","reactcss":825}],483:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatch = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatch = exports.SliderSwatch = function SliderSwatch(_ref) {
  var hsl = _ref.hsl,
      offset = _ref.offset,
      onClick = _ref.onClick,
      active = _ref.active,
      first = _ref.first,
      last = _ref.last;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatch: {
        height: '12px',
        background: 'hsl(' + hsl.h + ', 50%, ' + offset * 100 + '%)',
        cursor: 'pointer'
      }
    },
    'first': {
      swatch: {
        borderRadius: '2px 0 0 2px'
      }
    },
    'last': {
      swatch: {
        borderRadius: '0 2px 2px 0'
      }
    },
    'active': {
      swatch: {
        transform: 'scaleY(1.8)',
        borderRadius: '3.6px/2px'
      }
    }
  }, { active: active, first: first, last: last });

  var handleClick = function handleClick(e) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset,
      source: 'hsl'
    }, e);
  };

  return _react2.default.createElement('div', { style: styles.swatch, onClick: handleClick });
};

exports.default = SliderSwatch;
},{"react":"react","reactcss":825}],484:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SliderSwatches = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _SliderSwatch = require('./SliderSwatch');

var _SliderSwatch2 = _interopRequireDefault(_SliderSwatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SliderSwatches = exports.SliderSwatches = function SliderSwatches(_ref) {
  var onClick = _ref.onClick,
      hsl = _ref.hsl;

  var styles = (0, _reactcss2.default)({
    'default': {
      swatches: {
        marginTop: '20px'
      },
      swatch: {
        boxSizing: 'border-box',
        width: '20%',
        paddingRight: '1px',
        float: 'left'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.swatches },
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.80',
        active: Math.round(hsl.l * 100) / 100 === 0.80 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick,
        first: true
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.65',
        active: Math.round(hsl.l * 100) / 100 === 0.65 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.50',
        active: Math.round(hsl.l * 100) / 100 === 0.50 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.35',
        active: Math.round(hsl.l * 100) / 100 === 0.35 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick
      })
    ),
    _react2.default.createElement(
      'div',
      { style: styles.swatch },
      _react2.default.createElement(_SliderSwatch2.default, {
        hsl: hsl,
        offset: '.20',
        active: Math.round(hsl.l * 100) / 100 === 0.20 && Math.round(hsl.s * 100) / 100 === 0.50,
        onClick: onClick,
        last: true
      })
    ),
    _react2.default.createElement('div', { style: styles.clear })
  );
};

exports.default = SliderSwatches;
},{"./SliderSwatch":483,"react":"react","reactcss":825}],485:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Swatches = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _materialColors = require('material-colors');

var material = _interopRequireWildcard(_materialColors);

var _common = require('../common');

var _reactMaterialDesign = require('../../../modules/react-material-design');

var _SwatchesGroup = require('./SwatchesGroup');

var _SwatchesGroup2 = _interopRequireDefault(_SwatchesGroup);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Swatches = exports.Swatches = function Swatches(_ref) {
  var width = _ref.width,
      height = _ref.height,
      onChange = _ref.onChange,
      colors = _ref.colors,
      hex = _ref.hex;

  var styles = (0, _reactcss2.default)({
    'default': {
      picker: {
        width: width,
        height: height
      },
      overflow: {
        height: height,
        overflowY: 'scroll'
      },
      body: {
        padding: '16px 0 6px 16px'
      },
      clear: {
        clear: 'both'
      }
    }
  });

  var handleChange = function handleChange(data, e) {
    _color2.default.isValidHex(data) && onChange({
      hex: data,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.picker, className: 'swatches-picker' },
    _react2.default.createElement(
      _reactMaterialDesign.Raised,
      null,
      _react2.default.createElement(
        'div',
        { style: styles.overflow },
        _react2.default.createElement(
          'div',
          { style: styles.body },
          (0, _map2.default)(colors, function (group) {
            return _react2.default.createElement(_SwatchesGroup2.default, {
              key: group.toString(),
              group: group,
              active: hex,
              onClick: handleChange
            });
          }),
          _react2.default.createElement('div', { style: styles.clear })
        )
      )
    )
  );
};

/* eslint-disable max-len */
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[material.red['900'], material.red['700'], material.red['500'], material.red['300'], material.red['100']], [material.pink['900'], material.pink['700'], material.pink['500'], material.pink['300'], material.pink['100']], [material.purple['900'], material.purple['700'], material.purple['500'], material.purple['300'], material.purple['100']], [material.deepPurple['900'], material.deepPurple['700'], material.deepPurple['500'], material.deepPurple['300'], material.deepPurple['100']], [material.indigo['900'], material.indigo['700'], material.indigo['500'], material.indigo['300'], material.indigo['100']], [material.blue['900'], material.blue['700'], material.blue['500'], material.blue['300'], material.blue['100']], [material.lightBlue['900'], material.lightBlue['700'], material.lightBlue['500'], material.lightBlue['300'], material.lightBlue['100']], [material.cyan['900'], material.cyan['700'], material.cyan['500'], material.cyan['300'], material.cyan['100']], [material.teal['900'], material.teal['700'], material.teal['500'], material.teal['300'], material.teal['100']], ['#194D33', material.green['700'], material.green['500'], material.green['300'], material.green['100']], [material.lightGreen['900'], material.lightGreen['700'], material.lightGreen['500'], material.lightGreen['300'], material.lightGreen['100']], [material.lime['900'], material.lime['700'], material.lime['500'], material.lime['300'], material.lime['100']], [material.yellow['900'], material.yellow['700'], material.yellow['500'], material.yellow['300'], material.yellow['100']], [material.amber['900'], material.amber['700'], material.amber['500'], material.amber['300'], material.amber['100']], [material.orange['900'], material.orange['700'], material.orange['500'], material.orange['300'], material.orange['100']], [material.deepOrange['900'], material.deepOrange['700'], material.deepOrange['500'], material.deepOrange['300'], material.deepOrange['100']], [material.brown['900'], material.brown['700'], material.brown['500'], material.brown['300'], material.brown['100']], [material.blueGrey['900'], material.blueGrey['700'], material.blueGrey['500'], material.blueGrey['300'], material.blueGrey['100']], ['#000000', '#525252', '#969696', '#D9D9D9', '#FFFFFF']]
};

exports.default = (0, _common.ColorWrap)(Swatches);
},{"../../../modules/react-material-design":495,"../../helpers/color":491,"../common":463,"./SwatchesGroup":487,"lodash/map":623,"material-colors":336,"react":"react","reactcss":825}],486:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesColor = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesColor = exports.SwatchesColor = function SwatchesColor(_ref) {
  var color = _ref.color,
      onClick = _ref.onClick,
      first = _ref.first,
      last = _ref.last,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      color: {
        width: '40px',
        height: '24px',
        cursor: 'pointer',
        background: color,
        marginBottom: '1px'
      },
      check: {
        fill: '#fff',
        marginLeft: '8px',
        display: 'none'
      }
    },
    'first': {
      color: {
        overflow: 'hidden',
        borderRadius: '2px 2px 0 0'
      }
    },
    'last': {
      color: {
        overflow: 'hidden',
        borderRadius: '0 0 2px 2px'
      }
    },
    'active': {
      check: {
        display: 'block'
      }
    },
    'color-#FFFFFF': {
      color: {
        boxShadow: 'inset 0 0 0 1px #ddd'
      },
      check: {
        fill: '#333'
      }
    }
  }, { first: first, last: last, active: active, 'color-#FFFFFF': color === '#FFFFFF' });

  var handleClick = function handleClick(e) {
    return onClick(color, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.color, onClick: handleClick },
    _react2.default.createElement(
      'div',
      { style: styles.check },
      _react2.default.createElement(
        'svg',
        { style: { width: '24px', height: '24px' }, viewBox: '0 0 24 24' },
        _react2.default.createElement('path', { d: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z' })
      )
    )
  );
};

exports.default = SwatchesColor;
},{"react":"react","reactcss":825}],487:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SwatchesGroup = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _SwatchesColor = require('./SwatchesColor');

var _SwatchesColor2 = _interopRequireDefault(_SwatchesColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SwatchesGroup = exports.SwatchesGroup = function SwatchesGroup(_ref) {
  var onClick = _ref.onClick,
      group = _ref.group,
      active = _ref.active;

  var styles = (0, _reactcss2.default)({
    'default': {
      group: {
        paddingBottom: '10px',
        width: '40px',
        float: 'left',
        marginRight: '10px'
      }
    }
  });

  return _react2.default.createElement(
    'div',
    { style: styles.group },
    (0, _map2.default)(group, function (color, i) {
      return _react2.default.createElement(_SwatchesColor2.default, {
        key: color,
        color: color,
        active: color.toLowerCase() === active,
        first: i === 0,
        last: i === group.length - 1,
        onClick: onClick
      });
    })
  );
};

exports.default = SwatchesGroup;
},{"./SwatchesColor":486,"lodash/map":623,"react":"react","reactcss":825}],488:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Twitter = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _map = require('lodash/map');

var _map2 = _interopRequireDefault(_map);

var _color = require('../../helpers/color');

var _color2 = _interopRequireDefault(_color);

var _common = require('../common');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Twitter = exports.Twitter = function Twitter(_ref) {
  var onChange = _ref.onChange,
      colors = _ref.colors,
      width = _ref.width,
      triangle = _ref.triangle;

  var styles = (0, _reactcss2.default)({
    'default': {
      card: {
        width: width,
        background: '#fff',
        border: '0 solid rgba(0,0,0,0.25)',
        boxShadow: '0 1px 4px rgba(0,0,0,0.25)',
        borderRadius: '4px',
        position: 'relative'
      },
      body: {
        padding: '15px 9px 9px 15px'
      },
      label: {
        fontSize: '18px',
        color: '#fff'
      },
      triangle: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent #fff transparent',
        position: 'absolute'
      },
      triangleShadow: {
        width: '0px',
        height: '0px',
        borderStyle: 'solid',
        borderWidth: '0 9px 10px 9px',
        borderColor: 'transparent transparent rgba(0,0,0,.1) transparent',
        position: 'absolute'
      },
      hash: {
        background: '#F0F0F0',
        height: '30px',
        width: '30px',
        borderRadius: '4px 0 0 4px',
        float: 'left',
        color: '#98A1A4',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      },
      input: {
        width: '100px',
        fontSize: '14px',
        color: '#666',
        border: '0px',
        outline: 'none',
        height: '28px',
        boxShadow: 'inset 0 0 0 1px #F0F0F0',
        borderRadius: '0 4px 4px 0',
        float: 'left',
        paddingLeft: '8px'
      },
      swatch: {
        width: '30px',
        height: '30px',
        float: 'left',
        borderRadius: '4px',
        margin: '0 6px 6px 0'
      },
      clear: {
        clear: 'both'
      }
    },
    'hide-triangle': {
      triangle: {
        display: 'none'
      },
      triangleShadow: {
        display: 'none'
      }
    },
    'top-left-triangle': {
      triangle: {
        top: '-10px',
        left: '12px'
      },
      triangleShadow: {
        top: '-11px',
        left: '12px'
      }
    },
    'top-right-triangle': {
      triangle: {
        top: '-10px',
        right: '12px'
      },
      triangleShadow: {
        top: '-11px',
        right: '12px'
      }
    }
  }, {
    'hide-triangle': triangle === 'hide',
    'top-left-triangle': triangle === 'top-left',
    'top-right-triangle': triangle === 'top-right'
  });

  var handleChange = function handleChange(hex, e) {
    _color2.default.isValidHex(hex) && onChange({
      hex: hex,
      source: 'hex'
    }, e);
  };

  return _react2.default.createElement(
    'div',
    { style: styles.card, className: 'twitter-picker' },
    _react2.default.createElement('div', { style: styles.triangleShadow }),
    _react2.default.createElement('div', { style: styles.triangle }),
    _react2.default.createElement(
      'div',
      { style: styles.body },
      (0, _map2.default)(colors, function (c, i) {
        return _react2.default.createElement(_common.Swatch, {
          key: i,
          color: c,
          hex: c,
          style: styles.swatch,
          onClick: handleChange
        });
      }),
      _react2.default.createElement(
        'div',
        { style: styles.hash },
        '#'
      ),
      _react2.default.createElement(_common.EditableInput, {
        placeholder: 'ff691f',
        style: { input: styles.input },
        value: '',
        onChange: handleChange
      }),
      _react2.default.createElement('div', { style: styles.clear })
    )
  );
};

Twitter.defaultProps = {
  width: '276px',
  colors: ['#FF6900', '#FCB900', '#7BDCB5', '#00D084', '#8ED1FC', '#0693E3', '#ABB8C3', '#EB144C', '#F78DA7', '#9900EF'],
  triangle: 'top-left'
};

exports.default = (0, _common.ColorWrap)(Twitter);
},{"../../helpers/color":491,"../common":463,"lodash/map":623,"react":"react","reactcss":825}],489:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateChange = calculateChange;
function calculateChange(e, skip, props, container) {
  !skip && e.preventDefault();
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (props.direction === 'vertical') {
    var a = void 0;
    if (top < 0) {
      a = 0;
    } else if (top > containerHeight) {
      a = 1;
    } else {
      a = Math.round(top * 100 / containerHeight) / 100;
    }

    if (props.hsl.a !== a) {
      return {
        h: props.hsl.h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: a,
        source: 'rgb'
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }

    if (props.a !== _a) {
      return {
        h: props.hsl.h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: _a,
        source: 'rgb'
      };
    }
  }
  return null;
}
},{}],490:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.get = get;
var checkboardCache = {};

function render(c1, c2, size, serverCanvas) {
  if (typeof document === 'undefined' && !serverCanvas) return null;
  var canvas = serverCanvas ? new serverCanvas() : document.createElement('canvas');
  canvas.width = canvas.height = size * 2;
  var ctx = canvas.getContext('2d');
  if (!ctx) return null; // If no context can be found, return early.
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c2;
  ctx.fillRect(0, 0, size, size);
  ctx.translate(size, size);
  ctx.fillRect(0, 0, size, size);
  return canvas.toDataURL();
}

function get(c1, c2, size, serverCanvas) {
  var key = c1 + '-' + c2 + '-' + size + (serverCanvas ? '-server' : '');
  var checkboard = render(c1, c2, size, serverCanvas);

  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  checkboardCache[key] = checkboard;
  return checkboard;
}
},{}],491:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.red = undefined;

var _each = require('lodash/each');

var _each2 = _interopRequireDefault(_each);

var _tinycolor = require('../../modules/tinycolor2');

var _tinycolor2 = _interopRequireDefault(_tinycolor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  simpleCheckForValidColor: function simpleCheckForValidColor(data) {
    var keysToCheck = ['r', 'g', 'b', 'a', 'h', 's', 'a', 'v'];
    var checked = 0;
    var passed = 0;
    (0, _each2.default)(keysToCheck, function (letter) {
      if (data[letter]) {
        checked++;
        if (!isNaN(data[letter])) {
          passed++;
        }
      }
    });
    return checked === passed ? data : false;
  },
  toState: function toState(data, oldHue) {
    var color = data.hex ? (0, _tinycolor2.default)(data.hex) : (0, _tinycolor2.default)(data);
    var hsl = color.toHsl();
    var hsv = color.toHsv();
    if (hsl.s === 0) {
      hsl.h = oldHue || 0;
      hsv.h = oldHue || 0;
    }

    return {
      hsl: hsl,
      hex: '#' + color.toHex(),
      rgb: color.toRgb(),
      hsv: hsv,
      oldHue: data.h || oldHue || hsl.h,
      source: data.source
    };
  },
  isValidHex: function isValidHex(hex) {
    return (0, _tinycolor2.default)(hex).isValid();
  }
};
var red = exports.red = {
  hsl: { a: 1, h: 0, l: 0.5, s: 1 },
  hex: '#ff0000',
  rgb: { r: 255, g: 0, b: 0, a: 1 },
  hsv: { h: 0, s: 1, v: 1, a: 1 }
};
},{"../../modules/tinycolor2":501,"lodash/each":605}],492:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateChange = calculateChange;
function calculateChange(e, skip, props, container) {
  !skip && e.preventDefault();
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (props.direction === 'vertical') {
    var h = void 0;
    if (top < 0) {
      h = 359;
    } else if (top > containerHeight) {
      h = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h = 360 * percent / 100;
    }

    if (props.hsl.h !== h) {
      return {
        h: h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: props.hsl.a,
        source: 'rgb'
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }

    if (props.hsl.h !== _h) {
      return {
        h: _h,
        s: props.hsl.s,
        l: props.hsl.l,
        a: props.hsl.a,
        source: 'rgb'
      };
    }
  }
  return null;
}
},{}],493:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calculateChange = calculateChange;
function calculateChange(e, skip, props, container) {
  !skip && e.preventDefault();
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x = typeof e.pageX === 'number' ? e.pageX : e.touches[0].pageX;
  var y = typeof e.pageY === 'number' ? e.pageY : e.touches[0].pageY;
  var left = x - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y - (container.getBoundingClientRect().top + window.pageYOffset);

  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  } else if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }

  var saturation = left * 100 / containerWidth;
  var bright = -(top * 100 / containerHeight) + 100;

  return {
    h: props.hsl.h,
    s: saturation,
    v: bright,
    a: props.hsl.a,
    source: 'rgb'
  };
}
},{}],494:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CustomPicker = exports.TwitterPicker = exports.SwatchesPicker = exports.SliderPicker = exports.SketchPicker = exports.PhotoshopPicker = exports.MaterialPicker = exports.HuePicker = exports.GithubPicker = exports.CompactPicker = exports.ChromePicker = exports.default = exports.CirclePicker = exports.BlockPicker = exports.AlphaPicker = undefined;

var _Alpha = require('./components/alpha/Alpha');

Object.defineProperty(exports, 'AlphaPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Alpha).default;
  }
});

var _Block = require('./components/block/Block');

Object.defineProperty(exports, 'BlockPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Block).default;
  }
});

var _Circle = require('./components/circle/Circle');

Object.defineProperty(exports, 'CirclePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Circle).default;
  }
});

var _Chrome = require('./components/chrome/Chrome');

Object.defineProperty(exports, 'ChromePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Chrome).default;
  }
});

var _Compact = require('./components/compact/Compact');

Object.defineProperty(exports, 'CompactPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Compact).default;
  }
});

var _Github = require('./components/github/Github');

Object.defineProperty(exports, 'GithubPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Github).default;
  }
});

var _Hue = require('./components/hue/Hue');

Object.defineProperty(exports, 'HuePicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Hue).default;
  }
});

var _Material = require('./components/material/Material');

Object.defineProperty(exports, 'MaterialPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Material).default;
  }
});

var _Photoshop = require('./components/photoshop/Photoshop');

Object.defineProperty(exports, 'PhotoshopPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Photoshop).default;
  }
});

var _Sketch = require('./components/sketch/Sketch');

Object.defineProperty(exports, 'SketchPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Sketch).default;
  }
});

var _Slider = require('./components/slider/Slider');

Object.defineProperty(exports, 'SliderPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Slider).default;
  }
});

var _Swatches = require('./components/swatches/Swatches');

Object.defineProperty(exports, 'SwatchesPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Swatches).default;
  }
});

var _Twitter = require('./components/twitter/Twitter');

Object.defineProperty(exports, 'TwitterPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_Twitter).default;
  }
});

var _ColorWrap = require('./components/common/ColorWrap');

Object.defineProperty(exports, 'CustomPicker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_ColorWrap).default;
  }
});

var _Chrome2 = _interopRequireDefault(_Chrome);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _Chrome2.default;
},{"./components/alpha/Alpha":446,"./components/block/Block":448,"./components/chrome/Chrome":450,"./components/circle/Circle":454,"./components/common/ColorWrap":458,"./components/compact/Compact":464,"./components/github/Github":467,"./components/hue/Hue":469,"./components/material/Material":471,"./components/photoshop/Photoshop":472,"./components/sketch/Sketch":478,"./components/slider/Slider":481,"./components/swatches/Swatches":485,"./components/twitter/Twitter":488}],495:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true,
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _libComponentsRaised = require('./lib/components/Raised');

var _libComponentsRaised2 = _interopRequireDefault(_libComponentsRaised);

var _libComponentsTile = require('./lib/components/Tile');

var _libComponentsTile2 = _interopRequireDefault(_libComponentsTile);

var _libComponentsTabs = require('./lib/components/Tabs');

var _libComponentsTabs2 = _interopRequireDefault(_libComponentsTabs);

exports.Raised = _libComponentsRaised2['default'];
exports.Tile = _libComponentsTile2['default'];
exports.Tabs = _libComponentsTabs2['default'];

},{"./lib/components/Raised":497,"./lib/components/Tabs":499,"./lib/components/Tile":500}],496:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Link = function (_React$Component) {
  _inherits(Link, _React$Component);

  function Link() {
    _classCallCheck(this, Link);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Link).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(Link, [{
    key: 'handleClick',
    value: function handleClick(e) {
      if (this.props.onClick) {
        this.props.onClick(e, this.props.callbackValue);
      }
    }
  }, {
    key: 'render',
    value: function render() {

      var a;
      if ((0, _isString2.default)(this.props.onClick)) {
        a = _react2.default.createElement(
          'a',
          { style: { textDecoration: 'none' }, href: this.props.onClick, target: this.props.newTab && '_blank' },
          this.props.children
        );
      } else {
        a = _react2.default.createElement(
          'a',
          { style: { textDecoration: 'none' }, onClick: this.handleClick },
          this.props.children
        );
      }

      return a;
    }
  }]);

  return Link;
}(_react2.default.Component);

// Link.propTypes =
//   onClick: React.PropTypes.oneOfType(
//     React.PropTypes.string,
//     React.PropTypes.func
//   );

Link.defaultProps = {
  newTab: false
};

exports.default = Link;
},{"lodash/isString":619,"react":"react"}],497:[function(require,module,exports){
/* jshint node: true, esnext: true */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Raised = function (_React$Component) {
  _inherits(Raised, _React$Component);

  function Raised() {
    _classCallCheck(this, Raised);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Raised).apply(this, arguments));
  }

  _createClass(Raised, [{
    key: 'render',
    value: function render() {

      var styles = (0, _reactcss2.default)({
        'default': {
          wrap: {
            position: 'relative'
          },
          content: {
            position: 'relative'
          },
          bg: {
            absolute: '0px 0px 0px 0px',
            boxShadow: '0 ${ this.props.zDepth }px ${ this.props.zDepth * 4 }px rgba(0,0,0,.24)',
            borderRadius: this.props.radius,
            background: this.props.background
          }
        },
        'zDepth-0': {
          bg: {
            boxShadow: 'none'
          }
        },

        'zDepth-1': {
          bg: {
            boxShadow: '0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)'
          }
        },
        'zDepth-2': {
          bg: {
            boxShadow: '0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)'
          }
        },
        'zDepth-3': {
          bg: {
            boxShadow: '0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)'
          }
        },
        'zDepth-4': {
          bg: {
            boxShadow: '0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)'
          }
        },
        'zDepth-5': {
          bg: {
            boxShadow: '0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)'
          }
        },
        'square': {
          bg: {
            borderRadius: '0'
          }
        },
        'circle': {
          bg: {
            borderRadius: '50%'
          }
        }
      }, this.props);

      return _react2.default.createElement(
        'div',
        { style: styles.wrap },
        _react2.default.createElement('div', { style: styles.bg }),
        _react2.default.createElement(
          'div',
          { style: styles.content },
          this.props.children
        )
      );
    }
  }]);

  return Raised;
}(_react2.default.Component);

Raised.propTypes = {
  background: _react2.default.PropTypes.string,
  zDepth: _react2.default.PropTypes.oneOf(['0', '1', '2', '3', '4', '5', 0, 1, 2, 3, 4, 5]),
  radius: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.string, _react2.default.PropTypes.number])
};

Raised.defaultProps = {
  background: '#fff',
  zDepth: '1',
  radius: '2px'
};

exports.default = Raised;
},{"react":"react","reactcss":825}],498:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tab = function (_React$Component) {
  _inherits(Tab, _React$Component);

  function Tab() {
    _classCallCheck(this, Tab);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Tab).call(this));

    _this.handleClick = _this.handleClick.bind(_this);
    return _this;
  }

  _createClass(Tab, [{
    key: 'handleClick',
    value: function handleClick() {
      if (this.props.selectable !== false) {
        this.props.onClick(this.props.tab);
      }
    }
  }, {
    key: 'render',
    value: function render() {

      var styles = (0, _reactcss2.default)({
        'default': {
          tab: {
            color: this.props.inactive || this.props.color,
            cursor: 'pointer',
            paddingLeft: '12px',
            paddingRight: '12px',
            height: '48px',
            lineHeight: '48px',
            textAlign: 'center',
            fontSize: '14px',
            textTransform: this.props.capitalize === false ? '' : 'uppercase',
            fontWeight: '500',
            whiteSpace: 'nowrap',
            opacity: '.47',
            transition: 'opacity 100ms linear'
          }
        },
        'selected': {
          tab: {
            color: this.props.color,
            opacity: '.87'
          }
        }
      }, this.props);

      return _react2.default.createElement(
        'div',
        { style: styles.tab, onClick: this.handleClick },
        this.props.children
      );
    }
  }]);

  return Tab;
}(_react2.default.Component);

Tab.propTypes = {
  selected: _react2.default.PropTypes.bool
};

Tab.defaultProps = {
  selected: false,
  color: '#fff'
};

exports.default = Tab;
},{"react":"react","reactcss":825}],499:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _Tab = require('./Tab');

var _Tab2 = _interopRequireDefault(_Tab);

var _Link = require('./Link');

var _Link2 = _interopRequireDefault(_Link);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// var Ink = require('./Ink');

// var context = {
//   primaryColor: '#2196F3',
//   accentColor: '#E91E63',
//   theme: 'light'
// }

var Tabs = function (_React$Component) {
  _inherits(Tabs, _React$Component);

  function Tabs(props) {
    _classCallCheck(this, Tabs);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Tabs).call(this));

    var selectedTab;
    if (props.selectedTab < (props.tabs && props.tabs.length)) {
      selectedTab = props.selectedTab;
    } else {
      selectedTab = 0;
    }

    _this.state = {
      selectedTab: selectedTab
    };

    _this.handleClick = _this.handleClick.bind(_this);
    _this.slide = _this.slide.bind(_this);
    return _this;
  }

  _createClass(Tabs, [{
    key: 'handleClick',
    value: function handleClick(tab) {
      if (this.props.onChange) {
        this.props.onChange(tab);
      }

      this.setState({
        selectedTab: tab
      });
    }
  }, {
    key: 'slide',
    value: function slide() {
      if (this.props.tabs.length) {
        var containerNode = this.refs.tabs.getDOMNode();
        var containerLeft = containerNode.scrollLeft;
        var containerRight = containerNode.offsetWidth + containerNode.scrollLeft;

        var selectedNode = this.refs['tab-' + this.state.selectedTab] && this.refs['tab-' + this.state.selectedTab].getDOMNode();
        var selectedLeft = selectedNode && selectedNode.getBoundingClientRect().left - containerNode.getBoundingClientRect().left + containerNode.scrollLeft;
        var selectedRight = selectedNode && selectedLeft + selectedNode.offsetWidth;

        // scroll right if tab is off screen
        if (selectedRight > containerRight) {
          containerNode.scrollLeft += selectedRight - containerRight;
        }

        // scroll left if tab is off screen
        if (selectedLeft < containerLeft) {
          containerNode.scrollLeft -= containerLeft - selectedLeft;
        }

        // slide the indicator
        var indicator = this.refs.indicator;
        indicator.style.left = selectedLeft + 'px';
        indicator.style.width = selectedNode.offsetWidth + 'px';
        indicator.style.height = '2px';
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.slide();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.selectedTab !== this.state.selectedTab) {
        this.setState({ selectedTab: nextProps.selectedTab });
      }
    }
  }, {
    key: 'componentWillUpdate',
    value: function componentWillUpdate(nextProps, nextState) {
      if (nextState.selectedTab >= (nextProps.tabs && nextProps.tabs.length)) {
        nextState.selectedTab = nextProps.tabs.length - 1;
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.slide();
    }
  }, {
    key: 'render',
    value: function render() {

      var styles = (0, _reactcss2.default)({
        'default': {
          tabs: {
            position: 'relative',
            background: this.props.background
          },
          tabWrap: {
            display: 'flex'
          },
          tab: {
            justifyContent: 'flex-start',
            minWidth: '68px',
            maxWidth: '240px'
          },
          Tab: {
            color: this.props.color,
            inactive: this.props.inactive,
            capitalize: this.props.capitalize
          },
          indicator: {
            height: '0',
            position: 'absolute',
            bottom: '0',
            left: '0',
            background: this.props.color,
            transition: 'all 200ms linear'
          }
        },
        'scrollable': {
          tabs: {
            overflowX: 'scroll'
          },
          tabWrap: {
            paddingLeft: '60px',
            justifyContent: 'flex-start',
            width: '400%'
          },
          tab: {
            width: 'auto'
          }
        },
        'align-justify': {
          tabWrap: {
            justifyContent: 'space-between'
          },
          tab: {
            width: 100 / this.props.tabs.length + '%'
          }
        },
        'align-left': {
          tabWrap: {
            paddingLeft: '60px',
            justifyContent: 'flex-start'
          },
          tab: {
            width: 'auto'
          }
        },
        'align-center': {
          tabWrap: {
            justifyContent: 'center'
          },
          tab: {
            width: 'auto'
          }
        }
      }, {
        'scrollable': this.props.width / this.props.tabs.length < 72
      }, this.props, this.state);

      var tabs = [];
      for (var i = 0; i < this.props.tabs.length; i++) {
        var tab = this.props.tabs[i];

        var label;
        var callback;
        var callbackValue;
        var newTab;
        if ((0, _isString2.default)(tab)) {
          label = tab;
          callback = null;
        } else {
          label = tab.label;
          callback = tab.onClick;
          callbackValue = tab.callbackValue;
          newTab = tab.newTab;
        }

        tabs.push(_react2.default.createElement(
          'div',
          { style: styles.tab, ref: 'tab-' + i, key: i },
          _react2.default.createElement(
            _Link2.default,
            { onClick: callback, callbackValue: callbackValue, newTab: newTab },
            _react2.default.createElement(
              _Tab2.default,
              { style: styles.Tab, tab: i, selected: this.state.selectedTab === i, selectable: tab.selectable, onClick: this.handleClick },
              label
            )
          )
        ));
      }

      return _react2.default.createElement(
        'div',
        { style: styles.tabs, ref: 'tabs' },
        _react2.default.createElement(
          'div',
          { style: styles.tabWrap, className: 'flexbox-fix' },
          tabs
        ),
        _react2.default.createElement('div', { style: styles.indicator, ref: 'indicator' })
      );
    }
  }]);

  return Tabs;
}(_react2.default.Component);

Tabs.defaultProps = {
  selectedTab: 0,
  background: 'transparent',
  color: '#fff'
};

exports.default = Tabs;
},{"./Link":496,"./Tab":498,"lodash/isString":619,"react":"react","reactcss":825}],500:[function(require,module,exports){
/* jshint node: true, esnext: true */
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactcss = require('reactcss');

var _reactcss2 = _interopRequireDefault(_reactcss);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tile = function (_React$Component) {
  _inherits(Tile, _React$Component);

  function Tile() {
    _classCallCheck(this, Tile);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(Tile).apply(this, arguments));
  }

  _createClass(Tile, [{
    key: 'render',
    value: function render() {

      var styles = (0, _reactcss2.default)({
        'default': {
          tile: {
            fontSize: '16px',
            padding: '16px',
            display: 'flex',
            justifyContent: 'space-between',
            color: this.props.color
          },
          primary: {
            display: 'flex',
            width: '100%'
          },
          sidebar: {
            minWidth: '56px',
            maxWidth: '56px',
            flexBasis: '56px' },
          // 72 minus 16
          content: {
            background: 'none',
            flex: '1',
            overflow: 'auto'
          },
          secondary: {
            flexBasis: '42',
            textAlign: 'center'
          },
          sidebarIcon: {
            marginTop: '-12px',
            marginLeft: '-12px',
            marginBottom: '-12px'
          }
        },
        'divider': {
          tile: {
            boxShadow: 'inset 0 -1px 0 rgba(0,0,0,.12)'
          }
        },
        'condensed': {
          tile: {
            paddingBottom: '0px',
            paddingTop: '0px',
            paddingRight: '0px'
          },
          sidebar: {
            minWidth: '28px',
            maxWidth: '28px',
            flexBasis: '28px'
          }
        }
      }, {
        'clickable': this.props.onClick
      }, this.props);

      var _props$children = _slicedToArray(this.props.children, 2);

      var sidebar = _props$children[0];
      var content = _props$children[1];


      return _react2.default.createElement(
        'div',
        { style: styles.tile, className: 'flexbox-fix' },
        _react2.default.createElement(
          'div',
          { style: styles.primary, className: 'flexbox-fix' },
          _react2.default.createElement(
            'div',
            { style: styles.sidebar, key: "sidebar-#{ sidebar }" },
            sidebar
          ),
          _react2.default.createElement(
            'div',
            { style: styles.content, key: "content-#{ content }" },
            content
          )
        )
      );
    }
  }]);

  return Tile;
}(_react2.default.Component);

;

exports.default = Tile;
},{"react":"react","reactcss":825}],501:[function(require,module,exports){
// jscs: disable

// TinyColor v1.1.2
// https://github.com/bgrins/TinyColor
// Brian Grinstead, MIT License

(function() {

var trimLeft = /^[\s,#]+/;
var trimRight = /\s+$/;
var tinyCounter = 0;
var math = Math;
var mathRound = math.round;
var mathMin = math.min;
var mathMax = math.max;
var mathRandom = math.random;

function tinycolor(color, opts) {

		color = (color) ? color : '';
		opts = opts || { };

		// If input is already a tinycolor, return itself
		if (color instanceof tinycolor) {
			 return color;
		}
		// If we are called as a function, call using new instead
		if (!(this instanceof tinycolor)) {
				return new tinycolor(color, opts);
		}

		var rgb = inputToRGB(color);
		this._originalInput = color,
		this._r = rgb.r,
		this._g = rgb.g,
		this._b = rgb.b,
		this._a = rgb.a,
		this._roundA = mathRound(100*this._a) / 100,
		this._format = opts.format || rgb.format;
		this._gradientType = opts.gradientType;

		// Don't let the range of [0,255] come back in [0,1].
		// Potentially lose a little bit of precision here, but will fix issues where
		// .5 gets interpreted as half of the total, instead of half of 1
		// If it was supposed to be 128, this was already taken care of by `inputToRgb`
		if (this._r < 1) { this._r = mathRound(this._r); }
		if (this._g < 1) { this._g = mathRound(this._g); }
		if (this._b < 1) { this._b = mathRound(this._b); }

		this._ok = rgb.ok;
		this._tc_id = tinyCounter++;
}

tinycolor.prototype = {
		isDark: function() {
				return this.getBrightness() < 128;
		},
		isLight: function() {
				return !this.isDark();
		},
		isValid: function() {
				return this._ok;
		},
		getOriginalInput: function() {
			return this._originalInput;
		},
		getFormat: function() {
				return this._format;
		},
		getAlpha: function() {
				return this._a;
		},
		getBrightness: function() {
				//http://www.w3.org/TR/AERT#color-contrast
				var rgb = this.toRgb();
				return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
		},
		getLuminance: function() {
				//http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
				var rgb = this.toRgb();
				var RsRGB, GsRGB, BsRGB, R, G, B;
				RsRGB = rgb.r/255;
				GsRGB = rgb.g/255;
				BsRGB = rgb.b/255;

				if (RsRGB <= 0.03928) {R = RsRGB / 12.92;} else {R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4);}
				if (GsRGB <= 0.03928) {G = GsRGB / 12.92;} else {G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4);}
				if (BsRGB <= 0.03928) {B = BsRGB / 12.92;} else {B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4);}
				return (0.2126 * R) + (0.7152 * G) + (0.0722 * B);
		},
		setAlpha: function(value) {
				this._a = boundAlpha(value);
				this._roundA = mathRound(100*this._a) / 100;
				return this;
		},
		toHsv: function() {
				var hsv = rgbToHsv(this._r, this._g, this._b);
				return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
		},
		toHsvString: function() {
				var hsv = rgbToHsv(this._r, this._g, this._b);
				var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
				return (this._a == 1) ?
					"hsv("	+ h + ", " + s + "%, " + v + "%)" :
					"hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
		},
		toHsl: function() {
				var hsl = rgbToHsl(this._r, this._g, this._b);
				return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
		},
		toHslString: function() {
				var hsl = rgbToHsl(this._r, this._g, this._b);
				var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
				return (this._a == 1) ?
					"hsl("	+ h + ", " + s + "%, " + l + "%)" :
					"hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
		},
		toHex: function(allow3Char) {
				return rgbToHex(this._r, this._g, this._b, allow3Char);
		},
		toHexString: function(allow3Char) {
				return '#' + this.toHex(allow3Char);
		},
		toHex8: function() {
				return rgbaToHex(this._r, this._g, this._b, this._a);
		},
		toHex8String: function() {
				return '#' + this.toHex8();
		},
		toRgb: function() {
				return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
		},
		toRgbString: function() {
				return (this._a == 1) ?
					"rgb("	+ mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
					"rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
		},
		toPercentageRgb: function() {
				return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
		},
		toPercentageRgbString: function() {
				return (this._a == 1) ?
					"rgb("	+ mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
					"rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
		},
		toName: function() {
				if (this._a === 0) {
						return "transparent";
				}

				if (this._a < 1) {
						return false;
				}

				return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
		},
		toFilter: function(secondColor) {
				var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
				var secondHex8String = hex8String;
				var gradientType = this._gradientType ? "GradientType = 1, " : "";

				if (secondColor) {
						var s = tinycolor(secondColor);
						secondHex8String = s.toHex8String();
				}

				return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
		},
		toString: function(format) {
				var formatSet = !!format;
				format = format || this._format;

				var formattedString = false;
				var hasAlpha = this._a < 1 && this._a >= 0;
				var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

				if (needsAlphaFormat) {
						// Special case for "transparent", all other non-alpha formats
						// will return rgba when there is transparency.
						if (format === "name" && this._a === 0) {
								return this.toName();
						}
						return this.toRgbString();
				}
				if (format === "rgb") {
						formattedString = this.toRgbString();
				}
				if (format === "prgb") {
						formattedString = this.toPercentageRgbString();
				}
				if (format === "hex" || format === "hex6") {
						formattedString = this.toHexString();
				}
				if (format === "hex3") {
						formattedString = this.toHexString(true);
				}
				if (format === "hex8") {
						formattedString = this.toHex8String();
				}
				if (format === "name") {
						formattedString = this.toName();
				}
				if (format === "hsl") {
						formattedString = this.toHslString();
				}
				if (format === "hsv") {
						formattedString = this.toHsvString();
				}

				return formattedString || this.toHexString();
		},

		_applyModification: function(fn, args) {
				var color = fn.apply(null, [this].concat([].slice.call(args)));
				this._r = color._r;
				this._g = color._g;
				this._b = color._b;
				this.setAlpha(color._a);
				return this;
		},
		lighten: function() {
				return this._applyModification(lighten, arguments);
		},
		brighten: function() {
				return this._applyModification(brighten, arguments);
		},
		darken: function() {
				return this._applyModification(darken, arguments);
		},
		desaturate: function() {
				return this._applyModification(desaturate, arguments);
		},
		saturate: function() {
				return this._applyModification(saturate, arguments);
		},
		greyscale: function() {
				return this._applyModification(greyscale, arguments);
		},
		spin: function() {
				return this._applyModification(spin, arguments);
		},

		_applyCombination: function(fn, args) {
				return fn.apply(null, [this].concat([].slice.call(args)));
		},
		analogous: function() {
				return this._applyCombination(analogous, arguments);
		},
		complement: function() {
				return this._applyCombination(complement, arguments);
		},
		monochromatic: function() {
				return this._applyCombination(monochromatic, arguments);
		},
		splitcomplement: function() {
				return this._applyCombination(splitcomplement, arguments);
		},
		triad: function() {
				return this._applyCombination(triad, arguments);
		},
		tetrad: function() {
				return this._applyCombination(tetrad, arguments);
		}
};

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color, opts) {
		if (typeof color == "object") {
				var newColor = {};
				for (var i in color) {
						if (color.hasOwnProperty(i)) {
								if (i === "a") {
										newColor[i] = color[i];
								}
								else {
										newColor[i] = convertToPercentage(color[i]);
								}
						}
				}
				color = newColor;
		}

		return tinycolor(color, opts);
};

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//		 "red"
//		 "#f00" or "f00"
//		 "#ff0000" or "ff0000"
//		 "#ff000000" or "ff000000"
//		 "rgb 255 0 0" or "rgb (255, 0, 0)"
//		 "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//		 "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//		 "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//		 "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//		 "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//		 "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

		var rgb = { r: 0, g: 0, b: 0 };
		var a = 1;
		var ok = false;
		var format = false;

		if (typeof color == "string") {
				color = stringInputToObject(color);
		}

		if (typeof color == "object") {
				if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
						rgb = rgbToRgb(color.r, color.g, color.b);
						ok = true;
						format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
				}
				else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
						color.s = convertToPercentage(color.s, 1);
						color.v = convertToPercentage(color.v, 1);
						rgb = hsvToRgb(color.h, color.s, color.v);
						ok = true;
						format = "hsv";
				}
				else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
						color.s = convertToPercentage(color.s);
						color.l = convertToPercentage(color.l);
						rgb = hslToRgb(color.h, color.s, color.l);
						ok = true;
						format = "hsl";
				}

				if (color.hasOwnProperty("a")) {
						a = color.a;
				}
		}

		a = boundAlpha(a);

		return {
				ok: ok,
				format: color.format || format,
				r: mathMin(255, mathMax(rgb.r, 0)),
				g: mathMin(255, mathMax(rgb.g, 0)),
				b: mathMin(255, mathMax(rgb.b, 0)),
				a: a
		};
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// <http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b){
		return {
				r: bound01(r, 255) * 255,
				g: bound01(g, 255) * 255,
				b: bound01(b, 255) * 255
		};
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

		r = bound01(r, 255);
		g = bound01(g, 255);
		b = bound01(b, 255);

		var max = mathMax(r, g, b), min = mathMin(r, g, b);
		var h, s, l = (max + min) / 2;

		if(max == min) {
				h = s = 0; // achromatic
		}
		else {
				var d = max - min;
				s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
				switch(max) {
						case r: h = (g - b) / d + (g < b ? 6 : 0); break;
						case g: h = (b - r) / d + 2; break;
						case b: h = (r - g) / d + 4; break;
				}

				h /= 6;
		}

		return { h: h, s: s, l: l };
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
		var r, g, b;

		h = bound01(h, 360);
		s = bound01(s, 100);
		l = bound01(l, 100);

		function hue2rgb(p, q, t) {
				if(t < 0) t += 1;
				if(t > 1) t -= 1;
				if(t < 1/6) return p + (q - p) * 6 * t;
				if(t < 1/2) return q;
				if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
				return p;
		}

		if(s === 0) {
				r = g = b = l; // achromatic
		}
		else {
				var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				var p = 2 * l - q;
				r = hue2rgb(p, q, h + 1/3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1/3);
		}

		return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

		r = bound01(r, 255);
		g = bound01(g, 255);
		b = bound01(b, 255);

		var max = mathMax(r, g, b), min = mathMin(r, g, b);
		var h, s, v = max;

		var d = max - min;
		s = max === 0 ? 0 : d / max;

		if(max == min) {
				h = 0; // achromatic
		}
		else {
				switch(max) {
						case r: h = (g - b) / d + (g < b ? 6 : 0); break;
						case g: h = (b - r) / d + 2; break;
						case b: h = (r - g) / d + 4; break;
				}
				h /= 6;
		}
		return { h: h, s: s, v: v };
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
 function hsvToRgb(h, s, v) {

		h = bound01(h, 360) * 6;
		s = bound01(s, 100);
		v = bound01(v, 100);

		var i = math.floor(h),
				f = h - i,
				p = v * (1 - s),
				q = v * (1 - f * s),
				t = v * (1 - (1 - f) * s),
				mod = i % 6,
				r = [v, q, p, p, t, v][mod],
				g = [t, v, v, q, p, p][mod],
				b = [p, p, t, v, v, q][mod];

		return { r: r * 255, g: g * 255, b: b * 255 };
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

		var hex = [
				pad2(mathRound(r).toString(16)),
				pad2(mathRound(g).toString(16)),
				pad2(mathRound(b).toString(16))
		];

		// Return a 3 character hex if possible
		if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
				return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
		}

		return hex.join("");
}
		// `rgbaToHex`
		// Converts an RGBA color plus alpha transparency to hex
		// Assumes r, g, b and a are contained in the set [0, 255]
		// Returns an 8 character hex
		function rgbaToHex(r, g, b, a) {

				var hex = [
						pad2(convertDecimalToHex(a)),
						pad2(mathRound(r).toString(16)),
						pad2(mathRound(g).toString(16)),
						pad2(mathRound(b).toString(16))
				];

				return hex.join("");
		}

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
		if (!color1 || !color2) { return false; }
		return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
		return tinycolor.fromRatio({
				r: mathRandom(),
				g: mathRandom(),
				b: mathRandom()
		});
};


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
		amount = (amount === 0) ? 0 : (amount || 10);
		var hsl = tinycolor(color).toHsl();
		hsl.s -= amount / 100;
		hsl.s = clamp01(hsl.s);
		return tinycolor(hsl);
}

function saturate(color, amount) {
		amount = (amount === 0) ? 0 : (amount || 10);
		var hsl = tinycolor(color).toHsl();
		hsl.s += amount / 100;
		hsl.s = clamp01(hsl.s);
		return tinycolor(hsl);
}

function greyscale(color) {
		return tinycolor(color).desaturate(100);
}

function lighten (color, amount) {
		amount = (amount === 0) ? 0 : (amount || 10);
		var hsl = tinycolor(color).toHsl();
		hsl.l += amount / 100;
		hsl.l = clamp01(hsl.l);
		return tinycolor(hsl);
}

function brighten(color, amount) {
		amount = (amount === 0) ? 0 : (amount || 10);
		var rgb = tinycolor(color).toRgb();
		rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
		rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
		rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
		return tinycolor(rgb);
}

function darken (color, amount) {
		amount = (amount === 0) ? 0 : (amount || 10);
		var hsl = tinycolor(color).toHsl();
		hsl.l -= amount / 100;
		hsl.l = clamp01(hsl.l);
		return tinycolor(hsl);
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
		var hsl = tinycolor(color).toHsl();
		var hue = (mathRound(hsl.h) + amount) % 360;
		hsl.h = hue < 0 ? 360 + hue : hue;
		return tinycolor(hsl);
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
		var hsl = tinycolor(color).toHsl();
		hsl.h = (hsl.h + 180) % 360;
		return tinycolor(hsl);
}

function triad(color) {
		var hsl = tinycolor(color).toHsl();
		var h = hsl.h;
		return [
				tinycolor(color),
				tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
				tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
		];
}

function tetrad(color) {
		var hsl = tinycolor(color).toHsl();
		var h = hsl.h;
		return [
				tinycolor(color),
				tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
				tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
				tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
		];
}

function splitcomplement(color) {
		var hsl = tinycolor(color).toHsl();
		var h = hsl.h;
		return [
				tinycolor(color),
				tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
				tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
		];
}

function analogous(color, results, slices) {
		results = results || 6;
		slices = slices || 30;

		var hsl = tinycolor(color).toHsl();
		var part = 360 / slices;
		var ret = [tinycolor(color)];

		for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
				hsl.h = (hsl.h + part) % 360;
				ret.push(tinycolor(hsl));
		}
		return ret;
}

function monochromatic(color, results) {
		results = results || 6;
		var hsv = tinycolor(color).toHsv();
		var h = hsv.h, s = hsv.s, v = hsv.v;
		var ret = [];
		var modification = 1 / results;

		while (results--) {
				ret.push(tinycolor({ h: h, s: s, v: v}));
				v = (v + modification) % 1;
		}

		return ret;
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
		amount = (amount === 0) ? 0 : (amount || 50);

		var rgb1 = tinycolor(color1).toRgb();
		var rgb2 = tinycolor(color2).toRgb();

		var p = amount / 100;
		var w = p * 2 - 1;
		var a = rgb2.a - rgb1.a;

		var w1;

		if (w * a == -1) {
				w1 = w;
		} else {
				w1 = (w + a) / (1 + w * a);
		}

		w1 = (w1 + 1) / 2;

		var w2 = 1 - w1;

		var rgba = {
				r: rgb2.r * w1 + rgb1.r * w2,
				g: rgb2.g * w1 + rgb1.g * w2,
				b: rgb2.b * w1 + rgb1.b * w2,
				a: rgb2.a * p	+ rgb1.a * (1 - p)
		};

		return tinycolor(rgba);
};


// Readability Functions
// ---------------------
// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
		var c1 = tinycolor(color1);
		var c2 = tinycolor(color2);
		return (Math.max(c1.getLuminance(),c2.getLuminance())+0.05) / (Math.min(c1.getLuminance(),c2.getLuminance())+0.05);
};

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//			the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//			the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//		tinycolor.isReadable("#000", "#111") => false
//		tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false

tinycolor.isReadable = function(color1, color2, wcag2) {
		var readability = tinycolor.readability(color1, color2);
		var wcag2Parms, out;

		out = false;

		wcag2Parms = validateWCAG2Parms(wcag2);
		switch (wcag2Parms.level + wcag2Parms.size) {
				case "AAsmall":
				case "AAAlarge":
						out = readability >= 4.5;
						break;
				case "AAlarge":
						out = readability >= 3;
						break;
				case "AAAsmall":
						out = readability >= 7;
						break;
		}
		return out;

};

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//		tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//		tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();	// "#ffffff"
//		tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//		tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"


tinycolor.mostReadable = function(baseColor, colorList, args) {
		var bestColor = null;
		var bestScore = 0;
		var readability;
		var includeFallbackColors, level, size ;
		args = args || {};
		includeFallbackColors = args.includeFallbackColors ;
		level = args.level;
		size = args.size;

		for (var i= 0; i < colorList.length ; i++) {
				readability = tinycolor.readability(baseColor, colorList[i]);
				if (readability > bestScore) {
						bestScore = readability;
						bestColor = tinycolor(colorList[i]);
				}
		}

		if (tinycolor.isReadable(baseColor, bestColor, {"level":level,"size":size}) || !includeFallbackColors) {
				return bestColor;
		}
		else {
				args.includeFallbackColors=false;
				return tinycolor.mostReadable(baseColor,["#fff", "#000"],args);
		}
};


// Big List of Colors
// ------------------
// <http://www.w3.org/TR/css3-color/#svg-color>
var names = tinycolor.names = {
		aliceblue: "f0f8ff",
		antiquewhite: "faebd7",
		aqua: "0ff",
		aquamarine: "7fffd4",
		azure: "f0ffff",
		beige: "f5f5dc",
		bisque: "ffe4c4",
		black: "000",
		blanchedalmond: "ffebcd",
		blue: "00f",
		blueviolet: "8a2be2",
		brown: "a52a2a",
		burlywood: "deb887",
		burntsienna: "ea7e5d",
		cadetblue: "5f9ea0",
		chartreuse: "7fff00",
		chocolate: "d2691e",
		coral: "ff7f50",
		cornflowerblue: "6495ed",
		cornsilk: "fff8dc",
		crimson: "dc143c",
		cyan: "0ff",
		darkblue: "00008b",
		darkcyan: "008b8b",
		darkgoldenrod: "b8860b",
		darkgray: "a9a9a9",
		darkgreen: "006400",
		darkgrey: "a9a9a9",
		darkkhaki: "bdb76b",
		darkmagenta: "8b008b",
		darkolivegreen: "556b2f",
		darkorange: "ff8c00",
		darkorchid: "9932cc",
		darkred: "8b0000",
		darksalmon: "e9967a",
		darkseagreen: "8fbc8f",
		darkslateblue: "483d8b",
		darkslategray: "2f4f4f",
		darkslategrey: "2f4f4f",
		darkturquoise: "00ced1",
		darkviolet: "9400d3",
		deeppink: "ff1493",
		deepskyblue: "00bfff",
		dimgray: "696969",
		dimgrey: "696969",
		dodgerblue: "1e90ff",
		firebrick: "b22222",
		floralwhite: "fffaf0",
		forestgreen: "228b22",
		fuchsia: "f0f",
		gainsboro: "dcdcdc",
		ghostwhite: "f8f8ff",
		gold: "ffd700",
		goldenrod: "daa520",
		gray: "808080",
		green: "008000",
		greenyellow: "adff2f",
		grey: "808080",
		honeydew: "f0fff0",
		hotpink: "ff69b4",
		indianred: "cd5c5c",
		indigo: "4b0082",
		ivory: "fffff0",
		khaki: "f0e68c",
		lavender: "e6e6fa",
		lavenderblush: "fff0f5",
		lawngreen: "7cfc00",
		lemonchiffon: "fffacd",
		lightblue: "add8e6",
		lightcoral: "f08080",
		lightcyan: "e0ffff",
		lightgoldenrodyellow: "fafad2",
		lightgray: "d3d3d3",
		lightgreen: "90ee90",
		lightgrey: "d3d3d3",
		lightpink: "ffb6c1",
		lightsalmon: "ffa07a",
		lightseagreen: "20b2aa",
		lightskyblue: "87cefa",
		lightslategray: "789",
		lightslategrey: "789",
		lightsteelblue: "b0c4de",
		lightyellow: "ffffe0",
		lime: "0f0",
		limegreen: "32cd32",
		linen: "faf0e6",
		magenta: "f0f",
		maroon: "800000",
		mediumaquamarine: "66cdaa",
		mediumblue: "0000cd",
		mediumorchid: "ba55d3",
		mediumpurple: "9370db",
		mediumseagreen: "3cb371",
		mediumslateblue: "7b68ee",
		mediumspringgreen: "00fa9a",
		mediumturquoise: "48d1cc",
		mediumvioletred: "c71585",
		midnightblue: "191970",
		mintcream: "f5fffa",
		mistyrose: "ffe4e1",
		moccasin: "ffe4b5",
		navajowhite: "ffdead",
		navy: "000080",
		oldlace: "fdf5e6",
		olive: "808000",
		olivedrab: "6b8e23",
		orange: "ffa500",
		orangered: "ff4500",
		orchid: "da70d6",
		palegoldenrod: "eee8aa",
		palegreen: "98fb98",
		paleturquoise: "afeeee",
		palevioletred: "db7093",
		papayawhip: "ffefd5",
		peachpuff: "ffdab9",
		peru: "cd853f",
		pink: "ffc0cb",
		plum: "dda0dd",
		powderblue: "b0e0e6",
		purple: "800080",
		rebeccapurple: "663399",
		red: "f00",
		rosybrown: "bc8f8f",
		royalblue: "4169e1",
		saddlebrown: "8b4513",
		salmon: "fa8072",
		sandybrown: "f4a460",
		seagreen: "2e8b57",
		seashell: "fff5ee",
		sienna: "a0522d",
		silver: "c0c0c0",
		skyblue: "87ceeb",
		slateblue: "6a5acd",
		slategray: "708090",
		slategrey: "708090",
		snow: "fffafa",
		springgreen: "00ff7f",
		steelblue: "4682b4",
		tan: "d2b48c",
		teal: "008080",
		thistle: "d8bfd8",
		tomato: "ff6347",
		turquoise: "40e0d0",
		violet: "ee82ee",
		wheat: "f5deb3",
		white: "fff",
		whitesmoke: "f5f5f5",
		yellow: "ff0",
		yellowgreen: "9acd32"
};

// Make it easy to access colors via `hexNames[hex]`
var hexNames = tinycolor.hexNames = flip(names);


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
		var flipped = { };
		for (var i in o) {
				if (o.hasOwnProperty(i)) {
						flipped[o[i]] = i;
				}
		}
		return flipped;
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
		a = parseFloat(a);

		if (isNaN(a) || a < 0 || a > 1) {
				a = 1;
		}

		return a;
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
		if (isOnePointZero(n)) { n = "100%"; }

		var processPercent = isPercentage(n);
		n = mathMin(max, mathMax(0, parseFloat(n)));

		// Automatically convert percentage into number
		if (processPercent) {
				n = parseInt(n * max, 10) / 100;
		}

		// Handle floating point rounding errors
		if ((math.abs(n - max) < 0.000001)) {
				return 1;
		}

		// Convert into [0, 1] range if it isn't already
		return (n % max) / parseFloat(max);
}

// Force a number between 0 and 1
function clamp01(val) {
		return mathMin(1, mathMax(0, val));
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
		return parseInt(val, 16);
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
		return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
		return typeof n === "string" && n.indexOf('%') != -1;
}

// Force a hex value to have 2 characters
function pad2(c) {
		return c.length == 1 ? '0' + c : '' + c;
}

// Replace a decimal with it's percentage value
function convertToPercentage(n, multiplier) {
		multiplier = multiplier || 100;
		if (n <= 1) {
				n = (n * multiplier) + "%";
		}

		return n;
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
		return Math.round(parseFloat(d) * 255).toString(16);
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
		return (parseIntFromHex(h) / 255);
}

var matchers = (function() {

		// <http://www.w3.org/TR/css3-values/#integers>
		var CSS_INTEGER = "[-\\+]?\\d+%?";

		// <http://www.w3.org/TR/css3-values/#number-value>
		var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

		// Allow positive/negative integer/number.	Don't capture the either/or, just the entire outcome.
		var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

		// Actual matching.
		// Parentheses and commas are optional, but not required.
		// Whitespace can take the place of commas or opening paren
		var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
		var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

		return {
				rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
				rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
				hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
				hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
				hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
				hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
				hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
				hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
				hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
		};
})();

// `stringInputToObject`
// Permissive string parsing.	Take in a number of formats, and output an object
// based on detected format.	Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

		color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
		var named = false;
		if (names[color]) {
				color = names[color];
				named = true;
		}
		else if (color == 'transparent') {
				return { r: 0, g: 0, b: 0, a: 0, format: "name" };
		}

		// Try to match string input using regular expressions.
		// Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
		// Just return an object and let the conversion functions handle that.
		// This way the result will be the same whether the tinycolor is initialized with string or object.
		var match;
		if ((match = matchers.rgb.exec(color))) {
				return { r: match[1], g: match[2], b: match[3] };
		}
		if ((match = matchers.rgba.exec(color))) {
				return { r: match[1], g: match[2], b: match[3], a: match[4] };
		}
		if ((match = matchers.hsl.exec(color))) {
				return { h: match[1], s: match[2], l: match[3] };
		}
		if ((match = matchers.hsla.exec(color))) {
				return { h: match[1], s: match[2], l: match[3], a: match[4] };
		}
		if ((match = matchers.hsv.exec(color))) {
				return { h: match[1], s: match[2], v: match[3] };
		}
		if ((match = matchers.hsva.exec(color))) {
				return { h: match[1], s: match[2], v: match[3], a: match[4] };
		}
		if ((match = matchers.hex8.exec(color))) {
				return {
						a: convertHexToDecimal(match[1]),
						r: parseIntFromHex(match[2]),
						g: parseIntFromHex(match[3]),
						b: parseIntFromHex(match[4]),
						format: named ? "name" : "hex8"
				};
		}
		if ((match = matchers.hex6.exec(color))) {
				return {
						r: parseIntFromHex(match[1]),
						g: parseIntFromHex(match[2]),
						b: parseIntFromHex(match[3]),
						format: named ? "name" : "hex"
				};
		}
		if ((match = matchers.hex3.exec(color))) {
				return {
						r: parseIntFromHex(match[1] + '' + match[1]),
						g: parseIntFromHex(match[2] + '' + match[2]),
						b: parseIntFromHex(match[3] + '' + match[3]),
						format: named ? "name" : "hex"
				};
		}

		return false;
}

function validateWCAG2Parms(parms) {
		// return valid WCAG2 parms for isReadable.
		// If input parms are invalid, return {"level":"AA", "size":"small"}
		var level, size;
		parms = parms || {"level":"AA", "size":"small"};
		level = (parms.level || "AA").toUpperCase();
		size = (parms.size || "small").toLowerCase();
		if (level !== "AA" && level !== "AAA") {
				level = "AA";
		}
		if (size !== "small" && size !== "large") {
				size = "small";
		}
		return {"level":level, "size":size};
}
// Node: Export function
if (typeof module !== "undefined" && module.exports) {
		module.exports = tinycolor;
}
// AMD/requirejs: Define the module
else if (typeof define === 'function' && define.amd) {
		define(function () {return tinycolor;});
}
// Browser: Expose to window
else {
		window.tinycolor = tinycolor;
}

})();

},{}],502:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;

},{"./_getNative":557,"./_root":592}],503:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./_hashClear":563,"./_hashDelete":564,"./_hashGet":565,"./_hashHas":566,"./_hashSet":567,"dup":162}],504:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./_listCacheClear":574,"./_listCacheDelete":575,"./_listCacheGet":576,"./_listCacheHas":577,"./_listCacheSet":578,"dup":163}],505:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"./_getNative":557,"./_root":592,"dup":164}],506:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"./_mapCacheClear":579,"./_mapCacheDelete":580,"./_mapCacheGet":581,"./_mapCacheHas":582,"./_mapCacheSet":583,"dup":165}],507:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;

},{"./_getNative":557,"./_root":592}],508:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./_getNative":557,"./_root":592,"dup":166}],509:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"./_MapCache":506,"./_setCacheAdd":593,"./_setCacheHas":594,"dup":167}],510:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    stackClear = require('./_stackClear'),
    stackDelete = require('./_stackDelete'),
    stackGet = require('./_stackGet'),
    stackHas = require('./_stackHas'),
    stackSet = require('./_stackSet');

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;

},{"./_ListCache":504,"./_stackClear":596,"./_stackDelete":597,"./_stackGet":598,"./_stackHas":599,"./_stackSet":600}],511:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./_root":592,"dup":168}],512:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;

},{"./_root":592}],513:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":557,"./_root":592}],514:[function(require,module,exports){
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],515:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],516:[function(require,module,exports){
var baseTimes = require('./_baseTimes'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isIndex = require('./_isIndex'),
    isTypedArray = require('./isTypedArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;

},{"./_baseTimes":541,"./_isIndex":568,"./isArguments":611,"./isArray":612,"./isBuffer":614,"./isTypedArray":621}],517:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],518:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"dup":174}],519:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],520:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"./eq":606,"dup":175}],521:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    createBaseEach = require('./_createBaseEach');

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./_baseForOwn":523,"./_createBaseEach":548}],522:[function(require,module,exports){
var createBaseFor = require('./_createBaseFor');

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./_createBaseFor":549}],523:[function(require,module,exports){
var baseFor = require('./_baseFor'),
    keys = require('./keys');

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"./_baseFor":522,"./keys":622}],524:[function(require,module,exports){
var castPath = require('./_castPath'),
    toKey = require('./_toKey');

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./_castPath":546,"./_toKey":602}],525:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    isArray = require('./isArray');

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;

},{"./_arrayPush":518,"./isArray":612}],526:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./_Symbol":511,"./_getRawTag":558,"./_objectToString":590,"dup":179}],527:[function(require,module,exports){
/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;

},{}],528:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"./_baseGetTag":526,"./isObjectLike":618,"dup":182}],529:[function(require,module,exports){
var baseIsEqualDeep = require('./_baseIsEqualDeep'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;

},{"./_baseIsEqualDeep":530,"./isObjectLike":618}],530:[function(require,module,exports){
var Stack = require('./_Stack'),
    equalArrays = require('./_equalArrays'),
    equalByTag = require('./_equalByTag'),
    equalObjects = require('./_equalObjects'),
    getTag = require('./_getTag'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isTypedArray = require('./isTypedArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;

},{"./_Stack":510,"./_equalArrays":550,"./_equalByTag":551,"./_equalObjects":552,"./_getTag":560,"./isArray":612,"./isBuffer":614,"./isTypedArray":621}],531:[function(require,module,exports){
var Stack = require('./_Stack'),
    baseIsEqual = require('./_baseIsEqual');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./_Stack":510,"./_baseIsEqual":529}],532:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"./_isMasked":571,"./_toSource":603,"./isFunction":615,"./isObject":617,"dup":184}],533:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isLength = require('./isLength'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;

},{"./_baseGetTag":526,"./isLength":616,"./isObjectLike":618}],534:[function(require,module,exports){
var baseMatches = require('./_baseMatches'),
    baseMatchesProperty = require('./_baseMatchesProperty'),
    identity = require('./identity'),
    isArray = require('./isArray'),
    property = require('./property');

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;

},{"./_baseMatches":537,"./_baseMatchesProperty":538,"./identity":610,"./isArray":612,"./property":626}],535:[function(require,module,exports){
var isPrototype = require('./_isPrototype'),
    nativeKeys = require('./_nativeKeys');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;

},{"./_isPrototype":572,"./_nativeKeys":588}],536:[function(require,module,exports){
var baseEach = require('./_baseEach'),
    isArrayLike = require('./isArrayLike');

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;

},{"./_baseEach":521,"./isArrayLike":613}],537:[function(require,module,exports){
var baseIsMatch = require('./_baseIsMatch'),
    getMatchData = require('./_getMatchData'),
    matchesStrictComparable = require('./_matchesStrictComparable');

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;

},{"./_baseIsMatch":531,"./_getMatchData":556,"./_matchesStrictComparable":585}],538:[function(require,module,exports){
var baseIsEqual = require('./_baseIsEqual'),
    get = require('./get'),
    hasIn = require('./hasIn'),
    isKey = require('./_isKey'),
    isStrictComparable = require('./_isStrictComparable'),
    matchesStrictComparable = require('./_matchesStrictComparable'),
    toKey = require('./_toKey');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;

},{"./_baseIsEqual":529,"./_isKey":569,"./_isStrictComparable":573,"./_matchesStrictComparable":585,"./_toKey":602,"./get":608,"./hasIn":609}],539:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],540:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;

},{"./_baseGet":524}],541:[function(require,module,exports){
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;

},{}],542:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":511,"./_arrayMap":517,"./isArray":612,"./isSymbol":620}],543:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"dup":187}],544:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],545:[function(require,module,exports){
var identity = require('./identity');

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;

},{"./identity":610}],546:[function(require,module,exports){
var isArray = require('./isArray'),
    isKey = require('./_isKey'),
    stringToPath = require('./_stringToPath'),
    toString = require('./toString');

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;

},{"./_isKey":569,"./_stringToPath":601,"./isArray":612,"./toString":631}],547:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"./_root":592,"dup":192}],548:[function(require,module,exports){
var isArrayLike = require('./isArrayLike');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./isArrayLike":613}],549:[function(require,module,exports){
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{}],550:[function(require,module,exports){
var SetCache = require('./_SetCache'),
    arraySome = require('./_arraySome'),
    cacheHas = require('./_cacheHas');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;

},{"./_SetCache":509,"./_arraySome":519,"./_cacheHas":544}],551:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    Uint8Array = require('./_Uint8Array'),
    eq = require('./eq'),
    equalArrays = require('./_equalArrays'),
    mapToArray = require('./_mapToArray'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;

},{"./_Symbol":511,"./_Uint8Array":512,"./_equalArrays":550,"./_mapToArray":584,"./_setToArray":595,"./eq":606}],552:[function(require,module,exports){
var getAllKeys = require('./_getAllKeys');

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;

},{"./_getAllKeys":554}],553:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],554:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbols = require('./_getSymbols'),
    keys = require('./keys');

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;

},{"./_baseGetAllKeys":525,"./_getSymbols":559,"./keys":622}],555:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./_isKeyable":570,"dup":196}],556:[function(require,module,exports){
var isStrictComparable = require('./_isStrictComparable'),
    keys = require('./keys');

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;

},{"./_isStrictComparable":573,"./keys":622}],557:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"./_baseIsNative":532,"./_getValue":561,"dup":197}],558:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./_Symbol":511,"dup":198}],559:[function(require,module,exports){
var arrayFilter = require('./_arrayFilter'),
    stubArray = require('./stubArray');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;

},{"./_arrayFilter":515,"./stubArray":627}],560:[function(require,module,exports){
var DataView = require('./_DataView'),
    Map = require('./_Map'),
    Promise = require('./_Promise'),
    Set = require('./_Set'),
    WeakMap = require('./_WeakMap'),
    baseGetTag = require('./_baseGetTag'),
    toSource = require('./_toSource');

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;

},{"./_DataView":502,"./_Map":505,"./_Promise":507,"./_Set":508,"./_WeakMap":513,"./_baseGetTag":526,"./_toSource":603}],561:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"dup":199}],562:[function(require,module,exports){
var castPath = require('./_castPath'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isIndex = require('./_isIndex'),
    isLength = require('./isLength'),
    toKey = require('./_toKey');

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;

},{"./_castPath":546,"./_isIndex":568,"./_toKey":602,"./isArguments":611,"./isArray":612,"./isLength":616}],563:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"./_nativeCreate":587,"dup":200}],564:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"dup":201}],565:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"./_nativeCreate":587,"dup":202}],566:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"./_nativeCreate":587,"dup":203}],567:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"./_nativeCreate":587,"dup":204}],568:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],569:[function(require,module,exports){
var isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;

},{"./isArray":612,"./isSymbol":620}],570:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"dup":206}],571:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./_coreJsData":547,"dup":207}],572:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;

},{}],573:[function(require,module,exports){
var isObject = require('./isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"./isObject":617}],574:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"dup":208}],575:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"./_assocIndexOf":520,"dup":209}],576:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"./_assocIndexOf":520,"dup":210}],577:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"./_assocIndexOf":520,"dup":211}],578:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"./_assocIndexOf":520,"dup":212}],579:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"./_Hash":503,"./_ListCache":504,"./_Map":505,"dup":213}],580:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"./_getMapData":555,"dup":214}],581:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"./_getMapData":555,"dup":215}],582:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"./_getMapData":555,"dup":216}],583:[function(require,module,exports){
arguments[4][217][0].apply(exports,arguments)
},{"./_getMapData":555,"dup":217}],584:[function(require,module,exports){
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;

},{}],585:[function(require,module,exports){
/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;

},{}],586:[function(require,module,exports){
var memoize = require('./memoize');

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;

},{"./memoize":624}],587:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"./_getNative":557,"dup":218}],588:[function(require,module,exports){
var overArg = require('./_overArg');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;

},{"./_overArg":591}],589:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;

},{"./_freeGlobal":553}],590:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],591:[function(require,module,exports){
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;

},{}],592:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./_freeGlobal":553,"dup":221}],593:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"dup":222}],594:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"dup":223}],595:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"dup":224}],596:[function(require,module,exports){
var ListCache = require('./_ListCache');

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;

},{"./_ListCache":504}],597:[function(require,module,exports){
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;

},{}],598:[function(require,module,exports){
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;

},{}],599:[function(require,module,exports){
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;

},{}],600:[function(require,module,exports){
var ListCache = require('./_ListCache'),
    Map = require('./_Map'),
    MapCache = require('./_MapCache');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;

},{"./_ListCache":504,"./_Map":505,"./_MapCache":506}],601:[function(require,module,exports){
var memoizeCapped = require('./_memoizeCapped');

/** Used to match property names within property paths. */
var reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;

},{"./_memoizeCapped":586}],602:[function(require,module,exports){
var isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;

},{"./isSymbol":620}],603:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"dup":228}],604:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":617,"./now":625,"./toNumber":630}],605:[function(require,module,exports){
module.exports = require('./forEach');

},{"./forEach":607}],606:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"dup":230}],607:[function(require,module,exports){
var arrayEach = require('./_arrayEach'),
    baseEach = require('./_baseEach'),
    castFunction = require('./_castFunction'),
    isArray = require('./isArray');

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;

},{"./_arrayEach":514,"./_baseEach":521,"./_castFunction":545,"./isArray":612}],608:[function(require,module,exports){
var baseGet = require('./_baseGet');

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;

},{"./_baseGet":524}],609:[function(require,module,exports){
var baseHasIn = require('./_baseHasIn'),
    hasPath = require('./_hasPath');

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;

},{"./_baseHasIn":527,"./_hasPath":562}],610:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"dup":231}],611:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"./_baseIsArguments":528,"./isObjectLike":618,"dup":233}],612:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"dup":234}],613:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"./isFunction":615,"./isLength":616,"dup":235}],614:[function(require,module,exports){
var root = require('./_root'),
    stubFalse = require('./stubFalse');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;

},{"./_root":592,"./stubFalse":628}],615:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"./_baseGetTag":526,"./isObject":617,"dup":237}],616:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"dup":238}],617:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"dup":239}],618:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],619:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;

},{"./_baseGetTag":526,"./isArray":612,"./isObjectLike":618}],620:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":526,"./isObjectLike":618}],621:[function(require,module,exports){
var baseIsTypedArray = require('./_baseIsTypedArray'),
    baseUnary = require('./_baseUnary'),
    nodeUtil = require('./_nodeUtil');

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;

},{"./_baseIsTypedArray":533,"./_baseUnary":543,"./_nodeUtil":589}],622:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeys = require('./_baseKeys'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;

},{"./_arrayLikeKeys":516,"./_baseKeys":535,"./isArrayLike":613}],623:[function(require,module,exports){
var arrayMap = require('./_arrayMap'),
    baseIteratee = require('./_baseIteratee'),
    baseMap = require('./_baseMap'),
    isArray = require('./isArray');

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;

},{"./_arrayMap":517,"./_baseIteratee":534,"./_baseMap":536,"./isArray":612}],624:[function(require,module,exports){
var MapCache = require('./_MapCache');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;

},{"./_MapCache":506}],625:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":592}],626:[function(require,module,exports){
var baseProperty = require('./_baseProperty'),
    basePropertyDeep = require('./_basePropertyDeep'),
    isKey = require('./_isKey'),
    toKey = require('./_toKey');

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;

},{"./_baseProperty":539,"./_basePropertyDeep":540,"./_isKey":569,"./_toKey":602}],627:[function(require,module,exports){
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;

},{}],628:[function(require,module,exports){
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;

},{}],629:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":604,"./isObject":617}],630:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":617,"./isSymbol":620}],631:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":542}],632:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSafari = exports.isFirefox = undefined;

var _memoize = require('lodash/memoize');

var _memoize2 = _interopRequireDefault(_memoize);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isFirefox = exports.isFirefox = (0, _memoize2.default)(function () {
  return (/firefox/i.test(navigator.userAgent)
  );
});
var isSafari = exports.isSafari = (0, _memoize2.default)(function () {
  return Boolean(window.safari);
});
},{"lodash/memoize":735}],633:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _union = require('lodash/union');

var _union2 = _interopRequireDefault(_union);

var _without = require('lodash/without');

var _without2 = _interopRequireDefault(_without);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var EnterLeaveCounter = function () {
  function EnterLeaveCounter() {
    _classCallCheck(this, EnterLeaveCounter);

    this.entered = [];
  }

  _createClass(EnterLeaveCounter, [{
    key: 'enter',
    value: function enter(enteringNode) {
      var previousLength = this.entered.length;

      var isNodeEntered = function isNodeEntered(node) {
        return document.documentElement.contains(node) && (!node.contains || node.contains(enteringNode));
      };

      this.entered = (0, _union2.default)(this.entered.filter(isNodeEntered), [enteringNode]);

      return previousLength === 0 && this.entered.length > 0;
    }
  }, {
    key: 'leave',
    value: function leave(leavingNode) {
      var previousLength = this.entered.length;

      this.entered = (0, _without2.default)(this.entered.filter(function (node) {
        return document.documentElement.contains(node);
      }), leavingNode);

      return previousLength > 0 && this.entered.length === 0;
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.entered = [];
    }
  }]);

  return EnterLeaveCounter;
}();

exports.default = EnterLeaveCounter;
},{"lodash/union":738,"lodash/without":739}],634:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _defaults = require('lodash/defaults');

var _defaults2 = _interopRequireDefault(_defaults);

var _shallowEqual = require('./shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _EnterLeaveCounter = require('./EnterLeaveCounter');

var _EnterLeaveCounter2 = _interopRequireDefault(_EnterLeaveCounter);

var _BrowserDetector = require('./BrowserDetector');

var _OffsetUtils = require('./OffsetUtils');

var _NativeDragSources = require('./NativeDragSources');

var _NativeTypes = require('./NativeTypes');

var NativeTypes = _interopRequireWildcard(_NativeTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HTML5Backend = function () {
  function HTML5Backend(manager) {
    _classCallCheck(this, HTML5Backend);

    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.registry = manager.getRegistry();
    this.context = manager.getContext();

    this.sourcePreviewNodes = {};
    this.sourcePreviewNodeOptions = {};
    this.sourceNodes = {};
    this.sourceNodeOptions = {};
    this.enterLeaveCounter = new _EnterLeaveCounter2.default();

    this.dragStartSourceIds = [];
    this.dropTargetIds = [];
    this.dragEnterTargetIds = [];
    this.currentNativeSource = null;
    this.currentNativeHandle = null;
    this.currentDragSourceNode = null;
    this.currentDragSourceNodeOffset = null;
    this.currentDragSourceNodeOffsetChanged = false;
    this.altKeyPressed = false;

    this.getSourceClientOffset = this.getSourceClientOffset.bind(this);
    this.handleTopDragStart = this.handleTopDragStart.bind(this);
    this.handleTopDragStartCapture = this.handleTopDragStartCapture.bind(this);
    this.handleTopDragEndCapture = this.handleTopDragEndCapture.bind(this);
    this.handleTopDragEnter = this.handleTopDragEnter.bind(this);
    this.handleTopDragEnterCapture = this.handleTopDragEnterCapture.bind(this);
    this.handleTopDragLeaveCapture = this.handleTopDragLeaveCapture.bind(this);
    this.handleTopDragOver = this.handleTopDragOver.bind(this);
    this.handleTopDragOverCapture = this.handleTopDragOverCapture.bind(this);
    this.handleTopDrop = this.handleTopDrop.bind(this);
    this.handleTopDropCapture = this.handleTopDropCapture.bind(this);
    this.handleSelectStart = this.handleSelectStart.bind(this);
    this.endDragIfSourceWasRemovedFromDOM = this.endDragIfSourceWasRemovedFromDOM.bind(this);
    this.endDragNativeItem = this.endDragNativeItem.bind(this);
  }

  _createClass(HTML5Backend, [{
    key: 'setup',
    value: function setup() {
      if (this.window === undefined) {
        return;
      }

      if (this.window.__isReactDndBackendSetUp) {
        // eslint-disable-line no-underscore-dangle
        throw new Error('Cannot have two HTML5 backends at the same time.');
      }
      this.window.__isReactDndBackendSetUp = true; // eslint-disable-line no-underscore-dangle
      this.addEventListeners(this.window);
    }
  }, {
    key: 'teardown',
    value: function teardown() {
      if (this.window === undefined) {
        return;
      }

      this.window.__isReactDndBackendSetUp = false; // eslint-disable-line no-underscore-dangle
      this.removeEventListeners(this.window);
      this.clearCurrentDragSourceNode();
    }
  }, {
    key: 'addEventListeners',
    value: function addEventListeners(target) {
      target.addEventListener('dragstart', this.handleTopDragStart);
      target.addEventListener('dragstart', this.handleTopDragStartCapture, true);
      target.addEventListener('dragend', this.handleTopDragEndCapture, true);
      target.addEventListener('dragenter', this.handleTopDragEnter);
      target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);
      target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);
      target.addEventListener('dragover', this.handleTopDragOver);
      target.addEventListener('dragover', this.handleTopDragOverCapture, true);
      target.addEventListener('drop', this.handleTopDrop);
      target.addEventListener('drop', this.handleTopDropCapture, true);
    }
  }, {
    key: 'removeEventListeners',
    value: function removeEventListeners(target) {
      target.removeEventListener('dragstart', this.handleTopDragStart);
      target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);
      target.removeEventListener('dragend', this.handleTopDragEndCapture, true);
      target.removeEventListener('dragenter', this.handleTopDragEnter);
      target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);
      target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);
      target.removeEventListener('dragover', this.handleTopDragOver);
      target.removeEventListener('dragover', this.handleTopDragOverCapture, true);
      target.removeEventListener('drop', this.handleTopDrop);
      target.removeEventListener('drop', this.handleTopDropCapture, true);
    }
  }, {
    key: 'connectDragPreview',
    value: function connectDragPreview(sourceId, node, options) {
      var _this = this;

      this.sourcePreviewNodeOptions[sourceId] = options;
      this.sourcePreviewNodes[sourceId] = node;

      return function () {
        delete _this.sourcePreviewNodes[sourceId];
        delete _this.sourcePreviewNodeOptions[sourceId];
      };
    }
  }, {
    key: 'connectDragSource',
    value: function connectDragSource(sourceId, node, options) {
      var _this2 = this;

      this.sourceNodes[sourceId] = node;
      this.sourceNodeOptions[sourceId] = options;

      var handleDragStart = function handleDragStart(e) {
        return _this2.handleDragStart(e, sourceId);
      };
      var handleSelectStart = function handleSelectStart(e) {
        return _this2.handleSelectStart(e, sourceId);
      };

      node.setAttribute('draggable', true);
      node.addEventListener('dragstart', handleDragStart);
      node.addEventListener('selectstart', handleSelectStart);

      return function () {
        delete _this2.sourceNodes[sourceId];
        delete _this2.sourceNodeOptions[sourceId];

        node.removeEventListener('dragstart', handleDragStart);
        node.removeEventListener('selectstart', handleSelectStart);
        node.setAttribute('draggable', false);
      };
    }
  }, {
    key: 'connectDropTarget',
    value: function connectDropTarget(targetId, node) {
      var _this3 = this;

      var handleDragEnter = function handleDragEnter(e) {
        return _this3.handleDragEnter(e, targetId);
      };
      var handleDragOver = function handleDragOver(e) {
        return _this3.handleDragOver(e, targetId);
      };
      var handleDrop = function handleDrop(e) {
        return _this3.handleDrop(e, targetId);
      };

      node.addEventListener('dragenter', handleDragEnter);
      node.addEventListener('dragover', handleDragOver);
      node.addEventListener('drop', handleDrop);

      return function () {
        node.removeEventListener('dragenter', handleDragEnter);
        node.removeEventListener('dragover', handleDragOver);
        node.removeEventListener('drop', handleDrop);
      };
    }
  }, {
    key: 'getCurrentSourceNodeOptions',
    value: function getCurrentSourceNodeOptions() {
      var sourceId = this.monitor.getSourceId();
      var sourceNodeOptions = this.sourceNodeOptions[sourceId];

      return (0, _defaults2.default)(sourceNodeOptions || {}, {
        dropEffect: this.altKeyPressed ? 'copy' : 'move'
      });
    }
  }, {
    key: 'getCurrentDropEffect',
    value: function getCurrentDropEffect() {
      if (this.isDraggingNativeItem()) {
        // It makes more sense to default to 'copy' for native resources
        return 'copy';
      }

      return this.getCurrentSourceNodeOptions().dropEffect;
    }
  }, {
    key: 'getCurrentSourcePreviewNodeOptions',
    value: function getCurrentSourcePreviewNodeOptions() {
      var sourceId = this.monitor.getSourceId();
      var sourcePreviewNodeOptions = this.sourcePreviewNodeOptions[sourceId];

      return (0, _defaults2.default)(sourcePreviewNodeOptions || {}, {
        anchorX: 0.5,
        anchorY: 0.5,
        captureDraggingState: false
      });
    }
  }, {
    key: 'getSourceClientOffset',
    value: function getSourceClientOffset(sourceId) {
      return (0, _OffsetUtils.getNodeClientOffset)(this.sourceNodes[sourceId]);
    }
  }, {
    key: 'isDraggingNativeItem',
    value: function isDraggingNativeItem() {
      var itemType = this.monitor.getItemType();
      return Object.keys(NativeTypes).some(function (key) {
        return NativeTypes[key] === itemType;
      });
    }
  }, {
    key: 'beginDragNativeItem',
    value: function beginDragNativeItem(type) {
      this.clearCurrentDragSourceNode();

      var SourceType = (0, _NativeDragSources.createNativeDragSource)(type);
      this.currentNativeSource = new SourceType();
      this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
      this.actions.beginDrag([this.currentNativeHandle]);

      // On Firefox, if mousemove fires, the drag is over but browser failed to tell us.
      // This is not true for other browsers.
      if ((0, _BrowserDetector.isFirefox)()) {
        this.window.addEventListener('mousemove', this.endDragNativeItem, true);
      }
    }
  }, {
    key: 'endDragNativeItem',
    value: function endDragNativeItem() {
      if (!this.isDraggingNativeItem()) {
        return;
      }

      if ((0, _BrowserDetector.isFirefox)()) {
        this.window.removeEventListener('mousemove', this.endDragNativeItem, true);
      }

      this.actions.endDrag();
      this.registry.removeSource(this.currentNativeHandle);
      this.currentNativeHandle = null;
      this.currentNativeSource = null;
    }
  }, {
    key: 'endDragIfSourceWasRemovedFromDOM',
    value: function endDragIfSourceWasRemovedFromDOM() {
      var node = this.currentDragSourceNode;
      if (document.body.contains(node)) {
        return;
      }

      if (this.clearCurrentDragSourceNode()) {
        this.actions.endDrag();
      }
    }
  }, {
    key: 'setCurrentDragSourceNode',
    value: function setCurrentDragSourceNode(node) {
      this.clearCurrentDragSourceNode();
      this.currentDragSourceNode = node;
      this.currentDragSourceNodeOffset = (0, _OffsetUtils.getNodeClientOffset)(node);
      this.currentDragSourceNodeOffsetChanged = false;

      // Receiving a mouse event in the middle of a dragging operation
      // means it has ended and the drag source node disappeared from DOM,
      // so the browser didn't dispatch the dragend event.
      this.window.addEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
    }
  }, {
    key: 'clearCurrentDragSourceNode',
    value: function clearCurrentDragSourceNode() {
      if (this.currentDragSourceNode) {
        this.currentDragSourceNode = null;
        this.currentDragSourceNodeOffset = null;
        this.currentDragSourceNodeOffsetChanged = false;
        this.window.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
        return true;
      }

      return false;
    }
  }, {
    key: 'checkIfCurrentDragSourceRectChanged',
    value: function checkIfCurrentDragSourceRectChanged() {
      var node = this.currentDragSourceNode;
      if (!node) {
        return false;
      }

      if (this.currentDragSourceNodeOffsetChanged) {
        return true;
      }

      this.currentDragSourceNodeOffsetChanged = !(0, _shallowEqual2.default)((0, _OffsetUtils.getNodeClientOffset)(node), this.currentDragSourceNodeOffset);

      return this.currentDragSourceNodeOffsetChanged;
    }
  }, {
    key: 'handleTopDragStartCapture',
    value: function handleTopDragStartCapture() {
      this.clearCurrentDragSourceNode();
      this.dragStartSourceIds = [];
    }
  }, {
    key: 'handleDragStart',
    value: function handleDragStart(e, sourceId) {
      this.dragStartSourceIds.unshift(sourceId);
    }
  }, {
    key: 'handleTopDragStart',
    value: function handleTopDragStart(e) {
      var _this4 = this;

      var dragStartSourceIds = this.dragStartSourceIds;

      this.dragStartSourceIds = null;

      var clientOffset = (0, _OffsetUtils.getEventClientOffset)(e);

      // Don't publish the source just yet (see why below)
      this.actions.beginDrag(dragStartSourceIds, {
        publishSource: false,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset: clientOffset
      });

      var dataTransfer = e.dataTransfer;

      var nativeType = (0, _NativeDragSources.matchNativeItemType)(dataTransfer);

      if (this.monitor.isDragging()) {
        if (typeof dataTransfer.setDragImage === 'function') {
          // Use custom drag image if user specifies it.
          // If child drag source refuses drag but parent agrees,
          // use parent's node as drag image. Neither works in IE though.
          var sourceId = this.monitor.getSourceId();
          var sourceNode = this.sourceNodes[sourceId];
          var dragPreview = this.sourcePreviewNodes[sourceId] || sourceNode;

          var _getCurrentSourcePrev = this.getCurrentSourcePreviewNodeOptions(),
              anchorX = _getCurrentSourcePrev.anchorX,
              anchorY = _getCurrentSourcePrev.anchorY;

          var anchorPoint = { anchorX: anchorX, anchorY: anchorY };
          var dragPreviewOffset = (0, _OffsetUtils.getDragPreviewOffset)(sourceNode, dragPreview, clientOffset, anchorPoint);
          dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
        }

        try {
          // Firefox won't drag without setting data
          dataTransfer.setData('application/json', {});
        } catch (err) {}
        // IE doesn't support MIME types in setData


        // Store drag source node so we can check whether
        // it is removed from DOM and trigger endDrag manually.
        this.setCurrentDragSourceNode(e.target);

        // Now we are ready to publish the drag source.. or are we not?

        var _getCurrentSourcePrev2 = this.getCurrentSourcePreviewNodeOptions(),
            captureDraggingState = _getCurrentSourcePrev2.captureDraggingState;

        if (!captureDraggingState) {
          // Usually we want to publish it in the next tick so that browser
          // is able to screenshot the current (not yet dragging) state.
          //
          // It also neatly avoids a situation where render() returns null
          // in the same tick for the source element, and browser freaks out.
          setTimeout(function () {
            return _this4.actions.publishDragSource();
          });
        } else {
          // In some cases the user may want to override this behavior, e.g.
          // to work around IE not supporting custom drag previews.
          //
          // When using a custom drag layer, the only way to prevent
          // the default drag preview from drawing in IE is to screenshot
          // the dragging state in which the node itself has zero opacity
          // and height. In this case, though, returning null from render()
          // will abruptly end the dragging, which is not obvious.
          //
          // This is the reason such behavior is strictly opt-in.
          this.actions.publishDragSource();
        }
      } else if (nativeType) {
        // A native item (such as URL) dragged from inside the document
        this.beginDragNativeItem(nativeType);
      } else if (!dataTransfer.types && (!e.target.hasAttribute || !e.target.hasAttribute('draggable'))) {
        // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.
        // Just let it drag. It's a native type (URL or text) and will be picked up in
        // dragenter handler.
        return; // eslint-disable-line no-useless-return
      } else {
        // If by this time no drag source reacted, tell browser not to drag.
        e.preventDefault();
      }
    }
  }, {
    key: 'handleTopDragEndCapture',
    value: function handleTopDragEndCapture() {
      if (this.clearCurrentDragSourceNode()) {
        // Firefox can dispatch this event in an infinite loop
        // if dragend handler does something like showing an alert.
        // Only proceed if we have not handled it already.
        this.actions.endDrag();
      }
    }
  }, {
    key: 'handleTopDragEnterCapture',
    value: function handleTopDragEnterCapture(e) {
      this.dragEnterTargetIds = [];

      var isFirstEnter = this.enterLeaveCounter.enter(e.target);
      if (!isFirstEnter || this.monitor.isDragging()) {
        return;
      }

      var dataTransfer = e.dataTransfer;

      var nativeType = (0, _NativeDragSources.matchNativeItemType)(dataTransfer);

      if (nativeType) {
        // A native item (such as file or URL) dragged from outside the document
        this.beginDragNativeItem(nativeType);
      }
    }
  }, {
    key: 'handleDragEnter',
    value: function handleDragEnter(e, targetId) {
      this.dragEnterTargetIds.unshift(targetId);
    }
  }, {
    key: 'handleTopDragEnter',
    value: function handleTopDragEnter(e) {
      var _this5 = this;

      var dragEnterTargetIds = this.dragEnterTargetIds;

      this.dragEnterTargetIds = [];

      if (!this.monitor.isDragging()) {
        // This is probably a native item type we don't understand.
        return;
      }

      this.altKeyPressed = e.altKey;

      if (!(0, _BrowserDetector.isFirefox)()) {
        // Don't emit hover in `dragenter` on Firefox due to an edge case.
        // If the target changes position as the result of `dragenter`, Firefox
        // will still happily dispatch `dragover` despite target being no longer
        // there. The easy solution is to only fire `hover` in `dragover` on FF.
        this.actions.hover(dragEnterTargetIds, {
          clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
        });
      }

      var canDrop = dragEnterTargetIds.some(function (targetId) {
        return _this5.monitor.canDropOnTarget(targetId);
      });

      if (canDrop) {
        // IE requires this to fire dragover events
        e.preventDefault();
        e.dataTransfer.dropEffect = this.getCurrentDropEffect();
      }
    }
  }, {
    key: 'handleTopDragOverCapture',
    value: function handleTopDragOverCapture() {
      this.dragOverTargetIds = [];
    }
  }, {
    key: 'handleDragOver',
    value: function handleDragOver(e, targetId) {
      this.dragOverTargetIds.unshift(targetId);
    }
  }, {
    key: 'handleTopDragOver',
    value: function handleTopDragOver(e) {
      var _this6 = this;

      var dragOverTargetIds = this.dragOverTargetIds;

      this.dragOverTargetIds = [];

      if (!this.monitor.isDragging()) {
        // This is probably a native item type we don't understand.
        // Prevent default "drop and blow away the whole document" action.
        e.preventDefault();
        e.dataTransfer.dropEffect = 'none';
        return;
      }

      this.altKeyPressed = e.altKey;

      this.actions.hover(dragOverTargetIds, {
        clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
      });

      var canDrop = dragOverTargetIds.some(function (targetId) {
        return _this6.monitor.canDropOnTarget(targetId);
      });

      if (canDrop) {
        // Show user-specified drop effect.
        e.preventDefault();
        e.dataTransfer.dropEffect = this.getCurrentDropEffect();
      } else if (this.isDraggingNativeItem()) {
        // Don't show a nice cursor but still prevent default
        // "drop and blow away the whole document" action.
        e.preventDefault();
        e.dataTransfer.dropEffect = 'none';
      } else if (this.checkIfCurrentDragSourceRectChanged()) {
        // Prevent animating to incorrect position.
        // Drop effect must be other than 'none' to prevent animation.
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      }
    }
  }, {
    key: 'handleTopDragLeaveCapture',
    value: function handleTopDragLeaveCapture(e) {
      if (this.isDraggingNativeItem()) {
        e.preventDefault();
      }

      var isLastLeave = this.enterLeaveCounter.leave(e.target);
      if (!isLastLeave) {
        return;
      }

      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      }
    }
  }, {
    key: 'handleTopDropCapture',
    value: function handleTopDropCapture(e) {
      this.dropTargetIds = [];
      e.preventDefault();

      if (this.isDraggingNativeItem()) {
        this.currentNativeSource.mutateItemByReadingDataTransfer(e.dataTransfer);
      }

      this.enterLeaveCounter.reset();
    }
  }, {
    key: 'handleDrop',
    value: function handleDrop(e, targetId) {
      this.dropTargetIds.unshift(targetId);
    }
  }, {
    key: 'handleTopDrop',
    value: function handleTopDrop(e) {
      var dropTargetIds = this.dropTargetIds;

      this.dropTargetIds = [];

      this.actions.hover(dropTargetIds, {
        clientOffset: (0, _OffsetUtils.getEventClientOffset)(e)
      });
      this.actions.drop({ dropEffect: this.getCurrentDropEffect() });

      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      } else {
        this.endDragIfSourceWasRemovedFromDOM();
      }
    }
  }, {
    key: 'handleSelectStart',
    value: function handleSelectStart(e) {
      var target = e.target;

      // Only IE requires us to explicitly say
      // we want drag drop operation to start

      if (typeof target.dragDrop !== 'function') {
        return;
      }

      // Inputs and textareas should be selectable
      if (target.tagName === 'INPUT' || target.tagName === 'SELECT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
        return;
      }

      // For other targets, ask IE
      // to enable drag and drop
      e.preventDefault();
      target.dragDrop();
    }
  }, {
    key: 'window',
    get: function get() {
      if (this.context && this.context.window) {
        return this.context.window;
      } else if (typeof window !== 'undefined') {
        return window;
      }
      return undefined;
    }
  }]);

  return HTML5Backend;
}();

exports.default = HTML5Backend;
},{"./BrowserDetector":632,"./EnterLeaveCounter":633,"./NativeDragSources":636,"./NativeTypes":637,"./OffsetUtils":638,"./shallowEqual":641,"lodash/defaults":721}],635:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint
   no-plusplus: off,
   no-mixed-operators: off
*/
var MonotonicInterpolant = function () {
  function MonotonicInterpolant(xs, ys) {
    _classCallCheck(this, MonotonicInterpolant);

    var length = xs.length;

    // Rearrange xs and ys so that xs is sorted
    var indexes = [];
    for (var i = 0; i < length; i++) {
      indexes.push(i);
    }
    indexes.sort(function (a, b) {
      return xs[a] < xs[b] ? -1 : 1;
    });

    // Get consecutive differences and slopes
    var dys = [];
    var dxs = [];
    var ms = [];
    var dx = void 0;
    var dy = void 0;
    for (var _i = 0; _i < length - 1; _i++) {
      dx = xs[_i + 1] - xs[_i];
      dy = ys[_i + 1] - ys[_i];
      dxs.push(dx);
      dys.push(dy);
      ms.push(dy / dx);
    }

    // Get degree-1 coefficients
    var c1s = [ms[0]];
    for (var _i2 = 0; _i2 < dxs.length - 1; _i2++) {
      var _m = ms[_i2];
      var mNext = ms[_i2 + 1];
      if (_m * mNext <= 0) {
        c1s.push(0);
      } else {
        dx = dxs[_i2];
        var dxNext = dxs[_i2 + 1];
        var common = dx + dxNext;
        c1s.push(3 * common / ((common + dxNext) / _m + (common + dx) / mNext));
      }
    }
    c1s.push(ms[ms.length - 1]);

    // Get degree-2 and degree-3 coefficients
    var c2s = [];
    var c3s = [];
    var m = void 0;
    for (var _i3 = 0; _i3 < c1s.length - 1; _i3++) {
      m = ms[_i3];
      var c1 = c1s[_i3];
      var invDx = 1 / dxs[_i3];
      var _common = c1 + c1s[_i3 + 1] - m - m;
      c2s.push((m - c1 - _common) * invDx);
      c3s.push(_common * invDx * invDx);
    }

    this.xs = xs;
    this.ys = ys;
    this.c1s = c1s;
    this.c2s = c2s;
    this.c3s = c3s;
  }

  _createClass(MonotonicInterpolant, [{
    key: "interpolate",
    value: function interpolate(x) {
      var xs = this.xs,
          ys = this.ys,
          c1s = this.c1s,
          c2s = this.c2s,
          c3s = this.c3s;

      // The rightmost point in the dataset should give an exact result

      var i = xs.length - 1;
      if (x === xs[i]) {
        return ys[i];
      }

      // Search for the interval x is in, returning the corresponding y if x is one of the original xs
      var low = 0;
      var high = c3s.length - 1;
      var mid = void 0;
      while (low <= high) {
        mid = Math.floor(0.5 * (low + high));
        var xHere = xs[mid];
        if (xHere < x) {
          low = mid + 1;
        } else if (xHere > x) {
          high = mid - 1;
        } else {
          return ys[mid];
        }
      }
      i = Math.max(0, high);

      // Interpolate
      var diff = x - xs[i];
      var diffSq = diff * diff;
      return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
    }
  }]);

  return MonotonicInterpolant;
}();

exports.default = MonotonicInterpolant;
},{}],636:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _nativeTypesConfig;

exports.createNativeDragSource = createNativeDragSource;
exports.matchNativeItemType = matchNativeItemType;

var _NativeTypes = require('./NativeTypes');

var NativeTypes = _interopRequireWildcard(_NativeTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
  var result = typesToTry.reduce(function (resultSoFar, typeToTry) {
    return resultSoFar || dataTransfer.getData(typeToTry);
  }, null);

  return result != null ? // eslint-disable-line eqeqeq
  result : defaultValue;
}

var nativeTypesConfig = (_nativeTypesConfig = {}, _defineProperty(_nativeTypesConfig, NativeTypes.FILE, {
  exposeProperty: 'files',
  matchesTypes: ['Files'],
  getData: function getData(dataTransfer) {
    return Array.prototype.slice.call(dataTransfer.files);
  }
}), _defineProperty(_nativeTypesConfig, NativeTypes.URL, {
  exposeProperty: 'urls',
  matchesTypes: ['Url', 'text/uri-list'],
  getData: function getData(dataTransfer, matchesTypes) {
    return getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\n');
  }
}), _defineProperty(_nativeTypesConfig, NativeTypes.TEXT, {
  exposeProperty: 'text',
  matchesTypes: ['Text', 'text/plain'],
  getData: function getData(dataTransfer, matchesTypes) {
    return getDataFromDataTransfer(dataTransfer, matchesTypes, '');
  }
}), _nativeTypesConfig);

function createNativeDragSource(type) {
  var _nativeTypesConfig$ty = nativeTypesConfig[type],
      exposeProperty = _nativeTypesConfig$ty.exposeProperty,
      matchesTypes = _nativeTypesConfig$ty.matchesTypes,
      getData = _nativeTypesConfig$ty.getData;


  return function () {
    function NativeDragSource() {
      var _item, _mutatorMap;

      _classCallCheck(this, NativeDragSource);

      this.item = (_item = {}, _mutatorMap = {}, _mutatorMap[exposeProperty] = _mutatorMap[exposeProperty] || {}, _mutatorMap[exposeProperty].get = function () {
        console.warn( // eslint-disable-line no-console
        'Browser doesn\'t allow reading "' + exposeProperty + '" until the drop event.');
        return null;
      }, _defineEnumerableProperties(_item, _mutatorMap), _item);
    }

    _createClass(NativeDragSource, [{
      key: 'mutateItemByReadingDataTransfer',
      value: function mutateItemByReadingDataTransfer(dataTransfer) {
        delete this.item[exposeProperty];
        this.item[exposeProperty] = getData(dataTransfer, matchesTypes);
      }
    }, {
      key: 'canDrag',
      value: function canDrag() {
        return true;
      }
    }, {
      key: 'beginDrag',
      value: function beginDrag() {
        return this.item;
      }
    }, {
      key: 'isDragging',
      value: function isDragging(monitor, handle) {
        return handle === monitor.getSourceId();
      }
    }, {
      key: 'endDrag',
      value: function endDrag() {}
    }]);

    return NativeDragSource;
  }();
}

function matchNativeItemType(dataTransfer) {
  var dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);

  return Object.keys(nativeTypesConfig).filter(function (nativeItemType) {
    var matchesTypes = nativeTypesConfig[nativeItemType].matchesTypes;

    return matchesTypes.some(function (t) {
      return dataTransferTypes.indexOf(t) > -1;
    });
  })[0] || null;
}
},{"./NativeTypes":637}],637:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var FILE = exports.FILE = '__NATIVE_FILE__';
var URL = exports.URL = '__NATIVE_URL__';
var TEXT = exports.TEXT = '__NATIVE_TEXT__';
},{}],638:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNodeClientOffset = getNodeClientOffset;
exports.getEventClientOffset = getEventClientOffset;
exports.getDragPreviewOffset = getDragPreviewOffset;

var _BrowserDetector = require('./BrowserDetector');

var _MonotonicInterpolant = require('./MonotonicInterpolant');

var _MonotonicInterpolant2 = _interopRequireDefault(_MonotonicInterpolant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint
   no-mixed-operators: off
*/
var ELEMENT_NODE = 1;

function getNodeClientOffset(node) {
  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;

  if (!el) {
    return null;
  }

  var _el$getBoundingClient = el.getBoundingClientRect(),
      top = _el$getBoundingClient.top,
      left = _el$getBoundingClient.left;

  return { x: left, y: top };
}

function getEventClientOffset(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}

function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint) {
  // The browsers will use the image intrinsic size under different conditions.
  // Firefox only cares if it's an image, but WebKit also wants it to be detached.
  var isImage = dragPreview.nodeName === 'IMG' && ((0, _BrowserDetector.isFirefox)() || !document.documentElement.contains(dragPreview));
  var dragPreviewNode = isImage ? sourceNode : dragPreview;

  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  var offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };

  var sourceWidth = sourceNode.offsetWidth,
      sourceHeight = sourceNode.offsetHeight;
  var anchorX = anchorPoint.anchorX,
      anchorY = anchorPoint.anchorY;


  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;

  // Work around @2x coordinate discrepancies in browsers
  if ((0, _BrowserDetector.isSafari)() && isImage) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  } else if ((0, _BrowserDetector.isFirefox)() && !isImage) {
    dragPreviewHeight *= window.devicePixelRatio;
    dragPreviewWidth *= window.devicePixelRatio;
  }

  // Interpolate coordinates depending on anchor point
  // If you know a simpler way to do this, let me know
  var interpolantX = new _MonotonicInterpolant2.default([0, 0.5, 1], [
  // Dock to the left
  offsetFromDragPreview.x,
  // Align at the center
  offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
  // Dock to the right
  offsetFromDragPreview.x + dragPreviewWidth - sourceWidth]);
  var interpolantY = new _MonotonicInterpolant2.default([0, 0.5, 1], [
  // Dock to the top
  offsetFromDragPreview.y,
  // Align at the center
  offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
  // Dock to the bottom
  offsetFromDragPreview.y + dragPreviewHeight - sourceHeight]);
  var x = interpolantX.interpolate(anchorX);
  var y = interpolantY.interpolate(anchorY);

  // Work around Safari 8 positioning bug
  if ((0, _BrowserDetector.isSafari)() && isImage) {
    // We'll have to wait for @3x to see if this is entirely correct
    y += (window.devicePixelRatio - 1) * dragPreviewHeight;
  }

  return { x: x, y: y };
}
},{"./BrowserDetector":632,"./MonotonicInterpolant":635}],639:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getEmptyImage;
var emptyImage = void 0;
function getEmptyImage() {
  if (!emptyImage) {
    emptyImage = new Image();
    emptyImage.src = 'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
  }

  return emptyImage;
}
},{}],640:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getEmptyImage = exports.NativeTypes = undefined;
exports.default = createHTML5Backend;

var _HTML5Backend = require('./HTML5Backend');

var _HTML5Backend2 = _interopRequireDefault(_HTML5Backend);

var _getEmptyImage = require('./getEmptyImage');

var _getEmptyImage2 = _interopRequireDefault(_getEmptyImage);

var _NativeTypes = require('./NativeTypes');

var NativeTypes = _interopRequireWildcard(_NativeTypes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.NativeTypes = NativeTypes;
exports.getEmptyImage = _getEmptyImage2.default;
function createHTML5Backend(manager) {
  return new _HTML5Backend2.default(manager);
}
},{"./HTML5Backend":634,"./NativeTypes":637,"./getEmptyImage":639}],641:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = shallowEqual;
function shallowEqual(objA, objB) {
  if (objA === objB) {
    return true;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var i = 0; i < keysA.length; i += 1) {
    if (!hasOwn.call(objB, keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }

    var valA = objA[keysA[i]];
    var valB = objB[keysA[i]];

    if (valA !== valB) {
      return false;
    }
  }

  return true;
}
},{}],642:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./_hashClear":685,"./_hashDelete":686,"./_hashGet":687,"./_hashHas":688,"./_hashSet":689,"dup":162}],643:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./_listCacheClear":696,"./_listCacheDelete":697,"./_listCacheGet":698,"./_listCacheHas":699,"./_listCacheSet":700,"dup":163}],644:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"./_getNative":682,"./_root":711,"dup":164}],645:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"./_mapCacheClear":701,"./_mapCacheDelete":702,"./_mapCacheGet":703,"./_mapCacheHas":704,"./_mapCacheSet":705,"dup":165}],646:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./_getNative":682,"./_root":711,"dup":166}],647:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"./_MapCache":645,"./_setCacheAdd":712,"./_setCacheHas":713,"dup":167}],648:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./_root":711,"dup":168}],649:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],650:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"./_baseIndexOf":662,"dup":171}],651:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"dup":172}],652:[function(require,module,exports){
arguments[4][516][0].apply(exports,arguments)
},{"./_baseTimes":670,"./_isIndex":691,"./isArguments":724,"./isArray":725,"./isBuffer":728,"./isTypedArray":733,"dup":516}],653:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],654:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"dup":174}],655:[function(require,module,exports){
var baseAssignValue = require('./_baseAssignValue'),
    eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;

},{"./_baseAssignValue":657,"./eq":722}],656:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"./eq":722,"dup":175}],657:[function(require,module,exports){
var defineProperty = require('./_defineProperty');

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;

},{"./_defineProperty":679}],658:[function(require,module,exports){
arguments[4][176][0].apply(exports,arguments)
},{"./_SetCache":647,"./_arrayIncludes":650,"./_arrayIncludesWith":651,"./_arrayMap":653,"./_baseUnary":671,"./_cacheHas":673,"dup":176}],659:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"dup":177}],660:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"./_arrayPush":654,"./_isFlattenable":690,"dup":178}],661:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./_Symbol":648,"./_getRawTag":683,"./_objectToString":709,"dup":179}],662:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"./_baseFindIndex":659,"./_baseIsNaN":664,"./_strictIndexOf":717,"dup":180}],663:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"./_baseGetTag":661,"./isObjectLike":732,"dup":182}],664:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183}],665:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"./_isMasked":694,"./_toSource":718,"./isFunction":729,"./isObject":731,"dup":184}],666:[function(require,module,exports){
arguments[4][533][0].apply(exports,arguments)
},{"./_baseGetTag":661,"./isLength":730,"./isObjectLike":732,"dup":533}],667:[function(require,module,exports){
var isObject = require('./isObject'),
    isPrototype = require('./_isPrototype'),
    nativeKeysIn = require('./_nativeKeysIn');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;

},{"./_isPrototype":695,"./_nativeKeysIn":707,"./isObject":731}],668:[function(require,module,exports){
arguments[4][185][0].apply(exports,arguments)
},{"./_overRest":710,"./_setToString":715,"./identity":723,"dup":185}],669:[function(require,module,exports){
arguments[4][186][0].apply(exports,arguments)
},{"./_defineProperty":679,"./constant":720,"./identity":723,"dup":186}],670:[function(require,module,exports){
arguments[4][541][0].apply(exports,arguments)
},{"dup":541}],671:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"dup":187}],672:[function(require,module,exports){
arguments[4][188][0].apply(exports,arguments)
},{"./_SetCache":647,"./_arrayIncludes":650,"./_arrayIncludesWith":651,"./_cacheHas":673,"./_createSet":677,"./_setToArray":714,"dup":188}],673:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],674:[function(require,module,exports){
var assignValue = require('./_assignValue'),
    baseAssignValue = require('./_baseAssignValue');

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;

},{"./_assignValue":655,"./_baseAssignValue":657}],675:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"./_root":711,"dup":192}],676:[function(require,module,exports){
var baseRest = require('./_baseRest'),
    isIterateeCall = require('./_isIterateeCall');

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"./_baseRest":668,"./_isIterateeCall":692}],677:[function(require,module,exports){
arguments[4][193][0].apply(exports,arguments)
},{"./_Set":646,"./_setToArray":714,"./noop":736,"dup":193}],678:[function(require,module,exports){
var eq = require('./eq');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
 * of source objects to the destination object for all destination properties
 * that resolve to `undefined`.
 *
 * @private
 * @param {*} objValue The destination value.
 * @param {*} srcValue The source value.
 * @param {string} key The key of the property to assign.
 * @param {Object} object The parent object of `objValue`.
 * @returns {*} Returns the value to assign.
 */
function customDefaultsAssignIn(objValue, srcValue, key, object) {
  if (objValue === undefined ||
      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
    return srcValue;
  }
  return objValue;
}

module.exports = customDefaultsAssignIn;

},{"./eq":722}],679:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./_getNative":682,"dup":194}],680:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],681:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./_isKeyable":693,"dup":196}],682:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"./_baseIsNative":665,"./_getValue":684,"dup":197}],683:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./_Symbol":648,"dup":198}],684:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"dup":199}],685:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"./_nativeCreate":706,"dup":200}],686:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"dup":201}],687:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"./_nativeCreate":706,"dup":202}],688:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"./_nativeCreate":706,"dup":203}],689:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"./_nativeCreate":706,"dup":204}],690:[function(require,module,exports){
arguments[4][205][0].apply(exports,arguments)
},{"./_Symbol":648,"./isArguments":724,"./isArray":725,"dup":205}],691:[function(require,module,exports){
arguments[4][568][0].apply(exports,arguments)
},{"dup":568}],692:[function(require,module,exports){
var eq = require('./eq'),
    isArrayLike = require('./isArrayLike'),
    isIndex = require('./_isIndex'),
    isObject = require('./isObject');

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;

},{"./_isIndex":691,"./eq":722,"./isArrayLike":726,"./isObject":731}],693:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"dup":206}],694:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./_coreJsData":675,"dup":207}],695:[function(require,module,exports){
arguments[4][572][0].apply(exports,arguments)
},{"dup":572}],696:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"dup":208}],697:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"./_assocIndexOf":656,"dup":209}],698:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"./_assocIndexOf":656,"dup":210}],699:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"./_assocIndexOf":656,"dup":211}],700:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"./_assocIndexOf":656,"dup":212}],701:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"./_Hash":642,"./_ListCache":643,"./_Map":644,"dup":213}],702:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"./_getMapData":681,"dup":214}],703:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"./_getMapData":681,"dup":215}],704:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"./_getMapData":681,"dup":216}],705:[function(require,module,exports){
arguments[4][217][0].apply(exports,arguments)
},{"./_getMapData":681,"dup":217}],706:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"./_getNative":682,"dup":218}],707:[function(require,module,exports){
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;

},{}],708:[function(require,module,exports){
arguments[4][589][0].apply(exports,arguments)
},{"./_freeGlobal":680,"dup":589}],709:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],710:[function(require,module,exports){
arguments[4][220][0].apply(exports,arguments)
},{"./_apply":649,"dup":220}],711:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./_freeGlobal":680,"dup":221}],712:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"dup":222}],713:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"dup":223}],714:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"dup":224}],715:[function(require,module,exports){
arguments[4][225][0].apply(exports,arguments)
},{"./_baseSetToString":669,"./_shortOut":716,"dup":225}],716:[function(require,module,exports){
arguments[4][226][0].apply(exports,arguments)
},{"dup":226}],717:[function(require,module,exports){
arguments[4][227][0].apply(exports,arguments)
},{"dup":227}],718:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"dup":228}],719:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    createAssigner = require('./_createAssigner'),
    keysIn = require('./keysIn');

/**
 * This method is like `_.assignIn` except that it accepts `customizer`
 * which is invoked to produce the assigned values. If `customizer` returns
 * `undefined`, assignment is handled by the method instead. The `customizer`
 * is invoked with five arguments: (objValue, srcValue, key, object, source).
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extendWith
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} sources The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @returns {Object} Returns `object`.
 * @see _.assignWith
 * @example
 *
 * function customizer(objValue, srcValue) {
 *   return _.isUndefined(objValue) ? srcValue : objValue;
 * }
 *
 * var defaults = _.partialRight(_.assignInWith, customizer);
 *
 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  copyObject(source, keysIn(source), object, customizer);
});

module.exports = assignInWith;

},{"./_copyObject":674,"./_createAssigner":676,"./keysIn":734}],720:[function(require,module,exports){
arguments[4][229][0].apply(exports,arguments)
},{"dup":229}],721:[function(require,module,exports){
var apply = require('./_apply'),
    assignInWith = require('./assignInWith'),
    baseRest = require('./_baseRest'),
    customDefaultsAssignIn = require('./_customDefaultsAssignIn');

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(args) {
  args.push(undefined, customDefaultsAssignIn);
  return apply(assignInWith, undefined, args);
});

module.exports = defaults;

},{"./_apply":649,"./_baseRest":668,"./_customDefaultsAssignIn":678,"./assignInWith":719}],722:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"dup":230}],723:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"dup":231}],724:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"./_baseIsArguments":663,"./isObjectLike":732,"dup":233}],725:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"dup":234}],726:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"./isFunction":729,"./isLength":730,"dup":235}],727:[function(require,module,exports){
arguments[4][236][0].apply(exports,arguments)
},{"./isArrayLike":726,"./isObjectLike":732,"dup":236}],728:[function(require,module,exports){
arguments[4][614][0].apply(exports,arguments)
},{"./_root":711,"./stubFalse":737,"dup":614}],729:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"./_baseGetTag":661,"./isObject":731,"dup":237}],730:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"dup":238}],731:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"dup":239}],732:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],733:[function(require,module,exports){
arguments[4][621][0].apply(exports,arguments)
},{"./_baseIsTypedArray":666,"./_baseUnary":671,"./_nodeUtil":708,"dup":621}],734:[function(require,module,exports){
var arrayLikeKeys = require('./_arrayLikeKeys'),
    baseKeysIn = require('./_baseKeysIn'),
    isArrayLike = require('./isArrayLike');

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;

},{"./_arrayLikeKeys":652,"./_baseKeysIn":667,"./isArrayLike":726}],735:[function(require,module,exports){
arguments[4][624][0].apply(exports,arguments)
},{"./_MapCache":645,"dup":624}],736:[function(require,module,exports){
arguments[4][241][0].apply(exports,arguments)
},{"dup":241}],737:[function(require,module,exports){
arguments[4][628][0].apply(exports,arguments)
},{"dup":628}],738:[function(require,module,exports){
var baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    baseUniq = require('./_baseUniq'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;

},{"./_baseFlatten":660,"./_baseRest":668,"./_baseUniq":672,"./isArrayLikeObject":727}],739:[function(require,module,exports){
arguments[4][242][0].apply(exports,arguments)
},{"./_baseDifference":658,"./_baseRest":668,"./isArrayLikeObject":727,"dup":242}],740:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unpackBackendForEs5Users = exports.createChildContext = exports.CHILD_CONTEXT_TYPES = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = DragDropContext;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _dndCore = require('dnd-core');

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _checkDecoratorArguments = require('./utils/checkDecoratorArguments');

var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CHILD_CONTEXT_TYPES = exports.CHILD_CONTEXT_TYPES = {
  dragDropManager: _react.PropTypes.object.isRequired
};

var createChildContext = exports.createChildContext = function createChildContext(backend, context) {
  return {
    dragDropManager: new _dndCore.DragDropManager(backend, context)
  };
};

var unpackBackendForEs5Users = exports.unpackBackendForEs5Users = function unpackBackendForEs5Users(backendOrModule) {
  // Auto-detect ES6 default export for people still using ES5
  var backend = backendOrModule;
  if ((typeof backend === 'undefined' ? 'undefined' : _typeof(backend)) === 'object' && typeof backend.default === 'function') {
    backend = backend.default;
  }
  (0, _invariant2.default)(typeof backend === 'function', 'Expected the backend to be a function or an ES6 module exporting a default function. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-drop-context.html');
  return backend;
};

function DragDropContext(backendOrModule) {
  _checkDecoratorArguments2.default.apply(undefined, ['DragDropContext', 'backend'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params

  var backend = unpackBackendForEs5Users(backendOrModule);
  var childContext = createChildContext(backend);

  return function decorateContext(DecoratedComponent) {
    var _class, _temp;

    var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

    var DragDropContextContainer = (_temp = _class = function (_Component) {
      _inherits(DragDropContextContainer, _Component);

      function DragDropContextContainer() {
        _classCallCheck(this, DragDropContextContainer);

        return _possibleConstructorReturn(this, (DragDropContextContainer.__proto__ || Object.getPrototypeOf(DragDropContextContainer)).apply(this, arguments));
      }

      _createClass(DragDropContextContainer, [{
        key: 'getDecoratedComponentInstance',
        value: function getDecoratedComponentInstance() {
          (0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can ' + 'not be a stateless component.');
          return this.child;
        }
      }, {
        key: 'getManager',
        value: function getManager() {
          return childContext.dragDropManager;
        }
      }, {
        key: 'getChildContext',
        value: function getChildContext() {
          return childContext;
        }
      }, {
        key: 'render',
        value: function render() {
          var _this2 = this;

          return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, {
            ref: function ref(child) {
              return _this2.child = child;
            }
          }));
        }
      }]);

      return DragDropContextContainer;
    }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragDropContext(' + displayName + ')', _class.childContextTypes = CHILD_CONTEXT_TYPES, _temp);


    return (0, _hoistNonReactStatics2.default)(DragDropContextContainer, DecoratedComponent);
  };
}
},{"./utils/checkDecoratorArguments":756,"dnd-core":153,"hoist-non-react-statics":326,"invariant":327,"react":"react"}],741:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp;

var _react = require('react');

var _DragDropContext = require('./DragDropContext');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * This class is a React-Component based version of the DragDropContext.
 * This is an alternative to decorating an application component with an ES7 decorator.
 */
var DragDropContextProvider = (_temp = _class = function (_Component) {
  _inherits(DragDropContextProvider, _Component);

  function DragDropContextProvider(props, context) {
    _classCallCheck(this, DragDropContextProvider);

    var _this = _possibleConstructorReturn(this, (DragDropContextProvider.__proto__ || Object.getPrototypeOf(DragDropContextProvider)).call(this, props, context));

    _this.backend = (0, _DragDropContext.unpackBackendForEs5Users)(props.backend);
    return _this;
  }

  _createClass(DragDropContextProvider, [{
    key: 'getChildContext',
    value: function getChildContext() {
      var _this2 = this;

      /**
       * This property determines which window global to use for creating the DragDropManager.
       * If a window has been injected explicitly via props, that is used first. If it is available
       * as a context value, then use that, otherwise use the browser global.
       */
      var getWindow = function getWindow() {
        if (_this2.props && _this2.props.window) {
          return _this2.props.window;
        } else if (_this2.context && _this2.context.window) {
          return _this2.context.window;
        } else if (typeof window !== 'undefined') {
          return window;
        }
        return undefined;
      };

      return (0, _DragDropContext.createChildContext)(this.backend, { window: getWindow() });
    }
  }, {
    key: 'render',
    value: function render() {
      return _react.Children.only(this.props.children);
    }
  }]);

  return DragDropContextProvider;
}(_react.Component), _class.propTypes = {
  backend: _react.PropTypes.oneOfType([_react.PropTypes.func, _react.PropTypes.object]).isRequired,
  children: _react.PropTypes.element.isRequired,
  window: _react.PropTypes.object }, _class.defaultProps = {
  window: undefined
}, _class.childContextTypes = _DragDropContext.CHILD_CONTEXT_TYPES, _class.displayName = 'DragDropContextProvider', _class.contextTypes = {
  window: _react.PropTypes.object
}, _temp);
exports.default = DragDropContextProvider;
},{"./DragDropContext":740,"react":"react"}],742:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = DragLayer;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _shallowEqual = require('./utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _shallowEqualScalar = require('./utils/shallowEqualScalar');

var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

var _checkDecoratorArguments = require('./utils/checkDecoratorArguments');

var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function DragLayer(collect) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  _checkDecoratorArguments2.default.apply(undefined, ['DragLayer', 'collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
  (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the first argument to DragLayer ' + 'to be a function that collects props to inject into the component. ', 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', collect);
  (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the second argument to DragLayer to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', options);

  return function decorateLayer(DecoratedComponent) {
    var _class, _temp;

    var _options$arePropsEqua = options.arePropsEqual,
        arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

    var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

    var DragLayerContainer = (_temp = _class = function (_Component) {
      _inherits(DragLayerContainer, _Component);

      _createClass(DragLayerContainer, [{
        key: 'getDecoratedComponentInstance',
        value: function getDecoratedComponentInstance() {
          (0, _invariant2.default)(this.child, 'In order to access an instance of the decorated component it can ' + 'not be a stateless component.');
          return this.child;
        }
      }, {
        key: 'shouldComponentUpdate',
        value: function shouldComponentUpdate(nextProps, nextState) {
          return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
        }
      }]);

      function DragLayerContainer(props, context) {
        _classCallCheck(this, DragLayerContainer);

        var _this = _possibleConstructorReturn(this, (DragLayerContainer.__proto__ || Object.getPrototypeOf(DragLayerContainer)).call(this, props));

        _this.handleChange = _this.handleChange.bind(_this);

        _this.manager = context.dragDropManager;
        (0, _invariant2.default)(_typeof(_this.manager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

        _this.state = _this.getCurrentState();
        return _this;
      }

      _createClass(DragLayerContainer, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
          this.isCurrentlyMounted = true;

          var monitor = this.manager.getMonitor();
          this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
          this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);

          this.handleChange();
        }
      }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
          this.isCurrentlyMounted = false;

          this.unsubscribeFromOffsetChange();
          this.unsubscribeFromStateChange();
        }
      }, {
        key: 'handleChange',
        value: function handleChange() {
          if (!this.isCurrentlyMounted) {
            return;
          }

          var nextState = this.getCurrentState();
          if (!(0, _shallowEqual2.default)(nextState, this.state)) {
            this.setState(nextState);
          }
        }
      }, {
        key: 'getCurrentState',
        value: function getCurrentState() {
          var monitor = this.manager.getMonitor();
          return collect(monitor);
        }
      }, {
        key: 'render',
        value: function render() {
          var _this2 = this;

          return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
            ref: function ref(child) {
              return _this2.child = child;
            }
          }));
        }
      }]);

      return DragLayerContainer;
    }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = 'DragLayer(' + displayName + ')', _class.contextTypes = {
      dragDropManager: _react.PropTypes.object.isRequired
    }, _temp);


    return (0, _hoistNonReactStatics2.default)(DragLayerContainer, DecoratedComponent);
  };
}
},{"./utils/checkDecoratorArguments":756,"./utils/shallowEqual":759,"./utils/shallowEqualScalar":760,"hoist-non-react-statics":326,"invariant":327,"lodash/isPlainObject":772,"react":"react"}],743:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DragSource;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _checkDecoratorArguments = require('./utils/checkDecoratorArguments');

var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

var _decorateHandler = require('./decorateHandler');

var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

var _registerSource = require('./registerSource');

var _registerSource2 = _interopRequireDefault(_registerSource);

var _createSourceFactory = require('./createSourceFactory');

var _createSourceFactory2 = _interopRequireDefault(_createSourceFactory);

var _createSourceMonitor = require('./createSourceMonitor');

var _createSourceMonitor2 = _interopRequireDefault(_createSourceMonitor);

var _createSourceConnector = require('./createSourceConnector');

var _createSourceConnector2 = _interopRequireDefault(_createSourceConnector);

var _isValidType = require('./utils/isValidType');

var _isValidType2 = _interopRequireDefault(_isValidType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DragSource(type, spec, collect) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  _checkDecoratorArguments2.default.apply(undefined, ['DragSource', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
  var getType = type;
  if (typeof type !== 'function') {
    (0, _invariant2.default)((0, _isValidType2.default)(type), 'Expected "type" provided as the first argument to DragSource to be ' + 'a string, or a function that returns a string given the current props. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', type);
    getType = function getType() {
      return type;
    };
  }
  (0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DragSource to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', spec);
  var createSource = (0, _createSourceFactory2.default)(spec);
  (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DragSource to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);
  (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DragSource to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);

  return function decorateSource(DecoratedComponent) {
    return (0, _decorateHandler2.default)({
      connectBackend: function connectBackend(backend, sourceId) {
        return backend.connectDragSource(sourceId);
      },
      containerDisplayName: 'DragSource',
      createHandler: createSource,
      registerHandler: _registerSource2.default,
      createMonitor: _createSourceMonitor2.default,
      createConnector: _createSourceConnector2.default,
      DecoratedComponent: DecoratedComponent,
      getType: getType,
      collect: collect,
      options: options
    });
  };
}
},{"./createSourceConnector":746,"./createSourceFactory":747,"./createSourceMonitor":748,"./decorateHandler":752,"./registerSource":754,"./utils/checkDecoratorArguments":756,"./utils/isValidType":758,"invariant":327,"lodash/isPlainObject":772}],744:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DropTarget;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _checkDecoratorArguments = require('./utils/checkDecoratorArguments');

var _checkDecoratorArguments2 = _interopRequireDefault(_checkDecoratorArguments);

var _decorateHandler = require('./decorateHandler');

var _decorateHandler2 = _interopRequireDefault(_decorateHandler);

var _registerTarget = require('./registerTarget');

var _registerTarget2 = _interopRequireDefault(_registerTarget);

var _createTargetFactory = require('./createTargetFactory');

var _createTargetFactory2 = _interopRequireDefault(_createTargetFactory);

var _createTargetMonitor = require('./createTargetMonitor');

var _createTargetMonitor2 = _interopRequireDefault(_createTargetMonitor);

var _createTargetConnector = require('./createTargetConnector');

var _createTargetConnector2 = _interopRequireDefault(_createTargetConnector);

var _isValidType = require('./utils/isValidType');

var _isValidType2 = _interopRequireDefault(_isValidType);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function DropTarget(type, spec, collect) {
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  _checkDecoratorArguments2.default.apply(undefined, ['DropTarget', 'type, spec, collect[, options]'].concat(Array.prototype.slice.call(arguments))); // eslint-disable-line prefer-rest-params
  var getType = type;
  if (typeof type !== 'function') {
    (0, _invariant2.default)((0, _isValidType2.default)(type, true), 'Expected "type" provided as the first argument to DropTarget to be ' + 'a string, an array of strings, or a function that returns either given ' + 'the current props. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', type);
    getType = function getType() {
      return type;
    };
  }
  (0, _invariant2.default)((0, _isPlainObject2.default)(spec), 'Expected "spec" provided as the second argument to DropTarget to be ' + 'a plain object. Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', spec);
  var createTarget = (0, _createTargetFactory2.default)(spec);
  (0, _invariant2.default)(typeof collect === 'function', 'Expected "collect" provided as the third argument to DropTarget to be ' + 'a function that returns a plain object of props to inject. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);
  (0, _invariant2.default)((0, _isPlainObject2.default)(options), 'Expected "options" provided as the fourth argument to DropTarget to be ' + 'a plain object when specified. ' + 'Instead, received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);

  return function decorateTarget(DecoratedComponent) {
    return (0, _decorateHandler2.default)({
      connectBackend: function connectBackend(backend, targetId) {
        return backend.connectDropTarget(targetId);
      },
      containerDisplayName: 'DropTarget',
      createHandler: createTarget,
      registerHandler: _registerTarget2.default,
      createMonitor: _createTargetMonitor2.default,
      createConnector: _createTargetConnector2.default,
      DecoratedComponent: DecoratedComponent,
      getType: getType,
      collect: collect,
      options: options
    });
  };
}
},{"./createTargetConnector":749,"./createTargetFactory":750,"./createTargetMonitor":751,"./decorateHandler":752,"./registerTarget":755,"./utils/checkDecoratorArguments":756,"./utils/isValidType":758,"invariant":327,"lodash/isPlainObject":772}],745:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = areOptionsEqual;

var _shallowEqual = require('./utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function areOptionsEqual(nextOptions, currentOptions) {
  if (currentOptions === nextOptions) {
    return true;
  }

  return currentOptions !== null && nextOptions !== null && (0, _shallowEqual2.default)(currentOptions, nextOptions);
}
},{"./utils/shallowEqual":759}],746:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createSourceConnector;

var _wrapConnectorHooks = require('./wrapConnectorHooks');

var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

var _areOptionsEqual = require('./areOptionsEqual');

var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createSourceConnector(backend) {
  var currentHandlerId = void 0;

  var currentDragSourceNode = void 0;
  var currentDragSourceOptions = void 0;
  var disconnectCurrentDragSource = void 0;

  var currentDragPreviewNode = void 0;
  var currentDragPreviewOptions = void 0;
  var disconnectCurrentDragPreview = void 0;

  function reconnectDragSource() {
    if (disconnectCurrentDragSource) {
      disconnectCurrentDragSource();
      disconnectCurrentDragSource = null;
    }

    if (currentHandlerId && currentDragSourceNode) {
      disconnectCurrentDragSource = backend.connectDragSource(currentHandlerId, currentDragSourceNode, currentDragSourceOptions);
    }
  }

  function reconnectDragPreview() {
    if (disconnectCurrentDragPreview) {
      disconnectCurrentDragPreview();
      disconnectCurrentDragPreview = null;
    }

    if (currentHandlerId && currentDragPreviewNode) {
      disconnectCurrentDragPreview = backend.connectDragPreview(currentHandlerId, currentDragPreviewNode, currentDragPreviewOptions);
    }
  }

  function receiveHandlerId(handlerId) {
    if (handlerId === currentHandlerId) {
      return;
    }

    currentHandlerId = handlerId;
    reconnectDragSource();
    reconnectDragPreview();
  }

  var hooks = (0, _wrapConnectorHooks2.default)({
    dragSource: function connectDragSource(node, options) {
      if (node === currentDragSourceNode && (0, _areOptionsEqual2.default)(options, currentDragSourceOptions)) {
        return;
      }

      currentDragSourceNode = node;
      currentDragSourceOptions = options;

      reconnectDragSource();
    },

    dragPreview: function connectDragPreview(node, options) {
      if (node === currentDragPreviewNode && (0, _areOptionsEqual2.default)(options, currentDragPreviewOptions)) {
        return;
      }

      currentDragPreviewNode = node;
      currentDragPreviewOptions = options;

      reconnectDragPreview();
    }
  });

  return {
    receiveHandlerId: receiveHandlerId,
    hooks: hooks
  };
}
},{"./areOptionsEqual":745,"./wrapConnectorHooks":761}],747:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createSourceFactory;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ALLOWED_SPEC_METHODS = ['canDrag', 'beginDrag', 'isDragging', 'endDrag'];
var REQUIRED_SPEC_METHODS = ['beginDrag'];

function createSourceFactory(spec) {
  Object.keys(spec).forEach(function (key) {
    (0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', ALLOWED_SPEC_METHODS.join(', '), key);
    (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
  });
  REQUIRED_SPEC_METHODS.forEach(function (key) {
    (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
  });

  var Source = function () {
    function Source(monitor) {
      _classCallCheck(this, Source);

      this.monitor = monitor;
      this.props = null;
      this.component = null;
    }

    _createClass(Source, [{
      key: 'receiveProps',
      value: function receiveProps(props) {
        this.props = props;
      }
    }, {
      key: 'receiveComponent',
      value: function receiveComponent(component) {
        this.component = component;
      }
    }, {
      key: 'canDrag',
      value: function canDrag() {
        if (!spec.canDrag) {
          return true;
        }

        return spec.canDrag(this.props, this.monitor);
      }
    }, {
      key: 'isDragging',
      value: function isDragging(globalMonitor, sourceId) {
        if (!spec.isDragging) {
          return sourceId === globalMonitor.getSourceId();
        }

        return spec.isDragging(this.props, this.monitor);
      }
    }, {
      key: 'beginDrag',
      value: function beginDrag() {
        var item = spec.beginDrag(this.props, this.monitor, this.component);
        if (process.env.NODE_ENV !== 'production') {
          (0, _invariant2.default)((0, _isPlainObject2.default)(item), 'beginDrag() must return a plain object that represents the dragged item. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', item);
        }
        return item;
      }
    }, {
      key: 'endDrag',
      value: function endDrag() {
        if (!spec.endDrag) {
          return;
        }

        spec.endDrag(this.props, this.monitor, this.component);
      }
    }]);

    return Source;
  }();

  return function createSource(monitor) {
    return new Source(monitor);
  };
}
}).call(this,require('_process'))
},{"_process":395,"invariant":327,"lodash/isPlainObject":772}],748:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createSourceMonitor;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isCallingCanDrag = false;
var isCallingIsDragging = false;

var SourceMonitor = function () {
  function SourceMonitor(manager) {
    _classCallCheck(this, SourceMonitor);

    this.internalMonitor = manager.getMonitor();
  }

  _createClass(SourceMonitor, [{
    key: 'receiveHandlerId',
    value: function receiveHandlerId(sourceId) {
      this.sourceId = sourceId;
    }
  }, {
    key: 'canDrag',
    value: function canDrag() {
      (0, _invariant2.default)(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

      try {
        isCallingCanDrag = true;
        return this.internalMonitor.canDragSource(this.sourceId);
      } finally {
        isCallingCanDrag = false;
      }
    }
  }, {
    key: 'isDragging',
    value: function isDragging() {
      (0, _invariant2.default)(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');

      try {
        isCallingIsDragging = true;
        return this.internalMonitor.isDraggingSource(this.sourceId);
      } finally {
        isCallingIsDragging = false;
      }
    }
  }, {
    key: 'getItemType',
    value: function getItemType() {
      return this.internalMonitor.getItemType();
    }
  }, {
    key: 'getItem',
    value: function getItem() {
      return this.internalMonitor.getItem();
    }
  }, {
    key: 'getDropResult',
    value: function getDropResult() {
      return this.internalMonitor.getDropResult();
    }
  }, {
    key: 'didDrop',
    value: function didDrop() {
      return this.internalMonitor.didDrop();
    }
  }, {
    key: 'getInitialClientOffset',
    value: function getInitialClientOffset() {
      return this.internalMonitor.getInitialClientOffset();
    }
  }, {
    key: 'getInitialSourceClientOffset',
    value: function getInitialSourceClientOffset() {
      return this.internalMonitor.getInitialSourceClientOffset();
    }
  }, {
    key: 'getSourceClientOffset',
    value: function getSourceClientOffset() {
      return this.internalMonitor.getSourceClientOffset();
    }
  }, {
    key: 'getClientOffset',
    value: function getClientOffset() {
      return this.internalMonitor.getClientOffset();
    }
  }, {
    key: 'getDifferenceFromInitialOffset',
    value: function getDifferenceFromInitialOffset() {
      return this.internalMonitor.getDifferenceFromInitialOffset();
    }
  }]);

  return SourceMonitor;
}();

function createSourceMonitor(manager) {
  return new SourceMonitor(manager);
}
},{"invariant":327}],749:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createTargetConnector;

var _wrapConnectorHooks = require('./wrapConnectorHooks');

var _wrapConnectorHooks2 = _interopRequireDefault(_wrapConnectorHooks);

var _areOptionsEqual = require('./areOptionsEqual');

var _areOptionsEqual2 = _interopRequireDefault(_areOptionsEqual);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createTargetConnector(backend) {
  var currentHandlerId = void 0;

  var currentDropTargetNode = void 0;
  var currentDropTargetOptions = void 0;
  var disconnectCurrentDropTarget = void 0;

  function reconnectDropTarget() {
    if (disconnectCurrentDropTarget) {
      disconnectCurrentDropTarget();
      disconnectCurrentDropTarget = null;
    }

    if (currentHandlerId && currentDropTargetNode) {
      disconnectCurrentDropTarget = backend.connectDropTarget(currentHandlerId, currentDropTargetNode, currentDropTargetOptions);
    }
  }

  function receiveHandlerId(handlerId) {
    if (handlerId === currentHandlerId) {
      return;
    }

    currentHandlerId = handlerId;
    reconnectDropTarget();
  }

  var hooks = (0, _wrapConnectorHooks2.default)({
    dropTarget: function connectDropTarget(node, options) {
      if (node === currentDropTargetNode && (0, _areOptionsEqual2.default)(options, currentDropTargetOptions)) {
        return;
      }

      currentDropTargetNode = node;
      currentDropTargetOptions = options;

      reconnectDropTarget();
    }
  });

  return {
    receiveHandlerId: receiveHandlerId,
    hooks: hooks
  };
}
},{"./areOptionsEqual":745,"./wrapConnectorHooks":761}],750:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createTargetFactory;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ALLOWED_SPEC_METHODS = ['canDrop', 'hover', 'drop'];

function createTargetFactory(spec) {
  Object.keys(spec).forEach(function (key) {
    (0, _invariant2.default)(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drop target specification to only have ' + 'some of the following keys: %s. ' + 'Instead received a specification with an unexpected "%s" key. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', ALLOWED_SPEC_METHODS.join(', '), key);
    (0, _invariant2.default)(typeof spec[key] === 'function', 'Expected %s in the drop target specification to be a function. ' + 'Instead received a specification with %s: %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', key, key, spec[key]);
  });

  var Target = function () {
    function Target(monitor) {
      _classCallCheck(this, Target);

      this.monitor = monitor;
      this.props = null;
      this.component = null;
    }

    _createClass(Target, [{
      key: 'receiveProps',
      value: function receiveProps(props) {
        this.props = props;
      }
    }, {
      key: 'receiveMonitor',
      value: function receiveMonitor(monitor) {
        this.monitor = monitor;
      }
    }, {
      key: 'receiveComponent',
      value: function receiveComponent(component) {
        this.component = component;
      }
    }, {
      key: 'canDrop',
      value: function canDrop() {
        if (!spec.canDrop) {
          return true;
        }

        return spec.canDrop(this.props, this.monitor);
      }
    }, {
      key: 'hover',
      value: function hover() {
        if (!spec.hover) {
          return;
        }

        spec.hover(this.props, this.monitor, this.component);
      }
    }, {
      key: 'drop',
      value: function drop() {
        if (!spec.drop) {
          return undefined;
        }

        var dropResult = spec.drop(this.props, this.monitor, this.component);
        if (process.env.NODE_ENV !== 'production') {
          (0, _invariant2.default)(typeof dropResult === 'undefined' || (0, _isPlainObject2.default)(dropResult), 'drop() must either return undefined, or an object that represents the drop result. ' + 'Instead received %s. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', dropResult);
        }
        return dropResult;
      }
    }]);

    return Target;
  }();

  return function createTarget(monitor) {
    return new Target(monitor);
  };
}
}).call(this,require('_process'))
},{"_process":395,"invariant":327,"lodash/isPlainObject":772}],751:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = createTargetMonitor;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var isCallingCanDrop = false;

var TargetMonitor = function () {
  function TargetMonitor(manager) {
    _classCallCheck(this, TargetMonitor);

    this.internalMonitor = manager.getMonitor();
  }

  _createClass(TargetMonitor, [{
    key: 'receiveHandlerId',
    value: function receiveHandlerId(targetId) {
      this.targetId = targetId;
    }
  }, {
    key: 'canDrop',
    value: function canDrop() {
      (0, _invariant2.default)(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html');

      try {
        isCallingCanDrop = true;
        return this.internalMonitor.canDropOnTarget(this.targetId);
      } finally {
        isCallingCanDrop = false;
      }
    }
  }, {
    key: 'isOver',
    value: function isOver(options) {
      return this.internalMonitor.isOverTarget(this.targetId, options);
    }
  }, {
    key: 'getItemType',
    value: function getItemType() {
      return this.internalMonitor.getItemType();
    }
  }, {
    key: 'getItem',
    value: function getItem() {
      return this.internalMonitor.getItem();
    }
  }, {
    key: 'getDropResult',
    value: function getDropResult() {
      return this.internalMonitor.getDropResult();
    }
  }, {
    key: 'didDrop',
    value: function didDrop() {
      return this.internalMonitor.didDrop();
    }
  }, {
    key: 'getInitialClientOffset',
    value: function getInitialClientOffset() {
      return this.internalMonitor.getInitialClientOffset();
    }
  }, {
    key: 'getInitialSourceClientOffset',
    value: function getInitialSourceClientOffset() {
      return this.internalMonitor.getInitialSourceClientOffset();
    }
  }, {
    key: 'getSourceClientOffset',
    value: function getSourceClientOffset() {
      return this.internalMonitor.getSourceClientOffset();
    }
  }, {
    key: 'getClientOffset',
    value: function getClientOffset() {
      return this.internalMonitor.getClientOffset();
    }
  }, {
    key: 'getDifferenceFromInitialOffset',
    value: function getDifferenceFromInitialOffset() {
      return this.internalMonitor.getDifferenceFromInitialOffset();
    }
  }]);

  return TargetMonitor;
}();

function createTargetMonitor(manager) {
  return new TargetMonitor(manager);
}
},{"invariant":327}],752:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.default = decorateHandler;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _disposables = require('disposables');

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _hoistNonReactStatics = require('hoist-non-react-statics');

var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);

var _shallowEqual = require('./utils/shallowEqual');

var _shallowEqual2 = _interopRequireDefault(_shallowEqual);

var _shallowEqualScalar = require('./utils/shallowEqualScalar');

var _shallowEqualScalar2 = _interopRequireDefault(_shallowEqualScalar);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function decorateHandler(_ref) {
  var _class, _temp;

  var DecoratedComponent = _ref.DecoratedComponent,
      createHandler = _ref.createHandler,
      createMonitor = _ref.createMonitor,
      createConnector = _ref.createConnector,
      registerHandler = _ref.registerHandler,
      containerDisplayName = _ref.containerDisplayName,
      getType = _ref.getType,
      collect = _ref.collect,
      options = _ref.options;
  var _options$arePropsEqua = options.arePropsEqual,
      arePropsEqual = _options$arePropsEqua === undefined ? _shallowEqualScalar2.default : _options$arePropsEqua;

  var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';

  var DragDropContainer = (_temp = _class = function (_Component) {
    _inherits(DragDropContainer, _Component);

    _createClass(DragDropContainer, [{
      key: 'getHandlerId',
      value: function getHandlerId() {
        return this.handlerId;
      }
    }, {
      key: 'getDecoratedComponentInstance',
      value: function getDecoratedComponentInstance() {
        return this.decoratedComponentInstance;
      }
    }, {
      key: 'shouldComponentUpdate',
      value: function shouldComponentUpdate(nextProps, nextState) {
        return !arePropsEqual(nextProps, this.props) || !(0, _shallowEqual2.default)(nextState, this.state);
      }
    }]);

    function DragDropContainer(props, context) {
      _classCallCheck(this, DragDropContainer);

      var _this = _possibleConstructorReturn(this, (DragDropContainer.__proto__ || Object.getPrototypeOf(DragDropContainer)).call(this, props, context));

      _this.handleChange = _this.handleChange.bind(_this);
      _this.handleChildRef = _this.handleChildRef.bind(_this);

      (0, _invariant2.default)(_typeof(_this.context.dragDropManager) === 'object', 'Could not find the drag and drop manager in the context of %s. ' + 'Make sure to wrap the top-level component of your app with DragDropContext. ' + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);

      _this.manager = _this.context.dragDropManager;
      _this.handlerMonitor = createMonitor(_this.manager);
      _this.handlerConnector = createConnector(_this.manager.getBackend());
      _this.handler = createHandler(_this.handlerMonitor);

      _this.disposable = new _disposables.SerialDisposable();
      _this.receiveProps(props);
      _this.state = _this.getCurrentState();
      _this.dispose();
      return _this;
    }

    _createClass(DragDropContainer, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.isCurrentlyMounted = true;
        this.disposable = new _disposables.SerialDisposable();
        this.currentType = null;
        this.receiveProps(this.props);
        this.handleChange();
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        if (!arePropsEqual(nextProps, this.props)) {
          this.receiveProps(nextProps);
          this.handleChange();
        }
      }
    }, {
      key: 'componentWillUnmount',
      value: function componentWillUnmount() {
        this.dispose();
        this.isCurrentlyMounted = false;
      }
    }, {
      key: 'receiveProps',
      value: function receiveProps(props) {
        this.handler.receiveProps(props);
        this.receiveType(getType(props));
      }
    }, {
      key: 'receiveType',
      value: function receiveType(type) {
        if (type === this.currentType) {
          return;
        }

        this.currentType = type;

        var _registerHandler = registerHandler(type, this.handler, this.manager),
            handlerId = _registerHandler.handlerId,
            unregister = _registerHandler.unregister;

        this.handlerId = handlerId;
        this.handlerMonitor.receiveHandlerId(handlerId);
        this.handlerConnector.receiveHandlerId(handlerId);

        var globalMonitor = this.manager.getMonitor();
        var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });

        this.disposable.setDisposable(new _disposables.CompositeDisposable(new _disposables.Disposable(unsubscribe), new _disposables.Disposable(unregister)));
      }
    }, {
      key: 'handleChange',
      value: function handleChange() {
        if (!this.isCurrentlyMounted) {
          return;
        }

        var nextState = this.getCurrentState();
        if (!(0, _shallowEqual2.default)(nextState, this.state)) {
          this.setState(nextState);
        }
      }
    }, {
      key: 'dispose',
      value: function dispose() {
        this.disposable.dispose();
        this.handlerConnector.receiveHandlerId(null);
      }
    }, {
      key: 'handleChildRef',
      value: function handleChildRef(component) {
        this.decoratedComponentInstance = component;
        this.handler.receiveComponent(component);
      }
    }, {
      key: 'getCurrentState',
      value: function getCurrentState() {
        var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor);

        if (process.env.NODE_ENV !== 'production') {
          (0, _invariant2.default)((0, _isPlainObject2.default)(nextState), 'Expected `collect` specified as the second argument to ' + '%s for %s to return a plain object of props to inject. ' + 'Instead, received %s.', containerDisplayName, displayName, nextState);
        }

        return nextState;
      }
    }, {
      key: 'render',
      value: function render() {
        return _react2.default.createElement(DecoratedComponent, _extends({}, this.props, this.state, {
          ref: this.handleChildRef
        }));
      }
    }]);

    return DragDropContainer;
  }(_react.Component), _class.DecoratedComponent = DecoratedComponent, _class.displayName = containerDisplayName + '(' + displayName + ')', _class.contextTypes = {
    dragDropManager: _react.PropTypes.object.isRequired
  }, _temp);


  return (0, _hoistNonReactStatics2.default)(DragDropContainer, DecoratedComponent);
}
}).call(this,require('_process'))
},{"./utils/shallowEqual":759,"./utils/shallowEqualScalar":760,"_process":395,"disposables":143,"hoist-non-react-statics":326,"invariant":327,"lodash/isPlainObject":772,"react":"react"}],753:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _DragDropContext = require('./DragDropContext');

Object.defineProperty(exports, 'DragDropContext', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragDropContext).default;
  }
});

var _DragDropContextProvider = require('./DragDropContextProvider');

Object.defineProperty(exports, 'DragDropContextProvider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragDropContextProvider).default;
  }
});

var _DragLayer = require('./DragLayer');

Object.defineProperty(exports, 'DragLayer', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragLayer).default;
  }
});

var _DragSource = require('./DragSource');

Object.defineProperty(exports, 'DragSource', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DragSource).default;
  }
});

var _DropTarget = require('./DropTarget');

Object.defineProperty(exports, 'DropTarget', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_DropTarget).default;
  }
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./DragDropContext":740,"./DragDropContextProvider":741,"./DragLayer":742,"./DragSource":743,"./DropTarget":744}],754:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = registerSource;
function registerSource(type, source, manager) {
  var registry = manager.getRegistry();
  var sourceId = registry.addSource(type, source);

  function unregisterSource() {
    registry.removeSource(sourceId);
  }

  return {
    handlerId: sourceId,
    unregister: unregisterSource
  };
}
},{}],755:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = registerTarget;
function registerTarget(type, target, manager) {
  var registry = manager.getRegistry();
  var targetId = registry.addTarget(type, target);

  function unregisterTarget() {
    registry.removeTarget(targetId);
  }

  return {
    handlerId: targetId,
    unregister: unregisterTarget
  };
}
},{}],756:[function(require,module,exports){
(function (process){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = checkDecoratorArguments;
function checkDecoratorArguments(functionName, signature) {
  if (process.env.NODE_ENV !== 'production') {
    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i += 1) {
      var arg = arguments.length <= i + 2 ? undefined : arguments[i + 2];
      if (arg && arg.prototype && arg.prototype.render) {
        console.error( // eslint-disable-line no-console
        'You seem to be applying the arguments in the wrong order. ' + ('It should be ' + functionName + '(' + signature + ')(Component), not the other way around. ') + 'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#you-seem-to-be-applying-the-arguments-in-the-wrong-order');
        return;
      }
    }
  }
}
}).call(this,require('_process'))
},{"_process":395}],757:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cloneWithRef;

var _invariant = require('invariant');

var _invariant2 = _interopRequireDefault(_invariant);

var _react = require('react');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function cloneWithRef(element, newRef) {
  var previousRef = element.ref;
  (0, _invariant2.default)(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' + 'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' + 'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute');

  if (!previousRef) {
    // When there is no ref on the element, use the new ref directly
    return (0, _react.cloneElement)(element, {
      ref: newRef
    });
  }

  return (0, _react.cloneElement)(element, {
    ref: function ref(node) {
      newRef(node);

      if (previousRef) {
        previousRef(node);
      }
    }
  });
}
},{"invariant":327,"react":"react"}],758:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
       value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = isValidType;

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isValidType(type, allowArray) {
       return typeof type === 'string' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || allowArray && (0, _isArray2.default)(type) && type.every(function (t) {
              return isValidType(t, false);
       });
}
},{"lodash/isArray":770}],759:[function(require,module,exports){
arguments[4][641][0].apply(exports,arguments)
},{"dup":641}],760:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = shallowEqualScalar;
function shallowEqualScalar(objA, objB) {
  if (objA === objB) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  var hasOwn = Object.prototype.hasOwnProperty;
  for (var i = 0; i < keysA.length; i += 1) {
    if (!hasOwn.call(objB, keysA[i])) {
      return false;
    }

    var valA = objA[keysA[i]];
    var valB = objB[keysA[i]];

    if (valA !== valB || (typeof valA === 'undefined' ? 'undefined' : _typeof(valA)) === 'object' || (typeof valB === 'undefined' ? 'undefined' : _typeof(valB)) === 'object') {
      return false;
    }
  }

  return true;
}
},{}],761:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = wrapConnectorHooks;

var _react = require('react');

var _cloneWithRef = require('./utils/cloneWithRef');

var _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function throwIfCompositeComponentElement(element) {
  // Custom components can no longer be wrapped directly in React DnD 2.0
  // so that we don't need to depend on findDOMNode() from react-dom.
  if (typeof element.type === 'string') {
    return;
  }

  var displayName = element.type.displayName || element.type.name || 'the component';

  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');
}

function wrapHookToRecognizeElement(hook) {
  return function () {
    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    // When passed a node, call the hook straight away.
    if (!(0, _react.isValidElement)(elementOrNode)) {
      var node = elementOrNode;
      hook(node, options);
      return undefined;
    }

    // If passed a ReactElement, clone it and attach this function as a ref.
    // This helps us achieve a neat API where user doesn't even know that refs
    // are being used under the hood.
    var element = elementOrNode;
    throwIfCompositeComponentElement(element);

    // When no options are passed, use the hook directly
    var ref = options ? function (node) {
      return hook(node, options);
    } : hook;

    return (0, _cloneWithRef2.default)(element, ref);
  };
}

function wrapConnectorHooks(hooks) {
  var wrappedHooks = {};

  Object.keys(hooks).forEach(function (key) {
    var hook = hooks[key];
    var wrappedHook = wrapHookToRecognizeElement(hook);
    wrappedHooks[key] = function () {
      return wrappedHook;
    };
  });

  return wrappedHooks;
}
},{"./utils/cloneWithRef":757,"react":"react"}],762:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./_root":769,"dup":168}],763:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./_Symbol":762,"./_getRawTag":766,"./_objectToString":767,"dup":179}],764:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],765:[function(require,module,exports){
var overArg = require('./_overArg');

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;

},{"./_overArg":768}],766:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./_Symbol":762,"dup":198}],767:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],768:[function(require,module,exports){
arguments[4][591][0].apply(exports,arguments)
},{"dup":591}],769:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./_freeGlobal":764,"dup":221}],770:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"dup":234}],771:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],772:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

},{"./_baseGetTag":763,"./_getPrototype":765,"./isObjectLike":771}],773:[function(require,module,exports){
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["Dropzone"] = factory(require("react"));
	else
		root["Dropzone"] = factory(root["react"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _react = __webpack_require__(1);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _attrAccept = __webpack_require__(2);
	
	var _attrAccept2 = _interopRequireDefault(_attrAccept);
	
	var _getDataTransferItems = __webpack_require__(3);
	
	var _getDataTransferItems2 = _interopRequireDefault(_getDataTransferItems);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint prefer-template: 0 */
	
	
	var supportMultiple = typeof document !== 'undefined' && document && document.createElement ? 'multiple' in document.createElement('input') : true;
	
	var Dropzone = function (_React$Component) {
	  _inherits(Dropzone, _React$Component);
	
	  _createClass(Dropzone, null, [{
	    key: 'onDocumentDragOver',
	    value: function onDocumentDragOver(e) {
	      // allow the entire document to be a drag target
	      e.preventDefault();
	    }
	  }]);
	
	  function Dropzone(props, context) {
	    _classCallCheck(this, Dropzone);
	
	    var _this = _possibleConstructorReturn(this, (Dropzone.__proto__ || Object.getPrototypeOf(Dropzone)).call(this, props, context));
	
	    _this.renderChildren = function (children) {
	      if (typeof children === 'function') {
	        return children(_this.state);
	      }
	      return children;
	    };
	
	    _this.onClick = _this.onClick.bind(_this);
	    _this.onDocumentDrop = _this.onDocumentDrop.bind(_this);
	    _this.onDragStart = _this.onDragStart.bind(_this);
	    _this.onDragEnter = _this.onDragEnter.bind(_this);
	    _this.onDragLeave = _this.onDragLeave.bind(_this);
	    _this.onDragOver = _this.onDragOver.bind(_this);
	    _this.onDrop = _this.onDrop.bind(_this);
	    _this.onFileDialogCancel = _this.onFileDialogCancel.bind(_this);
	    _this.fileAccepted = _this.fileAccepted.bind(_this);
	    _this.setRef = _this.setRef.bind(_this);
	    _this.isFileDialogActive = false;
	    _this.state = {
	      isDragActive: false,
	      acceptedFiles: [],
	      rejectedFiles: []
	    };
	    return _this;
	  }
	
	  _createClass(Dropzone, [{
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var preventDropOnDocument = this.props.preventDropOnDocument;
	
	      this.dragTargets = [];
	
	      if (preventDropOnDocument) {
	        document.addEventListener('dragover', Dropzone.onDocumentDragOver, false);
	        document.addEventListener('drop', this.onDocumentDrop, false);
	      }
	      // Tried implementing addEventListener, but didn't work out
	      document.body.onfocus = this.onFileDialogCancel;
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      var preventDropOnDocument = this.props.preventDropOnDocument;
	
	      if (preventDropOnDocument) {
	        document.removeEventListener('dragover', Dropzone.onDocumentDragOver);
	        document.removeEventListener('drop', this.onDocumentDrop);
	      }
	      // Can be replaced with removeEventListener, if addEventListener works
	      document.body.onfocus = null;
	    }
	  }, {
	    key: 'onDocumentDrop',
	    value: function onDocumentDrop(e) {
	      if (this.node.contains(e.target)) {
	        // if we intercepted an event for our instance, let it propagate down to the instance's onDrop handler
	        return;
	      }
	      e.preventDefault();
	      this.dragTargets = [];
	    }
	  }, {
	    key: 'onDragStart',
	    value: function onDragStart(e) {
	      if (this.props.onDragStart) {
	        this.props.onDragStart.call(this, e);
	      }
	    }
	  }, {
	    key: 'onDragEnter',
	    value: function onDragEnter(e) {
	      e.preventDefault();
	
	      // Count the dropzone and any children that are entered.
	      if (this.dragTargets.indexOf(e.target) === -1) {
	        this.dragTargets.push(e.target);
	      }
	
	      var allFilesAccepted = this.allFilesAccepted((0, _getDataTransferItems2.default)(e, this.props.multiple));
	
	      this.setState({
	        isDragActive: allFilesAccepted,
	        isDragReject: !allFilesAccepted
	      });
	
	      if (this.props.onDragEnter) {
	        this.props.onDragEnter.call(this, e);
	      }
	    }
	  }, {
	    key: 'onDragOver',
	    value: function onDragOver(e) {
	      // eslint-disable-line class-methods-use-this
	      e.preventDefault();
	      e.stopPropagation();
	      try {
	        e.dataTransfer.dropEffect = 'copy'; // eslint-disable-line no-param-reassign
	      } catch (err) {
	        // continue regardless of error
	      }
	
	      if (this.props.onDragOver) {
	        this.props.onDragOver.call(this, e);
	      }
	      return false;
	    }
	  }, {
	    key: 'onDragLeave',
	    value: function onDragLeave(e) {
	      var _this2 = this;
	
	      e.preventDefault();
	
	      // Only deactivate once the dropzone and all children have been left.
	      this.dragTargets = this.dragTargets.filter(function (el) {
	        return el !== e.target && _this2.node.contains(el);
	      });
	      if (this.dragTargets.length > 0) {
	        return;
	      }
	
	      this.setState({
	        isDragActive: false,
	        isDragReject: false
	      });
	
	      if (this.props.onDragLeave) {
	        this.props.onDragLeave.call(this, e);
	      }
	    }
	  }, {
	    key: 'onDrop',
	    value: function onDrop(e) {
	      var _this3 = this;
	
	      var _props = this.props,
	          onDrop = _props.onDrop,
	          onDropAccepted = _props.onDropAccepted,
	          onDropRejected = _props.onDropRejected,
	          multiple = _props.multiple,
	          disablePreview = _props.disablePreview;
	
	      var fileList = (0, _getDataTransferItems2.default)(e, multiple);
	      var acceptedFiles = [];
	      var rejectedFiles = [];
	
	      // Stop default browser behavior
	      e.preventDefault();
	
	      // Reset the counter along with the drag on a drop.
	      this.dragTargets = [];
	      this.isFileDialogActive = false;
	
	      fileList.forEach(function (file) {
	        if (!disablePreview) {
	          file.preview = window.URL.createObjectURL(file); // eslint-disable-line no-param-reassign
	        }
	
	        if (_this3.fileAccepted(file) && _this3.fileMatchSize(file)) {
	          acceptedFiles.push(file);
	        } else {
	          rejectedFiles.push(file);
	        }
	      });
	
	      if (onDrop) {
	        onDrop.call(this, acceptedFiles, rejectedFiles, e);
	      }
	
	      if (rejectedFiles.length > 0 && onDropRejected) {
	        onDropRejected.call(this, rejectedFiles, e);
	      }
	
	      if (acceptedFiles.length > 0 && onDropAccepted) {
	        onDropAccepted.call(this, acceptedFiles, e);
	      }
	
	      // Reset drag state
	      this.setState({
	        isDragActive: false,
	        isDragReject: false,
	        acceptedFiles: acceptedFiles,
	        rejectedFiles: rejectedFiles
	      });
	    }
	  }, {
	    key: 'onClick',
	    value: function onClick(e) {
	      var _props2 = this.props,
	          onClick = _props2.onClick,
	          disableClick = _props2.disableClick;
	
	      if (!disableClick) {
	        e.stopPropagation();
	        this.open();
	        if (onClick) {
	          onClick.call(this, e);
	        }
	      }
	    }
	  }, {
	    key: 'onFileDialogCancel',
	    value: function onFileDialogCancel() {
	      // timeout will not recognize context of this method
	      var onFileDialogCancel = this.props.onFileDialogCancel;
	      var fileInputEl = this.fileInputEl;
	      var isFileDialogActive = this.isFileDialogActive;
	      // execute the timeout only if the onFileDialogCancel is defined and FileDialog
	      // is opened in the browser
	
	      if (onFileDialogCancel && isFileDialogActive) {
	        setTimeout(function () {
	          // Returns an object as FileList
	          var FileList = fileInputEl.files;
	          if (!FileList.length) {
	            isFileDialogActive = false;
	            onFileDialogCancel();
	          }
	        }, 300);
	      }
	    }
	  }, {
	    key: 'setRef',
	    value: function setRef(ref) {
	      this.node = ref;
	    }
	  }, {
	    key: 'fileAccepted',
	    value: function fileAccepted(file) {
	      // Firefox versions prior to 53 return a bogus MIME type for every file drag, so dragovers with
	      // that MIME type will always be accepted
	      return file.type === 'application/x-moz-file' || (0, _attrAccept2.default)(file, this.props.accept);
	    }
	  }, {
	    key: 'fileMatchSize',
	    value: function fileMatchSize(file) {
	      return file.size <= this.props.maxSize && file.size >= this.props.minSize;
	    }
	  }, {
	    key: 'allFilesAccepted',
	    value: function allFilesAccepted(files) {
	      return files.every(this.fileAccepted);
	    }
	  }, {
	    key: 'open',
	    value: function open() {
	      this.isFileDialogActive = true;
	      this.fileInputEl.value = null;
	      this.fileInputEl.click();
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this4 = this;
	
	      var _props3 = this.props,
	          accept = _props3.accept,
	          activeClassName = _props3.activeClassName,
	          inputProps = _props3.inputProps,
	          multiple = _props3.multiple,
	          name = _props3.name,
	          rejectClassName = _props3.rejectClassName,
	          children = _props3.children,
	          rest = _objectWithoutProperties(_props3, ['accept', 'activeClassName', 'inputProps', 'multiple', 'name', 'rejectClassName', 'children']);
	
	      var activeStyle = rest.activeStyle,
	          className = rest.className,
	          rejectStyle = rest.rejectStyle,
	          style = rest.style,
	          props = _objectWithoutProperties(rest, ['activeStyle', 'className', 'rejectStyle', 'style']);
	
	      var _state = this.state,
	          isDragActive = _state.isDragActive,
	          isDragReject = _state.isDragReject;
	
	
	      className = className || '';
	
	      if (isDragActive && activeClassName) {
	        className += ' ' + activeClassName;
	      }
	      if (isDragReject && rejectClassName) {
	        className += ' ' + rejectClassName;
	      }
	
	      if (!className && !style && !activeStyle && !rejectStyle) {
	        style = {
	          width: 200,
	          height: 200,
	          borderWidth: 2,
	          borderColor: '#666',
	          borderStyle: 'dashed',
	          borderRadius: 5
	        };
	        activeStyle = {
	          borderStyle: 'solid',
	          backgroundColor: '#eee'
	        };
	        rejectStyle = {
	          borderStyle: 'solid',
	          backgroundColor: '#ffdddd'
	        };
	      }
	
	      var appliedStyle = void 0;
	      if (activeStyle && isDragActive) {
	        appliedStyle = _extends({}, style, activeStyle);
	      } else if (rejectStyle && isDragReject) {
	        appliedStyle = _extends({}, style, rejectStyle);
	      } else {
	        appliedStyle = _extends({}, style);
	      }
	
	      var inputAttributes = {
	        accept: accept,
	        type: 'file',
	        style: { display: 'none' },
	        multiple: supportMultiple && multiple,
	        ref: function ref(el) {
	          return _this4.fileInputEl = el;
	        }, // eslint-disable-line
	        onChange: this.onDrop
	      };
	
	      if (name && name.length) {
	        inputAttributes.name = name;
	      }
	
	      // Remove custom properties before passing them to the wrapper div element
	      var customProps = ['acceptedFiles', 'preventDropOnDocument', 'disablePreview', 'disableClick', 'onDropAccepted', 'onDropRejected', 'onFileDialogCancel', 'maxSize', 'minSize'];
	      var divProps = _extends({}, props);
	      customProps.forEach(function (prop) {
	        return delete divProps[prop];
	      });
	
	      return _react2.default.createElement(
	        'div',
	        _extends({
	          className: className,
	          style: appliedStyle
	        }, divProps /* expand user provided props first so event handlers are never overridden */, {
	          onClick: this.onClick,
	          onDragStart: this.onDragStart,
	          onDragEnter: this.onDragEnter,
	          onDragOver: this.onDragOver,
	          onDragLeave: this.onDragLeave,
	          onDrop: this.onDrop,
	          ref: this.setRef
	        }),
	        this.renderChildren(children),
	        _react2.default.createElement('input', _extends({}, inputProps /* expand user provided inputProps first so inputAttributes override them */, inputAttributes))
	      );
	    }
	  }]);
	
	  return Dropzone;
	}(_react2.default.Component);
	
	Dropzone.defaultProps = {
	  preventDropOnDocument: true,
	  disablePreview: false,
	  disableClick: false,
	  multiple: true,
	  maxSize: Infinity,
	  minSize: 0
	};
	
	Dropzone.propTypes = {
	  onClick: _react2.default.PropTypes.func,
	  onDrop: _react2.default.PropTypes.func,
	  onDropAccepted: _react2.default.PropTypes.func,
	  onDropRejected: _react2.default.PropTypes.func,
	  onDragStart: _react2.default.PropTypes.func,
	  onDragEnter: _react2.default.PropTypes.func,
	  onDragOver: _react2.default.PropTypes.func,
	  onDragLeave: _react2.default.PropTypes.func,
	
	  children: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.node, _react2.default.PropTypes.func]), // Contents of the dropzone
	  style: _react2.default.PropTypes.object, // CSS styles to apply
	  activeStyle: _react2.default.PropTypes.object, // CSS styles to apply when drop will be accepted
	  rejectStyle: _react2.default.PropTypes.object, // CSS styles to apply when drop will be rejected
	  className: _react2.default.PropTypes.string, // Optional className
	  activeClassName: _react2.default.PropTypes.string, // className for accepted state
	  rejectClassName: _react2.default.PropTypes.string, // className for rejected state
	
	  preventDropOnDocument: _react2.default.PropTypes.bool, // If false, allow dropped items to take over the current browser window
	  disablePreview: _react2.default.PropTypes.bool, // Enable/disable preview generation
	  disableClick: _react2.default.PropTypes.bool, // Disallow clicking on the dropzone container to open file dialog
	  onFileDialogCancel: _react2.default.PropTypes.func, // Provide a callback on clicking the cancel button of the file dialog
	
	  inputProps: _react2.default.PropTypes.object, // Pass additional attributes to the <input type="file"/> tag
	  multiple: _react2.default.PropTypes.bool, // Allow dropping multiple files
	  accept: _react2.default.PropTypes.string, // Allow specific types of files. See https://github.com/okonet/attr-accept for more information
	  name: _react2.default.PropTypes.string, // name attribute for the input tag
	  maxSize: _react2.default.PropTypes.number,
	  minSize: _react2.default.PropTypes.number
	};
	
	exports.default = Dropzone;
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports=function(t){function n(e){if(r[e])return r[e].exports;var o=r[e]={exports:{},id:e,loaded:!1};return t[e].call(o.exports,o,o.exports,n),o.loaded=!0,o.exports}var r={};return n.m=t,n.c=r,n.p="",n(0)}([function(t,n,r){"use strict";n.__esModule=!0,r(8),r(9),n["default"]=function(t,n){if(t&&n){var r=function(){var r=Array.isArray(n)?n:n.split(","),e=t.name||"",o=t.type||"",i=o.replace(/\/.*$/,"");return{v:r.some(function(t){var n=t.trim();return"."===n.charAt(0)?e.toLowerCase().endsWith(n.toLowerCase()):/\/\*$/.test(n)?i===n.replace(/\/.*$/,""):o===n})}}();if("object"==typeof r)return r.v}return!0},t.exports=n["default"]},function(t,n){var r=t.exports={version:"1.2.2"};"number"==typeof __e&&(__e=r)},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n,r){var e=r(2),o=r(1),i=r(4),u=r(19),c="prototype",f=function(t,n){return function(){return t.apply(n,arguments)}},s=function(t,n,r){var a,p,l,y,d=t&s.G,h=t&s.P,v=d?e:t&s.S?e[n]||(e[n]={}):(e[n]||{})[c],x=d?o:o[n]||(o[n]={});d&&(r=n);for(a in r)p=!(t&s.F)&&v&&a in v,l=(p?v:r)[a],y=t&s.B&&p?f(l,e):h&&"function"==typeof l?f(Function.call,l):l,v&&!p&&u(v,a,l),x[a]!=l&&i(x,a,y),h&&((x[c]||(x[c]={}))[a]=l)};e.core=o,s.F=1,s.G=2,s.S=4,s.P=8,s.B=16,s.W=32,t.exports=s},function(t,n,r){var e=r(5),o=r(18);t.exports=r(22)?function(t,n,r){return e.setDesc(t,n,o(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n){var r=Object;t.exports={create:r.create,getProto:r.getPrototypeOf,isEnum:{}.propertyIsEnumerable,getDesc:r.getOwnPropertyDescriptor,setDesc:r.defineProperty,setDescs:r.defineProperties,getKeys:r.keys,getNames:r.getOwnPropertyNames,getSymbols:r.getOwnPropertySymbols,each:[].forEach}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(20)("wks"),o=r(2).Symbol;t.exports=function(t){return e[t]||(e[t]=o&&o[t]||(o||r(6))("Symbol."+t))}},function(t,n,r){r(26),t.exports=r(1).Array.some},function(t,n,r){r(25),t.exports=r(1).String.endsWith},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(10);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,o){return t.call(n,r,e,o)}}return function(){return t.apply(n,arguments)}}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(e){try{return n[r(7)("match")]=!1,!"/./"[t](n)}catch(o){}}return!0}},function(t,n){t.exports=function(t){try{return!!t()}catch(n){return!0}}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(16),o=r(11),i=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[i])?!!n:"RegExp"==o(t))}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n,r){var e=r(2),o=r(4),i=r(6)("src"),u="toString",c=Function[u],f=(""+c).split(u);r(1).inspectSource=function(t){return c.call(t)},(t.exports=function(t,n,r,u){"function"==typeof r&&(o(r,i,t[n]?""+t[n]:f.join(String(n))),"name"in r||(r.name=n)),t===e?t[n]=r:(u||delete t[n],o(t,n,r))})(Function.prototype,u,function(){return"function"==typeof this&&this[i]||c.call(this)})},function(t,n,r){var e=r(2),o="__core-js_shared__",i=e[o]||(e[o]={});t.exports=function(t){return i[t]||(i[t]={})}},function(t,n,r){var e=r(17),o=r(13);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(o(t))}},function(t,n,r){t.exports=!r(15)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(23),o=Math.min;t.exports=function(t){return t>0?o(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(3),o=r(24),i=r(21),u="endsWith",c=""[u];e(e.P+e.F*r(14)(u),"String",{endsWith:function(t){var n=i(this,t,u),r=arguments,e=r.length>1?r[1]:void 0,f=o(n.length),s=void 0===e?f:Math.min(o(e),f),a=String(t);return c?c.call(n,a,s):n.slice(s-a.length,s)===a}})},function(t,n,r){var e=r(5),o=r(3),i=r(1).Array||Array,u={},c=function(t,n){e.each.call(t.split(","),function(t){void 0==n&&t in i?u[t]=i[t]:t in[]&&(u[t]=r(12)(Function.call,[][t],n))})};c("pop,reverse,shift,keys,values,entries",1),c("indexOf,every,some,forEach,map,filter,find,findIndex,includes",3),c("join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill"),o(o.S,"Array",u)}]);

/***/ },
/* 3 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = getDataTransferFiles;
	function getDataTransferFiles(event) {
	  var isMultipleAllowed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
	
	  var dataTransferItemsList = [];
	  if (event.dataTransfer) {
	    var dt = event.dataTransfer;
	    if (dt.files && dt.files.length) {
	      dataTransferItemsList = dt.files;
	    } else if (dt.items && dt.items.length) {
	      // During the drag even the dataTransfer.files is null
	      // but Chrome implements some drag store, which is accesible via dataTransfer.items
	      dataTransferItemsList = dt.items;
	    }
	  } else if (event.target && event.target.files) {
	    dataTransferItemsList = event.target.files;
	  }
	
	  if (dataTransferItemsList.length > 0) {
	    dataTransferItemsList = isMultipleAllowed ? dataTransferItemsList : [dataTransferItemsList[0]];
	  }
	
	  // Convert from DataTransferItemsList to the native Array
	  return Array.prototype.slice.call(dataTransferItemsList);
	}
	module.exports = exports["default"];

/***/ }
/******/ ])
});
;

},{"react":"react"}],774:[function(require,module,exports){
"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var React = require('react');
var ReactDOM = require('react-dom');
var assign = require('object-assign');

var Escape = React.createClass({
    displayName: 'Escape',

    render: function render() {
        this._nodes = this.renderLayer();
        return React.createElement('noscript', { ref: 'from' });
    },
    renderLayer: function renderLayer() {
        var _props = this.props;
        var style = _props.style;

        var props = _objectWithoutProperties(_props, ['style']);

        style = style || {};
        assign(style, styles.escapeLayer, styles[props.to]);
        return React.createElement(
            'div',
            _extends({ style: style }, props),
            this.props.children
        );
    },
    componentDidMount: function componentDidMount() {
        this.escapePoint = this.refs.from.parentNode;
        var layer = document.createElement('div');
        document.body.appendChild(layer);
        this._layer = layer;
        ReactDOM.render(this._nodes, this._layer);
    },
    componentDidUpdate: function componentDidUpdate() {
        ReactDOM.render(this._nodes, this._layer);
    },
    componentWillUnmount: function componentWillUnmount() {
        this.escapePoint = undefined;
        ReactDOM.unmountComponentAtNode(this._layer);
        this._layer.parentNode.removeChild(this._layer);
        this._layer = null;
    },
    getSize: function getSize() {
        var e = this._layer.firstChild;
        return { width: e.offsetWidth, height: e.offsetHeight };
    }
});

var styles = {
    escapeLayer: {
        position: 'absolute',
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        zIndex: 10001,
        pointerEvents: 'none',
        overflow: 'visible'
    },
    viewport: {
        position: 'fixed'
    }
};

module.exports = Escape;
},{"object-assign":373,"react":"react","react-dom":"react-dom"}],775:[function(require,module,exports){
"use strict";

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var React = require('react');
var Escape = require('react-escape');

var _require = require('pex-geom');

var Rect = _require.Rect;
var Vec2 = _require.Vec2;

var classNames = require('classnames');

// get Rect of element in viewport coordinates
function viewportRect(element) {
    var rect = element.getBoundingClientRect();
    return new Rect(rect.left, rect.top, rect.width, rect.height);
}

// represents a scheme for attaching a popup rect to an anchor rect
function AttachScheme(name, args) {
    this.name = name;
    this.fits = args.fits;
    this.calcTranslation = args.calcTranslation;
}

// given an anchor edge and a popup edge
// return the delta necessary to align the popup edge on the anchor edge
function align(aedge, pedge) {
    return aedge - pedge;
}

// given an anchor bounds and popup bounds and available space,
// return the delta required to align the popup bounds to anchor bounds according to which side has the most available space
function edgeAlignMaxSpace(amin, amax, pmin, pmax, space) {
    var rspace = space - amax;
    var lspace = amin;
    return rspace <= lspace ? amax - pmax : amin - pmin;
}

// given a delta, popup bounds, and available space
// return a new delta which keeps the popup bounds within the available space
function dclamp(delta, pmin, pmax, space) {
    var edgemax = pmax + delta;
    var edgemin = pmin + delta;
    // nudge back into viewport if any edges fall out of bounds
    if (edgemin < 0) return delta - edgemin;else if (edgemax > space) return delta + (space - edgemax);
    return delta;
}

function clamp(value, pmin, pmax) {
    return value < pmin ? pmin : value > pmax ? pmax : value;
}

function center_y(rect) {
    return (rect.min.y + rect.max.y) * 0.5;
}

function center_x(rect) {
    return (rect.min.x + rect.max.x) * 0.5;
}

function translateRect(rect, translation) {
    if (!rect || !translation) return rect;
    return new Rect(rect.x + translation.x, rect.y + translation.y, rect.width, rect.height);
}

var edgeSchemes = {
    "over": new AttachScheme('over', {
        fits: function fits(arect, psize, viewport) {
            return psize.y <= Math.min(arect.min.y, viewport.y);
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(edgeAlignMaxSpace(arect.min.x, arect.max.x, prect.min.x, prect.max.x, viewport.x), prect.min.x, prect.max.x, viewport.x), dclamp(align(arect.min.y - gap, prect.max.y), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "under": new AttachScheme('under', {
        fits: function fits(arect, psize, viewport) {
            return psize.y <= viewport.y - arect.max.y;
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(edgeAlignMaxSpace(arect.min.x, arect.max.x, prect.min.x, prect.max.x, viewport.x), prect.min.x, prect.max.x, viewport.x), dclamp(align(arect.max.y + gap, prect.min.y), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "left": new AttachScheme('left', {
        fits: function fits(arect, psize, viewport) {
            return psize.x <= Math.min(arect.min.x, viewport.x);
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(arect.min.x - gap, prect.max.x), prect.min.x, prect.max.x, viewport.x), dclamp(edgeAlignMaxSpace(arect.min.y, arect.max.y, prect.min.y, prect.max.y, viewport.y), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "right": new AttachScheme('right', {
        fits: function fits(arect, psize, viewport) {
            return psize.x <= viewport.x - arect.max.x;
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(arect.max.x + gap, prect.min.x), prect.min.x, prect.max.x, viewport.x), dclamp(edgeAlignMaxSpace(arect.min.y, arect.max.y, prect.min.y, prect.max.y, viewport.y), prect.min.y, prect.max.y, viewport.y));
        }
    })
};

var centerSchemes = {
    "over": new AttachScheme('over', {
        fits: function fits(arect, psize, viewport) {
            return psize.y <= Math.min(arect.min.y, viewport.y);
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(center_x(arect), center_x(prect)), prect.min.x, prect.max.x, viewport.x), dclamp(align(arect.min.y - gap, prect.max.y), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "under": new AttachScheme('under', {
        fits: function fits(arect, psize, viewport) {
            return psize.y <= viewport.y - arect.max.y;
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(center_x(arect), center_x(prect)), prect.min.x, prect.max.x, viewport.x), dclamp(align(arect.max.y + gap, prect.min.y), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "left": new AttachScheme('left', {
        fits: function fits(arect, psize, viewport) {
            return psize.x <= Math.min(arect.min.x, viewport.x);
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(arect.min.x - gap, prect.max.x), prect.min.x, prect.max.x, viewport.x), dclamp(align(center_y(arect), center_y(prect)), prect.min.y, prect.max.y, viewport.y));
        }
    }),
    "right": new AttachScheme('right', {
        fits: function fits(arect, psize, viewport) {
            return psize.x <= viewport.x - arect.max.x;
        },
        calcTranslation: function calcTranslation(arect, prect, gap, viewport) {
            return new Vec2(dclamp(align(arect.max.x + gap, prect.min.x), prect.min.x, prect.max.x, viewport.x), dclamp(align(center_y(arect), center_y(prect)), prect.min.y, prect.max.y, viewport.y));
        }
    })
};

var edgeFactors = {
    "over": { v: -1, h: 0, par: function par(rect) {
            return { min: rect.y, max: rect.y + rect.height };
        }, perp: function perp(rect) {
            return { min: rect.x, max: rect.x + rect.width };
        } },
    "under": { v: 1, h: 0, par: function par(rect) {
            return { min: rect.y, max: rect.y + rect.height };
        }, perp: function perp(rect) {
            return { min: rect.x, max: rect.x + rect.width };
        } },
    "left": { v: 0, h: -1, perp: function perp(rect) {
            return { min: rect.y, max: rect.y + rect.height };
        }, par: function par(rect) {
            return { min: rect.x, max: rect.x + rect.width };
        } },
    "right": { v: 0, h: 1, perp: function perp(rect) {
            return { min: rect.y, max: rect.y + rect.height };
        }, par: function par(rect) {
            return { min: rect.x, max: rect.x + rect.width };
        } },
    "unknown": { v: 0, h: 0, perp: function perp() {
            return { min: 0, max: 0 };
        }, par: function par() {
            return { min: 0, max: 0 };
        } }
};

function getSchemes(align) {
    return align == 'center' ? centerSchemes : edgeSchemes;
}

// parses the text of an "attachment" prop into an array of scheme objects
function parseEdgeAlignProps(edges, align) {
    var schemes = getSchemes(align);
    if (!edges) return [schemes.under, schemes.over, schemes.right, schemes.left];
    return edges.split(',').map(function (name) {
        return schemes[name.trim()];
    }).filter(function (s) {
        return s;
    });
}

var styles = {
    required: {
        position: 'absolute'
    },
    default: {
        pointerEvents: 'auto'
    },
    prefab_float: {
        boxShadow: '2px 2px 6px rgba(0, 0, 0, 0.5)',
        backgroundColor: 'white'
    },
    prefab_callout: {
        boxShadow: '2px 2px 6px rgba(0, 0, 0, 0.5)',
        backgroundColor: 'white',
        borderRadius: 5
    }
};

function inflate(r, d) {
    return { min: { x: r.min.x - d, y: r.min.y - d }, max: { x: r.max.x + d, y: r.max.y + d } };
}

var bridgeSize = 20;
// precalculate the breadth (size at base) and elevation (distance to peak from base)
var bridgeBreadth = bridgeSize * 2;
var bridgeElev = bridgeSize;

var bridgeProps = {
    over: function over(anchorRect, popupRect, translation) {
        return {
            height: bridgeSize,
            width: bridgeSize * 2,
            bottom: -bridgeSize,
            left: clamp(anchorRect.min.x - translation.x + anchorRect.width * 0.5 - bridgeElev, 0, popupRect.width - bridgeBreadth),
            transform: 'translate(' + bridgeBreadth * 0.5 + ',' + bridgeElev * 0.5 + '),rotate(0,0,0)'
        };
    },
    under: function under(anchorRect, popupRect, translation) {
        return {
            height: bridgeSize,
            width: bridgeSize * 2,
            top: -bridgeSize,
            left: clamp(anchorRect.min.x - translation.x + anchorRect.width * 0.5 - bridgeElev, 0, popupRect.width - bridgeBreadth),
            transform: 'translate(' + bridgeBreadth * 0.5 + ',' + bridgeElev * 0.5 + '),rotate(180,0,0)'
        };
    },
    left: function left(anchorRect, popupRect, translation) {
        return {
            height: bridgeSize * 2,
            width: bridgeSize,
            right: -bridgeSize,
            top: clamp(anchorRect.min.y - translation.y + anchorRect.height * 0.5 - bridgeElev, 0, popupRect.height - bridgeBreadth),
            transform: 'translate(' + bridgeElev * 0.5 + ',' + bridgeBreadth * 0.5 + '),rotate(-90,0,0)'
        };
    },
    right: function right(anchorRect, popupRect, translation) {
        return {
            height: bridgeSize * 2,
            width: bridgeSize,
            left: -bridgeSize,
            top: clamp(anchorRect.min.y - translation.y + anchorRect.height * 0.5 - bridgeElev, 0, popupRect.height - bridgeBreadth),
            transform: 'translate(' + bridgeElev * 0.5 + ',' + bridgeBreadth * 0.5 + '),rotate(90,0,0)'
        };
    }
};

function makeBridge(state, props) {
    // do not calculate unless we have a position for the anchor and popup
    if (!state.anchorRect) return null;
    // get the relevant values from the state
    var schemeName = state.schemeName;
    var anchorRect = state.anchorRect;
    var popupRect = state.popupRect;
    var translation = state.translation;
    // calculate bridge location

    var _bridgeProps$schemeNa = bridgeProps[schemeName](anchorRect, popupRect, translation);

    var transform = _bridgeProps$schemeNa.transform;

    var bridgeStyle = _objectWithoutProperties(_bridgeProps$schemeNa, ['transform']);

    var trianglePath = "M -20.5,-11 0,9.5 20.5,-11 Z";

    var trianglePathOutline = "M -19.5,-10 -20,-10 0,10 20,-10 19.5,-10 0,9.5 Z";
    //let trianglePathOutline = "M -20,-10 0,10 20,-10 0,9.5 Z"

    return React.createElement(
        'div',
        {
            className: 'bridge',
            style: _extends({
                position: 'absolute',
                overflow: 'visible'
            }, bridgeStyle) },
        React.createElement(
            'svg',
            {
                style: { width: bridgeStyle.width, height: bridgeStyle.height, overflow: 'visible' } },
            React.createElement(
                'g',
                { transform: transform },
                React.createElement('path', {
                    style: { fill: 'white' },
                    d: trianglePath }),
                React.createElement('path', {
                    style: { fill: '#808080' },
                    d: trianglePathOutline })
            )
        )
    );
}

var FloatAffixed = React.createClass({
    displayName: 'FloatAffixed',

    render: function render() {
        var _this = this;

        var _props = this.props;
        var prefab = _props.prefab;
        var edges = _props.edges;
        var align = _props.align;
        var anchor = _props.anchor;
        var bridge = _props.bridge;
        var gap = _props.gap;
        var render = _props.render;
        var children = _props.children;
        var className = _props.className;
        var style = _props.style;

        var props = _objectWithoutProperties(_props, ['prefab', 'edges', 'align', 'anchor', 'bridge', 'gap', 'render', 'children', 'className', 'style']);

        var theme = prefab && styles['prefab_' + prefab];
        var popupStyle = _extends({}, styles.default, theme, style, styles.required, {
            transform: 'translate(' + this.state.translation.x + 'px,' + this.state.translation.y + 'px)'
        });
        var edgeFactor = edgeFactors[this.state.schemeName || "unknown"];
        var translation = this.state.translation;

        if (render) {
            children = render(this.state.schemeName, {
                edges: {
                    anchor: edgeFactor.perp(this.state.anchorRect),
                    popup: edgeFactor.perp(translateRect(this.state.popupRect, translation))
                }
            });
        }
        return React.createElement(
            Escape,
            { ref: 'escape', to: 'viewport', style: { overflow: 'hidden' } },
            React.createElement(
                'div',
                _extends({
                    ref: function ref(r) {
                        _this._popup = r;
                    },
                    style: popupStyle
                }, props, {
                    className: classNames("float-affixed", this.state.schemeName, className) }),
                this.props.bridge ? makeBridge(this.state, this.props) : null,
                children
            )
        );
    },
    propTypes: {
        prefab: React.PropTypes.string,
        anchor: React.PropTypes.func,
        attachment: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.arrayOf(React.PropTypes.string)]),
        style: React.PropTypes.object
    },
    getInitialState: function getInitialState() {
        return {
            translation: new Vec2(0, 0)
        };
    },
    componentDidMount: function componentDidMount() {
        var _this2 = this;

        this._schemes = parseEdgeAlignProps(this.props.edges, this.props.align);
        this._anchor = this.props.anchor ? this.props.anchor() : this.refs.escape.escapePoint;
        if (!this._anchor)
            /* eslint no-console: 0 */
            console.error("no anchor supplied for float-affixed");
        this.withAnchorAncestors(function (e) {
            return e.addEventListener("scroll", _this2.elementDidScroll);
        });
        window.addEventListener("resize", this.windowDidResize);
        this.reposition(this.props);
    },
    componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
        if (this.props.edges != nextProps.edges || this.props.align != nextProps.align) {
            this._schemes = parseEdgeAlignProps(nextProps.edges, nextProps.align);
        }
        if (nextProps != this.props) {
            this.reposition(nextProps);
        }
    },
    componentWillUnmount: function componentWillUnmount() {
        var _this3 = this;

        window.removeEventListener("resize", this.windowDidResize);
        this.withAnchorAncestors(function (e) {
            return e.removeEventListener("scroll", _this3.elementDidScroll);
        });
    },
    withAnchorAncestors: function withAnchorAncestors(cb) {
        if (this._anchor) {
            var e = this._anchor.parentNode;
            while (e != null && e != window) {
                cb(e);
                e = e.parentNode;
            }
        }
    },
    elementDidScroll: function elementDidScroll() {
        this.reposition(this.props);
    },
    windowDidResize: function windowDidResize() {
        this.reposition(this.props);
    },
    reposition: function reposition(props) {
        var prect = viewportRect(this._popup);
        var psize = prect.getSize();
        var arect = viewportRect(this._anchor);
        var gap = (props.gap || 0) + (props.bridge ? bridgeSize : 0);
        var viewport = this.viewportSize();

        var scheme = this.chooseScheme(inflate(arect, gap), psize, viewport);
        var delta = scheme.calcTranslation(arect, prect, gap, viewport);
        /*
        if (!delta || (delta.x === 0 && delta.y === 0))
            return;
        */
        var nextTranslation = this.state.translation.clone().add(delta);
        this.setState({
            translation: nextTranslation,
            schemeName: scheme.name,
            anchorRect: arect,
            popupRect: prect
        });
    },
    chooseScheme: function chooseScheme(arect, psize, viewport) {
        // if there is a scheme, and it still fits, nothing to do
        if (this._scheme && this._scheme.fits(arect, psize, viewport) && this._schemes.indexOf(this._scheme) != -1) return this._scheme;

        // otherwise, find the first scheme that fits
        var scheme = this._schemes.find(function (s) {
            return s.fits(arect, psize, viewport);
        }) || this._scheme || this._schemes[0];
        return this._scheme = scheme;
    },
    viewportSize: function viewportSize() {
        var _refs$escape$getSize = this.refs.escape.getSize();

        var width = _refs$escape$getSize.width;
        var height = _refs$escape$getSize.height;

        return new Vec2(width, height);
    }
});

module.exports = FloatAffixed;
},{"classnames":118,"pex-geom":376,"react":"react","react-escape":774}],776:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var React = require('react');

var sizerStyle = { position: 'absolute', visibility: 'hidden', height: 0, width: 0, overflow: 'scroll', whiteSpace: 'pre' };

var nextFrame = typeof window !== 'undefined' ? (function () {
	return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
		window.setTimeout(callback, 1000 / 60);
	};
})().bind(window) : undefined; // If window is undefined, then we can't define a nextFrame function

var AutosizeInput = React.createClass({
	displayName: 'AutosizeInput',

	propTypes: {
		value: React.PropTypes.any, // field value
		defaultValue: React.PropTypes.any, // default field value
		onChange: React.PropTypes.func, // onChange handler: function(newValue) {}
		style: React.PropTypes.object, // css styles for the outer element
		className: React.PropTypes.string, // className for the outer element
		minWidth: React.PropTypes.oneOfType([// minimum width for input element
		React.PropTypes.number, React.PropTypes.string]),
		inputStyle: React.PropTypes.object, // css styles for the input element
		inputClassName: React.PropTypes.string // className for the input element
	},
	getDefaultProps: function getDefaultProps() {
		return {
			minWidth: 1
		};
	},
	getInitialState: function getInitialState() {
		return {
			inputWidth: this.props.minWidth
		};
	},
	componentDidMount: function componentDidMount() {
		this.copyInputStyles();
		this.updateInputWidth();
	},
	componentDidUpdate: function componentDidUpdate() {
		this.updateInputWidth();
	},
	copyInputStyles: function copyInputStyles() {
		if (!this.isMounted() || !window.getComputedStyle) {
			return;
		}
		var inputStyle = window.getComputedStyle(this.refs.input);
		if (!inputStyle) {
			return;
		}
		var widthNode = this.refs.sizer;
		widthNode.style.fontSize = inputStyle.fontSize;
		widthNode.style.fontFamily = inputStyle.fontFamily;
		widthNode.style.fontWeight = inputStyle.fontWeight;
		widthNode.style.fontStyle = inputStyle.fontStyle;
		widthNode.style.letterSpacing = inputStyle.letterSpacing;
		if (this.props.placeholder) {
			var placeholderNode = this.refs.placeholderSizer;
			placeholderNode.style.fontSize = inputStyle.fontSize;
			placeholderNode.style.fontFamily = inputStyle.fontFamily;
			placeholderNode.style.fontWeight = inputStyle.fontWeight;
			placeholderNode.style.fontStyle = inputStyle.fontStyle;
			placeholderNode.style.letterSpacing = inputStyle.letterSpacing;
		}
	},
	updateInputWidth: function updateInputWidth() {
		if (!this.isMounted() || typeof this.refs.sizer.scrollWidth === 'undefined') {
			return;
		}
		var newInputWidth = undefined;
		if (this.props.placeholder) {
			newInputWidth = Math.max(this.refs.sizer.scrollWidth, this.refs.placeholderSizer.scrollWidth) + 2;
		} else {
			newInputWidth = this.refs.sizer.scrollWidth + 2;
		}
		if (newInputWidth < this.props.minWidth) {
			newInputWidth = this.props.minWidth;
		}
		if (newInputWidth !== this.state.inputWidth) {
			this.setState({
				inputWidth: newInputWidth
			});
		}
	},
	getInput: function getInput() {
		return this.refs.input;
	},
	focus: function focus() {
		this.refs.input.focus();
	},
	blur: function blur() {
		this.refs.input.blur();
	},
	select: function select() {
		this.refs.input.select();
	},
	render: function render() {
		var sizerValue = this.props.defaultValue || this.props.value || '';
		var wrapperStyle = this.props.style || {};
		if (!wrapperStyle.display) wrapperStyle.display = 'inline-block';
		var inputStyle = _extends({}, this.props.inputStyle);
		inputStyle.width = this.state.inputWidth + 'px';
		inputStyle.boxSizing = 'content-box';
		var placeholder = this.props.placeholder ? React.createElement(
			'div',
			{ ref: 'placeholderSizer', style: sizerStyle },
			this.props.placeholder
		) : null;
		return React.createElement(
			'div',
			{ className: this.props.className, style: wrapperStyle },
			React.createElement('input', _extends({}, this.props, { ref: 'input', className: this.props.inputClassName, style: inputStyle })),
			React.createElement(
				'div',
				{ ref: 'sizer', style: sizerStyle },
				sizerValue
			),
			placeholder
		);
	}
});

module.exports = AutosizeInput;
},{"react":"react"}],777:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _eventlistener = require('eventlistener');

var _lodash = require('lodash.debounce');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.throttle');

var _lodash4 = _interopRequireDefault(_lodash3);

var _parentScroll = require('./utils/parentScroll');

var _parentScroll2 = _interopRequireDefault(_parentScroll);

var _inViewport = require('./utils/inViewport');

var _inViewport2 = _interopRequireDefault(_inViewport);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LazyLoad = function (_Component) {
  _inherits(LazyLoad, _Component);

  function LazyLoad(props) {
    _classCallCheck(this, LazyLoad);

    var _this = _possibleConstructorReturn(this, (LazyLoad.__proto__ || Object.getPrototypeOf(LazyLoad)).call(this, props));

    _this.lazyLoadHandler = _this.lazyLoadHandler.bind(_this);

    if (props.throttle > 0) {
      if (props.debounce) {
        _this.lazyLoadHandler = (0, _lodash2.default)(_this.lazyLoadHandler, props.throttle);
      } else {
        _this.lazyLoadHandler = (0, _lodash4.default)(_this.lazyLoadHandler, props.throttle);
      }
    }

    _this.state = { visible: false };
    return _this;
  }

  _createClass(LazyLoad, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._mounted = true;
      var eventNode = this.getEventNode();

      this.lazyLoadHandler();

      if (this.lazyLoadHandler.flush) {
        this.lazyLoadHandler.flush();
      }

      (0, _eventlistener.add)(window, 'resize', this.lazyLoadHandler);
      (0, _eventlistener.add)(eventNode, 'scroll', this.lazyLoadHandler);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps() {
      if (!this.state.visible) {
        this.lazyLoadHandler();
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(_nextProps, nextState) {
      return nextState.visible;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this._mounted = false;
      if (this.lazyLoadHandler.cancel) {
        this.lazyLoadHandler.cancel();
      }

      this.detachListeners();
    }
  }, {
    key: 'getEventNode',
    value: function getEventNode() {
      return (0, _parentScroll2.default)((0, _reactDom.findDOMNode)(this));
    }
  }, {
    key: 'getOffset',
    value: function getOffset() {
      var _props = this.props,
          offset = _props.offset,
          offsetVertical = _props.offsetVertical,
          offsetHorizontal = _props.offsetHorizontal,
          offsetTop = _props.offsetTop,
          offsetBottom = _props.offsetBottom,
          offsetLeft = _props.offsetLeft,
          offsetRight = _props.offsetRight,
          threshold = _props.threshold;


      var _offsetAll = threshold || offset;
      var _offsetVertical = offsetVertical || _offsetAll;
      var _offsetHorizontal = offsetHorizontal || _offsetAll;

      return {
        top: offsetTop || _offsetVertical,
        bottom: offsetBottom || _offsetVertical,
        left: offsetLeft || _offsetHorizontal,
        right: offsetRight || _offsetHorizontal
      };
    }
  }, {
    key: 'lazyLoadHandler',
    value: function lazyLoadHandler() {
      if (!this._mounted) {
        return;
      }
      var offset = this.getOffset();
      var node = (0, _reactDom.findDOMNode)(this);
      var eventNode = this.getEventNode();

      if ((0, _inViewport2.default)(node, eventNode, offset)) {
        var onContentVisible = this.props.onContentVisible;


        this.setState({ visible: true }, function () {
          if (onContentVisible) {
            onContentVisible();
          }
        });
        this.detachListeners();
      }
    }
  }, {
    key: 'detachListeners',
    value: function detachListeners() {
      var eventNode = this.getEventNode();

      (0, _eventlistener.remove)(window, 'resize', this.lazyLoadHandler);
      (0, _eventlistener.remove)(eventNode, 'scroll', this.lazyLoadHandler);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          children = _props2.children,
          className = _props2.className,
          height = _props2.height,
          width = _props2.width;
      var visible = this.state.visible;


      var elStyles = { height: height, width: width };
      var elClasses = 'LazyLoad' + (visible ? ' is-visible' : '') + (className ? ' ' + className : '');

      return _react2.default.createElement(this.props.elementType, {
        className: elClasses,
        style: elStyles
      }, visible && _react.Children.only(children));
    }
  }]);

  return LazyLoad;
}(_react.Component);

exports.default = LazyLoad;


LazyLoad.propTypes = {
  children: _react.PropTypes.node.isRequired,
  className: _react.PropTypes.string,
  debounce: _react.PropTypes.bool,
  elementType: _react.PropTypes.string,
  height: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
  offset: _react.PropTypes.number,
  offsetBottom: _react.PropTypes.number,
  offsetHorizontal: _react.PropTypes.number,
  offsetLeft: _react.PropTypes.number,
  offsetRight: _react.PropTypes.number,
  offsetTop: _react.PropTypes.number,
  offsetVertical: _react.PropTypes.number,
  threshold: _react.PropTypes.number,
  throttle: _react.PropTypes.number,
  width: _react.PropTypes.oneOfType([_react.PropTypes.string, _react.PropTypes.number]),
  onContentVisible: _react.PropTypes.func
};

LazyLoad.defaultProps = {
  elementType: 'div',
  debounce: true,
  offset: 0,
  offsetBottom: 0,
  offsetHorizontal: 0,
  offsetLeft: 0,
  offsetRight: 0,
  offsetTop: 0,
  offsetVertical: 0,
  throttle: 250
};
},{"./utils/inViewport":779,"./utils/parentScroll":780,"eventlistener":274,"lodash.debounce":331,"lodash.throttle":332,"react":"react","react-dom":"react-dom"}],778:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getElementPosition;
/*
* Finds element's position relative to the whole document,
* rather than to the viewport as it is the case with .getBoundingClientRect().
*/
function getElementPosition(element) {
  var rect = element.getBoundingClientRect();

  return {
    top: rect.top + window.pageYOffset,
    left: rect.left + window.pageXOffset
  };
}
},{}],779:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = inViewport;

var _getElementPosition = require('./getElementPosition');

var _getElementPosition2 = _interopRequireDefault(_getElementPosition);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isHidden = function isHidden(element) {
  return element.offsetParent === null;
};

function inViewport(element, container, customOffset) {
  if (isHidden(element)) {
    return false;
  }

  var top = void 0;
  var bottom = void 0;
  var left = void 0;
  var right = void 0;

  if (typeof container === 'undefined' || container === window) {
    top = window.pageYOffset;
    left = window.pageXOffset;
    bottom = top + window.innerHeight;
    right = left + window.innerWidth;
  } else {
    var containerPosition = (0, _getElementPosition2.default)(container);

    top = containerPosition.top;
    left = containerPosition.left;
    bottom = top + container.offsetHeight;
    right = left + container.offsetWidth;
  }

  var elementPosition = (0, _getElementPosition2.default)(element);

  return top <= elementPosition.top + element.offsetHeight + customOffset.top && bottom >= elementPosition.top - customOffset.bottom && left <= elementPosition.left + element.offsetWidth + customOffset.left && right >= elementPosition.left - customOffset.right;
}
},{"./getElementPosition":778}],780:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var style = function style(element, prop) {
  return typeof getComputedStyle !== 'undefined' ? getComputedStyle(element, null).getPropertyValue(prop) : element.style[prop];
};

var overflow = function overflow(element) {
  return style(element, 'overflow') + style(element, 'overflow-y') + style(element, 'overflow-x');
};

var scrollParent = function scrollParent(element) {
  if (!(element instanceof HTMLElement)) {
    return window;
  }

  var parent = element;

  while (parent) {
    if (parent === document.body || parent === document.documentElement) {
      break;
    }

    if (!parent.parentNode) {
      break;
    }

    if (/(scroll|auto)/.test(overflow(parent))) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return window;
};

exports.default = scrollParent;
},{}],781:[function(require,module,exports){
var ActionCancelModalComponent, H, ModalPopupComponent, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

_ = require('lodash');

ModalPopupComponent = require('./ModalPopupComponent');

module.exports = ActionCancelModalComponent = (function(superClass) {
  extend(ActionCancelModalComponent, superClass);

  function ActionCancelModalComponent() {
    return ActionCancelModalComponent.__super__.constructor.apply(this, arguments);
  }

  ActionCancelModalComponent.propTypes = {
    title: React.PropTypes.node,
    actionLabel: React.PropTypes.node,
    onAction: React.PropTypes.func,
    onCancel: React.PropTypes.func,
    onDelete: React.PropTypes.func,
    deleteLabel: React.PropTypes.node,
    size: React.PropTypes.string
  };

  ActionCancelModalComponent.prototype.render = function() {
    return React.createElement(ModalPopupComponent, {
      size: this.props.size,
      header: this.props.title,
      footer: [
        H.button({
          key: "cancel",
          type: "button",
          onClick: this.props.onCancel,
          className: "btn btn-default"
        }, this.props.onAction ? "Cancel" : "Close"), this.props.onAction ? H.button({
          key: "action",
          type: "button",
          onClick: this.props.onAction,
          className: "btn btn-primary"
        }, this.props.actionLabel || "Save") : void 0, this.props.onDelete ? H.button({
          key: "delete",
          type: "button",
          style: {
            float: "left"
          },
          onClick: this.props.onDelete,
          className: "btn btn-danger"
        }, this.props.deleteLabel || "Delete") : void 0
      ]
    }, this.props.children);
  };

  return ActionCancelModalComponent;

})(React.Component);

},{"./ModalPopupComponent":786,"lodash":"lodash","react":"react"}],782:[function(require,module,exports){
var AsyncLoadComponent, H, R, React, ReactDOM,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

R = React.createElement;

module.exports = AsyncLoadComponent = (function(superClass) {
  extend(AsyncLoadComponent, superClass);

  function AsyncLoadComponent() {
    this.state = {
      loading: false
    };
    this._mounted = false;
    this._loadSeqStarted = 0;
    this._loadSeqCompleted = 0;
  }

  AsyncLoadComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    throw new Error("Not implemented");
  };

  AsyncLoadComponent.prototype.load = function(props, prevProps, callback) {
    throw new Error("Not implemented");
  };

  AsyncLoadComponent.prototype.forceLoad = function() {
    return this._performLoad(this.props, this.props);
  };

  AsyncLoadComponent.prototype._performLoad = function(newProps, oldProps) {
    var callback, seq;
    this._loadSeqStarted += 1;
    seq = this._loadSeqStarted;
    callback = (function(_this) {
      return function(state) {
        if (!_this._mounted) {
          return;
        }
        if (seq < _this._loadSeqCompleted) {
          return;
        }
        _this._loadSeqCompleted = seq;
        _this.setState(state);
        if (seq === _this._loadSeqStarted) {
          return _this.setState({
            loading: false
          });
        }
      };
    })(this);
    return this.setState({
      loading: true
    }, (function(_this) {
      return function() {
        return _this.load(newProps, oldProps, callback);
      };
    })(this));
  };

  AsyncLoadComponent.prototype.componentWillMount = function() {
    this._mounted = true;
    return this._performLoad(this.props, {});
  };

  AsyncLoadComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (this.isLoadNeeded(nextProps, this.props)) {
      return this._performLoad(nextProps, this.props);
    }
  };

  AsyncLoadComponent.prototype.componentWillUnmount = function() {
    return this._mounted = false;
  };

  return AsyncLoadComponent;

})(React.Component);

},{"react":"react","react-dom":"react-dom"}],783:[function(require,module,exports){
var AutoSizeComponent, H, R, React, ReactDOM, Resizable,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

R = React.createElement;

Resizable = require('./react-component-resizable');

module.exports = AutoSizeComponent = (function(superClass) {
  extend(AutoSizeComponent, superClass);

  AutoSizeComponent.propTypes = {
    injectWidth: React.PropTypes.bool,
    injectHeight: React.PropTypes.bool
  };

  function AutoSizeComponent() {
    this.updateSize = bind(this.updateSize, this);
    this.state = {
      width: null,
      height: null
    };
  }

  AutoSizeComponent.prototype.componentDidMount = function() {
    $(window).on('resize', this.updateSize);
    return this.updateSize();
  };

  AutoSizeComponent.prototype.componentWillUnmount = function() {
    return $(window).off('resize', this.updateSize);
  };

  AutoSizeComponent.prototype.updateSize = function() {
    var node;
    node = ReactDOM.findDOMNode(this);
    return this.setState({
      width: node.clientWidth,
      height: node.clientHeight
    });
  };

  AutoSizeComponent.prototype.render = function() {
    var innerElem, overrides, style;
    innerElem = null;
    if ((this.state.width != null) && (this.state.height != null)) {
      overrides = {};
      if (this.props.injectWidth) {
        overrides.width = this.state.width;
      }
      if (this.props.injectHeight) {
        overrides.height = this.state.height;
      }
      if (typeof this.props.children === "function") {
        innerElem = this.props.children(overrides);
      } else {
        innerElem = React.cloneElement(React.Children.only(this.props.children), overrides);
      }
    }
    style = {};
    if (this.props.injectWidth) {
      style.width = "100%";
    }
    if (this.props.injectHeight) {
      style.height = "100%";
    }
    return R(Resizable, {
      style: style,
      onResize: this.updateSize
    }, innerElem);
  };

  return AutoSizeComponent;

})(React.Component);

},{"./react-component-resizable":794,"react":"react","react-dom":"react-dom"}],784:[function(require,module,exports){
var CrossComponent, H, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = CrossComponent = (function(superClass) {
  extend(CrossComponent, superClass);

  function CrossComponent() {
    return CrossComponent.__super__.constructor.apply(this, arguments);
  }

  CrossComponent.propTypes = {
    n: React.PropTypes.string,
    e: React.PropTypes.string,
    s: React.PropTypes.string,
    w: React.PropTypes.string,
    width: React.PropTypes.any,
    height: React.PropTypes.any,
    collapseTop: React.PropTypes.bool
  };

  CrossComponent.defaultProps = {
    width: "100%",
    height: "100%"
  };

  CrossComponent.prototype.render = function() {
    return H.div({
      className: "flexBox",
      style: {
        display: "flex",
        flexDirection: "column",
        width: this.props.width,
        height: this.props.height
      }
    }, H.div({
      className: "flexBox",
      style: {
        display: "flex",
        flex: (this.props.collapseTop ? "0 1 0px" : "1 1 0px")
      }
    }, H.div({
      className: "flexBox",
      style: {
        flex: "1 1 0px",
        borderRight: this.props.n,
        borderBottom: this.props.w
      }
    }), H.div({
      className: "flexBox",
      style: {
        flex: "1 1 0px",
        borderBottom: this.props.e
      }
    })), H.div({
      className: "flexBox",
      style: {
        display: "flex",
        flex: "1 1 0px"
      }
    }, H.div({
      className: "flexBox",
      style: {
        flex: "1 1 0px",
        borderRight: this.props.s
      }
    }), H.div({
      className: "flexBox",
      style: {
        flex: "1 1 0px"
      }
    })));
  };

  return CrossComponent;

})(React.Component);

},{"react":"react"}],785:[function(require,module,exports){
var H, LoadingComponent, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = LoadingComponent = (function(superClass) {
  extend(LoadingComponent, superClass);

  function LoadingComponent() {
    return LoadingComponent.__super__.constructor.apply(this, arguments);
  }

  LoadingComponent.propTypes = {
    width: React.PropTypes.any,
    height: React.PropTypes.any,
    label: React.PropTypes.node
  };

  LoadingComponent.defaultProps = {
    width: "100%",
    height: "100%",
    label: H.div({
      className: "text-muted",
      style: {
        fontSize: 30
      }
    }, H.i({
      className: "fa fa-spin fa-spinner"
    }), " Loading...")
  };

  LoadingComponent.prototype.render = function() {
    return H.div({
      style: {
        width: this.props.width,
        height: this.props.height,
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      }
    }, this.props.label);
  };

  return LoadingComponent;

})(React.Component);

},{"react":"react"}],786:[function(require,module,exports){
var H, InnerModalComponent, ModalPopupComponent, React, ReactDOM, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

_ = require('lodash');

module.exports = ModalPopupComponent = (function(superClass) {
  extend(ModalPopupComponent, superClass);

  function ModalPopupComponent() {
    return ModalPopupComponent.__super__.constructor.apply(this, arguments);
  }

  ModalPopupComponent.propTypes = {
    header: React.PropTypes.node,
    footer: React.PropTypes.node,
    size: React.PropTypes.string,
    showCloseX: React.PropTypes.bool,
    onClose: React.PropTypes.func
  };

  ModalPopupComponent.prototype.componentDidMount = function() {
    this.modalNode = $('<div></div>').get(0);
    $("body").append(this.modalNode);
    return this.update(this.props);
  };

  ModalPopupComponent.prototype.componentWillReceiveProps = function(nextProps) {
    return this.update(nextProps);
  };

  ModalPopupComponent.prototype.update = function(props) {
    var elem;
    elem = React.createElement(InnerModalComponent, props);
    return ReactDOM.unstable_renderSubtreeIntoContainer(this, elem, this.modalNode);
  };

  ModalPopupComponent.prototype.componentWillUnmount = function() {
    ReactDOM.unmountComponentAtNode(this.modalNode);
    return $(this.modalNode).remove();
  };

  ModalPopupComponent.prototype.render = function() {
    return null;
  };

  ModalPopupComponent.show = function(modalFunc, onClose) {
    var close, popupElem, tempDiv;
    tempDiv = $('<div></div>').get(0);
    close = function() {
      ReactDOM.unmountComponentAtNode(tempDiv);
      $(tempDiv).remove();
      if (onClose) {
        return onClose();
      }
    };
    popupElem = modalFunc(close);
    return ReactDOM.render(popupElem, tempDiv);
  };

  return ModalPopupComponent;

})(React.Component);

InnerModalComponent = (function(superClass) {
  extend(InnerModalComponent, superClass);

  function InnerModalComponent() {
    return InnerModalComponent.__super__.constructor.apply(this, arguments);
  }

  InnerModalComponent.propTypes = {
    header: React.PropTypes.node,
    footer: React.PropTypes.node,
    size: React.PropTypes.string,
    showCloseX: React.PropTypes.bool,
    onClose: React.PropTypes.func
  };

  InnerModalComponent.prototype.render = function() {
    var dialogClass, overlayStyle, rootStyle;
    dialogClass = "modal-dialog";
    if (this.props.size === "large") {
      dialogClass += " modal-lg";
    }
    if (this.props.size === "small") {
      dialogClass += " modal-sm";
    }
    rootStyle = {
      position: "fixed",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      zIndex: 1040
    };
    overlayStyle = {
      position: "absolute",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      backgroundColor: "rgba(0, 0, 0, 0.7)"
    };
    return H.div({
      style: rootStyle
    }, H.style(null, 'body { overflow-y: hidden }'), H.div({
      style: overlayStyle,
      onClick: this.props.onClose
    }), H.div({
      className: dialogClass
    }, H.div({
      className: "modal-content"
    }, this.props.header ? H.div({
      className: "modal-header"
    }, this.props.showCloseX ? H.button({
      className: "close"
    }, H.span({
      onClick: this.props.onClose
    }, "\u00d7")) : void 0, H.h4({
      className: "modal-title"
    }, this.props.header)) : void 0, H.div({
      className: "modal-body",
      style: {
        maxHeight: window.innerHeight - 56 - 65 - 30 - 30,
        overflowY: "auto"
      }
    }, this.props.children), this.props.footer ? H.div({
      className: "modal-footer"
    }, this.props.footer) : void 0, !this.props.header && this.props.showCloseX ? H.button({
      className: "close",
      style: {
        position: "absolute",
        right: 10,
        top: 10
      }
    }, H.span({
      onClick: this.props.onClose
    }, "\u00d7")) : void 0)));
  };

  return InnerModalComponent;

})(React.Component);

},{"lodash":"lodash","react":"react","react-dom":"react-dom"}],787:[function(require,module,exports){
var H, InnerModalComponent, ModalWindowComponent, React, ReactDOM, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

_ = require('lodash');

module.exports = ModalWindowComponent = (function(superClass) {
  extend(ModalWindowComponent, superClass);

  function ModalWindowComponent() {
    return ModalWindowComponent.__super__.constructor.apply(this, arguments);
  }

  ModalWindowComponent.propTypes = {
    isOpen: React.PropTypes.bool.isRequired,
    onRequestClose: React.PropTypes.func,
    backgroundColor: React.PropTypes.string,
    outerPadding: React.PropTypes.number,
    innerPadding: React.PropTypes.number
  };

  ModalWindowComponent.prototype.componentDidMount = function() {
    this.modalNode = $('<div></div>').get(0);
    $("body").append(this.modalNode);
    return this.update(this.props);
  };

  ModalWindowComponent.prototype.componentWillReceiveProps = function(nextProps) {
    return this.update(nextProps);
  };

  ModalWindowComponent.prototype.update = function(props) {
    var elem;
    elem = React.createElement(InnerModalComponent, props);
    return ReactDOM.unstable_renderSubtreeIntoContainer(this, elem, this.modalNode);
  };

  ModalWindowComponent.prototype.componentWillUnmount = function() {
    ReactDOM.unmountComponentAtNode(this.modalNode);
    return $(this.modalNode).remove();
  };

  ModalWindowComponent.prototype.render = function() {
    return null;
  };

  ModalWindowComponent.show = function(modalFunc, onClose) {
    var close, popupElem, tempDiv;
    tempDiv = $('<div></div>').get(0);
    close = function() {
      ReactDOM.unmountComponentAtNode(tempDiv);
      $(tempDiv).remove();
      if (onClose) {
        return onClose();
      }
    };
    popupElem = modalFunc(close);
    return ReactDOM.render(popupElem, tempDiv);
  };

  return ModalWindowComponent;

})(React.Component);

InnerModalComponent = (function(superClass) {
  extend(InnerModalComponent, superClass);

  function InnerModalComponent() {
    return InnerModalComponent.__super__.constructor.apply(this, arguments);
  }

  InnerModalComponent.propTypes = {
    isOpen: React.PropTypes.bool.isRequired,
    onRequestClose: React.PropTypes.func,
    outerPadding: React.PropTypes.number,
    innerPadding: React.PropTypes.number,
    backgroundColor: React.PropTypes.string
  };

  InnerModalComponent.defaultProps = {
    outerPadding: 40,
    innerPadding: 20,
    backgroundColor: "white"
  };

  InnerModalComponent.prototype.render = function() {
    var closeStyle, contentStyle, overlayStyle, windowStyle;
    if (!this.props.isOpen) {
      return null;
    }
    overlayStyle = {
      position: "fixed",
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      zIndex: 1040,
      backgroundColor: "rgba(0, 0, 0, 0.7)"
    };
    windowStyle = {
      position: "fixed",
      left: this.props.outerPadding,
      right: this.props.outerPadding,
      top: this.props.outerPadding,
      bottom: this.props.outerPadding,
      zIndex: 1040,
      backgroundColor: this.props.backgroundColor,
      borderRadius: 10,
      border: "solid 1px #AAA"
    };
    contentStyle = {
      position: "absolute",
      left: this.props.innerPadding,
      right: this.props.innerPadding,
      top: this.props.innerPadding,
      bottom: this.props.innerPadding,
      overflowY: "auto"
    };
    closeStyle = {
      position: "absolute",
      right: 8,
      top: 8,
      color: "#888"
    };
    return H.div({
      className: "modal-window-component"
    }, H.style(null, 'body { overflow-y: hidden }'), H.div({
      style: overlayStyle,
      onClick: this.props.onRequestClose,
      className: "modal-window-component-overlay"
    }), H.div({
      style: windowStyle,
      className: "modal-window-component-window"
    }, this.props.onRequestClose ? H.div({
      style: closeStyle
    }, H.span({
      className: "glyphicon glyphicon-remove",
      onClick: this.props.onRequestClose
    })) : void 0, H.div({
      style: contentStyle
    }, this.props.children)));
  };

  return InnerModalComponent;

})(React.Component);

},{"lodash":"lodash","react":"react","react-dom":"react-dom"}],788:[function(require,module,exports){
var DragDropContext, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

DragDropContext = require('react-dnd').DragDropContext;

module.exports = function(backend) {
  return function(component) {
    var NestableDragDropContextContainer, contextClass;
    contextClass = DragDropContext(backend)(component);
    return NestableDragDropContextContainer = (function(superClass) {
      extend(NestableDragDropContextContainer, superClass);

      function NestableDragDropContextContainer() {
        return NestableDragDropContextContainer.__super__.constructor.apply(this, arguments);
      }

      NestableDragDropContextContainer.contextTypes = {
        dragDropManager: React.PropTypes.object
      };

      NestableDragDropContextContainer.prototype.render = function() {
        if (this.context.dragDropManager) {
          return React.createElement(component, this.props);
        } else {
          return React.createElement(contextClass, this.props);
        }
      };

      return NestableDragDropContextContainer;

    })(React.Component);
  };
};

},{"react":"react","react-dnd":753}],789:[function(require,module,exports){
var H, NumberInputComponent, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

module.exports = NumberInputComponent = (function(superClass) {
  extend(NumberInputComponent, superClass);

  NumberInputComponent.propTypes = {
    decimal: React.PropTypes.bool,
    value: React.PropTypes.number,
    onChange: React.PropTypes.func.isRequired,
    style: React.PropTypes.object,
    small: React.PropTypes.bool,
    placeholder: React.PropTypes.string
  };

  NumberInputComponent.defaultProps = {
    decimal: true
  };

  function NumberInputComponent(props) {
    this.handleBlur = bind(this.handleBlur, this);
    NumberInputComponent.__super__.constructor.call(this, props);
    this.state = {
      inputText: this.props.value != null ? "" + this.props.value : ""
    };
  }

  NumberInputComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (nextProps.value !== this.props.value) {
      return this.setState({
        inputText: nextProps.value != null ? "" + nextProps.value : ""
      });
    }
  };

  NumberInputComponent.prototype.focus = function() {
    return this.refs.input.focus();
  };

  NumberInputComponent.prototype.handleBlur = function() {
    var val;
    if (this.isValid()) {
      val = this.props.decimal ? parseFloat(this.state.inputText) : parseInt(this.state.inputText);
      if (isNaN(val)) {
        return this.props.onChange(null);
      } else {
        return this.props.onChange(val);
      }
    } else {
      return this.props.onChange(this.props.value);
    }
  };

  NumberInputComponent.prototype.isValid = function() {
    if (this.state.inputText.length === 0) {
      return true;
    }
    if (this.props.decimal) {
      return this.state.inputText.match(/^-?[0-9]*\.?[0-9]+$/) && !isNaN(parseFloat(this.state.inputText));
    } else {
      return this.state.inputText.match(/^-?\d+$/);
    }
  };

  NumberInputComponent.prototype.render = function() {
    var style;
    style = _.clone(this.props.style || {});
    if (!style.width) {
      style.width = "8em";
    }
    if (!this.isValid()) {
      style.borderColor = "#a94442";
      style.boxShadow = "inset 0 1px 1px rgba(0,0,0,.075)";
      style.backgroundColor = "rgba(132, 53, 52, 0.12)";
    }
    return H.input({
      ref: 'input',
      type: this.props.decimal ? "number" : "tel",
      step: this.props.decimal ? "any" : "1",
      className: "form-control " + (this.props.small ? "input-sm" : ""),
      placeholder: this.props.placeholder,
      style: style,
      value: this.state.inputText,
      onChange: (function(_this) {
        return function(ev) {
          return _this.setState({
            inputText: ev.target.value
          });
        };
      })(this),
      onBlur: this.handleBlur,
      onKeyDown: this.handleKeyDown
    });
  };

  return NumberInputComponent;

})(React.Component);

},{"lodash":"lodash","react":"react"}],790:[function(require,module,exports){
var H, OverlayTrigger, Popover, PopoverHelpComponent, R, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

Popover = require('react-bootstrap/lib/Popover');

OverlayTrigger = require('react-bootstrap/lib/OverlayTrigger');

module.exports = PopoverHelpComponent = (function(superClass) {
  extend(PopoverHelpComponent, superClass);

  function PopoverHelpComponent() {
    return PopoverHelpComponent.__super__.constructor.apply(this, arguments);
  }

  PopoverHelpComponent.propTypes = {
    placement: React.PropTypes.string
  };

  PopoverHelpComponent.defaultProps = {
    placement: "top"
  };

  PopoverHelpComponent.prototype.render = function() {
    return R(OverlayTrigger, {
      ref: "overlay",
      trigger: ["hover", "focus"],
      placement: this.props.placement,
      overlay: R(Popover, null, this.props.children)
    }, H.span({
      className: "text-muted",
      style: {
        cursor: "pointer"
      }
    }, H.span({
      className: "glyphicon glyphicon-question-sign"
    })));
  };

  return PopoverHelpComponent;

})(React.Component);

},{"lodash":"lodash","react":"react","react-bootstrap/lib/OverlayTrigger":432,"react-bootstrap/lib/Popover":433}],791:[function(require,module,exports){
var $, ReactDOM, ReactElementPrinter, _;

_ = require('lodash');

$ = require('jquery');

ReactDOM = require('react-dom');

module.exports = ReactElementPrinter = (function() {
  function ReactElementPrinter() {}

  ReactElementPrinter.prototype.print = function(element, options) {
    var extraCss;
    extraCss = $('<style id="react_element_printer_css">\n  @media print {\n    /* Hide body and get rid of margins */\n    body {\n      visibility: hidden;\n      margin: 0;\n      padding: 0;\n      opacity: 100%\n    }\n\n    /* Hide all children of body */\n    body > * {\n      display: none;\n    }\n\n    /* Setup special region */\n    #react_element_printer {\n      display: block !important;\n      visibility: visible;\n    }\n  }\n\n  /* Don\'t show when not printing */\n  #react_element_printer {\n    /* Removed because causes c3 titles to be hidden for mysterious reasons\n    display: none;\n    */\n  }\n\n  /* Default to letter sized pages */\n  @page  {\n    size: 8.5in 11in; \n    margin: 0.5in 0.5in 0.5in 0.5in; \n  }\n\n  #react_element_printer_splash {\n    display: flex; \n    align-items: center;\n    justify-content: center;    \n    position: fixed; \n    left: 0;\n    top: 0;\n    z-index: 9999;\n    width: 100%;\n    height: 100%;\n    overflow: visible;    \n    background-color: rgba(255,255,255,0.7);\n  }\n\n  @media print {\n    #react_element_printer_splash {\n      display: none;\n    }\n  }\n\n</style>');
    $("body").append(extraCss);
    $("body").append('<div id="react_element_printer"></div>');
    $("body").append('<div id="react_element_printer_splash">\n  <div style="font-size: 30pt;">\n    <i class="fa fa-spinner fa-spin"></i>\n    Preparing to print...\n  </div>\n</div>');
    return ReactDOM.render(element, $("#react_element_printer").get(0), (function(_this) {
      return function() {
        return _.delay(function() {
          window.print();
          ReactDOM.unmountComponentAtNode($("#react_element_printer").get(0));
          $("#react_element_printer").remove();
          $("#react_element_printer_css").remove();
          return $("#react_element_printer_splash").remove();
        }, options.delay || 1000);
      };
    })(this));
  };

  return ReactElementPrinter;

})();

},{"jquery":"jquery","lodash":"lodash","react-dom":"react-dom"}],792:[function(require,module,exports){
var H, React, TabbedComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

module.exports = TabbedComponent = (function(superClass) {
  extend(TabbedComponent, superClass);

  TabbedComponent.propTypes = {
    tabs: React.PropTypes.array.isRequired,
    initialTabId: React.PropTypes.string,
    tabId: React.PropTypes.string,
    onAddTab: React.PropTypes.func,
    onTabClick: React.PropTypes.func
  };

  function TabbedComponent() {
    this.renderTab = bind(this.renderTab, this);
    this.handleRemove = bind(this.handleRemove, this);
    this.handleClick = bind(this.handleClick, this);
    TabbedComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      tabId: this.props.initialTabId
    };
  }

  TabbedComponent.prototype.handleClick = function(tabId) {
    if (this.props.onTabClick != null) {
      return this.props.onTabClick(tabId);
    } else {
      return this.setState({
        tabId: tabId
      });
    }
  };

  TabbedComponent.prototype.handleRemove = function(tab, ev) {
    ev.stopPropagation();
    return tab.onRemove();
  };

  TabbedComponent.prototype.renderTab = function(tab) {
    var tabId;
    if (this.props.tabId != null) {
      tabId = this.props.tabId;
    } else {
      tabId = this.state.tabId;
    }
    return H.li({
      key: tab.id,
      className: (tabId === tab.id ? "active" : void 0)
    }, H.a({
      onClick: this.handleClick.bind(null, tab.id)
    }, tab.label, tab.onRemove ? H.button({
      type: "button",
      className: "btn btn-xs btn-link",
      onClick: this.handleRemove.bind(null, tab)
    }, H.span({
      className: "fa fa-times"
    })) : void 0));
  };

  TabbedComponent.prototype.render = function() {
    var currentTab, tabId;
    if (this.props.tabId != null) {
      tabId = this.props.tabId;
    } else {
      tabId = this.state.tabId;
    }
    currentTab = _.findWhere(this.props.tabs, {
      id: tabId
    });
    return H.div(null, H.ul({
      key: "tabs",
      className: "nav nav-tabs",
      style: {
        marginBottom: 10
      }
    }, _.map(this.props.tabs, this.renderTab), this.props.onAddTab ? H.li({
      key: "_add"
    }, H.a({
      onClick: this.props.onAddTab
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }))) : void 0), H.div({
      key: "currentTab"
    }, currentTab ? currentTab.elem : void 0));
  };

  return TabbedComponent;

})(React.Component);

},{"lodash":"lodash","react":"react"}],793:[function(require,module,exports){
var Button, Checkbox, FormGroup, H, Icon, R, Radio, React, Select, TextInput, classnames,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

classnames = require('classnames');

React = require('react');

H = React.DOM;

R = React.createElement;

exports.Spinner = function() {
  return H.i({
    className: "fa fa-spinner fa-spin"
  });
};

exports.Button = Button = (function(superClass) {
  extend(Button, superClass);

  function Button() {
    return Button.__super__.constructor.apply(this, arguments);
  }

  Button.propTypes = {
    type: React.PropTypes.string,
    onClick: React.PropTypes.func,
    disabled: React.PropTypes.bool,
    active: React.PropTypes.bool,
    size: React.PropTypes.string
  };

  Button.defaultProps = {
    type: "default"
  };

  Button.prototype.render = function() {
    var obj;
    return H.button({
      type: "button",
      className: classnames("btn", "btn-" + this.props.type, {
        active: this.props.active
      }, (
        obj = {},
        obj["btn-" + this.props.size] = this.props.size != null,
        obj
      )),
      onClick: this.props.onClick,
      disabled: this.props.disabled
    }, this.props.children);
  };

  return Button;

})(React.Component);

exports.Icon = Icon = (function(superClass) {
  extend(Icon, superClass);

  function Icon() {
    return Icon.__super__.constructor.apply(this, arguments);
  }

  Icon.propTypes = {
    id: React.PropTypes.string.isRequired
  };

  Icon.prototype.render = function() {
    if (this.props.id.match(/^fa-/)) {
      return H.i({
        className: "fa " + this.props.id
      });
    } else if (this.props.id.match(/^glyphicon-/)) {
      return H.i({
        className: "glyphicon " + this.props.id
      });
    } else {
      return null;
    }
  };

  return Icon;

})(React.Component);

exports.FormGroup = FormGroup = (function(superClass) {
  extend(FormGroup, superClass);

  function FormGroup() {
    return FormGroup.__super__.constructor.apply(this, arguments);
  }

  FormGroup.propTypes = {
    label: React.PropTypes.node,
    labelMuted: React.PropTypes.bool,
    hint: React.PropTypes.node,
    help: React.PropTypes.node
  };

  FormGroup.prototype.render = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      key: "label"
    }, this.props.labelMuted ? H.span({
      className: "text-muted"
    }, this.props.label) : this.props.label, this.props.hint ? H.span({
      className: "text-muted",
      style: {
        fontWeight: this.props.label ? "normal" : void 0
      }
    }, this.props.label ? " - " : void 0, this.props.hint) : void 0), H.div({
      key: "contents",
      style: {
        marginLeft: 5
      }
    }, this.props.children), this.props.help ? H.p({
      key: "help",
      className: "help-block",
      style: {
        marginLeft: 5
      }
    }, this.props.help) : void 0);
  };

  return FormGroup;

})(React.Component);

exports.Checkbox = Checkbox = (function(superClass) {
  extend(Checkbox, superClass);

  function Checkbox() {
    return Checkbox.__super__.constructor.apply(this, arguments);
  }

  Checkbox.propTypes = {
    value: React.PropTypes.bool,
    onChange: React.PropTypes.func,
    inline: React.PropTypes.bool
  };

  Checkbox.prototype.render = function() {
    if (this.props.inline) {
      return H.label({
        className: "checkbox-inline"
      }, H.input({
        type: "checkbox",
        checked: this.props.value || false,
        onChange: (function(_this) {
          return function(ev) {
            return _this.props.onChange(ev.target.checked);
          };
        })(this)
      }), this.props.children);
    } else {
      return H.div({
        className: "checkbox"
      }, H.label(null, H.input({
        type: "checkbox",
        checked: this.props.value || false,
        onChange: (function(_this) {
          return function(ev) {
            return _this.props.onChange(ev.target.checked);
          };
        })(this)
      }), this.props.children));
    }
  };

  return Checkbox;

})(React.Component);

exports.Radio = Radio = (function(superClass) {
  extend(Radio, superClass);

  function Radio() {
    return Radio.__super__.constructor.apply(this, arguments);
  }

  Radio.propTypes = {
    value: React.PropTypes.any,
    radioValue: React.PropTypes.any,
    onChange: React.PropTypes.func,
    inline: React.PropTypes.bool
  };

  Radio.prototype.render = function() {
    return H.div({
      className: (this.props.inline ? "radio-inline" : "radio")
    }, H.label(null, H.input({
      type: "radio",
      checked: this.props.value === this.props.radioValue,
      onChange: function() {},
      onClick: (function(_this) {
        return function(ev) {
          return _this.props.onChange(_this.props.radioValue);
        };
      })(this)
    }), this.props.children));
  };

  return Radio;

})(React.Component);

exports.Select = Select = (function(superClass) {
  extend(Select, superClass);

  function Select() {
    this.handleChange = bind(this.handleChange, this);
    return Select.__super__.constructor.apply(this, arguments);
  }

  Select.propTypes = {
    value: React.PropTypes.any,
    onChange: React.PropTypes.func,
    options: React.PropTypes.arrayOf(React.PropTypes.shape({
      value: React.PropTypes.any,
      label: React.PropTypes.string
    })),
    size: React.PropTypes.string,
    nullLabel: React.PropTypes.string
  };

  Select.prototype.handleChange = function(ev) {
    var value;
    value = JSON.parse(ev.target.value);
    return this.props.onChange(value);
  };

  Select.prototype.render = function() {
    var options;
    options = this.props.options.slice();
    if (this.props.nullLabel != null) {
      options.unshift({
        value: null,
        label: this.props.nullLabel
      });
    }
    return H.select({
      className: classnames("form-control", {
        "input-sm": this.props.size === "sm"
      }, {
        "input-lg": this.props.size === "lg"
      }),
      value: JSON.stringify(this.props.value != null ? this.props.value : null),
      onChange: this.handleChange
    }, _.map(options, (function(_this) {
      return function(option) {
        return H.option({
          key: JSON.stringify(option.value),
          value: JSON.stringify(option.value)
        }, option.label);
      };
    })(this)));
  };

  return Select;

})(React.Component);

exports.TextInput = TextInput = (function(superClass) {
  extend(TextInput, superClass);

  function TextInput() {
    this.handleChange = bind(this.handleChange, this);
    return TextInput.__super__.constructor.apply(this, arguments);
  }

  TextInput.propTypes = {
    value: React.PropTypes.string,
    onChange: React.PropTypes.func,
    placeholder: React.PropTypes.string,
    size: React.PropTypes.string,
    emptyNull: React.PropTypes.bool
  };

  TextInput.prototype.handleChange = function(ev) {
    var value;
    value = ev.target.value;
    if (this.props.emptyNull) {
      value = value || null;
    }
    return this.props.onChange(value);
  };

  TextInput.prototype.render = function() {
    return H.input({
      type: "text",
      className: classnames("form-control", {
        "input-sm": this.props.size === "sm"
      }, {
        "input-lg": this.props.size === "lg"
      }),
      value: this.props.value || "",
      onChange: this.handleChange,
      placeholder: this.props.placeholder
    });
  };

  return TextInput;

})(React.Component);

},{"classnames":118,"react":"react"}],794:[function(require,module,exports){
(function (global){
/*
The MIT License (MIT)

Copyright (c) 2014 Nicholas Rakoto

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


https://github.com/nrako/react-component-resizable
ES6 compiled

*/

'use strict';

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

var React = global.React || require('react');
var objectAssign = require('object-assign');

var Resizable = React.createClass({
  displayName: 'Resizable',


  lastDimensions: {
    width: null,
    height: null
  },

  propTypes: {
    triggersClass: React.PropTypes.string,
    expandClass: React.PropTypes.string,
    contractClass: React.PropTypes.string,
    embedCss: React.PropTypes.bool,
    onResize: React.PropTypes.func.isRequired
  },

  getDefaultProps: function getDefaultProps() {
    return {
      triggersClass: 'resize-triggers',
      expandClass: 'expand-trigger',
      contractClass: 'contract-trigger',
      embedCss: true
    };
  },

  requestFrame: function requestFrame(fn) {
    return (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (fn) {
      return window.setTimeout(fn, 20);
    })(fn);
  },

  cancelFrame: function cancelFrame(id) {
    return (window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout)(id);
  },

  componentDidMount: function componentDidMount() {
    this.resetTriggers();
    this.initialResetTriggersTimeout = setTimeout(this.resetTriggers, 1000);
  },

  componentWillUnmount: function componentWillUnmount() {
    clearTimeout(this.initialResetTriggersTimeout);
  },

  componentDidUpdate: function componentDidUpdate() {
    this.resetTriggers();
  },

  resetTriggers: function resetTriggers() {
    var contract = this.refs.contract;
    var expandChild = this.refs.expandChild;
    var expand = this.refs.expand;

    contract.scrollLeft = contract.scrollWidth;
    contract.scrollTop = contract.scrollHeight;
    expandChild.style.width = expand.offsetWidth + 1 + 'px';
    expandChild.style.height = expand.offsetHeight + 1 + 'px';
    expand.scrollLeft = expand.scrollWidth;
    expand.scrollTop = expand.scrollHeight;
  },

  onScroll: function onScroll() {
    if (this.r) this.cancelFrame(this.r);
    this.r = this.requestFrame(function () {
      var dimensions = this.getDimensions();

      // Ref is gone, just ignore
      if (!dimensions) {
        return;
      }

      if (this.haveDimensionsChanged(dimensions)) {
        this.lastDimensions = dimensions;
        this.props.onResize(dimensions);
      }
    }.bind(this));
  },

  getDimensions: function getDimensions() {
    var el = this.refs.resizable;
    if (!el) {
      return null;
    }

    return {
      width: el.offsetWidth,
      height: el.offsetHeight
    };
  },

  haveDimensionsChanged: function haveDimensionsChanged(dimensions) {
    return dimensions.width != this.lastDimensions.width || dimensions.height != this.lastDimensions.height;
  },

  render: function render() {
    var _props = this.props;
    var triggersClass = _props.triggersClass;
    var expandClass = _props.expandClass;
    var contractClass = _props.contractClass;
    var embedCss = _props.embedCss;
    var onResize = _props.onResize;

    var rest = _objectWithoutProperties(_props, ['triggersClass', 'expandClass', 'contractClass', 'embedCss', 'onResize']);

    var props = objectAssign({}, rest, { onScroll: this.onScroll, ref: 'resizable' });
    return React.createElement('div', props, [this.props.children, React.createElement('div', { className: triggersClass, key: 'trigger' }, [React.createElement('div', { className: expandClass, ref: 'expand', key: 'expand' }, React.createElement('div', { ref: 'expandChild' })), React.createElement('div', { className: contractClass, ref: 'contract', key: 'contract' })]), embedCss ? React.createElement('style', { key: 'embededCss', dangerouslySetInnerHTML: { __html: '.resize-triggers { visibility: hidden; } .resize-triggers, .resize-triggers > div, .contract-trigger:before { content: \" \"; display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; } .resize-triggers > div { background: #eee; overflow: auto; } .contract-trigger:before { width: 200%; height: 200%; }' } }) : null]);
  }

});

module.exports = Resizable;
global.Resizable = Resizable;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object-assign":373,"react":"react"}],795:[function(require,module,exports){
var DragDropContext, H, HTML5Backend, NestableDragDropContext, R, React, ReorderableListComponent, ReorderableListItemComponent, _, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

uuid = require('uuid');

H = React.DOM;

R = React.createElement;

DragDropContext = require('react-dnd').DragDropContext;

HTML5Backend = require('react-dnd-html5-backend');

ReorderableListItemComponent = require("./ReorderableListItemComponent");

NestableDragDropContext = require("../NestableDragDropContext");

ReorderableListComponent = (function(superClass) {
  extend(ReorderableListComponent, superClass);

  ReorderableListComponent.propTypes = {
    items: React.PropTypes.array.isRequired,
    onReorder: React.PropTypes.func.isRequired,
    renderItem: React.PropTypes.func.isRequired,
    listId: React.PropTypes.string,
    getItemId: React.PropTypes.func.isRequired,
    element: React.PropTypes.object
  };

  function ReorderableListComponent() {
    this.fixOrder = bind(this.fixOrder, this);
    this.handleEndDrag = bind(this.handleEndDrag, this);
    this.handlePutAfter = bind(this.handlePutAfter, this);
    this.handlePutBefore = bind(this.handlePutBefore, this);
    ReorderableListComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      order: null,
      listId: this.props.listId ? this.props.listId : uuid()
    };
  }

  ReorderableListComponent.defaultProps = {
    element: H.div(null)
  };

  ReorderableListComponent.prototype.componentWillReceiveProps = function(nextProps) {
    var newOrder, oldOrder;
    newOrder = _.map(nextProps.items, (function(_this) {
      return function(item) {
        return _this.props.getItemId(item);
      };
    })(this));
    oldOrder = _.map(this.props.items, (function(_this) {
      return function(item) {
        return _this.props.getItemId(item);
      };
    })(this));
    if (!_.isEqual(newOrder, oldOrder)) {
      this.setState({
        order: null
      });
    }
    return this.setState({
      listId: nextProps.listId ? nextProps.listId : uuid()
    });
  };

  ReorderableListComponent.prototype.handlePutBefore = function(id, beforeId) {
    var index, order;
    order = _.map(this.props.items, (function(_this) {
      return function(item) {
        return _this.props.getItemId(item);
      };
    })(this));
    order = _.without(order, beforeId);
    index = order.indexOf(id);
    order.splice(index, 0, beforeId);
    if (!_.isEqual(order, this.state.order)) {
      return this.setState({
        order: order
      });
    }
  };

  ReorderableListComponent.prototype.handlePutAfter = function(id, afterId) {
    var index, order;
    order = _.map(this.props.items, (function(_this) {
      return function(item) {
        return _this.props.getItemId(item);
      };
    })(this));
    order = _.without(order, afterId);
    index = order.indexOf(id);
    order.splice(index + 1, 0, afterId);
    if (!_.isEqual(order, this.state.order)) {
      return this.setState({
        order: order
      });
    }
  };

  ReorderableListComponent.prototype.handleEndDrag = function() {
    var order;
    if (!this.state.order) {
      return;
    }
    order = this.state.order.slice();
    this.setState({
      order: null
    });
    return this.props.onReorder(this.fixOrder(this.props.items.slice(), order));
  };

  ReorderableListComponent.prototype.fixOrder = function(items, order) {
    if (!order) {
      return items;
    }
    return items.sort((function(_this) {
      return function(left, right) {
        if (order.indexOf(_this.props.getItemId(left)) < order.indexOf(_this.props.getItemId(right))) {
          return -1;
        }
        if (order.indexOf(_this.props.getItemId(left)) > order.indexOf(_this.props.getItemId(right))) {
          return 1;
        }
        return 0;
      };
    })(this));
  };

  ReorderableListComponent.prototype.render = function() {
    var items;
    items = this.props.items.slice();
    this.fixOrder(items, this.state.order);
    return React.cloneElement(this.props.element, null, _.map(items, (function(_this) {
      return function(item, index) {
        return R(ReorderableListItemComponent, {
          key: _this.props.getItemId(item),
          item: item,
          index: index,
          renderItem: _this.props.renderItem,
          constrainTo: _this.state.listId,
          getItemId: _this.props.getItemId,
          onPutAfter: _this.handlePutAfter,
          onPutBefore: _this.handlePutBefore,
          onEndDrag: _this.handleEndDrag
        });
      };
    })(this)));
  };

  return ReorderableListComponent;

})(React.Component);

module.exports = NestableDragDropContext(HTML5Backend)(ReorderableListComponent);

},{"../NestableDragDropContext":788,"./ReorderableListItemComponent":796,"lodash":"lodash","react":"react","react-dnd":753,"react-dnd-html5-backend":640,"uuid":1007}],796:[function(require,module,exports){
var DragSource, DropTarget, H, R, React, ReactDOM, ReorderableListItemComponent, _, collectSource, collectTarget, itemSource, itemTarget,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ReactDOM = require('react-dom');

DragSource = require('react-dnd').DragSource;

DropTarget = require('react-dnd').DropTarget;

itemTarget = {
  hover: function(props, monitor, component) {
    var clientOffset, hoverBoundingRect, hoverClientY, hoverMiddleY, hoveringId, myId;
    hoveringId = monitor.getItem().id;
    myId = props.getItemId(props.item);
    if (hoveringId === myId) {
      return;
    }
    if (props.constrainTo !== monitor.getItem().constrainTo) {
      return;
    }
    hoverBoundingRect = ReactDOM.findDOMNode(component).getBoundingClientRect();
    hoverMiddleY = (hoverBoundingRect.bottom - hoverBoundingRect.top) / 2;
    clientOffset = monitor.getClientOffset();
    hoverClientY = clientOffset.y - hoverBoundingRect.top;
    if ((hoverClientY < hoverMiddleY) && (hoverClientY < monitor.getItem().height)) {
      props.onPutBefore(myId, hoveringId);
      return;
    }
    if ((hoverClientY > hoverMiddleY) && (hoverClientY > hoverBoundingRect.height - monitor.getItem().height)) {
      props.onPutAfter(myId, hoveringId);
    }
  },
  canDrop: function(props, monitor) {
    return props.constrainTo === monitor.getItem().constrainTo;
  }
};

collectTarget = function(connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver() && monitor.canDrop(),
    canDrop: monitor.canDrop()
  };
};

itemSource = {
  beginDrag: function(props, monitor, component) {
    return {
      id: props.getItemId(props.item),
      constrainTo: props.constrainTo,
      height: ReactDOM.findDOMNode(component).getBoundingClientRect().height
    };
  },
  isDragging: function(props, monitor) {
    return props.getItemId(props.item) === monitor.getItem().id;
  },
  endDrag: function(props, monitor, component) {
    return props.onEndDrag();
  }
};

collectSource = function(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview(),
    isDragging: monitor.isDragging()
  };
};

ReorderableListItemComponent = (function(superClass) {
  extend(ReorderableListItemComponent, superClass);

  function ReorderableListItemComponent() {
    return ReorderableListItemComponent.__super__.constructor.apply(this, arguments);
  }

  ReorderableListItemComponent.propTypes = {
    item: React.PropTypes.object.isRequired,
    isDragging: React.PropTypes.bool.isRequired,
    isOver: React.PropTypes.bool.isRequired,
    canDrop: React.PropTypes.bool.isRequired,
    connectDragSource: React.PropTypes.func.isRequired,
    connectDropTarget: React.PropTypes.func.isRequired,
    connectDragPreview: React.PropTypes.func.isRequired,
    onPutBefore: React.PropTypes.func.isRequired,
    onPutAfter: React.PropTypes.func.isRequired,
    onEndDrag: React.PropTypes.func.isRequired,
    index: React.PropTypes.number.isRequired,
    renderItem: React.PropTypes.func.isRequired,
    constrainTo: React.PropTypes.string.isRequired,
    getItemId: React.PropTypes.func.isRequired
  };

  ReorderableListItemComponent.prototype.render = function() {
    return this.props.renderItem(this.props.item, this.props.index, this.props.connectDragSource, this.props.connectDragPreview, this.props.connectDropTarget);
  };

  return ReorderableListItemComponent;

})(React.Component);

module.exports = _.flow(DragSource("form-item", itemSource, collectSource), DropTarget("form-item", itemTarget, collectTarget))(ReorderableListItemComponent);

},{"lodash":"lodash","react":"react","react-dnd":753,"react-dom":"react-dom"}],797:[function(require,module,exports){
var _, immutable;

_ = require('lodash');

immutable = require('object-path-immutable');

module.exports = function(value, onChange, args) {
  var newValue;
  if (_.isObject(args[0])) {
    newValue = _.extend({}, value, args[0]);
    return onChange(newValue);
  }
  if (args.length === 1) {
    return function(v) {
      newValue = immutable.set(value, args[0], v);
      return onChange(newValue);
    };
  } else if (args.length === 2) {
    newValue = immutable.set(value, args[0], args[1]);
    return onChange(newValue);
  }
};

},{"lodash":"lodash","object-path-immutable":374}],798:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = configAnimation;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

var _raf = require('raf');

var _raf2 = _interopRequireDefault(_raf);

function configAnimation() {
  var config = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
  var _config$timeStep = config.timeStep;
  var timeStep = _config$timeStep === undefined ? 1 / 60 * 1000 : _config$timeStep;
  var _config$timeScale = config.timeScale;
  var timeScale = _config$timeScale === undefined ? 1 : _config$timeScale;
  var _config$maxSteps = config.maxSteps;
  var maxSteps = _config$maxSteps === undefined ? 10 : _config$maxSteps;
  var _config$raf = config.raf;
  var raf = _config$raf === undefined ? _raf2['default'] : _config$raf;
  var _config$now = config.now;
  var now = _config$now === undefined ? _performanceNow2['default'] : _config$now;

  var animRunning = [];
  var running = false;
  var prevTime = 0;
  var accumulatedTime = 0;

  function loop() {
    var currentTime = now();
    var frameTime = currentTime - prevTime; // delta

    prevTime = currentTime;
    accumulatedTime += frameTime * timeScale;

    if (accumulatedTime > timeStep * maxSteps) {
      accumulatedTime = 0;
    }

    var frameNumber = Math.ceil(accumulatedTime / timeStep);
    for (var i = 0; i < animRunning.length; i++) {
      var _animRunning$i = animRunning[i];
      var active = _animRunning$i.active;
      var animationStep = _animRunning$i.animationStep;
      var prevPrevState = _animRunning$i.prevState;
      var prevNextState = animRunning[i].nextState;

      if (!active) {
        continue;
      }

      // Seems like because the TS sets destVals as enterVals for the first
      // tick, we might render that value twice. We render it once, currValue is
      // enterVal and destVal is enterVal. The next tick is faster than 16ms,
      // so accumulatedTime (which would be about -16ms from the previous tick)
      // is negative (-16ms + any number less than 16ms < 0). So we just render
      // part ways towards the nextState, but that's enterVal still. We render
      // say 75% between currValue (=== enterVal) and destValue (=== enterVal).
      // So we render the same value a second time.
      // The solution below is to recalculate the destination state even when
      // you're moving partially towards it.
      if (accumulatedTime <= 0) {
        animRunning[i].nextState = animationStep(timeStep / 1000, prevPrevState);
      } else {
        for (var j = 0; j < frameNumber; j++) {
          animRunning[i].nextState = animationStep(timeStep / 1000, prevNextState);
          var _ref = [prevNextState, animRunning[i].nextState];
          animRunning[i].prevState = _ref[0];
          prevNextState = _ref[1];
        }
      }
    }

    accumulatedTime = accumulatedTime - frameNumber * timeStep;

    // Render and filter in one iteration.
    var alpha = 1 + accumulatedTime / timeStep;
    for (var i = 0; i < animRunning.length; i++) {
      var _animRunning$i2 = animRunning[i];
      var animationRender = _animRunning$i2.animationRender;
      var nextState = _animRunning$i2.nextState;
      var prevState = _animRunning$i2.prevState;

      // Might mutate animRunning........
      animationRender(alpha, nextState, prevState);
    }

    animRunning = animRunning.filter(function (_ref2) {
      var active = _ref2.active;
      return active;
    });

    if (animRunning.length === 0) {
      running = false;
    } else {
      raf(loop);
    }
  }

  function start() {
    if (!running) {
      running = true;
      prevTime = now();
      accumulatedTime = 0;
      raf(loop);
    }
  }

  return function startAnimation(state, animationStep, animationRender) {
    for (var i = 0; i < animRunning.length; i++) {
      var val = animRunning[i];
      if (val.animationStep === animationStep) {
        val.active = true;
        val.prevState = state;
        start();
        return val.stop;
      }
    }

    var newAnim = {
      animationStep: animationStep,
      animationRender: animationRender,
      prevState: state,
      nextState: state,
      active: true
    };

    newAnim.stop = function () {
      return newAnim.active = false;
    };
    animRunning.push(newAnim);

    start();

    return newAnim.stop;
  };
}

module.exports = exports['default'];
},{"performance-now":375,"raf":401}],799:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = components;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _noVelocity = require('./noVelocity');

var _noVelocity2 = _interopRequireDefault(_noVelocity);

var _hasReachedStyle = require('./hasReachedStyle');

var _hasReachedStyle2 = _interopRequireDefault(_hasReachedStyle);

var _mergeDiff = require('./mergeDiff');

var _mergeDiff2 = _interopRequireDefault(_mergeDiff);

var _animationLoop = require('./animationLoop');

var _animationLoop2 = _interopRequireDefault(_animationLoop);

var _zero = require('./zero');

var _zero2 = _interopRequireDefault(_zero);

var _updateTree = require('./updateTree');

var _deprecatedSprings2 = require('./deprecatedSprings');

var _deprecatedSprings3 = _interopRequireDefault(_deprecatedSprings2);

var _stripStyle = require('./stripStyle');

var _stripStyle2 = _interopRequireDefault(_stripStyle);

var startAnimation = _animationLoop2['default']();

function mapObject(f, obj) {
  var ret = {};
  for (var key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = f(obj[key], key);
  }
  return ret;
}

function everyObj(f, obj) {
  for (var key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
}

function components(React) {
  var PropTypes = React.PropTypes;

  var Motion = React.createClass({
    displayName: 'Motion',

    propTypes: {
      // TOOD: warn against putting a config in here
      defaultValue: function defaultValue(prop, propName) {
        if (prop[propName]) {
          return new Error('Spring\'s `defaultValue` has been changed to `defaultStyle`. ' + 'Its format received a few (easy to update!) changes as well.');
        }
      },
      endValue: function endValue(prop, propName) {
        if (prop[propName]) {
          return new Error('Spring\'s `endValue` has been changed to `style`. Its format ' + 'received a few (easy to update!) changes as well.');
        }
      },
      defaultStyle: PropTypes.object,
      style: PropTypes.object.isRequired,
      children: PropTypes.func.isRequired
    },

    getInitialState: function getInitialState() {
      var _props = this.props;
      var defaultStyle = _props.defaultStyle;
      var style = _props.style;

      var currentStyle = defaultStyle || style;
      return {
        currentStyle: currentStyle,
        currentVelocity: mapObject(_zero2['default'], currentStyle)
      };
    },

    componentDidMount: function componentDidMount() {
      this.startAnimating();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {
      this.startAnimating();
    },

    animationStep: function animationStep(timestep, state) {
      var currentStyle = state.currentStyle;
      var currentVelocity = state.currentVelocity;
      var style = this.props.style;

      var newCurrentStyle = _updateTree.updateCurrentStyle(timestep, currentStyle, currentVelocity, style);
      var newCurrentVelocity = _updateTree.updateCurrentVelocity(timestep, currentStyle, currentVelocity, style);

      // TOOD: this isn't necessary anymore. It was used only against endValue func
      if (_noVelocity2['default'](currentVelocity, newCurrentStyle) && _noVelocity2['default'](newCurrentVelocity, newCurrentStyle)) {
        // check explanation in `Motion.animationRender`
        this.stopAnimation(); // Nasty side effects....
      }

      return {
        currentStyle: newCurrentStyle,
        currentVelocity: newCurrentVelocity
      };
    },

    stopAnimation: null,

    // used in animationRender
    hasUnmounted: false,

    componentWillUnmount: function componentWillUnmount() {
      this.stopAnimation();
      this.hasUnmounted = true;
    },

    startAnimating: function startAnimating() {
      // Is smart enough to not start it twice
      this.stopAnimation = startAnimation(this.state, this.animationStep, this.animationRender);
    },

    animationRender: function animationRender(alpha, nextState, prevState) {
      // `this.hasUnmounted` might be true in the following condition:
      // user does some checks in `style` and calls an owner handler
      // owner sets state in the callback, triggering a re-render
      // unmounts Motion
      if (!this.hasUnmounted) {
        this.setState({
          currentStyle: _updateTree.interpolateValue(alpha, nextState.currentStyle, prevState.currentStyle),
          currentVelocity: nextState.currentVelocity
        });
      }
    },

    render: function render() {
      var strippedStyle = _stripStyle2['default'](this.state.currentStyle);
      var renderedChildren = this.props.children(strippedStyle);
      return renderedChildren && React.Children.only(renderedChildren);
    }
  });

  var StaggeredMotion = React.createClass({
    displayName: 'StaggeredMotion',

    propTypes: {
      defaultStyle: function defaultStyle(prop, propName) {
        if (prop[propName]) {
          return new Error('You forgot the "s" for `StaggeredMotion`\'s `defaultStyles`.');
        }
      },
      style: function style(prop, propName) {
        if (prop[propName]) {
          return new Error('You forgot the "s" for `StaggeredMotion`\'s `styles`.');
        }
      },
      // TOOD: warn against putting configs in here
      defaultStyles: PropTypes.arrayOf(PropTypes.object),
      styles: PropTypes.func.isRequired,
      children: PropTypes.func.isRequired
    },

    getInitialState: function getInitialState() {
      var _props2 = this.props;
      var styles = _props2.styles;
      var defaultStyles = _props2.defaultStyles;

      var currentStyles = defaultStyles ? defaultStyles : styles();
      return {
        currentStyles: currentStyles,
        currentVelocities: currentStyles.map(function (s) {
          return mapObject(_zero2['default'], s);
        })
      };
    },

    componentDidMount: function componentDidMount() {
      this.startAnimating();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {
      this.startAnimating();
    },

    animationStep: function animationStep(timestep, state) {
      var currentStyles = state.currentStyles;
      var currentVelocities = state.currentVelocities;

      var styles = this.props.styles(currentStyles.map(_stripStyle2['default']));

      var newCurrentStyles = currentStyles.map(function (currentStyle, i) {
        return _updateTree.updateCurrentStyle(timestep, currentStyle, currentVelocities[i], styles[i]);
      });
      var newCurrentVelocities = currentStyles.map(function (currentStyle, i) {
        return _updateTree.updateCurrentVelocity(timestep, currentStyle, currentVelocities[i], styles[i]);
      });

      // TODO: is this right?
      if (currentVelocities.every(function (v, k) {
        return _noVelocity2['default'](v, currentStyles[k]);
      }) && newCurrentVelocities.every(function (v, k) {
        return _noVelocity2['default'](v, newCurrentStyles[k]);
      })) {
        this.stopAnimation();
      }

      return {
        currentStyles: newCurrentStyles,
        currentVelocities: newCurrentVelocities
      };
    },

    stopAnimation: null,

    // used in animationRender
    hasUnmounted: false,

    componentWillUnmount: function componentWillUnmount() {
      this.stopAnimation();
      this.hasUnmounted = true;
    },

    startAnimating: function startAnimating() {
      this.stopAnimation = startAnimation(this.state, this.animationStep, this.animationRender);
    },

    animationRender: function animationRender(alpha, nextState, prevState) {
      // See comment in Motion.
      if (!this.hasUnmounted) {
        var currentStyles = nextState.currentStyles.map(function (style, i) {
          return _updateTree.interpolateValue(alpha, style, prevState.currentStyles[i]);
        });
        this.setState({
          currentStyles: currentStyles,
          currentVelocities: nextState.currentVelocities
        });
      }
    },

    render: function render() {
      var strippedStyle = this.state.currentStyles.map(_stripStyle2['default']);
      var renderedChildren = this.props.children(strippedStyle);
      return renderedChildren && React.Children.only(renderedChildren);
    }
  });

  var TransitionMotion = React.createClass({
    displayName: 'TransitionMotion',

    propTypes: {
      defaultValue: function defaultValue(prop, propName) {
        if (prop[propName]) {
          return new Error('TransitionSpring\'s `defaultValue` has been changed to ' + '`defaultStyles`. Its format received a few (easy to update!) ' + 'changes as well.');
        }
      },
      endValue: function endValue(prop, propName) {
        if (prop[propName]) {
          return new Error('TransitionSpring\'s `endValue` has been changed to `styles`. ' + 'Its format received a few (easy to update!) changes as well.');
        }
      },
      defaultStyle: function defaultStyle(prop, propName) {
        if (prop[propName]) {
          return new Error('You forgot the "s" for `TransitionMotion`\'s `defaultStyles`.');
        }
      },
      style: function style(prop, propName) {
        if (prop[propName]) {
          return new Error('You forgot the "s" for `TransitionMotion`\'s `styles`.');
        }
      },
      // TOOD: warn against putting configs in here
      defaultStyles: PropTypes.objectOf(PropTypes.any),
      styles: PropTypes.oneOfType([PropTypes.func, PropTypes.objectOf(PropTypes.any.isRequired)]).isRequired,
      willLeave: PropTypes.oneOfType([PropTypes.func]),
      // TOOD: warn against putting configs in here
      willEnter: PropTypes.oneOfType([PropTypes.func]),
      children: PropTypes.func.isRequired
    },

    getDefaultProps: function getDefaultProps() {
      return {
        willEnter: function willEnter(key, value) {
          return value;
        },
        willLeave: function willLeave() {
          return null;
        }
      };
    },

    getInitialState: function getInitialState() {
      var _props3 = this.props;
      var styles = _props3.styles;
      var defaultStyles = _props3.defaultStyles;

      var currentStyles = undefined;
      if (defaultStyles == null) {
        if (typeof styles === 'function') {
          currentStyles = styles();
        } else {
          currentStyles = styles;
        }
      } else {
        currentStyles = defaultStyles;
      }
      return {
        currentStyles: currentStyles,
        currentVelocities: mapObject(function (s) {
          return mapObject(_zero2['default'], s);
        }, currentStyles)
      };
    },

    componentDidMount: function componentDidMount() {
      this.startAnimating();
    },

    componentWillReceiveProps: function componentWillReceiveProps() {
      this.startAnimating();
    },

    animationStep: function animationStep(timestep, state) {
      var currentStyles = state.currentStyles;
      var currentVelocities = state.currentVelocities;
      var _props4 = this.props;
      var styles = _props4.styles;
      var willEnter = _props4.willEnter;
      var willLeave = _props4.willLeave;

      if (typeof styles === 'function') {
        styles = styles(currentStyles);
      }

      // TODO: huh?
      var mergedStyles = styles; // set mergedStyles to styles as the default
      var hasNewKey = false;

      mergedStyles = _mergeDiff2['default'](currentStyles, styles,
      // TODO: stop allocating like crazy in this whole code path
      function (key) {
        var res = willLeave(key, currentStyles[key], styles, currentStyles, currentVelocities);
        if (res == null) {
          // For legacy reason. We won't allow returning null soon
          // TODO: remove, after next release
          return null;
        }

        if (_noVelocity2['default'](currentVelocities[key], currentStyles[key]) && _hasReachedStyle2['default'](currentStyles[key], res)) {
          return null;
        }
        return res;
      });

      Object.keys(mergedStyles).filter(function (key) {
        return !currentStyles.hasOwnProperty(key);
      }).forEach(function (key) {
        var _extends2, _extends3;

        hasNewKey = true;
        var enterStyle = willEnter(key, mergedStyles[key], styles, currentStyles, currentVelocities);

        // We can mutate this here because mergeDiff returns a new Obj
        mergedStyles[key] = enterStyle;

        currentStyles = _extends({}, currentStyles, (_extends2 = {}, _extends2[key] = enterStyle, _extends2));
        currentVelocities = _extends({}, currentVelocities, (_extends3 = {}, _extends3[key] = mapObject(_zero2['default'], enterStyle), _extends3));
      });

      var newCurrentStyles = mapObject(function (mergedStyle, key) {
        return _updateTree.updateCurrentStyle(timestep, currentStyles[key], currentVelocities[key], mergedStyle);
      }, mergedStyles);
      var newCurrentVelocities = mapObject(function (mergedStyle, key) {
        return _updateTree.updateCurrentVelocity(timestep, currentStyles[key], currentVelocities[key], mergedStyle);
      }, mergedStyles);

      if (!hasNewKey && everyObj(function (v, k) {
        return _noVelocity2['default'](v, currentStyles[k]);
      }, currentVelocities) && everyObj(function (v, k) {
        return _noVelocity2['default'](v, newCurrentStyles[k]);
      }, newCurrentVelocities)) {
        // check explanation in `Motion.animationRender`
        this.stopAnimation(); // Nasty side effects....
      }

      return {
        currentStyles: newCurrentStyles,
        currentVelocities: newCurrentVelocities
      };
    },

    stopAnimation: null,

    // used in animationRender
    hasUnmounted: false,

    componentWillUnmount: function componentWillUnmount() {
      this.stopAnimation();
      this.hasUnmounted = true;
    },

    startAnimating: function startAnimating() {
      this.stopAnimation = startAnimation(this.state, this.animationStep, this.animationRender);
    },

    animationRender: function animationRender(alpha, nextState, prevState) {
      // See comment in Motion.
      if (!this.hasUnmounted) {
        var currentStyles = mapObject(function (style, key) {
          return _updateTree.interpolateValue(alpha, style, prevState.currentStyles[key]);
        }, nextState.currentStyles);
        this.setState({
          currentStyles: currentStyles,
          currentVelocities: nextState.currentVelocities
        });
      }
    },

    render: function render() {
      var strippedStyle = mapObject(_stripStyle2['default'], this.state.currentStyles);
      var renderedChildren = this.props.children(strippedStyle);
      return renderedChildren && React.Children.only(renderedChildren);
    }
  });

  var _deprecatedSprings = _deprecatedSprings3['default'](React);

  var Spring = _deprecatedSprings.Spring;
  var TransitionSpring = _deprecatedSprings.TransitionSpring;

  return { Spring: Spring, TransitionSpring: TransitionSpring, Motion: Motion, StaggeredMotion: StaggeredMotion, TransitionMotion: TransitionMotion };
}

module.exports = exports['default'];
},{"./animationLoop":798,"./deprecatedSprings":800,"./hasReachedStyle":801,"./mergeDiff":802,"./noVelocity":803,"./stripStyle":809,"./updateTree":810,"./zero":811}],800:[function(require,module,exports){
(function (process){
'use strict';

exports.__esModule = true;
exports['default'] = deprecatedSprings;
var hasWarnedForSpring = {};
var hasWarnedForTransitionSpring = {};

function deprecatedSprings(React) {
  var Spring = React.createClass({
    displayName: 'Spring',

    componentWillMount: function componentWillMount() {
      if (process.env.NODE_ENV === 'development') {
        var ownerName = this._reactInternalInstance._currentElement._owner && this._reactInternalInstance._currentElement._owner.getName();
        if (!hasWarnedForSpring[ownerName]) {
          hasWarnedForSpring[ownerName] = true;
          console.error('Spring (used in %srender) has now been renamed to Motion. ' + 'Please see the release note for the upgrade path. Thank you!', ownerName ? ownerName + '\'s ' : 'React.');
        }
      }
    },

    render: function render() {
      return null;
    }
  });

  var TransitionSpring = React.createClass({
    displayName: 'TransitionSpring',

    componentWillMount: function componentWillMount() {
      if (process.env.NODE_ENV === 'development') {
        var ownerName = this._reactInternalInstance._currentElement._owner && this._reactInternalInstance._currentElement._owner.getName();
        if (!hasWarnedForTransitionSpring[ownerName]) {
          hasWarnedForTransitionSpring[ownerName] = true;
          console.error('TransitionSpring (used in %srender) has now been renamed to ' + 'TransitionMotion. Please see the release note for the upgrade ' + 'path. Thank you!', ownerName ? ownerName + '\'s ' : 'React.');
        }
      }
    },

    render: function render() {
      return null;
    }
  });

  return { Spring: Spring, TransitionSpring: TransitionSpring };
}

module.exports = exports['default'];
}).call(this,require('_process'))
},{"_process":395}],801:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = hasReachedStyle;

function hasReachedStyle(currentStyle, style) {
  for (var key in style) {
    if (!style.hasOwnProperty(key)) {
      continue;
    }
    var currentValue = currentStyle[key];
    var destValue = style[key];
    if (destValue == null || !destValue.config) {
      // not a spring config
      continue;
    }
    if (currentValue.config && currentValue.val !== destValue.val) {
      return false;
    }
    if (!currentValue.config && currentValue !== destValue.val) {
      return false;
    }
  }

  return true;
}

module.exports = exports['default'];
},{}],802:[function(require,module,exports){


// this function is allocation-less thanks to babel, which transforms the tail
// calls into loops
'use strict';

exports.__esModule = true;
exports['default'] = mergeDiff;
function mergeDiffArr(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
  var _again = true;

  _function: while (_again) {
    var arrA = _x,
        arrB = _x2,
        collB = _x3,
        indexA = _x4,
        indexB = _x5,
        onRemove = _x6,
        accum = _x7;
    endA = endB = keyA = keyB = fill = fill = undefined;
    _again = false;

    var endA = indexA === arrA.length;
    var endB = indexB === arrB.length;
    var keyA = arrA[indexA];
    var keyB = arrB[indexB];
    if (endA && endB) {
      // returning null here, otherwise lint complains that we're not expecting
      // a return value in subsequent calls. We know what we're doing.
      return null;
    }

    if (endA) {
      accum[keyB] = collB[keyB];
      _x = arrA;
      _x2 = arrB;
      _x3 = collB;
      _x4 = indexA;
      _x5 = indexB + 1;
      _x6 = onRemove;
      _x7 = accum;
      _again = true;
      continue _function;
    }

    if (endB) {
      var fill = onRemove(keyA);
      if (fill != null) {
        accum[keyA] = fill;
      }
      _x = arrA;
      _x2 = arrB;
      _x3 = collB;
      _x4 = indexA + 1;
      _x5 = indexB;
      _x6 = onRemove;
      _x7 = accum;
      _again = true;
      continue _function;
    }

    if (keyA === keyB) {
      accum[keyA] = collB[keyA];
      _x = arrA;
      _x2 = arrB;
      _x3 = collB;
      _x4 = indexA + 1;
      _x5 = indexB + 1;
      _x6 = onRemove;
      _x7 = accum;
      _again = true;
      continue _function;
    }

    if (!collB.hasOwnProperty(keyA)) {
      var fill = onRemove(keyA);
      if (fill != null) {
        accum[keyA] = fill;
      }
      _x = arrA;
      _x2 = arrB;
      _x3 = collB;
      _x4 = indexA + 1;
      _x5 = indexB;
      _x6 = onRemove;
      _x7 = accum;
      _again = true;
      continue _function;
    }

    _x = arrA;
    _x2 = arrB;
    _x3 = collB;
    _x4 = indexA + 1;
    _x5 = indexB;
    _x6 = onRemove;
    _x7 = accum;
    _again = true;
    continue _function;
  }
}

function mergeDiff(a, b, onRemove) {
  var ret = {};
  // if anyone can make this work without allocating the arrays here, we'll
  // give you a medal
  mergeDiffArr(Object.keys(a), Object.keys(b), b, 0, 0, onRemove, ret);
  return ret;
}

module.exports = exports['default'];
},{}],803:[function(require,module,exports){

// currentStyle keeps the info about whether a prop is configured as a spring
// or if it's just a random prop that happens to be present on the style

'use strict';

exports.__esModule = true;
exports['default'] = noVelocity;

function noVelocity(currentVelocity, currentStyle) {
  for (var key in currentVelocity) {
    if (!currentVelocity.hasOwnProperty(key)) {
      continue;
    }
    if (currentStyle[key] != null && currentStyle[key].config && currentVelocity[key] !== 0) {
      return false;
    }
  }
  return true;
}

module.exports = exports['default'];
},{}],804:[function(require,module,exports){

// [stiffness, damping]
"use strict";

exports.__esModule = true;
exports["default"] = {
  noWobble: [170, 26], // the default
  gentle: [120, 14],
  wobbly: [180, 12],
  stiff: [210, 20]
};
module.exports = exports["default"];
},{}],805:[function(require,module,exports){
'use strict';

exports.__esModule = true;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _components2 = require('./components');

var _components3 = _interopRequireDefault(_components2);

var _reorderKeys = require('./reorderKeys');

var _reorderKeys2 = _interopRequireDefault(_reorderKeys);

var _components = _components3['default'](_react2['default']);

var Spring = _components.Spring;
var TransitionSpring = _components.TransitionSpring;
var Motion = _components.Motion;
var StaggeredMotion = _components.StaggeredMotion;
var TransitionMotion = _components.TransitionMotion;
exports.Spring = Spring;
exports.TransitionSpring = TransitionSpring;
exports.Motion = Motion;
exports.StaggeredMotion = StaggeredMotion;
exports.TransitionMotion = TransitionMotion;

var _spring2 = require('./spring');

var _spring3 = _interopRequireDefault(_spring2);

exports.spring = _spring3['default'];

var _presets2 = require('./presets');

var _presets3 = _interopRequireDefault(_presets2);

exports.presets = _presets3['default'];
var utils = {
  reorderKeys: _reorderKeys2['default']
};
exports.utils = utils;
},{"./components":799,"./presets":804,"./reorderKeys":806,"./spring":807,"react":"react"}],806:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = reorderKeys;

function reorderKeys(obj, f) {
  var newKeys = f(Object.keys(obj));
  var ret = {};
  for (var i = 0; i < newKeys.length; i++) {
    var key = newKeys[i];
    ret[key] = obj[key];
  }

  return ret;
}

module.exports = exports["default"];
},{}],807:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = spring;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _presets = require('./presets');

var _presets2 = _interopRequireDefault(_presets);

function spring(val) {
  var config = arguments.length <= 1 || arguments[1] === undefined ? _presets2['default'].noWobble : arguments[1];

  return { val: val, config: config };
}

module.exports = exports['default'];
},{"./presets":804}],808:[function(require,module,exports){
"use strict";

exports.__esModule = true;
exports["default"] = stepper;

var errorMargin = 0.0001;

function stepper(frameRate, x, v, destX, k, b) {
  // Spring stiffness, in kg / s^2

  // for animations, destX is really spring length (spring at rest). initial
  // position is considered as the stretched/compressed position of a spring
  var Fspring = -k * (x - destX);

  // Damping, in kg / s
  var Fdamper = -b * v;

  // usually we put mass here, but for animation purposes, specifying mass is a
  // bit redundant. you could simply adjust k and b accordingly
  // let a = (Fspring + Fdamper) / mass;
  var a = Fspring + Fdamper;

  var newV = v + a * frameRate;
  var newX = x + newV * frameRate;

  if (Math.abs(newV - v) < errorMargin && Math.abs(newX - x) < errorMargin) {
    return [destX, 0];
  }

  return [newX, newV];
}

module.exports = exports["default"];
},{}],809:[function(require,module,exports){

// turn {x: {val: 1, config: [1, 2]}, y: 2} generated by
// `{x: spring(1, [1, 2]), y: 2}` into {x: 1, y: 2}

'use strict';

exports.__esModule = true;
exports['default'] = stripStyle;

function stripStyle(style) {
  var ret = {};
  for (var key in style) {
    if (!style.hasOwnProperty(key)) {
      continue;
    }
    ret[key] = style[key] == null || style[key].val == null ? style[key] : style[key].val;
  }
  return ret;
}

module.exports = exports['default'];
},{}],810:[function(require,module,exports){


// TODO: refactor common logic with updateCurrValue and updateCurrVelocity
'use strict';

exports.__esModule = true;
exports.interpolateValue = interpolateValue;
exports.updateCurrentStyle = updateCurrentStyle;
exports.updateCurrentVelocity = updateCurrentVelocity;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _stepper = require('./stepper');

var _stepper2 = _interopRequireDefault(_stepper);

var _spring = require('./spring');

var _spring2 = _interopRequireDefault(_spring);

function interpolateValue(alpha, nextStyle, prevStyle) {
  // might be used by a TransitionMotion, where prevStyle might not exist anymore
  if (!prevStyle) {
    return nextStyle;
  }

  var ret = {};
  for (var key in nextStyle) {
    if (!nextStyle.hasOwnProperty(key)) {
      continue;
    }

    if (nextStyle[key] == null || !nextStyle[key].config) {
      ret[key] = nextStyle[key];
      // not a spring config, not something we want to interpolate
      continue;
    }
    var prevValue = prevStyle[key].config ? prevStyle[key].val : prevStyle[key];
    ret[key] = _spring2['default'](nextStyle[key].val * alpha + prevValue * (1 - alpha), nextStyle[key].config);
  }

  return ret;
}

// TODO: refactor common logic with updateCurrentVelocity

function updateCurrentStyle(frameRate, currentStyle, currentVelocity, style) {
  var ret = {};
  for (var key in style) {
    if (!style.hasOwnProperty(key)) {
      continue;
    }
    if (style[key] == null || !style[key].config) {
      ret[key] = style[key];
      // not a spring config, not something we want to interpolate
      continue;
    }
    var _style$key$config = style[key].config;
    var k = _style$key$config[0];
    var b = _style$key$config[1];

    var val = _stepper2['default'](frameRate,
    // might have been a non-springed prop that just became one
    currentStyle[key].val == null ? currentStyle[key] : currentStyle[key].val, currentVelocity[key], style[key].val, k, b)[0];
    ret[key] = _spring2['default'](val, style[key].config);
  }
  return ret;
}

function updateCurrentVelocity(frameRate, currentStyle, currentVelocity, style) {
  var ret = {};
  for (var key in style) {
    if (!style.hasOwnProperty(key)) {
      continue;
    }
    if (style[key] == null || !style[key].config) {
      // not a spring config, not something we want to interpolate
      ret[key] = 0;
      continue;
    }
    var _style$key$config2 = style[key].config;
    var k = _style$key$config2[0];
    var b = _style$key$config2[1];

    var val = _stepper2['default'](frameRate,
    // might have been a non-springed prop that just became one
    currentStyle[key].val == null ? currentStyle[key] : currentStyle[key].val, currentVelocity[key], style[key].val, k, b)[1];
    ret[key] = val;
  }
  return ret;
}
},{"./spring":807,"./stepper":808}],811:[function(require,module,exports){

// used by the tree-walking updates and springs. Avoids some allocations
"use strict";

exports.__esModule = true;
exports["default"] = zero;

function zero() {
  return 0;
}

module.exports = exports["default"];
},{}],812:[function(require,module,exports){
'use strict';

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');
var ReactDOM = require('react-dom');

var ClickOutComponent = (function (_React$Component) {
  _inherits(ClickOutComponent, _React$Component);

  function ClickOutComponent() {
    _classCallCheck(this, ClickOutComponent);

    _get(Object.getPrototypeOf(ClickOutComponent.prototype), 'constructor', this).call(this);
  }

  _createClass(ClickOutComponent, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var self = this;
      var el = ReactDOM.findDOMNode(this);

      self.__windowListener = function (e) {
        if ((e.__clickedElements || []).indexOf(el) !== -1) return;

        var clickOutHandler = self.onClickOut || self.props.onClickOut;
        if (!clickOutHandler) {
          return console.warn('onClickOut is not defined.');
        }

        clickOutHandler.call(self, e);
      };

      self.__elementListener = function (e) {
        e.__clickedElements = e.__clickedElements || [];
        e.__clickedElements.push(el);
      };

      setTimeout(function () {
        if (self.__unmounted) return;
        window.addEventListener('click', self.__windowListener);
        el.addEventListener('click', self.__elementListener);
      }, 0);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      window.removeEventListener('click', this.__windowListener);
      ReactDOM.findDOMNode(this).removeEventListener('click', this.__elementListener);
      this.__unmounted = true;
    }
  }, {
    key: 'render',
    value: function render() {
      return Array.isArray(this.props.children) ? React.createElement(
        'div',
        null,
        this.props.children
      ) : React.Children.only(this.props.children);
    }
  }]);

  return ClickOutComponent;
})(React.Component);

module.exports = ClickOutComponent;

},{"react":"react","react-dom":"react-dom"}],813:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _createChainableTypeChecker = require('./utils/createChainableTypeChecker');

var _createChainableTypeChecker2 = _interopRequireDefault(_createChainableTypeChecker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(props, propName, componentName, location, propFullName) {
  var propValue = props[propName];
  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);

  if (_react2.default.isValidElement(propValue)) {
    return new Error('Invalid ' + location + ' `' + propFullName + '` of type ReactElement ' + ('supplied to `' + componentName + '`, expected a ReactComponent or a ') + 'DOMElement. You can usually obtain a ReactComponent or DOMElement ' + 'from a ReactElement by attaching a ref to it.');
  }

  if ((propType !== 'object' || typeof propValue.render !== 'function') && propValue.nodeType !== 1) {
    return new Error('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected a ReactComponent or a ') + 'DOMElement.');
  }

  return null;
}

exports.default = (0, _createChainableTypeChecker2.default)(validate);
},{"./utils/createChainableTypeChecker":816,"react":"react"}],814:[function(require,module,exports){
'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _createChainableTypeChecker = require('./utils/createChainableTypeChecker');

var _createChainableTypeChecker2 = _interopRequireDefault(_createChainableTypeChecker);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function elementType(props, propName, componentName, location, propFullName) {
  var propValue = props[propName];
  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);

  if (_react2.default.isValidElement(propValue)) {
    return new Error('Invalid ' + location + ' `' + propFullName + '` of type ReactElement ' + ('supplied to `' + componentName + '`, expected an element type (a string ') + 'or a ReactClass).');
  }

  if (propType !== 'function' && propType !== 'string') {
    return new Error('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected an element type (a string ') + 'or a ReactClass).');
  }

  return null;
}

exports.default = (0, _createChainableTypeChecker2.default)(elementType);
},{"./utils/createChainableTypeChecker":816,"react":"react"}],815:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = isRequiredForA11y;
function isRequiredForA11y(validator) {
  return function validate(props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    if (props[propName] == null) {
      return new Error('The ' + location + ' `' + propFullNameSafe + '` is required to make ' + ('`' + componentNameSafe + '` accessible for users of assistive ') + 'technologies such as screen readers.');
    }

    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {
      args[_key - 5] = arguments[_key];
    }

    return validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));
  };
}
},{}],816:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.default = createChainableTypeChecker;
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

// Mostly taken from ReactPropTypes.

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName) {
    var componentNameSafe = componentName || '<<anonymous>>';
    var propFullNameSafe = propFullName || propName;

    if (props[propName] == null) {
      if (isRequired) {
        return new Error('Required ' + location + ' `' + propFullNameSafe + '` was not specified ' + ('in `' + componentNameSafe + '`.'));
      }

      return null;
    }

    for (var _len = arguments.length, args = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
      args[_key - 6] = arguments[_key];
    }

    return validate.apply(undefined, [props, propName, componentNameSafe, location, propFullNameSafe].concat(args));
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}
},{}],817:[function(require,module,exports){
'use strict';

var React = require('react');
var classes = require('classnames');

var Option = React.createClass({
	displayName: 'Option',

	propTypes: {
		addLabelText: React.PropTypes.string, // string rendered in case of allowCreate option passed to ReactSelect
		className: React.PropTypes.string, // className (based on mouse position)
		mouseDown: React.PropTypes.func, // method to handle click on option element
		mouseEnter: React.PropTypes.func, // method to handle mouseEnter on option element
		mouseLeave: React.PropTypes.func, // method to handle mouseLeave on option element
		option: React.PropTypes.object.isRequired, // object that is base for that option
		renderFunc: React.PropTypes.func // method passed to ReactSelect component to render label text
	},
	blockEvent: function blockEvent(event) {
		event.preventDefault();
		if (event.target.tagName !== 'A' || !('href' in event.target)) {
			return;
		}

		if (event.target.target) {
			window.open(event.target.href);
		} else {
			window.location.href = event.target.href;
		}
	},
	handleMouseDown: function handleMouseDown(e) {
		this.props.mouseDown(this.props.option, e);
	},
	handleMouseEnter: function handleMouseEnter(e) {
		this.props.mouseEnter(this.props.option, e);
	},
	handleMouseLeave: function handleMouseLeave(e) {
		this.props.mouseLeave(this.props.option, e);
	},
	render: function render() {
		var option = this.props.option;
		var label = option.create ? this.props.addLabelText.replace('{label}', option.label) : this.props.renderFunc(option);
		var optionClasses = classes(this.props.className, option.className);

		return option.disabled ? React.createElement(
			'div',
			{ className: optionClasses,
				onMouseDown: this.blockEvent,
				onClick: this.blockEvent },
			label
		) : React.createElement(
			'div',
			{ className: optionClasses,
				style: option.style,
				onMouseDown: this.handleMouseDown,
				onMouseEnter: this.handleMouseEnter,
				onMouseLeave: this.handleMouseLeave,
				onClick: this.handleMouseDown,
				title: option.title },
			label
		);
	}
});

module.exports = Option;
},{"classnames":118,"react":"react"}],818:[function(require,module,exports){
/* disable some rules until we refactor more completely; fixing them now would
   cause conflicts with some open PRs unnecessarily. */
/* eslint react/jsx-sort-prop-types: 0, react/sort-comp: 0, react/prop-types: 0 */

'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var React = require('react');
var ReactDOM = require('react-dom');
var Input = require('react-input-autosize');
var classes = require('classnames');
var Value = require('./Value');
var SingleValue = require('./SingleValue');
var Option = require('./Option');

var requestId = 0;

var Select = React.createClass({

	displayName: 'Select',

	propTypes: {
		addLabelText: React.PropTypes.string, // placeholder displayed when you want to add a label on a multi-value input
		allowCreate: React.PropTypes.bool, // whether to allow creation of new entries
		asyncOptions: React.PropTypes.func, // function to call to get options
		autoload: React.PropTypes.bool, // whether to auto-load the default async options set
		backspaceRemoves: React.PropTypes.bool, // whether backspace removes an item if there is no text input
		cacheAsyncResults: React.PropTypes.bool, // whether to allow cache
		className: React.PropTypes.string, // className for the outer element
		clearAllText: React.PropTypes.string, // title for the "clear" control when multi: true
		clearValueText: React.PropTypes.string, // title for the "clear" control
		clearable: React.PropTypes.bool, // should it be possible to reset value
		delimiter: React.PropTypes.string, // delimiter to use to join multiple values
		disabled: React.PropTypes.bool, // whether the Select is disabled or not
		filterOption: React.PropTypes.func, // method to filter a single option  (option, filterString)
		filterOptions: React.PropTypes.func, // method to filter the options array: function ([options], filterString, [values])
		ignoreCase: React.PropTypes.bool, // whether to perform case-insensitive filtering
		inputProps: React.PropTypes.object, // custom attributes for the Input (in the Select-control) e.g: {'data-foo': 'bar'}
		isLoading: React.PropTypes.bool, // whether the Select is loading externally or not (such as options being loaded)
		labelKey: React.PropTypes.string, // path of the label value in option objects
		matchPos: React.PropTypes.string, // (any|start) match the start or entire string when filtering
		matchProp: React.PropTypes.string, // (any|label|value) which option property to filter on
		multi: React.PropTypes.bool, // multi-value input
		name: React.PropTypes.string, // field name, for hidden <input /> tag
		newOptionCreator: React.PropTypes.func, // factory to create new options when allowCreate set
		noResultsText: React.PropTypes.string, // placeholder displayed when there are no matching search results
		onBlur: React.PropTypes.func, // onBlur handler: function (event) {}
		onChange: React.PropTypes.func, // onChange handler: function (newValue) {}
		onFocus: React.PropTypes.func, // onFocus handler: function (event) {}
		onInputChange: React.PropTypes.func, // onInputChange handler: function (inputValue) {}
		onOptionLabelClick: React.PropTypes.func, // onCLick handler for value labels: function (value, event) {}
		optionComponent: React.PropTypes.func, // option component to render in dropdown
		optionRenderer: React.PropTypes.func, // optionRenderer: function (option) {}
		options: React.PropTypes.array, // array of options
		placeholder: React.PropTypes.string, // field placeholder, displayed when there's no value
		searchable: React.PropTypes.bool, // whether to enable searching feature or not
		searchingText: React.PropTypes.string, // message to display whilst options are loading via asyncOptions
		searchPromptText: React.PropTypes.string, // label to prompt for search input
		singleValueComponent: React.PropTypes.func, // single value component when multiple is set to false
		value: React.PropTypes.any, // initial field value
		valueComponent: React.PropTypes.func, // value component to render in multiple mode
		valueKey: React.PropTypes.string, // path of the label value in option objects
		valueRenderer: React.PropTypes.func // valueRenderer: function (option) {}
	},

	getDefaultProps: function getDefaultProps() {
		return {
			addLabelText: 'Add "{label}"?',
			allowCreate: false,
			asyncOptions: undefined,
			autoload: true,
			backspaceRemoves: true,
			cacheAsyncResults: true,
			className: undefined,
			clearAllText: 'Clear all',
			clearValueText: 'Clear value',
			clearable: true,
			delimiter: ',',
			disabled: false,
			ignoreCase: true,
			inputProps: {},
			isLoading: false,
			labelKey: 'label',
			matchPos: 'any',
			matchProp: 'any',
			name: undefined,
			newOptionCreator: undefined,
			noResultsText: 'No results found',
			onChange: undefined,
			onInputChange: undefined,
			onOptionLabelClick: undefined,
			optionComponent: Option,
			options: undefined,
			placeholder: 'Select...',
			searchable: true,
			searchingText: 'Searching...',
			searchPromptText: 'Type to search',
			singleValueComponent: SingleValue,
			value: undefined,
			valueComponent: Value,
			valueKey: 'value'
		};
	},

	getInitialState: function getInitialState() {
		return {
			/*
    * set by getStateFromValue on componentWillMount:
    * - value
    * - values
    * - filteredOptions
    * - inputValue
    * - placeholder
    * - focusedOption
   */
			isFocused: false,
			isLoading: false,
			isOpen: false,
			options: this.props.options
		};
	},

	componentWillMount: function componentWillMount() {
		var _this = this;

		this._optionsCache = {};
		this._optionsFilterString = '';
		this._closeMenuIfClickedOutside = function (event) {
			if (!_this.state.isOpen) {
				return;
			}
			var menuElem = ReactDOM.findDOMNode(_this.refs.selectMenuContainer);
			var controlElem = ReactDOM.findDOMNode(_this.refs.control);

			var eventOccuredOutsideMenu = _this.clickedOutsideElement(menuElem, event);
			var eventOccuredOutsideControl = _this.clickedOutsideElement(controlElem, event);

			// Hide dropdown menu if click occurred outside of menu
			if (eventOccuredOutsideMenu && eventOccuredOutsideControl) {
				_this.setState({
					isOpen: false
				}, _this._unbindCloseMenuIfClickedOutside);
			}
		};
		this._bindCloseMenuIfClickedOutside = function () {
			if (!document.addEventListener && document.attachEvent) {
				document.attachEvent('onclick', _this._closeMenuIfClickedOutside);
			} else {
				document.addEventListener('click', _this._closeMenuIfClickedOutside);
			}
		};
		this._unbindCloseMenuIfClickedOutside = function () {
			if (!document.removeEventListener && document.detachEvent) {
				document.detachEvent('onclick', _this._closeMenuIfClickedOutside);
			} else {
				document.removeEventListener('click', _this._closeMenuIfClickedOutside);
			}
		};
		this.setState(this.getStateFromValue(this.props.value));
	},

	componentDidMount: function componentDidMount() {
		if (this.props.asyncOptions && this.props.autoload) {
			this.autoloadAsyncOptions();
		}
	},

	componentWillUnmount: function componentWillUnmount() {
		clearTimeout(this._blurTimeout);
		clearTimeout(this._focusTimeout);
		if (this.state.isOpen) {
			this._unbindCloseMenuIfClickedOutside();
		}
	},

	componentWillReceiveProps: function componentWillReceiveProps(newProps) {
		var _this2 = this;

		var optionsChanged = false;
		if (JSON.stringify(newProps.options) !== JSON.stringify(this.props.options)) {
			optionsChanged = true;
			this.setState({
				options: newProps.options,
				filteredOptions: this.filterOptions(newProps.options)
			});
		}
		if (newProps.value !== this.state.value || newProps.placeholder !== this.props.placeholder || optionsChanged) {
			var setState = function setState(newState) {
				_this2.setState(_this2.getStateFromValue(newProps.value, newState && newState.options || newProps.options, newProps.placeholder));
			};
			if (this.props.asyncOptions) {
				this.loadAsyncOptions(newProps.value, {}, setState);
			} else {
				setState();
			}
		}
	},

	componentDidUpdate: function componentDidUpdate() {
		var _this3 = this;

		if (!this.props.disabled && this._focusAfterUpdate) {
			clearTimeout(this._blurTimeout);
			clearTimeout(this._focusTimeout);
			this._focusTimeout = setTimeout(function () {
				if (!_this3.isMounted()) return;
				_this3.getInputNode().focus();
				_this3._focusAfterUpdate = false;
			}, 50);
		}
		if (this._focusedOptionReveal) {
			if (this.refs.focused && this.refs.menu) {
				var focusedDOM = ReactDOM.findDOMNode(this.refs.focused);
				var menuDOM = ReactDOM.findDOMNode(this.refs.menu);
				var focusedRect = focusedDOM.getBoundingClientRect();
				var menuRect = menuDOM.getBoundingClientRect();

				if (focusedRect.bottom > menuRect.bottom || focusedRect.top < menuRect.top) {
					menuDOM.scrollTop = focusedDOM.offsetTop + focusedDOM.clientHeight - menuDOM.offsetHeight;
				}
			}
			this._focusedOptionReveal = false;
		}
	},

	focus: function focus() {
		this.getInputNode().focus();
	},

	clickedOutsideElement: function clickedOutsideElement(element, event) {
		var eventTarget = event.target ? event.target : event.srcElement;
		while (eventTarget != null) {
			if (eventTarget === element) return false;
			eventTarget = eventTarget.offsetParent;
		}
		return true;
	},

	getStateFromValue: function getStateFromValue(value, options, placeholder) {
		var _this4 = this;

		if (!options) {
			options = this.state.options;
		}
		if (!placeholder) {
			placeholder = this.props.placeholder;
		}

		// reset internal filter string
		this._optionsFilterString = '';

		var values = this.initValuesArray(value, options);
		var filteredOptions = this.filterOptions(options, values);

		var focusedOption;
		var valueForState = null;
		if (!this.props.multi && values.length) {
			focusedOption = values[0];
			valueForState = values[0][this.props.valueKey];
		} else {
			focusedOption = this.getFirstFocusableOption(filteredOptions);
			valueForState = values.map(function (v) {
				return v[_this4.props.valueKey];
			}).join(this.props.delimiter);
		}

		return {
			value: valueForState,
			values: values,
			inputValue: '',
			filteredOptions: filteredOptions,
			placeholder: !this.props.multi && values.length ? values[0][this.props.labelKey] : placeholder,
			focusedOption: focusedOption
		};
	},

	getFirstFocusableOption: function getFirstFocusableOption(options) {
		for (var optionIndex = 0; optionIndex < options.length; ++optionIndex) {
			if (!options[optionIndex].disabled) {
				return options[optionIndex];
			}
		}
	},

	initValuesArray: function initValuesArray(values, options) {
		var _this5 = this;

		if (!Array.isArray(values)) {
			if (typeof values === 'string') {
				values = values === '' ? [] : this.props.multi ? values.split(this.props.delimiter) : [values];
			} else {
				values = values !== undefined && values !== null ? [values] : [];
			}
		}
		return values.map(function (val) {
			if (typeof val === 'string' || typeof val === 'number') {
				var _ref;

				for (var key in options) {
					if (options.hasOwnProperty(key) && options[key] && (options[key][_this5.props.valueKey] === val || typeof options[key][_this5.props.valueKey] === 'number' && options[key][_this5.props.valueKey].toString() === val)) {
						return options[key];
					}
				}
				return _ref = {}, _defineProperty(_ref, _this5.props.valueKey, val), _defineProperty(_ref, _this5.props.labelKey, val), _ref;
			} else {
				return val;
			}
		});
	},

	setValue: function setValue(value, focusAfterUpdate) {
		if (focusAfterUpdate || focusAfterUpdate === undefined) {
			this._focusAfterUpdate = true;
		}
		var newState = this.getStateFromValue(value);
		newState.isOpen = false;
		this.fireChangeEvent(newState);
		this.setState(newState);
	},

	selectValue: function selectValue(value) {
		if (!this.props.multi) {
			this.setValue(value);
		} else if (value) {
			this.addValue(value);
		}
		this._unbindCloseMenuIfClickedOutside();
	},

	addValue: function addValue(value) {
		this.setValue(this.state.values.concat(value));
	},

	popValue: function popValue() {
		this.setValue(this.state.values.slice(0, this.state.values.length - 1));
	},

	removeValue: function removeValue(valueToRemove) {
		this.setValue(this.state.values.filter(function (value) {
			return value !== valueToRemove;
		}));
	},

	clearValue: function clearValue(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, ignore it.
		if (event && event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();
		this.setValue(null);
	},

	resetValue: function resetValue() {
		this.setValue(this.state.value === '' ? null : this.state.value);
	},

	getInputNode: function getInputNode() {
		var input = this.refs.input;
		return this.props.searchable ? input : ReactDOM.findDOMNode(input);
	},

	fireChangeEvent: function fireChangeEvent(newState) {
		if (newState.value !== this.state.value && this.props.onChange) {
			this.props.onChange(newState.value, newState.values);
		}
	},

	handleMouseDown: function handleMouseDown(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();

		// for the non-searchable select, close the dropdown when button is clicked
		if (this.state.isOpen && !this.props.searchable) {
			this.setState({
				isOpen: false
			}, this._unbindCloseMenuIfClickedOutside);
			return;
		}

		if (this.state.isFocused) {
			this.setState({
				isOpen: true
			}, this._bindCloseMenuIfClickedOutside);
		} else {
			this._openAfterFocus = true;
			this.getInputNode().focus();
		}
	},

	handleMouseDownOnMenu: function handleMouseDownOnMenu(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();
	},

	handleMouseDownOnArrow: function handleMouseDownOnArrow(event) {
		// if the event was triggered by a mousedown and not the primary
		// button, or if the component is disabled, ignore it.
		if (this.props.disabled || event.type === 'mousedown' && event.button !== 0) {
			return;
		}
		// If not focused, handleMouseDown will handle it
		if (!this.state.isOpen) {
			return;
		}
		event.stopPropagation();
		event.preventDefault();
		this.setState({
			isOpen: false
		}, this._unbindCloseMenuIfClickedOutside);
	},

	handleInputFocus: function handleInputFocus(event) {
		var _this6 = this;

		var newIsOpen = this.state.isOpen || this._openAfterFocus;
		this.setState({
			isFocused: true,
			isOpen: newIsOpen
		}, function () {
			if (newIsOpen) {
				_this6._bindCloseMenuIfClickedOutside();
			} else {
				_this6._unbindCloseMenuIfClickedOutside();
			}
		});
		this._openAfterFocus = false;
		if (this.props.onFocus) {
			this.props.onFocus(event);
		}
	},

	handleInputBlur: function handleInputBlur(event) {
		var _this7 = this;

		var menuDOM = ReactDOM.findDOMNode(this.refs.menu);
		if (document.activeElement.isEqualNode(menuDOM)) {
			return;
		}
		this._blurTimeout = setTimeout(function () {
			if (_this7._focusAfterUpdate || !_this7.isMounted()) return;
			_this7.setState({
				inputValue: '',
				isFocused: false,
				isOpen: false
			});
		}, 50);
		if (this.props.onBlur) {
			this.props.onBlur(event);
		}
	},

	handleKeyDown: function handleKeyDown(event) {
		if (this.props.disabled) return;
		switch (event.keyCode) {
			case 8:
				// backspace
				if (!this.state.inputValue && this.props.backspaceRemoves) {
					event.preventDefault();
					this.popValue();
				}
				return;
			case 9:
				// tab
				if (event.shiftKey || !this.state.isOpen || !this.state.focusedOption) {
					return;
				}
				this.selectFocusedOption();
				break;
			case 13:
				// enter
				if (!this.state.isOpen) return;
				this.selectFocusedOption();
				break;
			case 27:
				// escape
				if (this.state.isOpen) {
					this.resetValue();
				} else if (this.props.clearable) {
					this.clearValue(event);
				}
				break;
			case 38:
				// up
				this.focusPreviousOption();
				break;
			case 40:
				// down
				this.focusNextOption();
				break;
			case 188:
				// ,
				if (this.props.allowCreate && this.props.multi) {
					event.preventDefault();
					event.stopPropagation();
					this.selectFocusedOption();
				} else {
					return;
				}
				break;
			default:
				return;
		}
		event.preventDefault();
	},

	// Ensures that the currently focused option is available in filteredOptions.
	// If not, returns the first available option.
	_getNewFocusedOption: function _getNewFocusedOption(filteredOptions) {
		for (var key in filteredOptions) {
			if (filteredOptions.hasOwnProperty(key) && filteredOptions[key] === this.state.focusedOption) {
				return filteredOptions[key];
			}
		}
		return this.getFirstFocusableOption(filteredOptions);
	},

	handleInputChange: function handleInputChange(event) {
		// assign an internal variable because we need to use
		// the latest value before setState() has completed.
		this._optionsFilterString = event.target.value;
		if (this.props.onInputChange) {
			this.props.onInputChange(event.target.value);
		}
		if (this.props.asyncOptions) {
			this.setState({
				isLoading: true,
				inputValue: event.target.value
			});
			this.loadAsyncOptions(event.target.value, {
				isLoading: false,
				isOpen: true
			}, this._bindCloseMenuIfClickedOutside);
		} else {
			var filteredOptions = this.filterOptions(this.state.options);
			this.setState({
				isOpen: true,
				inputValue: event.target.value,
				filteredOptions: filteredOptions,
				focusedOption: this._getNewFocusedOption(filteredOptions)
			}, this._bindCloseMenuIfClickedOutside);
		}
	},

	autoloadAsyncOptions: function autoloadAsyncOptions() {
		var _this8 = this;

		this.setState({
			isLoading: true
		});
		this.loadAsyncOptions('', { isLoading: false }, function () {
			// update with new options but don't focus
			_this8.setValue(_this8.props.value, false);
		});
	},

	loadAsyncOptions: function loadAsyncOptions(input, state, callback) {
		if (input === undefined) input = '';

		var _this9 = this;

		var thisRequestId = this._currentRequestId = requestId++;
		if (this.props.cacheAsyncResults) {
			for (var i = 0; i <= input.length; i++) {
				var cacheKey = input.slice(0, i);
				if (this._optionsCache[cacheKey] && (input === cacheKey || this._optionsCache[cacheKey].complete)) {
					var options = this._optionsCache[cacheKey].options;
					var filteredOptions = this.filterOptions(options);
					var newState = {
						options: options,
						filteredOptions: filteredOptions,
						focusedOption: this._getNewFocusedOption(filteredOptions)
					};
					for (var key in state) {
						if (state.hasOwnProperty(key)) {
							newState[key] = state[key];
						}
					}
					this.setState(newState);
					if (callback) callback.call(this, newState);
					return;
				}
			}
		}

		var optionsResponseHandler = function optionsResponseHandler(err, data) {
			if (err) throw err;
			if (_this9.props.cacheAsyncResults) {
				_this9._optionsCache[input] = data;
			}
			if (thisRequestId !== _this9._currentRequestId) {
				return;
			}
			var filteredOptions = _this9.filterOptions(data.options);
			var newState = {
				options: data.options,
				filteredOptions: filteredOptions,
				focusedOption: _this9._getNewFocusedOption(filteredOptions)
			};
			for (var key in state) {
				if (state.hasOwnProperty(key)) {
					newState[key] = state[key];
				}
			}
			_this9.setState(newState);
			if (callback) callback.call(_this9, newState);
		};

		var asyncOpts = this.props.asyncOptions(input, optionsResponseHandler);

		if (asyncOpts && typeof asyncOpts.then === 'function') {
			asyncOpts.then(function (data) {
				optionsResponseHandler(null, data);
			}, function (err) {
				optionsResponseHandler(err);
			});
		}
	},

	filterOptions: function filterOptions(options, values) {
		var _this10 = this;

		var filterValue = this._optionsFilterString;
		var exclude = (values || this.state.values).map(function (i) {
			return i[_this10.props.valueKey];
		});
		if (this.props.filterOptions) {
			return this.props.filterOptions.call(this, options, filterValue, exclude);
		} else {
			var filterOption = function filterOption(op) {
				if (this.props.multi && exclude.indexOf(op[this.props.valueKey]) > -1) return false;
				if (this.props.filterOption) return this.props.filterOption.call(this, op, filterValue);
				var valueTest = String(op[this.props.valueKey]);
				var labelTest = String(op[this.props.labelKey]);
				if (this.props.ignoreCase) {
					valueTest = valueTest.toLowerCase();
					labelTest = labelTest.toLowerCase();
					filterValue = filterValue.toLowerCase();
				}
				return !filterValue || this.props.matchPos === 'start' ? this.props.matchProp !== 'label' && valueTest.substr(0, filterValue.length) === filterValue || this.props.matchProp !== 'value' && labelTest.substr(0, filterValue.length) === filterValue : this.props.matchProp !== 'label' && valueTest.indexOf(filterValue) >= 0 || this.props.matchProp !== 'value' && labelTest.indexOf(filterValue) >= 0;
			};
			return (options || []).filter(filterOption, this);
		}
	},

	selectFocusedOption: function selectFocusedOption() {
		if (this.props.allowCreate && !this.state.focusedOption) {
			return this.selectValue(this.state.inputValue);
		}

		if (this.state.focusedOption) {
			return this.selectValue(this.state.focusedOption);
		}
	},

	focusOption: function focusOption(op) {
		this.setState({
			focusedOption: op
		});
	},

	focusNextOption: function focusNextOption() {
		this.focusAdjacentOption('next');
	},

	focusPreviousOption: function focusPreviousOption() {
		this.focusAdjacentOption('previous');
	},

	focusAdjacentOption: function focusAdjacentOption(dir) {
		this._focusedOptionReveal = true;
		var ops = this.state.filteredOptions.filter(function (op) {
			return !op.disabled;
		});
		if (!this.state.isOpen) {
			this.setState({
				isOpen: true,
				inputValue: '',
				focusedOption: this.state.focusedOption || ops[dir === 'next' ? 0 : ops.length - 1]
			}, this._bindCloseMenuIfClickedOutside);
			return;
		}
		if (!ops.length) {
			return;
		}
		var focusedIndex = -1;
		for (var i = 0; i < ops.length; i++) {
			if (this.state.focusedOption === ops[i]) {
				focusedIndex = i;
				break;
			}
		}
		var focusedOption = ops[0];
		if (dir === 'next' && focusedIndex > -1 && focusedIndex < ops.length - 1) {
			focusedOption = ops[focusedIndex + 1];
		} else if (dir === 'previous') {
			if (focusedIndex > 0) {
				focusedOption = ops[focusedIndex - 1];
			} else {
				focusedOption = ops[ops.length - 1];
			}
		}
		this.setState({
			focusedOption: focusedOption
		});
	},

	unfocusOption: function unfocusOption(op) {
		if (this.state.focusedOption === op) {
			this.setState({
				focusedOption: null
			});
		}
	},

	renderOptionLabel: function renderOptionLabel(op) {
		return op[this.props.labelKey];
	},

	buildMenu: function buildMenu() {
		var focusedValue = this.state.focusedOption ? this.state.focusedOption[this.props.valueKey] : null;
		var renderLabel = this.props.optionRenderer || this.renderOptionLabel;
		if (this.state.filteredOptions.length > 0) {
			focusedValue = focusedValue == null ? this.state.filteredOptions[0] : focusedValue;
		}
		// Add the current value to the filtered options in last resort
		var options = this.state.filteredOptions;
		if (this.props.allowCreate && this.state.inputValue.trim()) {
			var inputValue = this.state.inputValue;
			options = options.slice();
			var newOption = this.props.newOptionCreator ? this.props.newOptionCreator(inputValue) : {
				value: inputValue,
				label: inputValue,
				create: true
			};
			options.unshift(newOption);
		}
		var ops = Object.keys(options).map(function (key) {
			var op = options[key];
			var isSelected = this.state.value === op[this.props.valueKey];
			var isFocused = focusedValue === op[this.props.valueKey];
			var optionClass = classes({
				'Select-option': true,
				'is-selected': isSelected,
				'is-focused': isFocused,
				'is-disabled': op.disabled
			});
			var ref = isFocused ? 'focused' : null;
			var optionResult = React.createElement(this.props.optionComponent, {
				key: 'option-' + op[this.props.valueKey],
				className: optionClass,
				renderFunc: renderLabel,
				mouseDown: this.selectValue,
				mouseEnter: this.focusOption,
				mouseLeave: this.unfocusOption,
				addLabelText: this.props.addLabelText,
				option: op,
				ref: ref
			});
			return optionResult;
		}, this);

		if (ops.length) {
			return ops;
		} else {
			var noResultsText, promptClass;
			if (this.isLoading()) {
				promptClass = 'Select-searching';
				noResultsText = this.props.searchingText;
			} else if (this.state.inputValue || !this.props.asyncOptions) {
				promptClass = 'Select-noresults';
				noResultsText = this.props.noResultsText;
			} else {
				promptClass = 'Select-search-prompt';
				noResultsText = this.props.searchPromptText;
			}

			return React.createElement(
				'div',
				{ className: promptClass },
				noResultsText
			);
		}
	},

	handleOptionLabelClick: function handleOptionLabelClick(value, event) {
		if (this.props.onOptionLabelClick) {
			this.props.onOptionLabelClick(value, event);
		}
	},

	isLoading: function isLoading() {
		return this.props.isLoading || this.state.isLoading;
	},

	render: function render() {
		var selectClass = classes('Select', this.props.className, {
			'Select--multi': this.props.multi,
			'is-searchable': this.props.searchable,
			'is-open': this.state.isOpen,
			'is-focused': this.state.isFocused,
			'is-loading': this.isLoading(),
			'is-disabled': this.props.disabled,
			'has-value': this.state.value
		});
		var value = [];
		if (this.props.multi) {
			this.state.values.forEach(function (val) {
				var renderLabel = this.props.valueRenderer || this.renderOptionLabel;
				var onOptionLabelClick = this.handleOptionLabelClick.bind(this, val);
				var onRemove = this.removeValue.bind(this, val);
				var valueComponent = React.createElement(this.props.valueComponent, {
					key: val[this.props.valueKey],
					option: val,
					renderer: renderLabel,
					optionLabelClick: !!this.props.onOptionLabelClick,
					onOptionLabelClick: onOptionLabelClick,
					onRemove: onRemove,
					disabled: this.props.disabled
				});
				value.push(valueComponent);
			}, this);
		}

		if (!this.state.inputValue && (!this.props.multi || !value.length)) {
			var val = this.state.values[0] || null;
			if (this.props.valueRenderer && !!this.state.values.length) {
				value.push(React.createElement(Value, {
					key: 0,
					option: val,
					renderer: this.props.valueRenderer,
					disabled: this.props.disabled }));
			} else {
				var singleValueComponent = React.createElement(this.props.singleValueComponent, {
					key: 'placeholder',
					value: val,
					placeholder: this.state.placeholder
				});
				value.push(singleValueComponent);
			}
		}

		// loading spinner
		var loading = this.isLoading() ? React.createElement(
			'span',
			{ className: 'Select-loading-zone', 'aria-hidden': 'true' },
			React.createElement('span', { className: 'Select-loading' })
		) : null;

		// clear "x" button
		var clear = this.props.clearable && this.state.value && !this.props.disabled && !this.isLoading() ? React.createElement(
			'span',
			{ className: 'Select-clear-zone', title: this.props.multi ? this.props.clearAllText : this.props.clearValueText, 'aria-label': this.props.multi ? this.props.clearAllText : this.props.clearValueText, onMouseDown: this.clearValue, onTouchEnd: this.clearValue, onClick: this.clearValue },
			React.createElement('span', { className: 'Select-clear', dangerouslySetInnerHTML: { __html: '&times;' } })
		) : null;

		// indicator arrow
		var arrow = React.createElement(
			'span',
			{ className: 'Select-arrow-zone', onMouseDown: this.handleMouseDownOnArrow },
			React.createElement('span', { className: 'Select-arrow', onMouseDown: this.handleMouseDownOnArrow })
		);

		var menu;
		var menuProps;
		if (this.state.isOpen) {
			menuProps = {
				ref: 'menu',
				className: 'Select-menu',
				onMouseDown: this.handleMouseDownOnMenu
			};
			menu = React.createElement(
				'div',
				{ ref: 'selectMenuContainer', className: 'Select-menu-outer' },
				React.createElement(
					'div',
					menuProps,
					this.buildMenu()
				)
			);
		}

		var input;
		var inputProps = {
			ref: 'input',
			className: 'Select-input ' + (this.props.inputProps.className || ''),
			tabIndex: this.props.tabIndex || 0,
			onFocus: this.handleInputFocus,
			onBlur: this.handleInputBlur
		};
		for (var key in this.props.inputProps) {
			if (this.props.inputProps.hasOwnProperty(key) && key !== 'className') {
				inputProps[key] = this.props.inputProps[key];
			}
		}

		if (!this.props.disabled) {
			if (this.props.searchable) {
				input = React.createElement(Input, _extends({ value: this.state.inputValue, onChange: this.handleInputChange, minWidth: '5' }, inputProps));
			} else {
				input = React.createElement(
					'div',
					inputProps,
					' '
				);
			}
		} else if (!this.props.multi || !this.state.values.length) {
			input = React.createElement(
				'div',
				{ className: 'Select-input' },
				' '
			);
		}

		return React.createElement(
			'div',
			{ ref: 'wrapper', className: selectClass },
			React.createElement('input', { type: 'hidden', ref: 'value', name: this.props.name, value: this.state.value, disabled: this.props.disabled }),
			React.createElement(
				'div',
				{ className: 'Select-control', ref: 'control', onKeyDown: this.handleKeyDown, onMouseDown: this.handleMouseDown, onTouchEnd: this.handleMouseDown },
				value,
				input,
				loading,
				clear,
				arrow
			),
			menu
		);
	}
});

module.exports = Select;
},{"./Option":817,"./SingleValue":819,"./Value":820,"classnames":118,"react":"react","react-dom":"react-dom","react-input-autosize":776}],819:[function(require,module,exports){
'use strict';

var React = require('react');
var classes = require('classnames');

var SingleValue = React.createClass({
	displayName: 'SingleValue',

	propTypes: {
		placeholder: React.PropTypes.string, // this is default value provided by React-Select based component
		value: React.PropTypes.object // selected option
	},
	render: function render() {
		var classNames = classes('Select-placeholder', this.props.value && this.props.value.className);
		return React.createElement(
			'div',
			{
				className: classNames,
				style: this.props.value && this.props.value.style,
				title: this.props.value && this.props.value.title
			},
			this.props.placeholder
		);
	}
});

module.exports = SingleValue;
},{"classnames":118,"react":"react"}],820:[function(require,module,exports){
'use strict';

var React = require('react');
var classes = require('classnames');

var Value = React.createClass({

	displayName: 'Value',

	propTypes: {
		disabled: React.PropTypes.bool, // disabled prop passed to ReactSelect
		onOptionLabelClick: React.PropTypes.func, // method to handle click on value label
		onRemove: React.PropTypes.func, // method to handle remove of that value
		option: React.PropTypes.object.isRequired, // option passed to component
		optionLabelClick: React.PropTypes.bool, // indicates if onOptionLabelClick should be handled
		renderer: React.PropTypes.func // method to render option label passed to ReactSelect
	},

	blockEvent: function blockEvent(event) {
		event.stopPropagation();
	},

	handleOnRemove: function handleOnRemove(event) {
		if (!this.props.disabled) {
			this.props.onRemove(event);
		}
	},

	render: function render() {
		var label = this.props.option.label;
		if (this.props.renderer) {
			label = this.props.renderer(this.props.option);
		}

		if (!this.props.onRemove && !this.props.optionLabelClick) {
			return React.createElement(
				'div',
				{
					className: classes('Select-value', this.props.option.className),
					style: this.props.option.style,
					title: this.props.option.title
				},
				label
			);
		}

		if (this.props.optionLabelClick) {
			label = React.createElement(
				'a',
				{ className: classes('Select-item-label__a', this.props.option.className),
					onMouseDown: this.blockEvent,
					onTouchEnd: this.props.onOptionLabelClick,
					onClick: this.props.onOptionLabelClick,
					style: this.props.option.style,
					title: this.props.option.title },
				label
			);
		}

		return React.createElement(
			'div',
			{ className: classes('Select-item', this.props.option.className),
				style: this.props.option.style,
				title: this.props.option.title },
			React.createElement(
				'span',
				{ className: 'Select-item-icon',
					onMouseDown: this.blockEvent,
					onClick: this.handleOnRemove,
					onTouchEnd: this.handleOnRemove },
				'×'
			),
			React.createElement(
				'span',
				{ className: 'Select-item-label' },
				label
			)
		);
	}

});

module.exports = Value;
},{"classnames":118,"react":"react"}],821:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.autoprefix = undefined;

var _forOwn2 = require('lodash/forOwn');

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transforms = {
  borderRadius: function borderRadius(value) {
    return {
      msBorderRadius: value,
      MozBorderRadius: value,
      OBorderRadius: value,
      WebkitBorderRadius: value,
      borderRadius: value
    };
  },
  boxShadow: function boxShadow(value) {
    return {
      msBoxShadow: value,
      MozBoxShadow: value,
      OBoxShadow: value,
      WebkitBoxShadow: value,
      boxShadow: value
    };
  },
  userSelect: function userSelect(value) {
    return {
      WebkitTouchCallout: value,
      KhtmlUserSelect: value,
      MozUserSelect: value,
      msUserSelect: value,
      WebkitUserSelect: value,
      userSelect: value
    };
  },

  flex: function flex(value) {
    return {
      WebkitBoxFlex: value,
      MozBoxFlex: value,
      WebkitFlex: value,
      msFlex: value,
      flex: value
    };
  },
  flexBasis: function flexBasis(value) {
    return {
      WebkitFlexBasis: value,
      flexBasis: value
    };
  },
  justifyContent: function justifyContent(value) {
    return {
      WebkitJustifyContent: value,
      justifyContent: value
    };
  },

  transition: function transition(value) {
    return {
      msTransition: value,
      MozTransition: value,
      OTransition: value,
      WebkitTransition: value,
      transition: value
    };
  },

  transform: function transform(value) {
    return {
      msTransform: value,
      MozTransform: value,
      OTransform: value,
      WebkitTransform: value,
      transform: value
    };
  },
  absolute: function absolute(value) {
    var direction = value && value.split(' ');
    return {
      position: 'absolute',
      top: direction && direction[0],
      right: direction && direction[1],
      bottom: direction && direction[2],
      left: direction && direction[3]
    };
  },
  extend: function extend(name, otherElementStyles) {
    var otherStyle = otherElementStyles[name];
    if (otherStyle) {
      return otherStyle;
    }
    return {
      'extend': name
    };
  }
};

var autoprefix = exports.autoprefix = function autoprefix(elements) {
  var prefixed = {};
  (0, _forOwn3.default)(elements, function (styles, element) {
    var expanded = {};
    (0, _forOwn3.default)(styles, function (value, key) {
      var transform = transforms[key];
      if (transform) {
        expanded = _extends({}, expanded, transform(value));
      } else {
        expanded[key] = value;
      }
    });
    prefixed[element] = expanded;
  });
  return prefixed;
};

exports.default = autoprefix;
},{"lodash/forOwn":962}],822:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.active = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var active = exports.active = function active(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Active, _React$Component);

    function Active() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Active);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function () {
        return _this.setState({ active: true });
      }, _this.handleMouseUp = function () {
        return _this.setState({ active: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Active;
  }(_react2.default.Component);
};

exports.default = active;
},{"react":"react"}],823:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hover = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var hover = exports.hover = function hover(Component) {
  var Span = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'span';

  return function (_React$Component) {
    _inherits(Hover, _React$Component);

    function Hover() {
      var _ref;

      var _temp, _this, _ret;

      _classCallCheck(this, Hover);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function () {
        return _this.setState({ hover: true });
      }, _this.handleMouseOut = function () {
        return _this.setState({ hover: false });
      }, _this.render = function () {
        return _react2.default.createElement(
          Span,
          { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
          _react2.default.createElement(Component, _extends({}, _this.props, _this.state))
        );
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    return Hover;
  }(_react2.default.Component);
};

exports.default = hover;
},{"react":"react"}],824:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.flattenNames = undefined;

var _isString2 = require('lodash/isString');

var _isString3 = _interopRequireDefault(_isString2);

var _forOwn2 = require('lodash/forOwn');

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _isPlainObject2 = require('lodash/isPlainObject');

var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);

var _map2 = require('lodash/map');

var _map3 = _interopRequireDefault(_map2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var flattenNames = exports.flattenNames = function flattenNames() {
  var things = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var names = [];

  (0, _map3.default)(things, function (thing) {
    if (Array.isArray(thing)) {
      flattenNames(thing).map(function (name) {
        return names.push(name);
      });
    } else if ((0, _isPlainObject3.default)(thing)) {
      (0, _forOwn3.default)(thing, function (value, key) {
        value === true && names.push(key);
        names.push(key + '-' + value);
      });
    } else if ((0, _isString3.default)(thing)) {
      names.push(thing);
    }
  });

  return names;
};

exports.default = flattenNames;
},{"lodash/forOwn":962,"lodash/isPlainObject":974,"lodash/isString":975,"lodash/map":980}],825:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReactCSS = exports.loop = exports.handleActive = exports.handleHover = exports.hover = undefined;

var _flattenNames = require('./flattenNames');

var _flattenNames2 = _interopRequireDefault(_flattenNames);

var _mergeClasses = require('./mergeClasses');

var _mergeClasses2 = _interopRequireDefault(_mergeClasses);

var _autoprefix = require('./autoprefix');

var _autoprefix2 = _interopRequireDefault(_autoprefix);

var _hover2 = require('./components/hover');

var _hover3 = _interopRequireDefault(_hover2);

var _active = require('./components/active');

var _active2 = _interopRequireDefault(_active);

var _loop2 = require('./loop');

var _loop3 = _interopRequireDefault(_loop2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.hover = _hover3.default;
exports.handleHover = _hover3.default;
exports.handleActive = _active2.default;
exports.loop = _loop3.default;
var ReactCSS = exports.ReactCSS = function ReactCSS(classes) {
  for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    activations[_key - 1] = arguments[_key];
  }

  var activeNames = (0, _flattenNames2.default)(activations);
  var merged = (0, _mergeClasses2.default)(classes, activeNames);
  return (0, _autoprefix2.default)(merged);
};

exports.default = ReactCSS;
},{"./autoprefix":821,"./components/active":822,"./components/hover":823,"./flattenNames":824,"./loop":826,"./mergeClasses":827}],826:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var loopable = function loopable(i, length) {
  var props = {};
  var setProp = function setProp(name) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    props[name] = value;
  };

  i === 0 && setProp('first-child');
  i === length - 1 && setProp('last-child');
  (i === 0 || i % 2 === 0) && setProp('even');
  Math.abs(i % 2) === 1 && setProp('odd');
  setProp('nth-child', i);

  return props;
};

exports.default = loopable;
},{}],827:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mergeClasses = undefined;

var _forOwn2 = require('lodash/forOwn');

var _forOwn3 = _interopRequireDefault(_forOwn2);

var _cloneDeep2 = require('lodash/cloneDeep');

var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var mergeClasses = exports.mergeClasses = function mergeClasses(classes) {
  var activeNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var styles = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
  activeNames.map(function (name) {
    var toMerge = classes[name];
    if (toMerge) {
      (0, _forOwn3.default)(toMerge, function (value, key) {
        if (!styles[key]) {
          styles[key] = {};
        }

        styles[key] = _extends({}, styles[key], toMerge[key]);
      });
    }

    return name;
  });
  return styles;
};

exports.default = mergeClasses;
},{"lodash/cloneDeep":960,"lodash/forOwn":962}],828:[function(require,module,exports){
arguments[4][502][0].apply(exports,arguments)
},{"./_getNative":907,"./_root":948,"dup":502}],829:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./_hashClear":915,"./_hashDelete":916,"./_hashGet":917,"./_hashHas":918,"./_hashSet":919,"dup":162}],830:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"./_listCacheClear":929,"./_listCacheDelete":930,"./_listCacheGet":931,"./_listCacheHas":932,"./_listCacheSet":933,"dup":163}],831:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"./_getNative":907,"./_root":948,"dup":164}],832:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"./_mapCacheClear":934,"./_mapCacheDelete":935,"./_mapCacheGet":936,"./_mapCacheHas":937,"./_mapCacheSet":938,"dup":165}],833:[function(require,module,exports){
arguments[4][507][0].apply(exports,arguments)
},{"./_getNative":907,"./_root":948,"dup":507}],834:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./_getNative":907,"./_root":948,"dup":166}],835:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"./_MapCache":832,"./_setCacheAdd":949,"./_setCacheHas":950,"dup":167}],836:[function(require,module,exports){
arguments[4][510][0].apply(exports,arguments)
},{"./_ListCache":830,"./_stackClear":952,"./_stackDelete":953,"./_stackGet":954,"./_stackHas":955,"./_stackSet":956,"dup":510}],837:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./_root":948,"dup":168}],838:[function(require,module,exports){
arguments[4][512][0].apply(exports,arguments)
},{"./_root":948,"dup":512}],839:[function(require,module,exports){
arguments[4][513][0].apply(exports,arguments)
},{"./_getNative":907,"./_root":948,"dup":513}],840:[function(require,module,exports){
/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

module.exports = addMapEntry;

},{}],841:[function(require,module,exports){
/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

module.exports = addSetEntry;

},{}],842:[function(require,module,exports){
arguments[4][514][0].apply(exports,arguments)
},{"dup":514}],843:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"dup":170}],844:[function(require,module,exports){
arguments[4][516][0].apply(exports,arguments)
},{"./_baseTimes":877,"./_isIndex":923,"./isArguments":966,"./isArray":967,"./isBuffer":969,"./isTypedArray":977,"dup":516}],845:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"dup":173}],846:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"dup":174}],847:[function(require,module,exports){
/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;

},{}],848:[function(require,module,exports){
arguments[4][519][0].apply(exports,arguments)
},{"dup":519}],849:[function(require,module,exports){
arguments[4][655][0].apply(exports,arguments)
},{"./_baseAssignValue":853,"./eq":961,"dup":655}],850:[function(require,module,exports){
arguments[4][175][0].apply(exports,arguments)
},{"./eq":961,"dup":175}],851:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keys = require('./keys');

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;

},{"./_copyObject":892,"./keys":978}],852:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    keysIn = require('./keysIn');

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;

},{"./_copyObject":892,"./keysIn":979}],853:[function(require,module,exports){
arguments[4][657][0].apply(exports,arguments)
},{"./_defineProperty":898,"dup":657}],854:[function(require,module,exports){
var Stack = require('./_Stack'),
    arrayEach = require('./_arrayEach'),
    assignValue = require('./_assignValue'),
    baseAssign = require('./_baseAssign'),
    baseAssignIn = require('./_baseAssignIn'),
    cloneBuffer = require('./_cloneBuffer'),
    copyArray = require('./_copyArray'),
    copySymbols = require('./_copySymbols'),
    copySymbolsIn = require('./_copySymbolsIn'),
    getAllKeys = require('./_getAllKeys'),
    getAllKeysIn = require('./_getAllKeysIn'),
    getTag = require('./_getTag'),
    initCloneArray = require('./_initCloneArray'),
    initCloneByTag = require('./_initCloneByTag'),
    initCloneObject = require('./_initCloneObject'),
    isArray = require('./isArray'),
    isBuffer = require('./isBuffer'),
    isObject = require('./isObject'),
    keys = require('./keys');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;

},{"./_Stack":836,"./_arrayEach":842,"./_assignValue":849,"./_baseAssign":851,"./_baseAssignIn":852,"./_cloneBuffer":884,"./_copyArray":891,"./_copySymbols":893,"./_copySymbolsIn":894,"./_getAllKeys":903,"./_getAllKeysIn":904,"./_getTag":912,"./_initCloneArray":920,"./_initCloneByTag":921,"./_initCloneObject":922,"./isArray":967,"./isBuffer":969,"./isObject":972,"./keys":978}],855:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;

},{"./isObject":972}],856:[function(require,module,exports){
arguments[4][521][0].apply(exports,arguments)
},{"./_baseForOwn":858,"./_createBaseEach":896,"dup":521}],857:[function(require,module,exports){
arguments[4][522][0].apply(exports,arguments)
},{"./_createBaseFor":897,"dup":522}],858:[function(require,module,exports){
arguments[4][523][0].apply(exports,arguments)
},{"./_baseFor":857,"./keys":978,"dup":523}],859:[function(require,module,exports){
arguments[4][524][0].apply(exports,arguments)
},{"./_castPath":882,"./_toKey":958,"dup":524}],860:[function(require,module,exports){
arguments[4][525][0].apply(exports,arguments)
},{"./_arrayPush":846,"./isArray":967,"dup":525}],861:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./_Symbol":837,"./_getRawTag":909,"./_objectToString":946,"dup":179}],862:[function(require,module,exports){
arguments[4][527][0].apply(exports,arguments)
},{"dup":527}],863:[function(require,module,exports){
arguments[4][182][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./isObjectLike":973,"dup":182}],864:[function(require,module,exports){
arguments[4][529][0].apply(exports,arguments)
},{"./_baseIsEqualDeep":865,"./isObjectLike":973,"dup":529}],865:[function(require,module,exports){
arguments[4][530][0].apply(exports,arguments)
},{"./_Stack":836,"./_equalArrays":899,"./_equalByTag":900,"./_equalObjects":901,"./_getTag":912,"./isArray":967,"./isBuffer":969,"./isTypedArray":977,"dup":530}],866:[function(require,module,exports){
arguments[4][531][0].apply(exports,arguments)
},{"./_Stack":836,"./_baseIsEqual":864,"dup":531}],867:[function(require,module,exports){
arguments[4][184][0].apply(exports,arguments)
},{"./_isMasked":926,"./_toSource":959,"./isFunction":970,"./isObject":972,"dup":184}],868:[function(require,module,exports){
arguments[4][533][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./isLength":971,"./isObjectLike":973,"dup":533}],869:[function(require,module,exports){
arguments[4][534][0].apply(exports,arguments)
},{"./_baseMatches":873,"./_baseMatchesProperty":874,"./identity":965,"./isArray":967,"./property":982,"dup":534}],870:[function(require,module,exports){
arguments[4][535][0].apply(exports,arguments)
},{"./_isPrototype":927,"./_nativeKeys":943,"dup":535}],871:[function(require,module,exports){
arguments[4][667][0].apply(exports,arguments)
},{"./_isPrototype":927,"./_nativeKeysIn":944,"./isObject":972,"dup":667}],872:[function(require,module,exports){
arguments[4][536][0].apply(exports,arguments)
},{"./_baseEach":856,"./isArrayLike":968,"dup":536}],873:[function(require,module,exports){
arguments[4][537][0].apply(exports,arguments)
},{"./_baseIsMatch":866,"./_getMatchData":906,"./_matchesStrictComparable":940,"dup":537}],874:[function(require,module,exports){
arguments[4][538][0].apply(exports,arguments)
},{"./_baseIsEqual":864,"./_isKey":924,"./_isStrictComparable":928,"./_matchesStrictComparable":940,"./_toKey":958,"./get":963,"./hasIn":964,"dup":538}],875:[function(require,module,exports){
arguments[4][539][0].apply(exports,arguments)
},{"dup":539}],876:[function(require,module,exports){
arguments[4][540][0].apply(exports,arguments)
},{"./_baseGet":859,"dup":540}],877:[function(require,module,exports){
arguments[4][541][0].apply(exports,arguments)
},{"dup":541}],878:[function(require,module,exports){
arguments[4][542][0].apply(exports,arguments)
},{"./_Symbol":837,"./_arrayMap":845,"./isArray":967,"./isSymbol":976,"dup":542}],879:[function(require,module,exports){
arguments[4][187][0].apply(exports,arguments)
},{"dup":187}],880:[function(require,module,exports){
arguments[4][190][0].apply(exports,arguments)
},{"dup":190}],881:[function(require,module,exports){
arguments[4][545][0].apply(exports,arguments)
},{"./identity":965,"dup":545}],882:[function(require,module,exports){
arguments[4][546][0].apply(exports,arguments)
},{"./_isKey":924,"./_stringToPath":957,"./isArray":967,"./toString":985,"dup":546}],883:[function(require,module,exports){
var Uint8Array = require('./_Uint8Array');

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;

},{"./_Uint8Array":838}],884:[function(require,module,exports){
var root = require('./_root');

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;

},{"./_root":948}],885:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;

},{"./_cloneArrayBuffer":883}],886:[function(require,module,exports){
var addMapEntry = require('./_addMapEntry'),
    arrayReduce = require('./_arrayReduce'),
    mapToArray = require('./_mapToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

module.exports = cloneMap;

},{"./_addMapEntry":840,"./_arrayReduce":847,"./_mapToArray":939}],887:[function(require,module,exports){
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;

},{}],888:[function(require,module,exports){
var addSetEntry = require('./_addSetEntry'),
    arrayReduce = require('./_arrayReduce'),
    setToArray = require('./_setToArray');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1;

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

module.exports = cloneSet;

},{"./_addSetEntry":841,"./_arrayReduce":847,"./_setToArray":951}],889:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;

},{"./_Symbol":837}],890:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer');

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;

},{"./_cloneArrayBuffer":883}],891:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],892:[function(require,module,exports){
arguments[4][674][0].apply(exports,arguments)
},{"./_assignValue":849,"./_baseAssignValue":853,"dup":674}],893:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbols = require('./_getSymbols');

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;

},{"./_copyObject":892,"./_getSymbols":910}],894:[function(require,module,exports){
var copyObject = require('./_copyObject'),
    getSymbolsIn = require('./_getSymbolsIn');

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;

},{"./_copyObject":892,"./_getSymbolsIn":911}],895:[function(require,module,exports){
arguments[4][192][0].apply(exports,arguments)
},{"./_root":948,"dup":192}],896:[function(require,module,exports){
arguments[4][548][0].apply(exports,arguments)
},{"./isArrayLike":968,"dup":548}],897:[function(require,module,exports){
arguments[4][549][0].apply(exports,arguments)
},{"dup":549}],898:[function(require,module,exports){
arguments[4][194][0].apply(exports,arguments)
},{"./_getNative":907,"dup":194}],899:[function(require,module,exports){
arguments[4][550][0].apply(exports,arguments)
},{"./_SetCache":835,"./_arraySome":848,"./_cacheHas":880,"dup":550}],900:[function(require,module,exports){
arguments[4][551][0].apply(exports,arguments)
},{"./_Symbol":837,"./_Uint8Array":838,"./_equalArrays":899,"./_mapToArray":939,"./_setToArray":951,"./eq":961,"dup":551}],901:[function(require,module,exports){
arguments[4][552][0].apply(exports,arguments)
},{"./_getAllKeys":903,"dup":552}],902:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],903:[function(require,module,exports){
arguments[4][554][0].apply(exports,arguments)
},{"./_baseGetAllKeys":860,"./_getSymbols":910,"./keys":978,"dup":554}],904:[function(require,module,exports){
var baseGetAllKeys = require('./_baseGetAllKeys'),
    getSymbolsIn = require('./_getSymbolsIn'),
    keysIn = require('./keysIn');

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;

},{"./_baseGetAllKeys":860,"./_getSymbolsIn":911,"./keysIn":979}],905:[function(require,module,exports){
arguments[4][196][0].apply(exports,arguments)
},{"./_isKeyable":925,"dup":196}],906:[function(require,module,exports){
arguments[4][556][0].apply(exports,arguments)
},{"./_isStrictComparable":928,"./keys":978,"dup":556}],907:[function(require,module,exports){
arguments[4][197][0].apply(exports,arguments)
},{"./_baseIsNative":867,"./_getValue":913,"dup":197}],908:[function(require,module,exports){
arguments[4][765][0].apply(exports,arguments)
},{"./_overArg":947,"dup":765}],909:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./_Symbol":837,"dup":198}],910:[function(require,module,exports){
arguments[4][559][0].apply(exports,arguments)
},{"./_arrayFilter":843,"./stubArray":983,"dup":559}],911:[function(require,module,exports){
var arrayPush = require('./_arrayPush'),
    getPrototype = require('./_getPrototype'),
    getSymbols = require('./_getSymbols'),
    stubArray = require('./stubArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;

},{"./_arrayPush":846,"./_getPrototype":908,"./_getSymbols":910,"./stubArray":983}],912:[function(require,module,exports){
arguments[4][560][0].apply(exports,arguments)
},{"./_DataView":828,"./_Map":831,"./_Promise":833,"./_Set":834,"./_WeakMap":839,"./_baseGetTag":861,"./_toSource":959,"dup":560}],913:[function(require,module,exports){
arguments[4][199][0].apply(exports,arguments)
},{"dup":199}],914:[function(require,module,exports){
arguments[4][562][0].apply(exports,arguments)
},{"./_castPath":882,"./_isIndex":923,"./_toKey":958,"./isArguments":966,"./isArray":967,"./isLength":971,"dup":562}],915:[function(require,module,exports){
arguments[4][200][0].apply(exports,arguments)
},{"./_nativeCreate":942,"dup":200}],916:[function(require,module,exports){
arguments[4][201][0].apply(exports,arguments)
},{"dup":201}],917:[function(require,module,exports){
arguments[4][202][0].apply(exports,arguments)
},{"./_nativeCreate":942,"dup":202}],918:[function(require,module,exports){
arguments[4][203][0].apply(exports,arguments)
},{"./_nativeCreate":942,"dup":203}],919:[function(require,module,exports){
arguments[4][204][0].apply(exports,arguments)
},{"./_nativeCreate":942,"dup":204}],920:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;

},{}],921:[function(require,module,exports){
var cloneArrayBuffer = require('./_cloneArrayBuffer'),
    cloneDataView = require('./_cloneDataView'),
    cloneMap = require('./_cloneMap'),
    cloneRegExp = require('./_cloneRegExp'),
    cloneSet = require('./_cloneSet'),
    cloneSymbol = require('./_cloneSymbol'),
    cloneTypedArray = require('./_cloneTypedArray');

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;

},{"./_cloneArrayBuffer":883,"./_cloneDataView":885,"./_cloneMap":886,"./_cloneRegExp":887,"./_cloneSet":888,"./_cloneSymbol":889,"./_cloneTypedArray":890}],922:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    getPrototype = require('./_getPrototype'),
    isPrototype = require('./_isPrototype');

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;

},{"./_baseCreate":855,"./_getPrototype":908,"./_isPrototype":927}],923:[function(require,module,exports){
arguments[4][568][0].apply(exports,arguments)
},{"dup":568}],924:[function(require,module,exports){
arguments[4][569][0].apply(exports,arguments)
},{"./isArray":967,"./isSymbol":976,"dup":569}],925:[function(require,module,exports){
arguments[4][206][0].apply(exports,arguments)
},{"dup":206}],926:[function(require,module,exports){
arguments[4][207][0].apply(exports,arguments)
},{"./_coreJsData":895,"dup":207}],927:[function(require,module,exports){
arguments[4][572][0].apply(exports,arguments)
},{"dup":572}],928:[function(require,module,exports){
arguments[4][573][0].apply(exports,arguments)
},{"./isObject":972,"dup":573}],929:[function(require,module,exports){
arguments[4][208][0].apply(exports,arguments)
},{"dup":208}],930:[function(require,module,exports){
arguments[4][209][0].apply(exports,arguments)
},{"./_assocIndexOf":850,"dup":209}],931:[function(require,module,exports){
arguments[4][210][0].apply(exports,arguments)
},{"./_assocIndexOf":850,"dup":210}],932:[function(require,module,exports){
arguments[4][211][0].apply(exports,arguments)
},{"./_assocIndexOf":850,"dup":211}],933:[function(require,module,exports){
arguments[4][212][0].apply(exports,arguments)
},{"./_assocIndexOf":850,"dup":212}],934:[function(require,module,exports){
arguments[4][213][0].apply(exports,arguments)
},{"./_Hash":829,"./_ListCache":830,"./_Map":831,"dup":213}],935:[function(require,module,exports){
arguments[4][214][0].apply(exports,arguments)
},{"./_getMapData":905,"dup":214}],936:[function(require,module,exports){
arguments[4][215][0].apply(exports,arguments)
},{"./_getMapData":905,"dup":215}],937:[function(require,module,exports){
arguments[4][216][0].apply(exports,arguments)
},{"./_getMapData":905,"dup":216}],938:[function(require,module,exports){
arguments[4][217][0].apply(exports,arguments)
},{"./_getMapData":905,"dup":217}],939:[function(require,module,exports){
arguments[4][584][0].apply(exports,arguments)
},{"dup":584}],940:[function(require,module,exports){
arguments[4][585][0].apply(exports,arguments)
},{"dup":585}],941:[function(require,module,exports){
arguments[4][586][0].apply(exports,arguments)
},{"./memoize":981,"dup":586}],942:[function(require,module,exports){
arguments[4][218][0].apply(exports,arguments)
},{"./_getNative":907,"dup":218}],943:[function(require,module,exports){
arguments[4][588][0].apply(exports,arguments)
},{"./_overArg":947,"dup":588}],944:[function(require,module,exports){
arguments[4][707][0].apply(exports,arguments)
},{"dup":707}],945:[function(require,module,exports){
arguments[4][589][0].apply(exports,arguments)
},{"./_freeGlobal":902,"dup":589}],946:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],947:[function(require,module,exports){
arguments[4][591][0].apply(exports,arguments)
},{"dup":591}],948:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./_freeGlobal":902,"dup":221}],949:[function(require,module,exports){
arguments[4][222][0].apply(exports,arguments)
},{"dup":222}],950:[function(require,module,exports){
arguments[4][223][0].apply(exports,arguments)
},{"dup":223}],951:[function(require,module,exports){
arguments[4][224][0].apply(exports,arguments)
},{"dup":224}],952:[function(require,module,exports){
arguments[4][596][0].apply(exports,arguments)
},{"./_ListCache":830,"dup":596}],953:[function(require,module,exports){
arguments[4][597][0].apply(exports,arguments)
},{"dup":597}],954:[function(require,module,exports){
arguments[4][598][0].apply(exports,arguments)
},{"dup":598}],955:[function(require,module,exports){
arguments[4][599][0].apply(exports,arguments)
},{"dup":599}],956:[function(require,module,exports){
arguments[4][600][0].apply(exports,arguments)
},{"./_ListCache":830,"./_Map":831,"./_MapCache":832,"dup":600}],957:[function(require,module,exports){
arguments[4][601][0].apply(exports,arguments)
},{"./_memoizeCapped":941,"dup":601}],958:[function(require,module,exports){
arguments[4][602][0].apply(exports,arguments)
},{"./isSymbol":976,"dup":602}],959:[function(require,module,exports){
arguments[4][228][0].apply(exports,arguments)
},{"dup":228}],960:[function(require,module,exports){
var baseClone = require('./_baseClone');

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;

},{"./_baseClone":854}],961:[function(require,module,exports){
arguments[4][230][0].apply(exports,arguments)
},{"dup":230}],962:[function(require,module,exports){
var baseForOwn = require('./_baseForOwn'),
    castFunction = require('./_castFunction');

/**
 * Iterates over own enumerable string keyed properties of an object and
 * invokes `iteratee` for each property. The iteratee is invoked with three
 * arguments: (value, key, object). Iteratee functions may exit iteration
 * early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forOwnRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forOwn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forOwn(object, iteratee) {
  return object && baseForOwn(object, castFunction(iteratee));
}

module.exports = forOwn;

},{"./_baseForOwn":858,"./_castFunction":881}],963:[function(require,module,exports){
arguments[4][608][0].apply(exports,arguments)
},{"./_baseGet":859,"dup":608}],964:[function(require,module,exports){
arguments[4][609][0].apply(exports,arguments)
},{"./_baseHasIn":862,"./_hasPath":914,"dup":609}],965:[function(require,module,exports){
arguments[4][231][0].apply(exports,arguments)
},{"dup":231}],966:[function(require,module,exports){
arguments[4][233][0].apply(exports,arguments)
},{"./_baseIsArguments":863,"./isObjectLike":973,"dup":233}],967:[function(require,module,exports){
arguments[4][234][0].apply(exports,arguments)
},{"dup":234}],968:[function(require,module,exports){
arguments[4][235][0].apply(exports,arguments)
},{"./isFunction":970,"./isLength":971,"dup":235}],969:[function(require,module,exports){
arguments[4][614][0].apply(exports,arguments)
},{"./_root":948,"./stubFalse":984,"dup":614}],970:[function(require,module,exports){
arguments[4][237][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./isObject":972,"dup":237}],971:[function(require,module,exports){
arguments[4][238][0].apply(exports,arguments)
},{"dup":238}],972:[function(require,module,exports){
arguments[4][239][0].apply(exports,arguments)
},{"dup":239}],973:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],974:[function(require,module,exports){
arguments[4][772][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./_getPrototype":908,"./isObjectLike":973,"dup":772}],975:[function(require,module,exports){
arguments[4][619][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./isArray":967,"./isObjectLike":973,"dup":619}],976:[function(require,module,exports){
arguments[4][620][0].apply(exports,arguments)
},{"./_baseGetTag":861,"./isObjectLike":973,"dup":620}],977:[function(require,module,exports){
arguments[4][621][0].apply(exports,arguments)
},{"./_baseIsTypedArray":868,"./_baseUnary":879,"./_nodeUtil":945,"dup":621}],978:[function(require,module,exports){
arguments[4][622][0].apply(exports,arguments)
},{"./_arrayLikeKeys":844,"./_baseKeys":870,"./isArrayLike":968,"dup":622}],979:[function(require,module,exports){
arguments[4][734][0].apply(exports,arguments)
},{"./_arrayLikeKeys":844,"./_baseKeysIn":871,"./isArrayLike":968,"dup":734}],980:[function(require,module,exports){
arguments[4][623][0].apply(exports,arguments)
},{"./_arrayMap":845,"./_baseIteratee":869,"./_baseMap":872,"./isArray":967,"dup":623}],981:[function(require,module,exports){
arguments[4][624][0].apply(exports,arguments)
},{"./_MapCache":832,"dup":624}],982:[function(require,module,exports){
arguments[4][626][0].apply(exports,arguments)
},{"./_baseProperty":875,"./_basePropertyDeep":876,"./_isKey":924,"./_toKey":958,"dup":626}],983:[function(require,module,exports){
arguments[4][627][0].apply(exports,arguments)
},{"dup":627}],984:[function(require,module,exports){
arguments[4][628][0].apply(exports,arguments)
},{"dup":628}],985:[function(require,module,exports){
arguments[4][631][0].apply(exports,arguments)
},{"./_baseToString":878,"dup":631}],986:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports.ActionTypes = undefined;
exports['default'] = createStore;

var _isPlainObject = require('lodash/isPlainObject');

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

var _symbolObservable = require('symbol-observable');

var _symbolObservable2 = _interopRequireDefault(_symbolObservable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var ActionTypes = exports.ActionTypes = {
  INIT: '@@redux/INIT'
};

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} enhancer The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }

  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */
  function getState() {
    return currentState;
  }

  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */
  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected listener to be a function.');
    }

    var isSubscribed = true;

    ensureCanMutateNextListeners();
    nextListeners.push(listener);

    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */
  function dispatch(action) {
    if (!(0, _isPlainObject2['default'])(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      listeners[i]();
    }

    return action;
  }

  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer;
    dispatch({ type: ActionTypes.INIT });
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/zenparsing/es-observable
   */
  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object') {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return { unsubscribe: unsubscribe };
      }
    }, _ref[_symbolObservable2['default']] = function () {
      return this;
    }, _ref;
  }

  // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.
  dispatch({ type: ActionTypes.INIT });

  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[_symbolObservable2['default']] = observable, _ref2;
}
},{"lodash/isPlainObject":996,"symbol-observable":1000}],987:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"./_root":994,"dup":168}],988:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./_Symbol":987,"./_getRawTag":991,"./_objectToString":992,"dup":179}],989:[function(require,module,exports){
arguments[4][195][0].apply(exports,arguments)
},{"dup":195}],990:[function(require,module,exports){
arguments[4][765][0].apply(exports,arguments)
},{"./_overArg":993,"dup":765}],991:[function(require,module,exports){
arguments[4][198][0].apply(exports,arguments)
},{"./_Symbol":987,"dup":198}],992:[function(require,module,exports){
arguments[4][219][0].apply(exports,arguments)
},{"dup":219}],993:[function(require,module,exports){
arguments[4][591][0].apply(exports,arguments)
},{"dup":591}],994:[function(require,module,exports){
arguments[4][221][0].apply(exports,arguments)
},{"./_freeGlobal":989,"dup":221}],995:[function(require,module,exports){
arguments[4][240][0].apply(exports,arguments)
},{"dup":240}],996:[function(require,module,exports){
arguments[4][772][0].apply(exports,arguments)
},{"./_baseGetTag":988,"./_getPrototype":990,"./isObjectLike":995,"dup":772}],997:[function(require,module,exports){
(function() {
  var out$ = typeof exports != 'undefined' && exports || typeof define != 'undefined' && {} || this;

  var doctype = '<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd" [<!ENTITY nbsp "&#160;">]>';

  function isElement(obj) {
    return obj instanceof HTMLElement || obj instanceof SVGElement;
  }

  function requireDomNode(el) {
    if (!isElement(el)) {
      throw new Error('an HTMLElement or SVGElement is required; got ' + el);
    }
  }

  function isExternal(url) {
    return url && url.lastIndexOf('http',0) == 0 && url.lastIndexOf(window.location.host) == -1;
  }

  function inlineImages(el, callback) {
    requireDomNode(el);

    var images = el.querySelectorAll('image'),
        left = images.length,
        checkDone = function() {
          if (left === 0) {
            callback();
          }
        };

    checkDone();
    for (var i = 0; i < images.length; i++) {
      (function(image) {
        var href = image.getAttributeNS("http://www.w3.org/1999/xlink", "href");
        if (href) {
          if (isExternal(href.value)) {
            console.warn("Cannot render embedded images linking to external hosts: "+href.value);
            return;
          }
        }
        var canvas = document.createElement('canvas');
        var ctx = canvas.getContext('2d');
        var img = new Image();
        img.crossOrigin="anonymous";
        href = href || image.getAttribute('href');
        if (href) {
          img.src = href;
          img.onload = function() {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            image.setAttributeNS("http://www.w3.org/1999/xlink", "href", canvas.toDataURL('image/png'));
            left--;
            checkDone();
          }
          img.onerror = function() {
            console.log("Could not load "+href);
            left--;
            checkDone();
          }
        } else {
          left--;
          checkDone();
        }
      })(images[i]);
    }
  }

  function styles(el, options, cssLoadedCallback) {
    var selectorRemap = options.selectorRemap;
    var modifyStyle = options.modifyStyle;
    var css = "";
    // each font that has extranl link is saved into queue, and processed
    // asynchronously
    var fontsQueue = [];
    var sheets = document.styleSheets;
    for (var i = 0; i < sheets.length; i++) {
      try {
        var rules = sheets[i].cssRules;
      } catch (e) {
        console.warn("Stylesheet could not be loaded: "+sheets[i].href);
        continue;
      }

      if (rules != null) {
        for (var j = 0, match; j < rules.length; j++, match = null) {
          var rule = rules[j];
          if (typeof(rule.style) != "undefined") {
            var selectorText;

            try {
              selectorText = rule.selectorText;
            } catch(err) {
              console.warn('The following CSS rule has an invalid selector: "' + rule + '"', err);
            }

            try {
              if (selectorText) {
                match = el.querySelector(selectorText);
              }
            } catch(err) {
              console.warn('Invalid CSS selector "' + selectorText + '"', err);
            }

            if (match) {
              var selector = selectorRemap ? selectorRemap(rule.selectorText) : rule.selectorText;
              var cssText = modifyStyle ? modifyStyle(rule.style.cssText) : rule.style.cssText;
              css += selector + " { " + cssText + " }\n";
            } else if(rule.cssText.match(/^@font-face/)) {
              // below we are trying to find matches to external link. E.g.
              // @font-face {
              //   // ...
              //   src: local('Abel'), url(https://fonts.gstatic.com/s/abel/v6/UzN-iejR1VoXU2Oc-7LsbvesZW2xOQ-xsNqO47m55DA.woff2);
              // }
              //
              // This regex will save extrnal link into first capture group
              var fontUrlRegexp = /url\(["']?(.+?)["']?\)/;
              // TODO: This needs to be changed to support multiple url declarations per font.
              var fontUrlMatch = rule.cssText.match(fontUrlRegexp);

              var externalFontUrl = (fontUrlMatch && fontUrlMatch[1]) || '';
              var fontUrlIsDataURI = externalFontUrl.match(/^data:/);
              if (fontUrlIsDataURI) {
                // We should ignore data uri - they are already embedded
                externalFontUrl = '';
              }

              if (externalFontUrl) {
                // okay, we are lucky. We can fetch this font later
                fontsQueue.push({
                  text: rule.cssText,
                  // Pass url regex, so that once font is downladed, we can run `replace()` on it
                  fontUrlRegexp: fontUrlRegexp,
                  format: getFontMimeTypeFromUrl(externalFontUrl),
                  url: externalFontUrl
                });
              } else {
                // otherwise, use previous logic
                css += rule.cssText + '\n';
              }
            }
          }
        }
      }
    }

    // Now all css is processed, it's time to handle scheduled fonts
    processFontQueue(fontsQueue);

    function getFontMimeTypeFromUrl(fontUrl) {
      var supportedFormats = {
        'woff2': 'font/woff2',
        'woff': 'font/woff',
        'otf': 'application/x-font-opentype',
        'ttf': 'application/x-font-ttf',
        'eot': 'application/vnd.ms-fontobject',
        'sfnt': 'application/font-sfnt',
        'svg': 'image/svg+xml'
      };
      var extensions = Object.keys(supportedFormats);
      for (var i = 0; i < extensions.length; ++i) {
        var extension = extensions[i];
        // TODO: This is not bullet proof, it needs to handle edge cases...
        if (fontUrl.indexOf('.' + extension) > 0) {
          return supportedFormats[extension];
        }
      }

      // If you see this error message, you probably need to update code above.
      console.error('Unknown font format for ' + fontUrl+ '; Fonts may not be working correctly');
      return 'application/octet-stream';
    }

    function processFontQueue(queue) {
      if (queue.length > 0) {
        // load fonts one by one until we have anything in the queue:
        var font = queue.pop();
        processNext(font);
      } else {
        // no more fonts to load.
        cssLoadedCallback(css);
      }

      function processNext(font) {
        // TODO: This could benefit from caching.
        var oReq = new XMLHttpRequest();
        oReq.addEventListener('load', fontLoaded);
        oReq.addEventListener('error', transferFailed);
        oReq.addEventListener('abort', transferFailed);
        oReq.open('GET', font.url);
        oReq.responseType = 'arraybuffer';
        oReq.send();

        function fontLoaded() {
          // TODO: it may be also worth to wait until fonts are fully loaded before
          // attempting to rasterize them. (e.g. use https://developer.mozilla.org/en-US/docs/Web/API/FontFaceSet )
          var fontBits = oReq.response;
          var fontInBase64 = arrayBufferToBase64(fontBits);
          updateFontStyle(font, fontInBase64);
        }

        function transferFailed(e) {
          console.warn('Failed to load font from: ' + font.url);
          console.warn(e)
          css += font.text + '\n';
          processFontQueue();
        }

        function updateFontStyle(font, fontInBase64) {
          var dataUrl = 'url("data:' + font.format + ';base64,' + fontInBase64 + '")';
          css += font.text.replace(font.fontUrlRegexp, dataUrl) + '\n';

          // schedule next font download on next tick.
          setTimeout(function() {
            processFontQueue(queue)
          }, 0);
        }

      }
    }

    function arrayBufferToBase64(buffer) {
      var binary = '';
      var bytes = new Uint8Array(buffer);
      var len = bytes.byteLength;

      for (var i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
      }

      return window.btoa(binary);
    }
  }

  function getDimension(el, clone, dim) {
    var v = (el.viewBox && el.viewBox.baseVal && el.viewBox.baseVal[dim]) ||
      (clone.getAttribute(dim) !== null && !clone.getAttribute(dim).match(/%$/) && parseInt(clone.getAttribute(dim))) ||
      el.getBoundingClientRect()[dim] ||
      parseInt(clone.style[dim]) ||
      parseInt(window.getComputedStyle(el).getPropertyValue(dim));
    return (typeof v === 'undefined' || v === null || isNaN(parseFloat(v))) ? 0 : v;
  }

  function reEncode(data) {
    data = encodeURIComponent(data);
    data = data.replace(/%([0-9A-F]{2})/g, function(match, p1) {
      var c = String.fromCharCode('0x'+p1);
      return c === '%' ? '%25' : c;
    });
    return decodeURIComponent(data);
  }

  out$.prepareSvg = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.scale = options.scale || 1;
    options.responsive = options.responsive || false;
    var xmlns = "http://www.w3.org/2000/xmlns/";

    inlineImages(el, function() {
      var outer = document.createElement("div");
      var clone = el.cloneNode(true);
      var width, height;
      if(el.tagName == 'svg') {
        width = options.width || getDimension(el, clone, 'width');
        height = options.height || getDimension(el, clone, 'height');
      } else if(el.getBBox) {
        var box = el.getBBox();
        width = box.x + box.width;
        height = box.y + box.height;
        clone.setAttribute('transform', clone.getAttribute('transform').replace(/translate\(.*?\)/, ''));

        var svg = document.createElementNS('http://www.w3.org/2000/svg','svg')
        svg.appendChild(clone)
        clone = svg;
      } else {
        console.error('Attempted to render non-SVG element', el);
        return;
      }

      clone.setAttribute("version", "1.1");
      if (!clone.getAttribute('xmlns')) {
        clone.setAttributeNS(xmlns, "xmlns", "http://www.w3.org/2000/svg");
      }
      if (!clone.getAttribute('xmlns:xlink')) {
        clone.setAttributeNS(xmlns, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      }

      if (options.responsive) {
        clone.removeAttribute('width');
        clone.removeAttribute('height');
        clone.setAttribute('preserveAspectRatio', 'xMinYMin meet');
      } else {
        clone.setAttribute("width", width * options.scale);
        clone.setAttribute("height", height * options.scale);
      }

      clone.setAttribute("viewBox", [
        options.left || 0,
        options.top || 0,
        width,
        height
      ].join(" "));

      var fos = clone.querySelectorAll('foreignObject > *');
      for (var i = 0; i < fos.length; i++) {
        if (!fos[i].getAttribute('xmlns')) {
          fos[i].setAttributeNS(xmlns, "xmlns", "http://www.w3.org/1999/xhtml");
        }
      }

      outer.appendChild(clone);

      // In case of custom fonts we need to fetch font first, and then inline
      // its url into data-uri format (encode as base64). That's why style
      // processing is done asynchonously. Once all inlining is finshed
      // cssLoadedCallback() is called.
      styles(el, options, cssLoadedCallback);

      function cssLoadedCallback(css) {
        // here all fonts are inlined, so that we can render them properly.
        var s = document.createElement('style');
        s.setAttribute('type', 'text/css');
        s.innerHTML = "<![CDATA[\n" + css + "\n]]>";
        var defs = document.createElement('defs');
        defs.appendChild(s);
        clone.insertBefore(defs, clone.firstChild);

        if (cb) {
          var outHtml = outer.innerHTML;
          outHtml = outHtml.replace(/NS\d+:href/gi, 'xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href');
          cb(outHtml, width, height);
        }
      }
    });
  }

  out$.svgAsDataUri = function(el, options, cb) {
    out$.prepareSvg(el, options, function(svg) {
      var uri = 'data:image/svg+xml;base64,' + window.btoa(reEncode(doctype + svg));
      if (cb) {
        cb(uri);
      }
    });
  }

  out$.svgAsPngUri = function(el, options, cb) {
    requireDomNode(el);

    options = options || {};
    options.encoderType = options.encoderType || 'image/png';
    options.encoderOptions = options.encoderOptions || 0.8;

    var convertToPng = function(src, w, h) {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.width = w;
      canvas.height = h;

      if(options.canvg) {
        options.canvg(canvas, src);
      } else {
        context.drawImage(src, 0, 0);
      }

      if(options.backgroundColor){
        context.globalCompositeOperation = 'destination-over';
        context.fillStyle = options.backgroundColor;
        context.fillRect(0, 0, canvas.width, canvas.height);
      }

      var png;
      try {
        png = canvas.toDataURL(options.encoderType, options.encoderOptions);
      } catch (e) {
        if ((typeof SecurityError !== 'undefined' && e instanceof SecurityError) || e.name == "SecurityError") {
          console.error("Rendered SVG images cannot be downloaded in this browser.");
          return;
        } else {
          throw e;
        }
      }
      cb(png);
    }

    if(options.canvg) {
      out$.prepareSvg(el, options, convertToPng);
    } else {
      out$.svgAsDataUri(el, options, function(uri) {
        var image = new Image();

        image.onload = function() {
          convertToPng(image, image.width, image.height);
        }

        image.onerror = function() {
          console.error(
            'There was an error loading the data URI as an image on the following SVG\n',
            window.atob(uri.slice(26)), '\n',
            "Open the following link to see browser's diagnosis\n",
            uri);
        }

        image.src = uri;
      });
    }
  }

  out$.download = function(name, uri) {
    if (navigator.msSaveOrOpenBlob) {
      navigator.msSaveOrOpenBlob(uriToBlob(uri), name);
    } else {
      var saveLink = document.createElement('a');
      var downloadSupported = 'download' in saveLink;
      if (downloadSupported) {
        saveLink.download = name;
        saveLink.href = uri;
        saveLink.style.display = 'none';
        document.body.appendChild(saveLink);
        saveLink.click();
        document.body.removeChild(saveLink);
      }
      else {
        window.open(uri, '_temp', 'menubar=no,toolbar=no,status=no');
      }
    }
  }

  function uriToBlob(uri) {
    var byteString = window.atob(uri.split(',')[1]);
    var mimeString = uri.split(',')[0].split(':')[1].split(';')[0]
    var buffer = new ArrayBuffer(byteString.length);
    var intArray = new Uint8Array(buffer);
    for (var i = 0; i < byteString.length; i++) {
      intArray[i] = byteString.charCodeAt(i);
    }
    return new Blob([buffer], {type: mimeString});
  }

  out$.saveSvg = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsDataUri(el, options, function(uri) {
      out$.download(name, uri);
    });
  }

  out$.saveSvgAsPng = function(el, name, options) {
    requireDomNode(el);

    options = options || {};
    out$.svgAsPngUri(el, options, function(uri) {
      out$.download(name, uri);
    });
  }

  // if define is defined create as an AMD module
  if (typeof define !== 'undefined') {
    define(function() {
      return out$;
    });
  }

})();

},{}],998:[function(require,module,exports){
'use strict';

var isArrayish = require('is-arrayish');

var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};

},{"is-arrayish":999}],999:[function(require,module,exports){
'use strict';

module.exports = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

},{}],1000:[function(require,module,exports){
module.exports = require('./lib/index');

},{"./lib/index":1001}],1001:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ponyfill = require('./ponyfill');

var _ponyfill2 = _interopRequireDefault(_ponyfill);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var root; /* global window */


if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = (0, _ponyfill2['default'])(root);
exports['default'] = result;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./ponyfill":1002}],1002:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports['default'] = symbolObservablePonyfill;
function symbolObservablePonyfill(root) {
	var result;
	var _Symbol = root.Symbol;

	if (typeof _Symbol === 'function') {
		if (_Symbol.observable) {
			result = _Symbol.observable;
		} else {
			result = _Symbol('observable');
			_Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
};
},{}],1003:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule update
 */

'use strict';

var __DEV__ = process.env.NODE_ENV !== 'production';

var invariant = require("invariant");
var hasOwnProperty = {}.hasOwnProperty;

function assign(target, sources) {
  if (target == null) {
    throw new TypeError('Object.assign target cannot be null or undefined');
  }

  var to = Object(target);

  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
    var nextSource = arguments[nextIndex];
    if (nextSource == null) {
      continue;
    }

    var from = Object(nextSource);

    // We don't currently support accessors nor proxies. Therefore this
    // copy cannot throw. If we ever supported this then we must handle
    // exceptions and side-effects. We don't support symbols so they won't
    // be transferred.

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
  }

  return to;
}

function shallowCopy(x) {
  if (Array.isArray(x)) {
    return x.concat();
  } else if (x && typeof x === 'object') {
    return assign(new x.constructor(), x);
  } else {
    return x;
  }
}

var COMMAND_PUSH = '$push';
var COMMAND_UNSHIFT = '$unshift';
var COMMAND_SPLICE = '$splice';
var COMMAND_SET = '$set';
var COMMAND_MERGE = '$merge';
var COMMAND_APPLY = '$apply';

var ALL_COMMANDS_LIST = [
  COMMAND_PUSH,
  COMMAND_UNSHIFT,
  COMMAND_SPLICE,
  COMMAND_SET,
  COMMAND_MERGE,
  COMMAND_APPLY
];

var ALL_COMMANDS_SET = {};

ALL_COMMANDS_LIST.forEach(function(command) {
  ALL_COMMANDS_SET[command] = true;
});

function invariantArrayCase(value, spec, command) {
  (__DEV__ ? invariant(
    Array.isArray(value),
    'update(): expected target of %s to be an array; got %s.',
    command,
    value
  ) : invariant(Array.isArray(value)));
  var specValue = spec[command];
  (__DEV__ ? invariant(
    Array.isArray(specValue),
    'update(): expected spec of %s to be an array; got %s. ' +
    'Did you forget to wrap your parameter in an array?',
    command,
    specValue
  ) : invariant(Array.isArray(specValue)));
}

function update(value, spec) {
  (__DEV__ ? invariant(
    typeof spec === 'object',
    'update(): You provided a key path to update() that did not contain one ' +
    'of %s. Did you forget to include {%s: ...}?',
    ALL_COMMANDS_LIST.join(', '),
    COMMAND_SET
  ) : invariant(typeof spec === 'object'));

  if (hasOwnProperty.call(spec, COMMAND_SET)) {
    (__DEV__ ? invariant(
      Object.keys(spec).length === 1,
      'Cannot have more than one key in an object with %s',
      COMMAND_SET
    ) : invariant(Object.keys(spec).length === 1));

    return spec[COMMAND_SET];
  }

  var nextValue = shallowCopy(value);

  if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
    var mergeObj = spec[COMMAND_MERGE];
    (__DEV__ ? invariant(
      mergeObj && typeof mergeObj === 'object',
      'update(): %s expects a spec of type \'object\'; got %s',
      COMMAND_MERGE,
      mergeObj
    ) : invariant(mergeObj && typeof mergeObj === 'object'));
    (__DEV__ ? invariant(
      nextValue && typeof nextValue === 'object',
      'update(): %s expects a target of type \'object\'; got %s',
      COMMAND_MERGE,
      nextValue
    ) : invariant(nextValue && typeof nextValue === 'object'));
    assign(nextValue, spec[COMMAND_MERGE]);
  }

  if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
    invariantArrayCase(value, spec, COMMAND_PUSH);
    spec[COMMAND_PUSH].forEach(function(item) {
      nextValue.push(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
    invariantArrayCase(value, spec, COMMAND_UNSHIFT);
    spec[COMMAND_UNSHIFT].forEach(function(item) {
      nextValue.unshift(item);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
    (__DEV__ ? invariant(
      Array.isArray(value),
      'Expected %s target to be an array; got %s',
      COMMAND_SPLICE,
      value
    ) : invariant(Array.isArray(value)));
    (__DEV__ ? invariant(
      Array.isArray(spec[COMMAND_SPLICE]),
      'update(): expected spec of %s to be an array of arrays; got %s. ' +
      'Did you forget to wrap your parameters in an array?',
      COMMAND_SPLICE,
      spec[COMMAND_SPLICE]
    ) : invariant(Array.isArray(spec[COMMAND_SPLICE])));
    spec[COMMAND_SPLICE].forEach(function(args) {
      (__DEV__ ? invariant(
        Array.isArray(args),
        'update(): expected spec of %s to be an array of arrays; got %s. ' +
        'Did you forget to wrap your parameters in an array?',
        COMMAND_SPLICE,
        spec[COMMAND_SPLICE]
      ) : invariant(Array.isArray(args)));
      nextValue.splice.apply(nextValue, args);
    });
  }

  if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
    (__DEV__ ? invariant(
      typeof spec[COMMAND_APPLY] === 'function',
      'update(): expected spec of %s to be a function; got %s.',
      COMMAND_APPLY,
      spec[COMMAND_APPLY]
    ) : invariant(typeof spec[COMMAND_APPLY] === 'function'));
    nextValue = spec[COMMAND_APPLY](nextValue);
  }

  for (var k in spec) {
    if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
      nextValue[k] = update(value[k], spec[k]);
    }
  }

  return nextValue;
}

module.exports = update;

}).call(this,require('_process'))
},{"_process":395,"invariant":327}],1004:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],1005:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],1006:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":1005,"_process":395,"inherits":1004}],1007:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":1010,"./v4":1011}],1008:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;

},{}],1009:[function(require,module,exports){
(function (global){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1010:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":1008,"./lib/rng":1009}],1011:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":1008,"./lib/rng":1009}],1012:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

'use strict';

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = function() {};

if (process.env.NODE_ENV !== 'production') {
  warning = function(condition, format, args) {
    var len = arguments.length;
    args = new Array(len > 2 ? len - 2 : 0);
    for (var key = 2; key < len; key++) {
      args[key - 2] = arguments[key];
    }
    if (format === undefined) {
      throw new Error(
        '`warning(condition, format, ...args)` requires a warning ' +
        'message argument'
      );
    }

    if (format.length < 10 || (/^[s\W]*$/).test(format)) {
      throw new Error(
        'The warning format should be able to uniquely identify this ' +
        'warning. Please, use a more descriptive format than: ' + format
      );
    }

    if (!condition) {
      var argIndex = 0;
      var message = 'Warning: ' +
        format.replace(/%s/g, function() {
          return args[argIndex++];
        });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch(x) {}
    }
  };
}

module.exports = warning;

}).call(this,require('_process'))
},{"_process":395}],1013:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],1014:[function(require,module,exports){
var CachingDataSource, DataSource, LRU,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

DataSource = require('mwater-expressions').DataSource;

LRU = require("lru-cache");

module.exports = CachingDataSource = (function(superClass) {
  extend(CachingDataSource, superClass);

  function CachingDataSource(options) {
    this.perform = options.perform;
    this.cache = LRU({
      max: 500,
      maxAge: 1000 * 15 * 60
    });
  }

  CachingDataSource.prototype.performQuery = function(query, cb) {
    var cacheKey, cachedRows;
    cacheKey = JSON.stringify(query);
    cachedRows = this.cache.get(cacheKey);
    if (cachedRows) {
      return cb(null, cachedRows);
    }
    return this.perform(query, (function(_this) {
      return function(err, rows) {
        if (!err) {
          _this.cache.set(cacheKey, rows);
        }
        return cb(err, rows);
      };
    })(this));
  };

  return CachingDataSource;

})(DataSource);


},{"lru-cache":333,"mwater-expressions":14}],1015:[function(require,module,exports){
var CheckboxComponent, H, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = CheckboxComponent = (function(superClass) {
  extend(CheckboxComponent, superClass);

  function CheckboxComponent() {
    this.handleClick = bind(this.handleClick, this);
    return CheckboxComponent.__super__.constructor.apply(this, arguments);
  }

  CheckboxComponent.propTypes = {
    checked: React.PropTypes.bool,
    onClick: React.PropTypes.func,
    onChange: React.PropTypes.func
  };

  CheckboxComponent.prototype.handleClick = function() {
    if (this.props.onChange) {
      this.props.onChange(!this.props.checked);
    }
    if (this.props.onClick) {
      return this.props.onClick();
    }
  };

  CheckboxComponent.prototype.render = function() {
    return H.div({
      className: (this.props.checked ? "mwater-visualization-checkbox checked" : "mwater-visualization-checkbox"),
      onClick: this.handleClick
    }, this.props.children);
  };

  return CheckboxComponent;

})(React.Component);


},{"react":"react"}],1016:[function(require,module,exports){
var ClickOutHandler, ColorComponent, H, React, SketchPicker, SwatchesPicker,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

ClickOutHandler = require('react-onclickout');

SketchPicker = require("react-color").SketchPicker;

SwatchesPicker = require('react-color').SwatchesPicker;

module.exports = ColorComponent = (function(superClass) {
  extend(ColorComponent, superClass);

  ColorComponent.propTypes = {
    color: React.PropTypes.string,
    onChange: React.PropTypes.func
  };

  function ColorComponent() {
    this.handleAdvanced = bind(this.handleAdvanced, this);
    this.handleTransparent = bind(this.handleTransparent, this);
    this.handleReset = bind(this.handleReset, this);
    this.handleClose = bind(this.handleClose, this);
    this.handleClick = bind(this.handleClick, this);
    ColorComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      advanced: false
    };
  }

  ColorComponent.prototype.handleClick = function() {
    return this.setState({
      open: !this.state.open,
      advanced: false
    });
  };

  ColorComponent.prototype.handleClose = function(color) {
    this.setState({
      open: false
    });
    return this.props.onChange(color.hex);
  };

  ColorComponent.prototype.handleReset = function() {
    this.setState({
      open: false
    });
    return this.props.onChange(null);
  };

  ColorComponent.prototype.handleTransparent = function() {
    this.setState({
      open: false
    });
    return this.props.onChange("transparent");
  };

  ColorComponent.prototype.handleAdvanced = function() {
    return this.setState({
      advanced: !this.state.advanced
    });
  };

  ColorComponent.prototype.render = function() {
    var popupPosition, style;
    style = {
      height: 20,
      width: 20,
      border: "solid 2px #888",
      borderRadius: 4,
      backgroundColor: this.props.color,
      cursor: "pointer",
      display: "inline-block"
    };
    if (!this.props.color) {
      style.backgroundColor = "#AAA";
      style.backgroundImage = "repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(255,255,255,.7) 2px, rgba(255,255,255,.7) 4px)";
    }
    popupPosition = {
      position: 'absolute',
      top: 0,
      left: 30,
      zIndex: 1000,
      backgroundColor: "white",
      border: "solid 1px #DDD",
      borderRadius: 3
    };
    return H.div({
      style: {
        position: "relative",
        display: "inline-block"
      }
    }, H.div({
      style: style,
      onClick: this.handleClick
    }), this.state.open ? React.createElement(ClickOutHandler, {
      onClickOut: ((function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this))
    }, H.div({
      style: popupPosition
    }, H.button({
      type: "button",
      className: "btn btn-link btn-sm",
      onClick: this.handleReset
    }, H.i({
      className: "fa fa-undo"
    }), " Reset Color"), H.button({
      type: "button",
      className: "btn btn-link btn-sm",
      onClick: this.handleAdvanced
    }, this.state.advanced ? "Basic" : "Advanced"), this.state.advanced ? React.createElement(SketchPicker, {
      color: this.props.color || void 0,
      onChangeComplete: this.handleClose
    }) : React.createElement(SwatchesPicker, {
      color: this.props.color || void 0,
      onChangeComplete: this.handleClose
    }))) : void 0);
  };

  return ColorComponent;

})(React.Component);


},{"react":"react","react-color":494,"react-onclickout":812}],1017:[function(require,module,exports){
var ColorSchemeFactory, _, brewer, c_c, d3, generateCategoricalSet, generateSequentialSet, rgbStringToHex;

_ = require('lodash');

d3 = require('d3-scale');

brewer = require('d3-scale-chromatic');

c_c = require('color-mixer');

rgbStringToHex = function(rgbString) {
  var _color, rgbArray;
  rgbArray = rgbString.substring(4, rgbString.length - 1).split(',').map(function(item) {
    return parseInt(item);
  });
  _color = new c_c.Color({
    rgb: rgbArray
  });
  return _color.hex();
};

generateCategoricalSet = function(set, number, reversed) {
  var i, j, ref, results;
  results = [];
  for (i = j = 0, ref = number; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    results.push(set[(reversed ? number - i - 1 : i) % set.length]);
  }
  return results;
};

generateSequentialSet = function(set, number, reversed) {
  var color, colors, i;
  color = d3.scaleLinear().domain([0, number - 1]).range([0, 1]);
  colors = (function() {
    var j, ref, results;
    results = [];
    for (i = j = 0, ref = number; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results.push(set(color((reversed ? number - i - 1 : i))));
    }
    return results;
  })();
  return _.map(colors, function(color) {
    return rgbStringToHex(color);
  });
};

module.exports = ColorSchemeFactory = (function() {
  function ColorSchemeFactory() {}

  ColorSchemeFactory.createColorScheme = function(options) {
    switch (options.type) {
      case 'schemeAccent':
        return generateCategoricalSet(brewer.schemeAccent, options.number, options.reversed);
      case 'schemeDark2':
        return generateCategoricalSet(brewer.schemeDark2, options.number, options.reversed);
      case 'schemePaired':
        return generateCategoricalSet(brewer.schemePaired, options.number, options.reversed);
      case 'schemePastel1':
        return generateCategoricalSet(brewer.schemePastel1, options.number, options.reversed);
      case 'schemePastel2':
        return generateCategoricalSet(brewer.schemePastel2, options.number, options.reversed);
      case 'schemeSet1':
        return generateCategoricalSet(brewer.schemeSet1, options.number, options.reversed);
      case 'schemeSet2':
        return generateCategoricalSet(brewer.schemeSet2, options.number, options.reversed);
      case 'schemeSet3':
        return generateCategoricalSet(brewer.schemeSet3, options.number, options.reversed);
      case 'interpolateBlues':
        return generateSequentialSet(brewer.interpolateBlues, options.number, options.reversed);
      case 'interpolateGreens':
        return generateSequentialSet(brewer.interpolateGreens, options.number, options.reversed);
      case 'interpolateGreys':
        return generateSequentialSet(brewer.interpolateGreys, options.number, options.reversed);
      case 'interpolateOranges':
        return generateSequentialSet(brewer.interpolateOranges, options.number, options.reversed);
      case 'interpolatePurples':
        return generateSequentialSet(brewer.interpolatePurples, options.number, options.reversed);
      case 'interpolateReds':
        return generateSequentialSet(brewer.interpolateReds, options.number, options.reversed);
      case 'interpolateBuGn':
        return generateSequentialSet(brewer.interpolateBuGn, options.number, options.reversed);
      case 'interpolateBuPu':
        return generateSequentialSet(brewer.interpolateBuPu, options.number, options.reversed);
      case 'interpolateGnBu':
        return generateSequentialSet(brewer.interpolateGnBu, options.number, options.reversed);
      case 'interpolateOrRd':
        return generateSequentialSet(brewer.interpolateOrRd, options.number, options.reversed);
      case 'interpolatePuBuGn':
        return generateSequentialSet(brewer.interpolatePuBuGn, options.number, options.reversed);
      case 'interpolatePuBu':
        return generateSequentialSet(brewer.interpolatePuBu, options.number, options.reversed);
      case 'interpolatePuRd':
        return generateSequentialSet(brewer.interpolatePuRd, options.number, options.reversed);
      case 'interpolateRdPu':
        return generateSequentialSet(brewer.interpolateRdPu, options.number, options.reversed);
      case 'interpolateYlGnBu':
        return generateSequentialSet(brewer.interpolateYlGnBu, options.number, options.reversed);
      case 'interpolateYlGn':
        return generateSequentialSet(brewer.interpolateYlGn, options.number, options.reversed);
      case 'interpolateYlOrBr':
        return generateSequentialSet(brewer.interpolateYlOrBr, options.number, options.reversed);
      case 'interpolateYlOrRd':
        return generateSequentialSet(brewer.interpolateYlOrRd, options.number, options.reversed);
      case 'interpolateBrBG':
        return generateSequentialSet(brewer.interpolateBrBG, options.number, options.reversed);
      case 'interpolatePRGn':
        return generateSequentialSet(brewer.interpolatePRGn, options.number, options.reversed);
      case 'interpolatePiYG':
        return generateSequentialSet(brewer.interpolatePiYG, options.number, options.reversed);
      case 'interpolatePuOr':
        return generateSequentialSet(brewer.interpolatePuOr, options.number, options.reversed);
      case 'interpolateRdBu':
        return generateSequentialSet(brewer.interpolateRdBu, options.number, options.reversed);
      case 'interpolateRdGy':
        return generateSequentialSet(brewer.interpolateRdGy, options.number, options.reversed);
      case 'interpolateRdYlBu':
        return generateSequentialSet(brewer.interpolateRdYlBu, options.number, options.reversed);
      case 'interpolateRdYlGn':
        return generateSequentialSet(brewer.interpolateRdYlGn, options.number, options.reversed);
      case 'interpolateSpectral':
        return generateSequentialSet(brewer.interpolateSpectral, options.number, options.reversed);
      default:
        throw "Scheme type is not valid";
    }
  };

  ColorSchemeFactory.createColorMapForCategories = function(categories, isCategorical) {
    var colorMap, scheme, type;
    if (isCategorical) {
      type = "schemeSet1";
    } else {
      type = "interpolateBlues";
    }
    scheme = ColorSchemeFactory.createColorScheme({
      type: type,
      number: _.any(categories, function(c) {
        return c.value == null;
      }) ? categories.length - 1 : categories.length
    });
    colorMap = _.map(categories, function(category, i) {
      return {
        value: category.value,
        color: category.value === null ? "#aaaaaa" : scheme[i % scheme.length]
      };
    });
    return colorMap;
  };

  return ColorSchemeFactory;

})();


},{"color-mixer":122,"d3-scale":136,"d3-scale-chromatic":135,"lodash":"lodash"}],1018:[function(require,module,exports){
var CsvBuilder, _;

_ = require('lodash');

module.exports = CsvBuilder = (function() {
  function CsvBuilder() {}

  CsvBuilder.prototype.build = function(table) {
    return this._stringifyCsv(table, this._csvifyValue);
  };

  CsvBuilder.prototype._stringifyCsv = function(table, replacer) {
    var c, cc, cell, csv, r, rr;
    replacer = replacer || function(r, c, v) {
      return v;
    };
    csv = "";
    rr = table.length;
    r = 0;
    while (r < rr) {
      if (r) {
        csv += "\r\n";
      }
      c = 0;
      cc = table[r].length;
      while (c < cc) {
        if (c) {
          csv += ",";
        }
        cell = replacer(r, c, table[r][c]);
        if (/[,\r\n"]/.test(cell)) {
          cell = "\"" + cell.replace(/"/g, "\"\"") + "\"";
        }
        csv += (cell || 0 === cell ? cell : "");
        ++c;
      }
      ++r;
    }
    return csv;
  };

  CsvBuilder.prototype._csvifyValue = function(r, c, value) {
    if (value == null) {
      return "";
    }
    if (_.isArray(value)) {
      return value.join(",");
    }
    if (value === true) {
      return "true";
    }
    if (value === false) {
      return "false";
    }
    return value;
  };

  return CsvBuilder;

})();


},{"lodash":"lodash"}],1019:[function(require,module,exports){
var ExprCleaner, ExprUtils, FilterExprComponent, FiltersDesignerComponent, H, PopoverHelpComponent, R, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

PopoverHelpComponent = require('react-library/lib/PopoverHelpComponent');

module.exports = FiltersDesignerComponent = (function(superClass) {
  extend(FiltersDesignerComponent, superClass);

  function FiltersDesignerComponent() {
    this.renderFilterableTable = bind(this.renderFilterableTable, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    return FiltersDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  FiltersDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    filterableTables: React.PropTypes.arrayOf(React.PropTypes.string),
    filters: React.PropTypes.object,
    onFiltersChange: React.PropTypes.func.isRequired
  };

  FiltersDesignerComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  FiltersDesignerComponent.prototype.handleFilterChange = function(table, expr) {
    var filters;
    expr = new ExprCleaner(this.props.schema).cleanExpr(expr, {
      table: table
    });
    filters = _.clone(this.props.filters || {});
    filters[table] = expr;
    return this.props.onFiltersChange(filters);
  };

  FiltersDesignerComponent.prototype.renderFilterableTable = function(table) {
    var name, ref;
    name = ExprUtils.localizeString(this.props.schema.getTable(table).name, this.context.locale);
    return H.div({
      key: table
    }, H.label(null, name), React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange.bind(null, table),
      table: table,
      value: (ref = this.props.filters) != null ? ref[table] : void 0
    }));
  };

  FiltersDesignerComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.filterableTables, this.renderFilterableTable));
  };

  return FiltersDesignerComponent;

})(React.Component);


},{"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/PopoverHelpComponent":790}],1020:[function(require,module,exports){
var ExprCompiler, ImplicitFilterBuilder, _, injectTableAlias;

_ = require('lodash');

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCompiler = require('mwater-expressions').ExprCompiler;

module.exports = ImplicitFilterBuilder = (function() {
  function ImplicitFilterBuilder(schema) {
    this.schema = schema;
  }

  ImplicitFilterBuilder.prototype.findJoins = function(filterableTables) {
    var allJoins, filterableTable, i, joins, len, table;
    allJoins = [];
    for (i = 0, len = filterableTables.length; i < len; i++) {
      filterableTable = filterableTables[i];
      table = this.schema.getTable(filterableTable);
      if (!table) {
        continue;
      }
      joins = _.filter(this.schema.getColumns(filterableTable), (function(_this) {
        return function(column) {
          return column.type === "join" && column.join.type === "n-1" && column.join.toTable !== filterableTable;
        };
      })(this));
      joins = _.flatten(_.filter(_.values(_.groupBy(joins, function(join) {
        return join.join.toTable;
      })), function(list) {
        return list.length === 1;
      }));
      allJoins = allJoins.concat(_.map(joins, function(join) {
        return {
          table: filterableTable,
          column: join.id
        };
      }));
    }
    return allJoins;
  };

  ImplicitFilterBuilder.prototype.extendFilters = function(filterableTables, filters) {
    var exprCompiler, i, implicitFilter, implicitFilters, j, join, joinColumn, joins, len, len1, parentFilter, parentFilters;
    implicitFilters = [];
    joins = this.findJoins(filterableTables);
    exprCompiler = new ExprCompiler(this.schema);
    for (i = 0, len = joins.length; i < len; i++) {
      join = joins[i];
      parentFilters = _.filter(filters, (function(_this) {
        return function(f) {
          return f.table === _this.schema.getColumn(join.table, join.column).join.toTable && f.jsonql;
        };
      })(this));
      if (parentFilters.length === 0) {
        continue;
      }
      joinColumn = this.schema.getColumn(join.table, join.column);
      implicitFilter = {
        table: join.table,
        jsonql: {
          type: "op",
          op: "or",
          exprs: [
            {
              type: "op",
              op: "exists",
              exprs: [
                {
                  type: "query",
                  selects: [],
                  from: {
                    type: "table",
                    table: joinColumn.join.toTable,
                    alias: "explicit"
                  },
                  where: {
                    type: "op",
                    op: "and",
                    exprs: [exprCompiler.compileJoin(joinColumn.join, "{alias}", "explicit")]
                  }
                }
              ]
            }, {
              type: "op",
              op: "is null",
              exprs: [
                exprCompiler.compileExpr({
                  expr: {
                    type: "field",
                    table: join.table,
                    column: join.column
                  },
                  tableAlias: "{alias}"
                })
              ]
            }
          ]
        }
      };
      for (j = 0, len1 = parentFilters.length; j < len1; j++) {
        parentFilter = parentFilters[j];
        implicitFilter.jsonql.exprs[0].exprs[0].where.exprs.push(injectTableAlias(parentFilter.jsonql, "explicit"));
      }
      implicitFilters.push(implicitFilter);
    }
    return filters.concat(implicitFilters);
    return filters;
  };

  return ImplicitFilterBuilder;

})();


},{"lodash":"lodash","mwater-expressions":14}],1021:[function(require,module,exports){
var AddRelatedFormModalComponent, ExprUtils, H, MWaterAddRelatedFormComponent, ModalPopupComponent, R, React, _, formUtils, moment, querystring, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

moment = require('moment');

ModalPopupComponent = require('react-library/lib/ModalPopupComponent');

querystring = require('querystring');

ExprUtils = require('mwater-expressions').ExprUtils;

ui = require('./UIComponents');

formUtils = require('mwater-forms/lib/formUtils');

module.exports = MWaterAddRelatedFormComponent = (function(superClass) {
  extend(MWaterAddRelatedFormComponent, superClass);

  MWaterAddRelatedFormComponent.propTypes = {
    table: React.PropTypes.string.isRequired,
    apiUrl: React.PropTypes.string.isRequired,
    client: React.PropTypes.string,
    user: React.PropTypes.string,
    onSelect: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired
  };

  function MWaterAddRelatedFormComponent() {
    this.handleSelect = bind(this.handleSelect, this);
    this.handleOpen = bind(this.handleOpen, this);
    MWaterAddRelatedFormComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      waitingForTable: null
    };
  }

  MWaterAddRelatedFormComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (this.state.waitingForTable && nextProps.schema.getTable(this.state.waitingForTable)) {
      return this.setState({
        waitingForTable: null
      });
    }
  };

  MWaterAddRelatedFormComponent.prototype.handleOpen = function() {
    return this.setState({
      open: true
    });
  };

  MWaterAddRelatedFormComponent.prototype.handleSelect = function(table) {
    this.setState({
      open: false
    });
    if (!this.props.schema.getTable(table)) {
      this.setState({
        waitingForTable: table
      });
    }
    return this.props.onSelect(table);
  };

  MWaterAddRelatedFormComponent.prototype.render = function() {
    return H.div(null, this.state.waitingForTable ? H.div(null, H.i({
      className: "fa fa-spin fa-spinner"
    }), " Adding...") : H.a({
      className: "btn btn-link",
      onClick: this.handleOpen
    }, "+ Add Related Survey"), this.state.open ? R(AddRelatedFormModalComponent, {
      table: this.props.table,
      apiUrl: this.props.apiUrl,
      client: this.props.client,
      user: this.props.user,
      onSelect: this.handleSelect,
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this)
    }) : void 0);
  };

  return MWaterAddRelatedFormComponent;

})(React.Component);

AddRelatedFormModalComponent = (function(superClass) {
  extend(AddRelatedFormModalComponent, superClass);

  AddRelatedFormModalComponent.propTypes = {
    table: React.PropTypes.string.isRequired,
    apiUrl: React.PropTypes.string.isRequired,
    client: React.PropTypes.string,
    user: React.PropTypes.string,
    onSelect: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  AddRelatedFormModalComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function AddRelatedFormModalComponent() {
    AddRelatedFormModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      items: null,
      search: ""
    };
  }

  AddRelatedFormModalComponent.prototype.componentDidMount = function() {
    var query;
    query = {};
    query.selector = JSON.stringify({
      state: {
        $ne: "deleted"
      }
    });
    if (this.props.client) {
      query.client = this.props.client;
    }
    return $.getJSON(this.props.apiUrl + "forms?" + querystring.stringify(query), (function(_this) {
      return function(forms) {
        var items;
        forms = _.sortByOrder(forms, [
          function(form) {
            if (form.created.by === _this.props.user) {
              return 1;
            } else {
              return 0;
            }
          }, function(form) {
            return form.modified.on;
          }
        ], ['desc', 'desc']);
        forms = _.filter(forms, function(form) {
          return formUtils.findEntityQuestion(form.design, _this.props.table.split(".")[1]);
        });
        items = _.map(forms, function(form) {
          return {
            name: ExprUtils.localizeString(form.design.name, _this.context.locale),
            desc: "Modified " + (moment(form.modified.on, moment.ISO_8601).format("ll")),
            onClick: _this.props.onSelect.bind(null, "responses:" + form._id)
          };
        });
        return _this.setState({
          items: items
        });
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        return _this.setState({
          error: xhr.responseText
        });
      };
    })(this));
  };

  AddRelatedFormModalComponent.prototype.renderContents = function() {
    var items, searchStringRegExp;
    if (!this.state.items) {
      return H.div({
        className: "alert alert-info"
      }, H.i({
        className: "fa fa-spin fa-spinner"
      }), " Loading...");
    }
    items = this.state.items;
    if (this.state.search) {
      searchStringRegExp = new RegExp(_.escapeRegExp(this.state.search), "i");
      items = _.filter(items, (function(_this) {
        return function(item) {
          return item.name.match(searchStringRegExp);
        };
      })(this));
    }
    return H.div(null, H.input({
      type: "text",
      className: "form-control",
      placeholder: "Search...",
      key: "search",
      ref: this.searchRef,
      style: {
        marginBottom: 10
      },
      value: this.state.search,
      onChange: (function(_this) {
        return function(ev) {
          return _this.setState({
            search: ev.target.value
          });
        };
      })(this)
    }), R(ui.OptionListComponent, {
      items: items
    }));
  };

  AddRelatedFormModalComponent.prototype.render = function() {
    return R(ModalPopupComponent, {
      showCloseX: true,
      onClose: this.props.onCancel,
      header: "Add Related Survey"
    }, this.renderContents());
  };

  return AddRelatedFormModalComponent;

})(React.Component);


},{"./UIComponents":1026,"lodash":"lodash","moment":337,"mwater-expressions":14,"mwater-forms/lib/formUtils":371,"querystring":400,"react":"react","react-library/lib/ModalPopupComponent":786}],1022:[function(require,module,exports){
var AsyncLoadComponent, H, LoadingComponent, MWaterAddRelatedFormComponent, MWaterDataSource, MWaterLoaderComponent, MWaterTableSelectComponent, R, React, Schema, _, mWaterLoader, querystring,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

Schema = require('mwater-expressions').Schema;

MWaterDataSource = require('mwater-expressions/lib/MWaterDataSource');

MWaterTableSelectComponent = require('./MWaterTableSelectComponent');

MWaterAddRelatedFormComponent = require('./MWaterAddRelatedFormComponent');

querystring = require('querystring');

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

LoadingComponent = require('react-library/lib/LoadingComponent');

mWaterLoader = require('./mWaterLoader');

module.exports = MWaterLoaderComponent = (function(superClass) {
  extend(MWaterLoaderComponent, superClass);

  MWaterLoaderComponent.propTypes = {
    apiUrl: React.PropTypes.string.isRequired,
    client: React.PropTypes.string,
    share: React.PropTypes.string,
    user: React.PropTypes.string,
    asUser: React.PropTypes.string,
    extraTables: React.PropTypes.arrayOf(React.PropTypes.string),
    onExtraTablesChange: React.PropTypes.func,
    addLayerElementFactory: React.PropTypes.func,
    children: React.PropTypes.func.isRequired
  };

  function MWaterLoaderComponent() {
    this.handleAddTable = bind(this.handleAddTable, this);
    MWaterLoaderComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      error: null,
      schema: null,
      dataSource: null
    };
    this.mounted = false;
  }

  MWaterLoaderComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return !_.isEqual(_.pick(newProps, "apiUrl", "client", "user", "share", "asUser", "extraTables"), _.pick(oldProps, "apiUrl", "client", "user", "share", "asUser", "extraTables"));
  };

  MWaterLoaderComponent.prototype.load = function(props, prevProps, callback) {
    return mWaterLoader({
      apiUrl: props.apiUrl,
      client: props.client,
      share: props.share,
      asUser: props.asUser,
      extraTables: props.extraTables
    }, (function(_this) {
      return function(error, config) {
        if (error) {
          console.log(error.message);
          return callback({
            error: "Cannot load one of the forms that this depends on. Perhaps the administrator has not shared the form with you?"
          });
        }
        return callback({
          schema: config.schema,
          dataSource: config.dataSource
        });
      };
    })(this));
  };

  MWaterLoaderComponent.childContextTypes = {
    tableSelectElementFactory: React.PropTypes.func,
    addLayerElementFactory: React.PropTypes.func,
    decorateScalarExprTreeSectionChildren: React.PropTypes.func
  };

  MWaterLoaderComponent.prototype.getChildContext = function() {
    var context;
    context = {};
    context.tableSelectElementFactory = (function(_this) {
      return function(schema, value, onChange) {
        return React.createElement(MWaterTableSelectComponent, {
          apiUrl: _this.props.apiUrl,
          client: _this.props.client,
          schema: schema,
          user: _this.props.user,
          table: value,
          onChange: onChange,
          extraTables: _this.props.extraTables,
          onExtraTablesChange: _this.props.onExtraTablesChange
        });
      };
    })(this);
    if (this.props.addLayerElementFactory) {
      context.addLayerElementFactory = this.props.addLayerElementFactory;
    }
    context.decorateScalarExprTreeSectionChildren = (function(_this) {
      return function(options) {
        if (options.tableId.match(/^entities\./) && options.section.id === "!related_forms") {
          return H.div(null, options.children, R(MWaterAddRelatedFormComponent, {
            table: options.tableId,
            apiUrl: _this.props.apiUrl,
            client: _this.props.client,
            user: _this.props.user,
            schema: _this.state.schema,
            onSelect: _this.handleAddTable
          }));
        } else {
          return options.children;
        }
      };
    })(this);
    return context;
  };

  MWaterLoaderComponent.prototype.handleAddTable = function(table) {
    var extraTables;
    extraTables = _.union(this.props.extraTables, [table]);
    return this.props.onExtraTablesChange(extraTables);
  };

  MWaterLoaderComponent.prototype.render = function() {
    if (!this.state.schema && !this.state.error) {
      return React.createElement(LoadingComponent);
    }
    return this.props.children(this.state.error, {
      schema: this.state.schema,
      dataSource: this.state.dataSource
    });
  };

  return MWaterLoaderComponent;

})(AsyncLoadComponent);


},{"./MWaterAddRelatedFormComponent":1021,"./MWaterTableSelectComponent":1023,"./mWaterLoader":1070,"lodash":"lodash","mwater-expressions":14,"mwater-expressions/lib/MWaterDataSource":8,"querystring":400,"react":"react","react-library/lib/AsyncLoadComponent":782,"react-library/lib/LoadingComponent":785}],1023:[function(require,module,exports){
var ExprUtils, FormsListComponent, H, MWaterTableSelectComponent, R, React, TabbedComponent, moment, querystring, siteTypes, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react');

H = React.DOM;

R = React.createElement;

querystring = require('querystring');

TabbedComponent = require('react-library/lib/TabbedComponent');

ui = require('./UIComponents');

ExprUtils = require("mwater-expressions").ExprUtils;

moment = require('moment');

siteTypes = ["entities.water_point", "entities.household", "entities.sanitation_facility", "entities.community", "entities.school", "entities.health_facility", "entities.surface_water", "entities.place_of_worship", "entities.water_system"];

module.exports = MWaterTableSelectComponent = (function(superClass) {
  extend(MWaterTableSelectComponent, superClass);

  MWaterTableSelectComponent.propTypes = {
    apiUrl: React.PropTypes.string.isRequired,
    client: React.PropTypes.string,
    schema: React.PropTypes.object.isRequired,
    user: React.PropTypes.string,
    table: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired,
    extraTables: React.PropTypes.array.isRequired,
    onExtraTablesChange: React.PropTypes.func.isRequired
  };

  MWaterTableSelectComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function MWaterTableSelectComponent() {
    this.handleExtraTableRemove = bind(this.handleExtraTableRemove, this);
    this.handleExtraTableAdd = bind(this.handleExtraTableAdd, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleChange = bind(this.handleChange, this);
    MWaterTableSelectComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      pendingExtraTable: null
    };
  }

  MWaterTableSelectComponent.prototype.componentWillReceiveProps = function(nextProps) {
    var table;
    if (this.state.pendingExtraTable) {
      table = this.state.pendingExtraTable;
      if (nextProps.schema.getTable(table)) {
        this.setState({
          pendingExtraTable: null
        });
        this.refs.toggleEdit.close();
        return nextProps.onChange(table);
      }
    }
  };

  MWaterTableSelectComponent.prototype.handleChange = function(tableId) {
    this.refs.toggleEdit.close();
    if (tableId !== this.props.table) {
      return this.props.onChange(tableId);
    }
  };

  MWaterTableSelectComponent.prototype.handleTableChange = function(tableId) {
    if (!this.props.schema.getTable(tableId)) {
      return this.setState({
        pendingExtraTable: tableId
      }, (function(_this) {
        return function() {
          return _this.props.onExtraTablesChange(_.union(_this.props.extraTables, [tableId]));
        };
      })(this));
    } else {
      return this.handleChange(tableId);
    }
  };

  MWaterTableSelectComponent.prototype.handleExtraTableAdd = function(tableId) {
    return this.props.onExtraTablesChange(_.union(this.props.extraTables, [tableId]));
  };

  MWaterTableSelectComponent.prototype.handleExtraTableRemove = function(tableId) {
    if (this.props.table === tableId) {
      this.props.onChange(null);
    }
    return this.props.onExtraTablesChange(_.without(this.props.extraTables, tableId));
  };

  MWaterTableSelectComponent.prototype.renderSites = function() {
    return R(ui.OptionListComponent, {
      items: _.compact(_.map(siteTypes, (function(_this) {
        return function(tableId) {
          var table;
          table = _this.props.schema.getTable(tableId);
          if (!table) {
            return null;
          }
          return {
            name: ExprUtils.localizeString(table.name, _this.context.locale),
            desc: ExprUtils.localizeString(table.desc, _this.context.locale),
            onClick: _this.handleChange.bind(null, table.id)
          };
        };
      })(this)))
    });
  };

  MWaterTableSelectComponent.prototype.renderForms = function() {
    return R(FormsListComponent, {
      schema: this.props.schema,
      client: this.props.client,
      apiUrl: this.props.apiUrl,
      user: this.props.user,
      onChange: this.handleTableChange,
      extraTables: this.props.extraTables,
      onExtraTableAdd: this.handleExtraTableAdd,
      onExtraTableRemove: this.handleExtraTableRemove
    });
  };

  MWaterTableSelectComponent.prototype.renderOther = function() {
    var otherTables;
    otherTables = _.filter(this.props.schema.getTables(), (function(_this) {
      return function(table) {
        var ref;
        return ((ref = table.id, indexOf.call(siteTypes, ref) < 0) && !table.id.match(/^responses:/)) && !table.deprecated;
      };
    })(this));
    otherTables = _.sortBy(otherTables, function(table) {
      return table.name.en;
    });
    return R(ui.OptionListComponent, {
      items: _.map(otherTables, (function(_this) {
        return function(table) {
          return {
            name: ExprUtils.localizeString(table.name, _this.context.locale),
            desc: ExprUtils.localizeString(table.desc, _this.context.locale),
            onClick: _this.handleChange.bind(null, table.id)
          };
        };
      })(this))
    });
  };

  MWaterTableSelectComponent.prototype.render = function() {
    var editor, ref;
    editor = H.div(null, this.state.pendingExtraTable ? H.div({
      className: "alert alert-info",
      key: "pendingExtraTable"
    }, H.i({
      className: "fa fa-spinner fa-spin"
    }), "\u00a0Please wait...") : void 0, H.div({
      className: "text-muted"
    }, "Select data from sites, surveys or an advanced category below. Indicators can be found within their associated site types."), R(TabbedComponent, {
      tabs: [
        {
          id: "sites",
          label: [
            H.i({
              className: "fa fa-map-marker"
            }), " Sites"
          ],
          elem: this.renderSites()
        }, {
          id: "forms",
          label: [
            H.i({
              className: "fa fa-th-list"
            }), " Surveys"
          ],
          elem: this.renderForms()
        }, {
          id: "other",
          label: "Advanced",
          elem: this.renderOther()
        }
      ],
      initialTabId: "sites"
    }));
    return R(ui.ToggleEditComponent, {
      ref: "toggleEdit",
      forceOpen: !this.props.table,
      label: this.props.table ? ExprUtils.localizeString((ref = this.props.schema.getTable(this.props.table)) != null ? ref.name : void 0, this.context.locale) : "",
      editor: editor
    });
  };

  return MWaterTableSelectComponent;

})(React.Component);

FormsListComponent = (function(superClass) {
  extend(FormsListComponent, superClass);

  FormsListComponent.propTypes = {
    apiUrl: React.PropTypes.string.isRequired,
    client: React.PropTypes.string,
    schema: React.PropTypes.object.isRequired,
    user: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired,
    extraTables: React.PropTypes.array.isRequired,
    onExtraTableAdd: React.PropTypes.func.isRequired,
    onExtraTableRemove: React.PropTypes.func.isRequired
  };

  FormsListComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function FormsListComponent() {
    this.searchRef = bind(this.searchRef, this);
    this.handleTableRemove = bind(this.handleTableRemove, this);
    this.handleTableAdd = bind(this.handleTableAdd, this);
    FormsListComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      forms: null,
      search: ""
    };
  }

  FormsListComponent.prototype.componentDidMount = function() {
    var query;
    query = {};
    query.fields = JSON.stringify({
      "design.name": 1,
      roles: 1,
      created: 1,
      modified: 1,
      state: 1,
      isMaster: 1
    });
    query.selector = JSON.stringify({
      design: {
        $exists: true
      },
      state: {
        $ne: "deleted"
      }
    });
    query.client = this.props.client;
    return $.getJSON(this.props.apiUrl + "forms?" + querystring.stringify(query), (function(_this) {
      return function(forms) {
        forms = _.sortByOrder(forms, [
          function(form) {
            var ref;
            if (ref = "responses:" + form._id, indexOf.call(_this.props.extraTables, ref) >= 0) {
              return 1;
            } else {
              return 0;
            }
          }, function(form) {
            if (form.created.by === _this.props.user) {
              return 1;
            } else {
              return 0;
            }
          }, function(form) {
            return form.modified.on;
          }
        ], ['desc', 'desc', 'desc']);
        return _this.setState({
          forms: _.map(forms, function(form) {
            return {
              id: form._id,
              name: ExprUtils.localizeString(form.design.name, _this.context.locale),
              desc: "Modified " + (moment(form.modified.on, moment.ISO_8601).format("ll"))
            };
          })
        });
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        return _this.setState({
          error: xhr.responseText
        });
      };
    })(this));
  };

  FormsListComponent.prototype.handleTableAdd = function(tableId) {
    return this.props.onExtraTableAdd(tableId);
  };

  FormsListComponent.prototype.handleTableRemove = function(table) {
    if (confirm("Remove " + (ExprUtils.localizeString(table.name, this.context.locale)) + "? Any widgets that depend on it will no longer work properly.")) {
      return this.props.onExtraTableRemove(table.id);
    }
  };

  FormsListComponent.prototype.searchRef = function(comp) {
    if (comp) {
      return comp.focus();
    }
  };

  FormsListComponent.prototype.render = function() {
    var escapeRegExp, forms, searchStringRegExp, tables;
    if (this.state.error) {
      return H.div({
        className: "alert alert-danger"
      }, this.state.error);
    }
    if (this.state.search) {
      escapeRegExp = function(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      };
      searchStringRegExp = new RegExp(escapeRegExp(this.state.search), "i");
      forms = _.filter(this.state.forms, (function(_this) {
        return function(form) {
          return form.name.match(searchStringRegExp);
        };
      })(this));
    } else {
      forms = this.state.forms;
    }
    forms = _.filter(forms, (function(_this) {
      return function(f) {
        var ref;
        return ref = "responses:" + f.id, indexOf.call(_this.props.extraTables, ref) < 0;
      };
    })(this));
    tables = _.filter(this.props.schema.getTables(), (function(_this) {
      return function(table) {
        return (table.id.match(/^responses:/) || table.id.match(/^master_responses:/)) && !table.deprecated;
      };
    })(this));
    tables = _.sortBy(tables, function(t) {
      return t.name.en;
    });
    return H.div(null, H.label(null, "Included Surveys:"), tables.length > 0 ? R(ui.OptionListComponent, {
      items: _.map(tables, (function(_this) {
        return function(table) {
          return {
            name: ExprUtils.localizeString(table.name, _this.context.locale),
            desc: ExprUtils.localizeString(table.desc, _this.context.locale),
            onClick: _this.props.onChange.bind(null, table.id),
            onRemove: _this.handleTableRemove.bind(null, table)
          };
        };
      })(this))
    }) : H.div(null, "None"), H.br(), H.label(null, "All Surveys:"), !this.state.forms || this.state.forms.length === 0 ? H.div({
      className: "alert alert-info"
    }, H.i({
      className: "fa fa-spinner fa-spin"
    }), "\u00A0Loading...") : [
      H.input({
        type: "text",
        className: "form-control input-sm",
        placeholder: "Search...",
        key: "search",
        ref: this.searchRef,
        style: {
          maxWidth: "20em",
          marginBottom: 10
        },
        value: this.state.search,
        onChange: (function(_this) {
          return function(ev) {
            return _this.setState({
              search: ev.target.value
            });
          };
        })(this)
      }), R(ui.OptionListComponent, {
        items: _.map(forms, (function(_this) {
          return function(form) {
            return {
              name: form.name,
              desc: form.desc,
              onClick: _this.props.onChange.bind(null, "responses:" + form.id)
            };
          };
        })(this))
      })
    ]);
  };

  return FormsListComponent;

})(React.Component);


},{"./UIComponents":1026,"moment":337,"mwater-expressions":14,"querystring":400,"react":"react","react-library/lib/TabbedComponent":792}],1024:[function(require,module,exports){
var H, RadioButtonComponent, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = RadioButtonComponent = (function(superClass) {
  extend(RadioButtonComponent, superClass);

  function RadioButtonComponent() {
    this.handleClick = bind(this.handleClick, this);
    return RadioButtonComponent.__super__.constructor.apply(this, arguments);
  }

  RadioButtonComponent.propTypes = {
    checked: React.PropTypes.bool,
    onClick: React.PropTypes.func,
    onChange: React.PropTypes.func
  };

  RadioButtonComponent.prototype.handleClick = function() {
    if (this.props.onChange) {
      this.props.onChange(!this.props.checked);
    }
    if (this.props.onClick) {
      return this.props.onClick();
    }
  };

  RadioButtonComponent.prototype.render = function() {
    return H.div({
      className: (this.props.checked ? "mwater-visualization-radio checked" : "mwater-visualization-radio"),
      onClick: this.handleClick
    }, this.props.children);
  };

  return RadioButtonComponent;

})(React.Component);


},{"react":"react"}],1025:[function(require,module,exports){
var ExprUtils, H, React, TableSelectComponent, ui,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ui = require('./UIComponents');

ExprUtils = require("mwater-expressions").ExprUtils;

H = React.DOM;

module.exports = TableSelectComponent = (function(superClass) {
  extend(TableSelectComponent, superClass);

  function TableSelectComponent() {
    return TableSelectComponent.__super__.constructor.apply(this, arguments);
  }

  TableSelectComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    value: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired
  };

  TableSelectComponent.contextTypes = {
    tableSelectElementFactory: React.PropTypes.func,
    locale: React.PropTypes.string
  };

  TableSelectComponent.prototype.render = function() {
    if (this.context.tableSelectElementFactory) {
      return this.context.tableSelectElementFactory(this.props.schema, this.props.value, this.props.onChange);
    }
    return React.createElement(ui.ToggleEditComponent, {
      forceOpen: !this.props.value,
      label: this.props.value ? ExprUtils.localizeString(this.props.schema.getTable(this.props.value).name, this.context.locale) : H.i(null, "Select..."),
      editor: (function(_this) {
        return function(onClose) {
          return React.createElement(ui.OptionListComponent, {
            hint: "Select source to get data from",
            items: _.map(_.filter(_this.props.schema.getTables(), function(table) {
              return !table.deprecated;
            }), function(table) {
              return {
                name: ExprUtils.localizeString(table.name, _this.context.locale),
                desc: ExprUtils.localizeString(table.desc, _this.context.locale),
                onClick: function() {
                  onClose();
                  return _this.props.onChange(table.id);
                }
              };
            })
          });
        };
      })(this)
    });
  };

  return TableSelectComponent;

})(React.Component);


},{"./UIComponents":1026,"mwater-expressions":14,"react":"react"}],1026:[function(require,module,exports){
var ButtonToggleComponent, H, LinkComponent, OptionComponent, OptionListComponent, R, React, ReactDOM, SectionComponent, SwitchViewComponent, ToggleEditComponent, motion,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

R = React.createElement;

motion = require('react-motion');

LinkComponent = require('mwater-expressions-ui').LinkComponent;

exports.SectionComponent = SectionComponent = (function(superClass) {
  extend(SectionComponent, superClass);

  function SectionComponent() {
    return SectionComponent.__super__.constructor.apply(this, arguments);
  }

  SectionComponent.propTypes = {
    icon: React.PropTypes.string,
    label: React.PropTypes.node
  };

  SectionComponent.prototype.render = function() {
    return H.div({
      style: {
        marginBottom: 15
      }
    }, H.label({
      className: "text-muted"
    }, this.props.icon && this.props.icon.match(/^fa-/) ? [
      H.i({
        className: "fa " + this.props.icon
      }), " "
    ] : void 0, this.props.icon && this.props.icon.match(/^glyphicon-/) ? [
      H.span({
        className: "glyphicon " + this.props.icon
      }), " "
    ] : void 0, this.props.label), H.div({
      style: {
        marginLeft: 10
      }
    }, this.props.children));
  };

  return SectionComponent;

})(React.Component);

exports.OptionListComponent = OptionListComponent = (function(superClass) {
  extend(OptionListComponent, superClass);

  function OptionListComponent() {
    return OptionListComponent.__super__.constructor.apply(this, arguments);
  }

  OptionListComponent.propTypes = {
    items: React.PropTypes.array.isRequired,
    hint: React.PropTypes.string
  };

  OptionListComponent.prototype.render = function() {
    return H.div(null, H.div({
      style: {
        color: "#AAA",
        fontStyle: "italic"
      },
      key: "hint"
    }, this.props.hint), H.div({
      className: "mwater-visualization-big-options",
      key: "options"
    }, _.map(this.props.items, (function(_this) {
      return function(item, i) {
        return R(OptionComponent, {
          name: item.name,
          desc: item.desc,
          onClick: item.onClick,
          onRemove: item.onRemove,
          key: i
        });
      };
    })(this))));
  };

  return OptionListComponent;

})(React.Component);

OptionComponent = (function(superClass) {
  extend(OptionComponent, superClass);

  function OptionComponent() {
    this.handleClick = bind(this.handleClick, this);
    return OptionComponent.__super__.constructor.apply(this, arguments);
  }

  OptionComponent.propTypes = {
    name: React.PropTypes.string,
    desc: React.PropTypes.string,
    onClick: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func
  };

  OptionComponent.prototype.handleClick = function(ev) {
    ev.stopPropagation();
    return this.props.onRemove();
  };

  OptionComponent.prototype.render = function() {
    return H.div({
      className: "mwater-visualization-big-option",
      onClick: this.props.onClick
    }, this.props.onRemove ? H.button({
      type: "button",
      className: "btn btn-link btn-xs pull-right",
      onClick: this.handleClick
    }, H.span({
      className: "glyphicon glyphicon-remove"
    })) : void 0, H.div({
      style: {
        fontWeight: "bold"
      }
    }, this.props.name), H.div({
      style: {
        color: "#888"
      }
    }, this.props.desc));
  };

  return OptionComponent;

})(React.Component);

exports.SwitchViewComponent = SwitchViewComponent = (function(superClass) {
  extend(SwitchViewComponent, superClass);

  SwitchViewComponent.propTypes = {
    views: React.PropTypes.object.isRequired,
    viewId: React.PropTypes.string.isRequired
  };

  function SwitchViewComponent(props) {
    this.refCallback = bind(this.refCallback, this);
    this.state = {
      measuring: false
    };
  }

  SwitchViewComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (nextProps.viewId !== this.props.viewId) {
      return this.setState({
        measuring: true
      });
    }
  };

  SwitchViewComponent.prototype.refCallback = function(id, comp) {
    this.comps = this.comps || {};
    return this.comps[id] = comp;
  };

  SwitchViewComponent.prototype.componentDidUpdate = function(prevProps, prevState) {
    var id, j, len, ref;
    if (this.state.measuring) {
      this.heights = {};
      ref = _.keys(this.props.views);
      for (j = 0, len = ref.length; j < len; j++) {
        id = ref[j];
        this.heights[id] = ReactDOM.findDOMNode(this.comps[id]).clientHeight;
      }
      return this.setState({
        measuring: false
      });
    }
  };

  SwitchViewComponent.prototype.render = function() {
    var id, ref, style, view;
    style = {};
    ref = this.props.views;
    for (id in ref) {
      view = ref[id];
      style[id] = motion.spring((id === this.props.viewId ? 1 : 0), [332, 34]);
    }
    return R(motion.Motion, {
      style: style
    }, (function(_this) {
      return function(style) {
        var height, val;
        if (_this.state.measuring) {
          return H.div({
            style: {
              position: "relative"
            }
          }, _.map(_.keys(_this.props.views), function(v) {
            return H.div({
              style: {
                position: "absolute",
                top: 0,
                opacity: style[v]
              },
              ref: _this.refCallback.bind(null, v),
              key: v
            }, _this.props.views[v]);
          }));
        }
        if (style[_this.props.viewId] !== 1) {
          height = 0;
          for (id in style) {
            val = style[id];
            height += val * _this.heights[id];
          }
          return H.div({
            style: {
              position: "relative",
              height: height
            }
          }, _.map(_.keys(_this.props.views), function(v) {
            return H.div({
              style: {
                position: "absolute",
                top: 0,
                left: 0,
                right: 0,
                opacity: style[v]
              },
              key: v
            }, _this.props.views[v]);
          }));
        }
        return H.div(null, H.div({
          key: _this.props.viewId
        }, _this.props.views[_this.props.viewId]));
      };
    })(this));
  };

  return SwitchViewComponent;

})(React.Component);

exports.ToggleEditComponent = ToggleEditComponent = (function(superClass) {
  extend(ToggleEditComponent, superClass);

  ToggleEditComponent.propTypes = {
    forceOpen: React.PropTypes.bool,
    initiallyOpen: React.PropTypes.bool,
    label: React.PropTypes.node.isRequired,
    editor: React.PropTypes.any.isRequired,
    onRemove: React.PropTypes.func
  };

  function ToggleEditComponent(props) {
    this.editorRef = bind(this.editorRef, this);
    this.handleToggle = bind(this.handleToggle, this);
    this.open = bind(this.open, this);
    this.close = bind(this.close, this);
    this.state = {
      open: props.initiallyOpen || false
    };
  }

  ToggleEditComponent.prototype.close = function() {
    if (this.editorComp) {
      this.editorHeight = ReactDOM.findDOMNode(this.editorComp).clientHeight;
    }
    return this.setState({
      open: false
    });
  };

  ToggleEditComponent.prototype.open = function() {
    return this.setState({
      open: true
    });
  };

  ToggleEditComponent.prototype.handleToggle = function() {
    return this.setState({
      open: !this.state.open
    });
  };

  ToggleEditComponent.prototype.editorRef = function(editorComp) {
    return this.editorComp = editorComp;
  };

  ToggleEditComponent.prototype.render = function() {
    var editor, isOpen, link;
    editor = this.props.editor;
    if (_.isFunction(editor)) {
      editor = editor(this.close);
    }
    link = R(LinkComponent, {
      onClick: this.open,
      onRemove: this.props.onRemove
    }, this.props.label);
    isOpen = this.state.open || this.props.forceOpen;
    return R(SwitchViewComponent, {
      views: {
        editor: editor,
        link: link
      },
      viewId: isOpen ? "editor" : "link"
    });
  };

  return ToggleEditComponent;

})(React.Component);

exports.ButtonToggleComponent = ButtonToggleComponent = (function(superClass) {
  extend(ButtonToggleComponent, superClass);

  function ButtonToggleComponent() {
    return ButtonToggleComponent.__super__.constructor.apply(this, arguments);
  }

  ButtonToggleComponent.propTypes = {
    value: React.PropTypes.any,
    options: React.PropTypes.arrayOf(React.PropTypes.shape({
      label: React.PropTypes.node.isRequired,
      value: React.PropTypes.any
    })).isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  ButtonToggleComponent.prototype.render = function() {
    return H.div({
      className: "btn-group btn-group-xs"
    }, _.map(this.props.options, (function(_this) {
      return function(option, i) {
        return H.button({
          type: "button",
          key: option.value,
          className: (option.value === _this.props.value ? "btn btn-default active" : "btn btn-default"),
          onClick: _this.props.onChange.bind(null, option.value)
        }, option.label);
      };
    })(this)));
  };

  return ButtonToggleComponent;

})(React.Component);


},{"mwater-expressions-ui":362,"react":"react","react-dom":"react-dom","react-motion":805}],1027:[function(require,module,exports){
var UndoStack, _;

_ = require('lodash');

module.exports = UndoStack = (function() {
  function UndoStack(undoStack, redoStack) {
    this.undoStack = undoStack || [];
    this.redoStack = redoStack || [];
  }

  UndoStack.prototype.push = function(value) {
    var redoStack, undoStack;
    if (_.isEqual(this.getValue(), value)) {
      return this;
    }
    undoStack = this.undoStack.slice();
    undoStack.push(value);
    redoStack = [];
    return new UndoStack(undoStack, redoStack);
  };

  UndoStack.prototype.canUndo = function() {
    return this.undoStack.length > 1;
  };

  UndoStack.prototype.canRedo = function() {
    return this.redoStack.length > 0;
  };

  UndoStack.prototype.undo = function() {
    var redoStack, undoStack;
    redoStack = this.redoStack.slice();
    redoStack.push(_.last(this.undoStack));
    undoStack = _.initial(this.undoStack);
    return new UndoStack(undoStack, redoStack);
  };

  UndoStack.prototype.redo = function() {
    var redoStack, undoStack;
    undoStack = this.undoStack.slice();
    undoStack.push(_.last(this.redoStack));
    redoStack = _.initial(this.redoStack);
    return new UndoStack(undoStack, redoStack);
  };

  UndoStack.prototype.getValue = function() {
    return _.last(this.undoStack);
  };

  return UndoStack;

})();


},{"lodash":"lodash"}],1028:[function(require,module,exports){
var H, React, ReactDOM, VerticalLayoutComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

_ = require('lodash');

module.exports = VerticalLayoutComponent = (function(superClass) {
  extend(VerticalLayoutComponent, superClass);

  VerticalLayoutComponent.propTypes = {
    height: React.PropTypes.number.isRequired,
    relativeHeights: React.PropTypes.object.isRequired
  };

  function VerticalLayoutComponent() {
    VerticalLayoutComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      availableHeight: 0
    };
  }

  VerticalLayoutComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (nextProps.height !== this.props.height || !_.isEqual(nextProps.relativeHeights, this.props.relativeHeights)) {
      return this.recalculateSize(nextProps);
    }
  };

  VerticalLayoutComponent.prototype.componentDidMount = function() {
    return this.recalculateSize(this.props);
  };

  VerticalLayoutComponent.prototype.recalculateSize = function(props) {
    var availableHeight, child, i, len, node, ref;
    availableHeight = props.height;
    ref = props.children;
    for (i = 0, len = ref.length; i < len; i++) {
      child = ref[i];
      if (!child) {
        continue;
      }
      if (props.relativeHeights[child.key]) {
        continue;
      }
      node = ReactDOM.findDOMNode(this.refs[child.key]);
      availableHeight -= $(node).outerHeight();
    }
    return this.setState({
      availableHeight: availableHeight
    });
  };

  VerticalLayoutComponent.prototype.getComponent = function(key) {
    return this.refs[key];
  };

  VerticalLayoutComponent.prototype.render = function() {
    return H.div({
      style: {
        height: this.props.height
      }
    }, React.Children.map(this.props.children, (function(_this) {
      return function(child) {
        var height;
        if (!child) {
          return;
        }
        if (child.key && _this.props.relativeHeights[child.key]) {
          if (_this.state.availableHeight) {
            height = _this.state.availableHeight * _this.props.relativeHeights[child.key];
            return H.div({
              style: {
                height: height,
                position: "relative"
              }
            }, H.div({
              style: {
                height: height
              },
              ref: child.key
            }, React.cloneElement(child, {
              height: height
            })));
          }
          return null;
        }
        return H.div({
          ref: child.key
        }, child);
      };
    })(this)));
  };

  return VerticalLayoutComponent;

})(React.Component);


},{"lodash":"lodash","react":"react","react-dom":"react-dom"}],1029:[function(require,module,exports){
var AxisBuilder, ExprCleaner, ExprCompiler, ExprUtils, H, React, _, d3Format, epsilon, moment, uuid, xforms,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

uuid = require('uuid');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCleaner = require('mwater-expressions').ExprCleaner;

d3Format = require('d3-format');

moment = require('moment');

React = require('react');

H = React.DOM;

xforms = [
  {
    type: "bin",
    input: "number",
    output: "enum"
  }, {
    type: "ranges",
    input: "number",
    output: "enum"
  }, {
    type: "date",
    input: "datetime",
    output: "date"
  }, {
    type: "year",
    input: "date",
    output: "date"
  }, {
    type: "year",
    input: "datetime",
    output: "date"
  }, {
    type: "yearmonth",
    input: "date",
    output: "date"
  }, {
    type: "yearmonth",
    input: "datetime",
    output: "date"
  }, {
    type: "month",
    input: "date",
    output: "enum"
  }, {
    type: "month",
    input: "datetime",
    output: "enum"
  }
];

epsilon = 0.000000001;

module.exports = AxisBuilder = (function() {
  function AxisBuilder(options) {
    this.schema = options.schema;
    this.exprUtils = new ExprUtils(this.schema);
    this.exprCleaner = new ExprCleaner(this.schema);
  }

  AxisBuilder.prototype.cleanAxis = function(options) {
    var aggrStatuses, axis, type, xform;
    if (!options.axis) {
      return;
    }
    axis = _.clone(options.axis);
    if (axis.aggr && axis.expr) {
      axis.expr = {
        type: "op",
        op: axis.aggr,
        table: axis.expr.table,
        exprs: (axis.aggr !== "count" ? [axis.expr] : [])
      };
      delete axis.aggr;
    }
    switch (options.aggrNeed) {
      case "none":
        aggrStatuses = ["literal", "individual"];
        break;
      case "optional":
        aggrStatuses = ["literal", "individual", "aggregate"];
        break;
      case "required":
        aggrStatuses = ["literal", "aggregate"];
    }
    axis.expr = this.exprCleaner.cleanExpr(axis.expr, {
      table: options.table,
      aggrStatuses: aggrStatuses
    });
    if (!axis.expr) {
      return null;
    }
    type = this.exprUtils.getExprType(axis.expr);
    if (axis.xform) {
      xform = _.find(xforms, function(xf) {
        var ref;
        if (xf.type !== axis.xform.type) {
          return false;
        }
        if (xf.input !== type) {
          return false;
        }
        if (options.types && (ref = xf.output, indexOf.call(options.types, ref) < 0)) {
          return false;
        }
        return true;
      });
      if (!xform) {
        delete axis.xform;
      }
    }
    if (!axis.xform && options.types && type && indexOf.call(options.types, type) < 0) {
      xform = _.find(xforms, function(xf) {
        var ref;
        return xf.input === type && (ref = xf.output, indexOf.call(options.types, ref) >= 0);
      });
      if (xform) {
        axis.xform = {
          type: xform.type
        };
        type = xform.output;
      } else {
        if (options.aggrNeed === "none") {
          return null;
        }
        if (indexOf.call(options.types, "number") < 0 || type !== "id") {
          return null;
        }
      }
    }
    if (axis.xform && axis.xform.type === "bin") {
      if (!axis.xform.numBins) {
        axis.xform.numBins = 5;
      }
    }
    if (axis.xform && axis.xform.type === "ranges") {
      if (!axis.xform.ranges) {
        axis.xform.ranges = [
          {
            id: uuid(),
            minOpen: false,
            maxOpen: true
          }
        ];
      }
    }
    return axis;
  };

  AxisBuilder.prototype.validateAxis = function(options) {
    var j, len, range, ref;
    if (!options.axis) {
      return;
    }
    if (options.axis.xform && options.axis.xform.type === "bin") {
      if (!options.axis.xform.numBins) {
        return "Missing numBins";
      }
      if (options.axis.xform.min == null) {
        return "Missing min";
      }
      if (options.axis.xform.max == null) {
        return "Missing max";
      }
      if (options.axis.xform.max < options.axis.xform.min) {
        return "Max < min";
      }
    }
    if (options.axis.xform && options.axis.xform.type === "ranges") {
      if (!options.axis.xform.ranges || !_.isArray(options.axis.xform.ranges)) {
        return "Missing ranges";
      }
      ref = options.axis.xform.ranges;
      for (j = 0, len = ref.length; j < len; j++) {
        range = ref[j];
        if ((range.minValue != null) && (range.maxValue != null) && range.minValue > range.maxValue) {
          return "Max < min";
        }
      }
    }
  };

  AxisBuilder.prototype.compileAxis = function(options) {
    var cases, compiledExpr, expr, exprCompiler, j, len, max, min, range, ref, thresholds, whens;
    if (!options.axis) {
      return null;
    }
    expr = options.axis.expr;
    if (options.axis.aggr) {
      expr = {
        type: "op",
        op: options.axis.aggr,
        table: expr.table,
        exprs: (options.axis.aggr !== "count" ? [expr] : [])
      };
    }
    exprCompiler = new ExprCompiler(this.schema);
    compiledExpr = exprCompiler.compileExpr({
      expr: expr,
      tableAlias: options.tableAlias
    });
    if (options.axis.xform) {
      if (options.axis.xform.type === "bin") {
        min = options.axis.xform.min;
        max = options.axis.xform.max;
        if (max === min) {
          max += epsilon;
        }
        if (max === min) {
          max = min * 1.00001;
        }
        if (options.axis.xform.excludeUpper) {
          thresholds = _.map(_.range(0, options.axis.xform.numBins), function(bin) {
            return min + (max - min) * bin / options.axis.xform.numBins;
          });
          thresholds.push(max + epsilon);
          compiledExpr = {
            type: "op",
            op: "width_bucket",
            exprs: [
              {
                type: "op",
                op: "::decimal",
                exprs: [compiledExpr]
              }, {
                type: "literal",
                value: thresholds
              }
            ]
          };
        } else {
          compiledExpr = {
            type: "op",
            op: "width_bucket",
            exprs: [compiledExpr, min, max, options.axis.xform.numBins]
          };
        }
      }
      if (options.axis.xform.type === "date") {
        compiledExpr = {
          type: "op",
          op: "substr",
          exprs: [compiledExpr, 1, 10]
        };
      }
      if (options.axis.xform.type === "year") {
        compiledExpr = {
          type: "op",
          op: "rpad",
          exprs: [
            {
              type: "op",
              op: "substr",
              exprs: [compiledExpr, 1, 4]
            }, 10, "-01-01"
          ]
        };
      }
      if (options.axis.xform.type === "yearmonth") {
        compiledExpr = {
          type: "op",
          op: "rpad",
          exprs: [
            {
              type: "op",
              op: "substr",
              exprs: [compiledExpr, 1, 7]
            }, 10, "-01"
          ]
        };
      }
      if (options.axis.xform.type === "month") {
        compiledExpr = {
          type: "op",
          op: "substr",
          exprs: [compiledExpr, 6, 2]
        };
      }
      if (options.axis.xform.type === "ranges") {
        cases = [];
        ref = options.axis.xform.ranges;
        for (j = 0, len = ref.length; j < len; j++) {
          range = ref[j];
          whens = [];
          if (range.minValue != null) {
            if (range.minOpen) {
              whens.push({
                type: "op",
                op: ">",
                exprs: [compiledExpr, range.minValue]
              });
            } else {
              whens.push({
                type: "op",
                op: ">=",
                exprs: [compiledExpr, range.minValue]
              });
            }
          }
          if (range.maxValue != null) {
            if (range.maxOpen) {
              whens.push({
                type: "op",
                op: "<",
                exprs: [compiledExpr, range.maxValue]
              });
            } else {
              whens.push({
                type: "op",
                op: "<=",
                exprs: [compiledExpr, range.maxValue]
              });
            }
          }
          if (whens.length > 1) {
            cases.push({
              when: {
                type: "op",
                op: "and",
                exprs: whens
              },
              then: range.id
            });
          } else if (whens.length === 1) {
            cases.push({
              when: whens[0],
              then: range.id
            });
          }
        }
        if (cases.length > 0) {
          compiledExpr = {
            type: "case",
            cases: cases
          };
        } else {
          compiledExpr = null;
        }
      }
    }
    return compiledExpr;
  };

  AxisBuilder.prototype.compileBinMinMax = function(expr, table, filterExpr, numBins) {
    var compiledExpr, compiledFilterExpr, exprCompiler, maxExpr, minExpr, query, where;
    exprCompiler = new ExprCompiler(this.schema);
    compiledExpr = exprCompiler.compileExpr({
      expr: expr,
      tableAlias: "binrange"
    });
    minExpr = {
      type: "op",
      op: "min",
      exprs: [
        {
          type: "field",
          tableAlias: "inner",
          column: "val"
        }
      ]
    };
    maxExpr = {
      type: "op",
      op: "max",
      exprs: [
        {
          type: "field",
          tableAlias: "inner",
          column: "val"
        }
      ]
    };
    where = {
      type: "op",
      op: "is not null",
      exprs: [compiledExpr]
    };
    if (filterExpr) {
      compiledFilterExpr = exprCompiler.compileExpr({
        expr: filterExpr,
        tableAlias: "binrange"
      });
      if (compiledFilterExpr) {
        where = {
          type: "op",
          op: "and",
          exprs: [where, compiledFilterExpr]
        };
      }
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: minExpr,
          alias: "min"
        }, {
          type: "select",
          expr: maxExpr,
          alias: "max"
        }
      ],
      from: {
        type: "subquery",
        query: {
          type: "query",
          selects: [
            {
              type: "select",
              expr: compiledExpr,
              alias: "val"
            }, {
              type: "select",
              expr: {
                type: "op",
                op: "ntile",
                exprs: [numBins + 2]
              },
              over: {
                orderBy: [
                  {
                    expr: compiledExpr,
                    direction: "asc"
                  }
                ]
              },
              alias: "ntilenum"
            }
          ],
          from: {
            type: "table",
            table: table,
            alias: "binrange"
          },
          where: where
        },
        alias: "inner"
      },
      where: {
        type: "op",
        op: "between",
        exprs: [
          {
            type: "field",
            tableAlias: "inner",
            column: "ntilenum"
          }, 2, numBins + 1
        ]
      }
    };
    return query;
  };

  AxisBuilder.prototype.getExprTypes = function(types) {
    var j, len, ref, xform;
    if (!types) {
      return null;
    }
    types = types.slice();
    for (j = 0, len = xforms.length; j < len; j++) {
      xform = xforms[j];
      if (ref = xform.output, indexOf.call(types, ref) >= 0) {
        types = _.union(types, [xform.input]);
      }
    }
    return types;
  };

  AxisBuilder.prototype.getValueColor = function(axis, value) {
    var item;
    item = _.find(axis.colorMap, (function(_this) {
      return function(item) {
        return item.value === value;
      };
    })(this));
    if (item) {
      return item.color;
    }
    return null;
  };

  AxisBuilder.prototype.getCategories = function(axis, values, locale) {
    var categories, current, end, format, hasNone, i, j, k, max, min, noneCategory, numBins, precision, ref, ref1, ref2, start, year;
    noneCategory = {
      value: null,
      label: axis.nullLabel || "None"
    };
    if (axis.xform && axis.xform.type === "ranges") {
      return _.map(axis.xform.ranges, (function(_this) {
        return function(range) {
          var label;
          label = range.label || "";
          if (!label) {
            if (range.minValue != null) {
              if (range.minOpen) {
                label = "> " + range.minValue;
              } else {
                label = ">= " + range.minValue;
              }
            }
            if (range.maxValue != null) {
              if (label) {
                label += " and ";
              }
              if (range.maxOpen) {
                label += "< " + range.maxValue;
              } else {
                label += "<= " + range.maxValue;
              }
            }
          }
          return {
            value: range.id,
            label: label
          };
        };
      })(this)).concat([noneCategory]);
    }
    if (axis.xform && axis.xform.type === "bin") {
      min = axis.xform.min;
      max = axis.xform.max;
      numBins = axis.xform.numBins;
      if ((min == null) || (max == null) || !numBins) {
        return [];
      }
      if ((max - min) <= epsilon || Math.abs((max - min) / (max + min)) < 0.0001) {
        return [
          {
            value: 0,
            label: "< " + min
          }, {
            value: 1,
            label: "= " + min
          }, {
            value: axis.xform.numBins + 1,
            label: "> " + min
          }, noneCategory
        ];
      }
      precision = d3Format.precisionFixed((max - min) / numBins);
      if (_.isNaN(precision)) {
        throw new Error("Min/max errors: " + min + " " + max + " " + numBins);
      }
      format = d3Format.format(",." + precision + "f");
      categories = [];
      if (!axis.xform.excludeLower) {
        categories.push({
          value: 0,
          label: "< " + (format(min))
        });
      }
      for (i = j = 1, ref = numBins; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        start = (i - 1) / numBins * (max - min) + min;
        end = i / numBins * (max - min) + min;
        categories.push({
          value: i,
          label: (format(start)) + " - " + (format(end))
        });
      }
      if (!axis.xform.excludeUpper) {
        categories.push({
          value: axis.xform.numBins + 1,
          label: "> " + (format(max))
        });
      }
      categories.push(noneCategory);
      return categories;
    }
    if (axis.xform && axis.xform.type === "month") {
      categories = [
        {
          value: "01",
          label: "January"
        }, {
          value: "02",
          label: "February"
        }, {
          value: "03",
          label: "March"
        }, {
          value: "04",
          label: "April"
        }, {
          value: "05",
          label: "May"
        }, {
          value: "06",
          label: "June"
        }, {
          value: "07",
          label: "July"
        }, {
          value: "08",
          label: "August"
        }, {
          value: "09",
          label: "September"
        }, {
          value: "10",
          label: "October"
        }, {
          value: "11",
          label: "November"
        }, {
          value: "12",
          label: "December"
        }
      ];
      if (_.any(values, function(v) {
        return v == null;
      })) {
        categories.push(noneCategory);
      }
      return categories;
    }
    if (axis.xform && axis.xform.type === "year") {
      hasNone = _.any(values, function(v) {
        return v == null;
      });
      values = _.compact(values);
      if (values.length === 0) {
        return [noneCategory];
      }
      min = _.min(_.map(values, function(date) {
        return parseInt(date.substr(0, 4));
      }));
      max = _.max(_.map(values, function(date) {
        return parseInt(date.substr(0, 4));
      }));
      categories = [];
      for (year = k = ref1 = min, ref2 = max; ref1 <= ref2 ? k <= ref2 : k >= ref2; year = ref1 <= ref2 ? ++k : --k) {
        categories.push({
          value: year + "-01-01",
          label: "" + year
        });
        if (categories.length >= 1000) {
          break;
        }
      }
      if (hasNone) {
        categories.push(noneCategory);
      }
      return categories;
    }
    if (axis.xform && axis.xform.type === "yearmonth") {
      hasNone = _.any(values, function(v) {
        return v == null;
      });
      values = _.compact(values);
      if (values.length === 0) {
        return [noneCategory];
      }
      min = values.sort()[0];
      max = values.sort().slice(-1)[0];
      current = moment(min, "YYYY-MM-DD");
      end = moment(max, "YYYY-MM-DD");
      categories = [];
      while (!current.isAfter(end)) {
        categories.push({
          value: current.format("YYYY-MM-DD"),
          label: current.format("MMM YYYY")
        });
        current.add(1, "months");
        if (categories.length >= 1000) {
          break;
        }
      }
      if (hasNone) {
        categories.push(noneCategory);
      }
      return categories;
    }
    switch (this.getAxisType(axis)) {
      case "enum":
      case "enumset":
        return _.map(this.exprUtils.getExprEnumValues(axis.expr), function(ev) {
          return {
            value: ev.id,
            label: ExprUtils.localizeString(ev.name, locale)
          };
        }).concat([noneCategory]);
      case "text":
        hasNone = _.any(values, function(v) {
          return v == null;
        });
        categories = _.map(_.compact(_.uniq(values)).sort(), function(v) {
          return {
            value: v,
            label: v || "None"
          };
        });
        if (hasNone) {
          categories.push(noneCategory);
        }
        return categories;
      case "boolean":
        return [
          {
            value: true,
            label: "True"
          }, {
            value: false,
            label: "False"
          }, noneCategory
        ];
      case "date":
        values = _.compact(values);
        if (values.length === 0) {
          return [noneCategory];
        }
        min = values.sort()[0];
        max = values.sort().slice(-1)[0];
        current = moment(min, "YYYY-MM-DD");
        end = moment(max, "YYYY-MM-DD");
        categories = [];
        while (!current.isAfter(end)) {
          categories.push({
            value: current.format("YYYY-MM-DD"),
            label: current.format("ll")
          });
          current.add(1, "days");
          if (categories.length >= 1000) {
            break;
          }
        }
        categories.push(noneCategory);
        return categories;
    }
    return [];
  };

  AxisBuilder.prototype.getAxisType = function(axis) {
    var type, xform;
    if (!axis) {
      return null;
    }
    if (axis.aggr === "count") {
      return "number";
    }
    type = this.exprUtils.getExprType(axis.expr);
    if (axis.xform) {
      xform = _.findWhere(xforms, {
        type: axis.xform.type,
        input: type
      });
      return xform.output;
    }
    return type;
  };

  AxisBuilder.prototype.isAxisAggr = function(axis) {
    return axis.aggr || this.exprUtils.getExprAggrStatus(axis.expr) === "aggregate";
  };

  AxisBuilder.prototype.summarizeAxis = function(axis, locale) {
    if (!axis) {
      return "None";
    }
    return this.exprUtils.summarizeExpr(axis.expr, locale);
  };

  AxisBuilder.prototype.formatValue = function(axis, value, locale) {
    var categories, category, format, num, type;
    if (value == null) {
      return axis.nullLabel || "None";
    }
    type = this.getAxisType(axis);
    categories = this.getCategories(axis, [value], locale);
    if (categories.length > 0) {
      if (type === "enumset") {
        if (_.isString(value)) {
          value = JSON.parse(value);
        }
        return _.map(value, function(v) {
          var category;
          category = _.findWhere(categories, {
            value: v
          });
          if (category) {
            return category.label;
          } else {
            return "???";
          }
        }).join(", ");
      } else {
        category = _.findWhere(categories, {
          value: value
        });
        if (category) {
          return category.label;
        } else {
          return "???";
        }
      }
    }
    switch (type) {
      case "text":
        return value;
      case "number":
        num = parseFloat(value);
        format = d3Format.format(axis.format != null ? axis.format : ",");
        return format(num);
      case "text[]":
        if (_.isString(value)) {
          value = JSON.parse(value);
        }
        return H.div(null, _.map(value, function(v, i) {
          return H.div({
            key: i
          }, v);
        }));
      case "date":
        return moment(value, moment.ISO_8601).format("ll");
      case "datetime":
        return moment(value, moment.ISO_8601).format("lll");
    }
    return "" + value;
  };

  AxisBuilder.prototype.createValueFilter = function(axis, value) {
    if (value != null) {
      return {
        type: "op",
        op: "=",
        exprs: [
          this.compileAxis({
            axis: axis,
            tableAlias: "{alias}"
          }), {
            type: "literal",
            value: value
          }
        ]
      };
    } else {
      return {
        type: "op",
        op: "is null",
        exprs: [
          this.compileAxis({
            axis: axis,
            tableAlias: "{alias}"
          })
        ]
      };
    }
  };

  AxisBuilder.prototype.isCategorical = function(axis) {
    var nonCategoricalTypes, type;
    nonCategoricalTypes = ["bin", "ranges", "date", "yearmonth"];
    if (axis.xform) {
      type = axis.xform.type;
    } else {
      type = this.exprUtils.getExprType(axis.expr);
    }
    return nonCategoricalTypes.indexOf(type) === -1;
  };

  return AxisBuilder;

})();


},{"d3-format":133,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react","uuid":1007}],1030:[function(require,module,exports){
var AxisBuilder, AxisColorEditorComponent, CategoryMapComponent, ColorPaletteCollectionComponent, ColorSchemeFactory, H, R, React, _, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

CategoryMapComponent = require('./CategoryMapComponent');

ColorSchemeFactory = require('../ColorSchemeFactory');

ColorPaletteCollectionComponent = require('./ColorPaletteCollectionComponent');

update = require('update-object');

AxisBuilder = require('./AxisBuilder');

module.exports = AxisColorEditorComponent = (function(superClass) {
  extend(AxisColorEditorComponent, superClass);

  AxisColorEditorComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    axis: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    categories: React.PropTypes.array,
    reorderable: React.PropTypes.bool,
    defaultColor: React.PropTypes.string,
    allowExcludedValues: React.PropTypes.bool,
    initiallyExpanded: React.PropTypes.bool
  };

  AxisColorEditorComponent.defaultProps = {
    reorderable: false
  };

  function AxisColorEditorComponent(props) {
    this.handleCancelCustomize = bind(this.handleCancelCustomize, this);
    this.handlePaletteChange = bind(this.handlePaletteChange, this);
    this.handleSelectPalette = bind(this.handleSelectPalette, this);
    AxisColorEditorComponent.__super__.constructor.call(this, props);
    this.state = {
      mode: "normal"
    };
  }

  AxisColorEditorComponent.prototype.componentWillMount = function() {
    return this.updateColorMap(this.props.categories);
  };

  AxisColorEditorComponent.prototype.componentDidUpdate = function() {
    return this.updateColorMap(this.props.categories);
  };

  AxisColorEditorComponent.prototype.updateColorMap = function(categories) {
    var axisBuilder, colorMap;
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    if (!categories) {
      return;
    }
    if (!this.props.axis.colorMap || !_.isEqual(_.pluck(this.props.axis.colorMap, "value").sort(), _.pluck(categories, "value").sort())) {
      colorMap = ColorSchemeFactory.createColorMapForCategories(categories, axisBuilder.isCategorical(this.props.axis));
      this.handlePaletteChange(colorMap);
      return this.setState({
        mode: "normal"
      });
    }
  };

  AxisColorEditorComponent.prototype.handleSelectPalette = function() {
    return this.setState({
      mode: "palette"
    });
  };

  AxisColorEditorComponent.prototype.handlePaletteChange = function(palette) {
    this.props.onChange(update(this.props.axis, {
      colorMap: {
        $set: palette
      },
      drawOrder: {
        $set: _.pluck(palette, "value")
      }
    }));
    return this.setState({
      mode: "normal"
    });
  };

  AxisColorEditorComponent.prototype.handleCancelCustomize = function() {
    return this.setState({
      mode: "normal"
    });
  };

  AxisColorEditorComponent.prototype.renderPreview = function() {
    return H.div({
      className: "axis-palette"
    }, _.map(this.props.categories.slice(0, 6), (function(_this) {
      return function(category, i) {
        var cellStyle, color;
        color = _.find(_this.props.axis.colorMap, {
          value: category.value
        });
        cellStyle = {
          display: 'inline-block',
          height: 20,
          width: 20,
          backgroundColor: color ? color.color : _this.props.defaultColor
        };
        return H.div({
          style: cellStyle,
          key: i
        }, " ");
      };
    })(this)));
  };

  AxisColorEditorComponent.prototype.render = function() {
    return H.div(null, this.state.mode === "palette" ? this.props.categories ? R(ColorPaletteCollectionComponent, {
      onPaletteSelected: this.handlePaletteChange,
      axis: this.props.axis,
      categories: this.props.categories,
      onCancel: this.handleCancelCustomize
    }) : void 0 : void 0, this.state.mode === "normal" ? H.div(null, H.p(null, H.a({
      style: {
        cursor: "pointer"
      },
      onClick: this.handleSelectPalette,
      key: "select-palette"
    }, "Change color scheme")), this.props.axis.colorMap ? H.div({
      key: "selected-palette"
    }, H.div(null, R(CategoryMapComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      axis: this.props.axis,
      onChange: this.props.onChange,
      categories: this.props.categories,
      key: "colorMap",
      reorderable: this.props.reorderable,
      allowExcludedValues: this.props.allowExcludedValues,
      showColorMap: true,
      initiallyExpanded: this.props.initiallyExpanded
    }))) : void 0) : void 0);
  };

  return AxisColorEditorComponent;

})(React.Component);


},{"../ColorSchemeFactory":1017,"./AxisBuilder":1029,"./CategoryMapComponent":1033,"./ColorPaletteCollectionComponent":1034,"lodash":"lodash","react":"react","update-object":1003}],1031:[function(require,module,exports){
var AsyncLoadComponent, AxisBuilder, AxisColorEditorComponent, AxisComponent, BinsComponent, CategoryMapComponent, ExprCompiler, ExprComponent, ExprUtils, H, LinkComponent, R, RangesComponent, React, ui, update, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

ExprComponent = require("mwater-expressions-ui").ExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCompiler = require('mwater-expressions').ExprCompiler;

LinkComponent = require('mwater-expressions-ui').LinkComponent;

AxisBuilder = require('./AxisBuilder');

update = require('update-object');

ui = require('../UIComponents');

BinsComponent = require('./BinsComponent');

RangesComponent = require('./RangesComponent');

AxisColorEditorComponent = require('./AxisColorEditorComponent');

CategoryMapComponent = require('./CategoryMapComponent');

module.exports = AxisComponent = (function(superClass) {
  extend(AxisComponent, superClass);

  AxisComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    types: React.PropTypes.array,
    aggrNeed: React.PropTypes.oneOf(['none', 'optional', 'required']).isRequired,
    value: React.PropTypes.object,
    onChange: React.PropTypes.func.isRequired,
    required: React.PropTypes.bool,
    showColorMap: React.PropTypes.bool,
    reorderable: React.PropTypes.bool,
    allowExcludedValues: React.PropTypes.bool,
    defaultColor: React.PropTypes.string,
    showFormat: React.PropTypes.bool
  };

  AxisComponent.defaultProps = {
    reorderable: false,
    allowExcludedValues: false
  };

  AxisComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function AxisComponent(props) {
    this.handleXformChange = bind(this.handleXformChange, this);
    this.handleXformTypeChange = bind(this.handleXformTypeChange, this);
    this.handleFormatChange = bind(this.handleFormatChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    AxisComponent.__super__.constructor.call(this, props);
    this.state = {
      categories: null
    };
  }

  AxisComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return !_.isEqual(_.omit(newProps.value, ["colorMap", "drawOrder"]), _.omit(oldProps.value, ["colorMap", "drawOrder"]));
  };

  AxisComponent.prototype.load = function(props, prevProps, callback) {
    var axis, axisBuilder, categories, valuesQuery;
    axisBuilder = new AxisBuilder({
      schema: props.schema
    });
    axis = axisBuilder.cleanAxis({
      axis: props.value,
      table: props.table,
      types: props.types,
      aggrNeed: props.aggrNeed
    });
    if (!axis || axisBuilder.validateAxis({
      axis: axis
    })) {
      return;
    }
    categories = axisBuilder.getCategories(axis);
    if (_.any(categories, function(category) {
      return category.value != null;
    })) {
      callback({
        categories: categories
      });
      return;
    }
    if (axisBuilder.isAxisAggr(axis)) {
      callback({
        categories: []
      });
      return;
    }
    valuesQuery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: axisBuilder.compileAxis({
            axis: axis,
            tableAlias: "main"
          }),
          alias: "val"
        }
      ],
      from: {
        type: "table",
        table: axis.expr.table,
        alias: "main"
      },
      groupBy: [1],
      limit: 50
    };
    return props.dataSource.performQuery(valuesQuery, (function(_this) {
      return function(error, rows) {
        if (error) {
          return;
        }
        categories = axisBuilder.getCategories(axis, _.pluck(rows, "val"));
        return callback({
          categories: categories
        });
      };
    })(this));
  };

  AxisComponent.prototype.handleExprChange = function(expr) {
    if (!expr) {
      this.props.onChange(null);
      return;
    }
    return this.props.onChange(this.cleanAxis(_.extend({}, _.omit(this.props.value, ["drawOrder"]), {
      expr: expr
    })));
  };

  AxisComponent.prototype.handleFormatChange = function(ev) {
    return this.props.onChange(_.extend({}, this.props.value, {
      format: ev.target.value
    }));
  };

  AxisComponent.prototype.handleXformTypeChange = function(type) {
    var end, i, j, max, min, numBins, ranges, ref, ref1, start, xform;
    if (!type) {
      this.props.onChange(_.omit(this.props.value, ["xform", "colorMap", "drawOrder"]));
    }
    if (type === "ranges" && ((ref = this.props.value.xform) != null ? ref.type : void 0) === "bin" && (this.props.value.xform.min != null) && (this.props.value.xform.max != null) && this.props.value.xform.min !== this.props.value.xform.max && this.props.value.xform.numBins) {
      min = this.props.value.xform.min;
      max = this.props.value.xform.max;
      numBins = this.props.value.xform.numBins;
      ranges = [
        {
          id: uuid(),
          maxValue: min,
          minOpen: false,
          maxOpen: true
        }
      ];
      for (i = j = 1, ref1 = numBins; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
        start = (i - 1) / numBins * (max - min) + min;
        end = i / numBins * (max - min) + min;
        ranges.push({
          id: uuid(),
          minValue: start,
          minOpen: false,
          maxValue: end,
          maxOpen: true
        });
      }
      ranges.push({
        id: uuid(),
        minValue: max,
        minOpen: true,
        maxOpen: true
      });
      xform = {
        type: "ranges",
        ranges: ranges
      };
    } else {
      xform = {
        type: type
      };
    }
    return this.props.onChange(update(_.omit(this.props.value, ["colorMap", "drawOrder"]), {
      xform: {
        $set: xform
      }
    }));
  };

  AxisComponent.prototype.handleXformChange = function(xform) {
    return this.props.onChange(this.cleanAxis(update(_.omit(this.props.value, ["drawOrder"]), {
      xform: {
        $set: xform
      }
    })));
  };

  AxisComponent.prototype.cleanAxis = function(axis) {
    var axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    return axisBuilder.cleanAxis({
      axis: axis,
      table: this.props.table,
      aggrNeed: this.props.aggrNeed,
      types: this.props.types
    });
  };

  AxisComponent.prototype.renderXform = function(axis) {
    var comp, exprType, exprUtils, ref;
    if (!axis) {
      return;
    }
    if (axis.xform && ((ref = axis.xform.type) === "bin" || ref === "ranges")) {
      if (axis.xform.type === "ranges") {
        comp = R(RangesComponent, {
          schema: this.props.schema,
          dataSource: this.props.dataSource,
          expr: axis.expr,
          xform: axis.xform,
          onChange: this.handleXformChange
        });
      } else {
        comp = R(BinsComponent, {
          schema: this.props.schema,
          dataSource: this.props.dataSource,
          expr: axis.expr,
          xform: axis.xform,
          onChange: this.handleXformChange
        });
      }
      return H.div(null, R(ui.ButtonToggleComponent, {
        value: axis.xform ? axis.xform.type : null,
        options: [
          {
            value: "bin",
            label: "Equal Bins"
          }, {
            value: "ranges",
            label: "Custom Ranges"
          }
        ],
        onChange: this.handleXformTypeChange
      }), comp);
    }
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType(axis.expr);
    switch (exprType) {
      case "date":
        return R(ui.ButtonToggleComponent, {
          value: axis.xform ? axis.xform.type : null,
          options: [
            {
              value: null,
              label: "Exact Date"
            }, {
              value: "year",
              label: "Year"
            }, {
              value: "yearmonth",
              label: "Year/Month"
            }, {
              value: "month",
              label: "Month"
            }
          ],
          onChange: this.handleXformTypeChange
        });
      case "datetime":
        return R(ui.ButtonToggleComponent, {
          value: axis.xform ? axis.xform.type : null,
          options: [
            {
              value: "date",
              label: "Date"
            }, {
              value: "year",
              label: "Year"
            }, {
              value: "yearmonth",
              label: "Year/Month"
            }, {
              value: "month",
              label: "Month"
            }
          ],
          onChange: this.handleXformTypeChange
        });
    }
  };

  AxisComponent.prototype.renderColorMap = function(axis) {
    if (!this.props.showColorMap || !axis || !axis.expr) {
      return null;
    }
    return [
      H.br(), R(AxisColorEditorComponent, {
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        axis: axis,
        categories: this.state.categories,
        onChange: this.props.onChange,
        reorderable: this.props.reorderable,
        defaultColor: this.props.defaultColor,
        allowExcludedValues: this.props.allowExcludedValues
      })
    ];
  };

  AxisComponent.prototype.renderExcludedValues = function(axis) {
    if (this.props.showColorMap || !axis || !axis.expr || !this.props.allowExcludedValues) {
      return null;
    }
    if (!this.state.categories || this.state.categories.length <= 1) {
      return null;
    }
    return [
      H.br(), R(CategoryMapComponent, {
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        axis: axis,
        onChange: this.props.onChange,
        categories: this.state.categories,
        reorderable: false,
        showColorMap: false,
        allowExcludedValues: true,
        initiallyExpanded: true
      })
    ];
  };

  AxisComponent.prototype.renderFormat = function(axis) {
    var formats;
    formats = [
      {
        value: ",",
        label: "Normal: 1,234.567"
      }, {
        value: "",
        label: "Plain: 1234.567"
      }, {
        value: ",.0f",
        label: "Rounded: 1,234"
      }, {
        value: ",.2f",
        label: "Two decimals: 1,234.56"
      }, {
        value: "$,.2f",
        label: "Currency: $1,234.56"
      }, {
        value: "$,.0f",
        label: "Currency rounded: $1,234"
      }, {
        value: ".0%",
        label: "Percent rounded: 12%"
      }
    ];
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Format"), ": ", H.select({
      value: (axis.format != null ? axis.format : ","),
      className: "form-control",
      style: {
        width: "auto",
        display: "inline-block"
      },
      onChange: this.handleFormatChange
    }, _.map(formats, function(format) {
      return H.option({
        key: format.value,
        value: format.value
      }, format.label);
    })));
  };

  AxisComponent.prototype.render = function() {
    var aggrStatuses, axis, axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    axis = this.cleanAxis(this.props.value);
    switch (this.props.aggrNeed) {
      case "none":
        aggrStatuses = ["literal", "individual"];
        break;
      case "optional":
        aggrStatuses = ["literal", "individual", "aggregate"];
        break;
      case "required":
        aggrStatuses = ["literal", "aggregate"];
    }
    return H.div(null, H.div(null, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: axisBuilder.getExprTypes(this.props.types),
      onChange: this.handleExprChange,
      value: this.props.value ? this.props.value.expr : void 0,
      aggrStatuses: aggrStatuses
    })), this.renderXform(axis), this.props.showFormat && axisBuilder.getAxisType(axis) === "number" ? this.renderFormat(axis) : void 0, this.renderColorMap(axis), this.renderExcludedValues(axis));
  };

  return AxisComponent;

})(AsyncLoadComponent);


},{"../UIComponents":1026,"./AxisBuilder":1029,"./AxisColorEditorComponent":1030,"./BinsComponent":1032,"./CategoryMapComponent":1033,"./RangesComponent":1035,"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/AsyncLoadComponent":782,"update-object":1003,"uuid":1007}],1032:[function(require,module,exports){
var AxisBuilder, BinsComponent, ExprUtils, H, LabeledInlineComponent, NumberInputComponent, R, React, update,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

update = require('update-object');

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('./AxisBuilder');

NumberInputComponent = require('react-library/lib/NumberInputComponent');

module.exports = BinsComponent = (function(superClass) {
  extend(BinsComponent, superClass);

  BinsComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    expr: React.PropTypes.object.isRequired,
    xform: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  function BinsComponent(props) {
    BinsComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      guessing: false
    };
  }

  BinsComponent.prototype.componentDidMount = function() {
    var axisBuilder, exprUtils, minMaxQuery, ref;
    if ((this.props.xform.min == null) || (this.props.xform.max == null)) {
      exprUtils = new ExprUtils(this.props.schema);
      if (exprUtils.getExprAggrStatus(this.props.expr) !== "individual") {
        if (((ref = this.props.expr) != null ? ref.op : void 0) === "percent where") {
          this.props.onChange(update(this.props.xform, {
            min: {
              $set: 0
            },
            max: {
              $set: 100
            },
            excludeLower: {
              $set: true
            },
            excludeUpper: {
              $set: true
            }
          }));
        }
        return;
      }
      axisBuilder = new AxisBuilder({
        schema: this.props.schema
      });
      minMaxQuery = axisBuilder.compileBinMinMax(this.props.expr, this.props.expr.table, null, this.props.xform.numBins);
      this.setState({
        guessing: true
      });
      return this.props.dataSource.performQuery(minMaxQuery, (function(_this) {
        return function(error, rows) {
          var max, min;
          if (_this.unmounted) {
            return;
          }
          _this.setState({
            guessing: false
          });
          if (error) {
            return;
          }
          if (rows[0].min != null) {
            min = parseFloat(rows[0].min);
            max = parseFloat(rows[0].max);
          }
          return _this.props.onChange(update(_this.props.xform, {
            min: {
              $set: min
            },
            max: {
              $set: max
            }
          }));
        };
      })(this));
    }
  };

  BinsComponent.prototype.componentWillUnmount = function() {
    return this.unmounted = true;
  };

  BinsComponent.prototype.render = function() {
    return H.div(null, H.div({
      key: "vals"
    }, R(LabeledInlineComponent, {
      key: "min",
      label: "Min:"
    }, R(NumberInputComponent, {
      small: true,
      value: this.props.xform.min,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onChange(update(_this.props.xform, {
            min: {
              $set: v
            }
          }));
        };
      })(this)
    })), " ", R(LabeledInlineComponent, {
      key: "max",
      label: "Max:"
    }, R(NumberInputComponent, {
      small: true,
      value: this.props.xform.max,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onChange(update(_this.props.xform, {
            max: {
              $set: v
            }
          }));
        };
      })(this)
    })), " ", R(LabeledInlineComponent, {
      key: "numBins",
      label: "# of Bins:"
    }, R(NumberInputComponent, {
      small: true,
      value: this.props.xform.numBins,
      decimal: false,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onChange(update(_this.props.xform, {
            numBins: {
              $set: v
            }
          }));
        };
      })(this)
    })), this.state.guessing ? H.i({
      className: "fa fa-spinner fa-spin"
    }) : (this.props.xform.min == null) || (this.props.xform.max == null) || !this.props.xform.numBins ? H.span({
      className: "text-danger",
      style: {
        paddingLeft: 10
      }
    }, "Min and max are required") : void 0), (this.props.xform.min != null) && (this.props.xform.max != null) && this.props.xform.numBins ? H.div({
      key: "excludes"
    }, H.label({
      className: "checkbox-inline",
      key: "lower"
    }, H.input({
      type: "checkbox",
      checked: !this.props.xform.excludeLower,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(update(_this.props.xform, {
            excludeLower: {
              $set: !ev.target.checked
            }
          }));
        };
      })(this)
    }), "Include < " + this.props.xform.min), H.label({
      className: "checkbox-inline",
      key: "upper"
    }, H.input({
      type: "checkbox",
      checked: !this.props.xform.excludeUpper,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(update(_this.props.xform, {
            excludeUpper: {
              $set: !ev.target.checked
            }
          }));
        };
      })(this)
    }), "Include > " + this.props.xform.max)) : void 0);
  };

  return BinsComponent;

})(React.Component);

LabeledInlineComponent = function(props) {
  return H.div({
    style: {
      display: "inline-block"
    }
  }, H.label({
    className: "text-muted"
  }, props.label), props.children);
};


},{"./AxisBuilder":1029,"mwater-expressions":14,"react":"react","react-library/lib/NumberInputComponent":789,"update-object":1003}],1033:[function(require,module,exports){
var AxisBuilder, CategoryMapComponent, ColorComponent, ExprCompiler, ExprUtils, H, R, React, ReorderableListComponent, _, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ExprCompiler = require('mwater-expressions').ExprCompiler;

AxisBuilder = require('./AxisBuilder');

update = require('update-object');

ColorComponent = require('../ColorComponent');

ExprUtils = require('mwater-expressions').ExprUtils;

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

module.exports = CategoryMapComponent = (function(superClass) {
  extend(CategoryMapComponent, superClass);

  CategoryMapComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    axis: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    categories: React.PropTypes.array,
    reorderable: React.PropTypes.bool,
    showColorMap: React.PropTypes.bool,
    allowExcludedValues: React.PropTypes.bool,
    initiallyExpanded: React.PropTypes.bool
  };

  function CategoryMapComponent(props) {
    this.renderCategory = bind(this.renderCategory, this);
    this.handleToggle = bind(this.handleToggle, this);
    this.handleNullLabelChange = bind(this.handleNullLabelChange, this);
    this.handleExcludeChange = bind(this.handleExcludeChange, this);
    this.handleColorChange = bind(this.handleColorChange, this);
    this.handleReorder = bind(this.handleReorder, this);
    CategoryMapComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      collapsed: !props.initiallyExpanded
    };
  }

  CategoryMapComponent.prototype.handleReorder = function(map) {
    var order;
    order = _.pluck(map, "value");
    return this.props.onChange(update(this.props.axis, {
      drawOrder: {
        $set: order
      }
    }));
  };

  CategoryMapComponent.prototype.handleColorChange = function(value, color) {
    var colorMap;
    colorMap = _.filter(this.props.axis.colorMap, (function(_this) {
      return function(item) {
        return item.value !== value;
      };
    })(this));
    if (color) {
      colorMap.push({
        value: value,
        color: color
      });
    }
    return this.props.onChange(update(this.props.axis, {
      colorMap: {
        $set: colorMap
      }
    }));
  };

  CategoryMapComponent.prototype.handleExcludeChange = function(value, ev) {
    var excludedValues;
    if (ev.target.checked) {
      excludedValues = _.difference(this.props.axis.excludedValues, [value]);
    } else {
      excludedValues = _.union(this.props.axis.excludedValues, [value]);
    }
    return this.props.onChange(update(this.props.axis, {
      excludedValues: {
        $set: excludedValues
      }
    }));
  };

  CategoryMapComponent.prototype.lookupColor = function(value) {
    var item;
    item = _.find(this.props.axis.colorMap, (function(_this) {
      return function(item) {
        return item.value === value;
      };
    })(this));
    if (item) {
      return item.color;
    }
    return null;
  };

  CategoryMapComponent.prototype.handleNullLabelChange = function(e) {
    var name;
    name = prompt("Enter label for none value", this.props.axis.nullLabel || ExprUtils.localizeString("None"));
    if (name) {
      return this.props.onChange(update(this.props.axis, {
        nullLabel: {
          $set: name
        }
      }));
    }
  };

  CategoryMapComponent.prototype.handleToggle = function() {
    return this.setState({
      collapsed: !this.state.collapsed
    });
  };

  CategoryMapComponent.prototype.renderLabel = function(category) {
    var label;
    label = ExprUtils.localizeString(category.label);
    if (category.value) {
      return label;
    } else {
      return H.a({
        onClick: this.handleNullLabelChange,
        style: {
          cursor: 'pointer'
        }
      }, label, H.span({
        style: {
          fontSize: 12,
          marginLeft: 4
        }
      }, "(click to change label for none value)"));
    }
  };

  CategoryMapComponent.prototype.renderCategory = function(category, index, connectDragSource, connectDragPreview, connectDropTarget) {
    var colorPickerStyle, elem, iconStyle, labelStyle;
    labelStyle = {
      verticalAlign: 'middle',
      marginLeft: 5
    };
    iconStyle = {
      cursor: "move",
      marginRight: 8,
      opacity: 0.5,
      fontSize: 12,
      height: 20
    };
    colorPickerStyle = {
      verticalAlign: 'middle',
      lineHeight: 1,
      display: 'inline-block',
      marginLeft: 5
    };
    elem = H.div(null, connectDragSource ? connectDragSource(H.i({
      className: "fa fa-bars",
      style: iconStyle
    })) : void 0, this.props.allowExcludedValues ? H.input({
      type: "checkbox",
      style: {
        marginLeft: 5,
        marginBottom: 5,
        verticalAlign: "middle"
      },
      checked: !_.includes(this.props.axis.excludedValues, category.value),
      onChange: this.handleExcludeChange.bind(null, category.value)
    }) : void 0, this.props.showColorMap ? H.div({
      style: colorPickerStyle
    }, R(ColorComponent, {
      key: 'color',
      color: this.lookupColor(category.value),
      onChange: (function(_this) {
        return function(color) {
          return _this.handleColorChange(category.value, color);
        };
      })(this)
    })) : void 0, H.span({
      style: labelStyle
    }, this.renderLabel(category)));
    if (connectDropTarget) {
      elem = connectDropTarget(elem);
    }
    if (connectDragPreview) {
      elem = connectDragPreview(elem);
    }
    return elem;
  };

  CategoryMapComponent.prototype.renderReorderable = function() {
    var drawOrder, orderedCategories;
    drawOrder = this.props.axis.drawOrder || _.pluck(this.props.axis.colorMap, "value");
    orderedCategories = _.sortBy(this.props.categories, (function(_this) {
      return function(category) {
        return _.indexOf(drawOrder, category.value);
      };
    })(this));
    return H.div(null, this.renderToggle(), R(ReorderableListComponent, {
      items: orderedCategories,
      onReorder: this.handleReorder,
      renderItem: this.renderCategory,
      getItemId: (function(_this) {
        return function(item) {
          return item.value;
        };
      })(this)
    }));
  };

  CategoryMapComponent.prototype.renderNonReorderable = function() {
    return H.div(null, this.renderToggle(), _.map(this.props.categories, (function(_this) {
      return function(category) {
        return _this.renderCategory(category);
      };
    })(this)));
  };

  CategoryMapComponent.prototype.renderToggle = function() {
    if (this.state.collapsed) {
      return H.div(null, H.a({
        onClick: this.handleToggle
      }, "Show Values ", H.i({
        className: "fa fa-caret-down"
      })));
    } else {
      return H.div(null, H.a({
        onClick: this.handleToggle
      }, "Hide Values ", H.i({
        className: "fa fa-caret-up"
      })));
    }
  };

  CategoryMapComponent.prototype.render = function() {
    if (this.state.collapsed) {
      return this.renderToggle();
    }
    if (this.props.reorderable) {
      return this.renderReorderable();
    } else {
      return this.renderNonReorderable();
    }
  };

  return CategoryMapComponent;

})(React.Component);


},{"../ColorComponent":1016,"./AxisBuilder":1029,"lodash":"lodash","mwater-expressions":14,"react":"react","react-library/lib/reorderable/ReorderableListComponent":795,"update-object":1003}],1034:[function(require,module,exports){
var ColorPaletteCollectionComponent, ColorPaletteComponent, ColorSchemeFactory, H, R, React, c_c, d3,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

ColorSchemeFactory = require('../ColorSchemeFactory');

c_c = require('color-mixer');

d3 = require('d3-scale');

module.exports = ColorPaletteCollectionComponent = (function(superClass) {
  extend(ColorPaletteCollectionComponent, superClass);

  function ColorPaletteCollectionComponent() {
    this.renderCancel = bind(this.renderCancel, this);
    this.onPaletteSelected = bind(this.onPaletteSelected, this);
    return ColorPaletteCollectionComponent.__super__.constructor.apply(this, arguments);
  }

  ColorPaletteCollectionComponent.propTypes = {
    onPaletteSelected: React.PropTypes.func.isRequired,
    axis: React.PropTypes.object.isRequired,
    categories: React.PropTypes.array.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  ColorPaletteCollectionComponent.palettes = [
    {
      type: "schemeSet1",
      reversed: false
    }, {
      type: "schemeSet2",
      reversed: false
    }, {
      type: "schemeSet3",
      reversed: false
    }, {
      type: "schemeAccent",
      reversed: false
    }, {
      type: "schemeDark2",
      reversed: false
    }, {
      type: "schemePaired",
      reversed: false
    }, {
      type: "schemePastel1",
      reversed: false
    }, {
      type: "schemePastel2",
      reversed: false
    }, {
      type: "interpolateSpectral",
      reversed: false
    }, {
      type: "interpolateSpectral",
      reversed: true
    }, {
      type: "interpolateBlues",
      reversed: false
    }, {
      type: "interpolateBlues",
      reversed: true
    }, {
      type: "interpolateGreens",
      reversed: false
    }, {
      type: "interpolateGreens",
      reversed: true
    }, {
      type: "interpolateGreys",
      reversed: false
    }, {
      type: "interpolateGreys",
      reversed: true
    }, {
      type: "interpolateOranges",
      reversed: false
    }, {
      type: "interpolateOranges",
      reversed: true
    }, {
      type: "interpolatePurples",
      reversed: false
    }, {
      type: "interpolatePurples",
      reversed: true
    }, {
      type: "interpolateReds",
      reversed: false
    }, {
      type: "interpolateReds",
      reversed: true
    }, {
      type: "interpolateBuGn",
      reversed: false
    }, {
      type: "interpolateBuGn",
      reversed: true
    }, {
      type: "interpolateBuPu",
      reversed: false
    }, {
      type: "interpolateBuPu",
      reversed: true
    }, {
      type: "interpolateGnBu",
      reversed: false
    }, {
      type: "interpolateGnBu",
      reversed: true
    }, {
      type: "interpolateOrRd",
      reversed: false
    }, {
      type: "interpolateOrRd",
      reversed: true
    }, {
      type: "interpolatePuBuGn",
      reversed: false
    }, {
      type: "interpolatePuBuGn",
      reversed: true
    }, {
      type: "interpolatePuBu",
      reversed: false
    }, {
      type: "interpolatePuBu",
      reversed: true
    }, {
      type: "interpolatePuRd",
      reversed: false
    }, {
      type: "interpolatePuRd",
      reversed: true
    }, {
      type: "interpolateRdPu",
      reversed: false
    }, {
      type: "interpolateRdPu",
      reversed: true
    }, {
      type: "interpolateYlGnBu",
      reversed: false
    }, {
      type: "interpolateYlGnBu",
      reversed: true
    }, {
      type: "interpolateYlGn",
      reversed: false
    }, {
      type: "interpolateYlGn",
      reversed: true
    }, {
      type: "interpolateYlOrBr",
      reversed: false
    }, {
      type: "interpolateYlOrBr",
      reversed: true
    }, {
      type: "interpolateYlOrRd",
      reversed: false
    }, {
      type: "interpolateYlOrRd",
      reversed: true
    }, {
      type: "interpolateBrBG",
      reversed: false
    }, {
      type: "interpolateBrBG",
      reversed: true
    }, {
      type: "interpolatePRGn",
      reversed: false
    }, {
      type: "interpolatePRGn",
      reversed: true
    }, {
      type: "interpolatePiYG",
      reversed: false
    }, {
      type: "interpolatePiYG",
      reversed: true
    }, {
      type: "interpolatePuOr",
      reversed: false
    }, {
      type: "interpolatePuOr",
      reversed: true
    }, {
      type: "interpolateRdBu",
      reversed: false
    }, {
      type: "interpolateRdBu",
      reversed: true
    }, {
      type: "interpolateRdGy",
      reversed: false
    }, {
      type: "interpolateRdGy",
      reversed: true
    }, {
      type: "interpolateRdYlBu",
      reversed: false
    }, {
      type: "interpolateRdYlBu",
      reversed: true
    }, {
      type: "interpolateRdYlGn",
      reversed: false
    }, {
      type: "interpolateRdYlGn",
      reversed: true
    }
  ];

  ColorPaletteCollectionComponent.prototype.onPaletteSelected = function(index) {
    var colorMap, scheme;
    scheme = ColorSchemeFactory.createColorScheme({
      type: ColorPaletteCollectionComponent.palettes[index].type,
      number: _.any(this.props.categories, function(c) {
        return c.value == null;
      }) ? this.props.categories.length - 1 : this.props.categories.length,
      reversed: ColorPaletteCollectionComponent.palettes[index].reversed
    });
    colorMap = _.map(this.props.categories, function(category, i) {
      return {
        value: category.value,
        color: category.value === null ? "#aaaaaa" : scheme[i % scheme.length]
      };
    });
    return this.props.onPaletteSelected(colorMap);
  };

  ColorPaletteCollectionComponent.prototype.renderCancel = function() {
    if (this.props.axis.colorMap) {
      return H.div(null, H.a({
        style: {
          cursor: "pointer"
        },
        onClick: this.props.onCancel,
        key: "cancel-customize"
      }, "Cancel"));
    }
  };

  ColorPaletteCollectionComponent.prototype.render = function() {
    return H.div(null, H.p(null, "Please select a color scheme"), _.map(ColorPaletteCollectionComponent.palettes, (function(_this) {
      return function(config, index) {
        return R(ColorPaletteComponent, {
          key: index,
          index: index,
          colorSet: ColorSchemeFactory.createColorScheme({
            type: config.type,
            number: Math.min(_this.props.categories.length - 1, 6),
            reversed: config.reversed
          }),
          onPaletteSelected: _this.onPaletteSelected,
          number: _this.props.categories.length
        });
      };
    })(this)), this.renderCancel());
  };

  return ColorPaletteCollectionComponent;

})(React.Component);

ColorPaletteComponent = (function(superClass) {
  extend(ColorPaletteComponent, superClass);

  function ColorPaletteComponent() {
    this.handleSelect = bind(this.handleSelect, this);
    return ColorPaletteComponent.__super__.constructor.apply(this, arguments);
  }

  ColorPaletteComponent.propTypes = {
    index: React.PropTypes.number.isRequired,
    colorSet: React.PropTypes.array.isRequired,
    onPaletteSelected: React.PropTypes.func.isRequired,
    number: React.PropTypes.number
  };

  ColorPaletteComponent.defaultProps = {
    number: 6
  };

  ColorPaletteComponent.prototype.handleSelect = function() {
    return this.props.onPaletteSelected(this.props.index);
  };

  ColorPaletteComponent.prototype.render = function() {
    return H.div({
      onClick: this.handleSelect,
      className: "axis-palette"
    }, _.map(this.props.colorSet.slice(0, this.props.number), (function(_this) {
      return function(color, i) {
        var cellStyle;
        cellStyle = {
          display: 'inline-block',
          height: 20,
          width: 20,
          backgroundColor: color
        };
        return H.div({
          style: cellStyle,
          key: i
        }, " ");
      };
    })(this)));
  };

  return ColorPaletteComponent;

})(React.Component);


},{"../ColorSchemeFactory":1017,"color-mixer":122,"d3-scale":136,"react":"react"}],1035:[function(require,module,exports){
var AxisBuilder, H, LinkComponent, NumberInputComponent, R, RangeComponent, RangesComponent, React, ReorderableListComponent, update, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

update = require('update-object');

LinkComponent = require('mwater-expressions-ui').LinkComponent;

AxisBuilder = require('./AxisBuilder');

NumberInputComponent = require('react-library/lib/NumberInputComponent');

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

module.exports = RangesComponent = (function(superClass) {
  extend(RangesComponent, superClass);

  function RangesComponent() {
    this.handleReorder = bind(this.handleReorder, this);
    this.renderRange = bind(this.renderRange, this);
    this.handleRemoveRange = bind(this.handleRemoveRange, this);
    this.handleAddRange = bind(this.handleAddRange, this);
    this.handleRangeChange = bind(this.handleRangeChange, this);
    return RangesComponent.__super__.constructor.apply(this, arguments);
  }

  RangesComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    expr: React.PropTypes.object.isRequired,
    xform: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  RangesComponent.prototype.handleRangeChange = function(index, range) {
    var ranges;
    ranges = this.props.xform.ranges.slice();
    ranges[index] = range;
    return this.props.onChange(update(this.props.xform, {
      ranges: {
        $set: ranges
      }
    }));
  };

  RangesComponent.prototype.handleAddRange = function() {
    var ranges;
    ranges = this.props.xform.ranges.slice();
    ranges.push({
      id: uuid(),
      minOpen: false,
      maxOpen: true
    });
    return this.props.onChange(update(this.props.xform, {
      ranges: {
        $set: ranges
      }
    }));
  };

  RangesComponent.prototype.handleRemoveRange = function(index) {
    var ranges;
    ranges = this.props.xform.ranges.slice();
    ranges.splice(index, 1);
    return this.props.onChange(update(this.props.xform, {
      ranges: {
        $set: ranges
      }
    }));
  };

  RangesComponent.prototype.renderRange = function(range, index, connectDragSource, connectDragPreview, connectDropTarget) {
    return R(RangeComponent, {
      key: range.id,
      range: range,
      onChange: this.handleRangeChange.bind(null, index),
      onRemove: this.handleRemoveRange.bind(null, index),
      connectDragSource: connectDragSource,
      connectDragPreview: connectDragPreview,
      connectDropTarget: connectDropTarget
    });
  };

  RangesComponent.prototype.handleReorder = function(ranges) {
    return this.props.onChange(update(this.props.xform, {
      ranges: {
        $set: ranges
      }
    }));
  };

  RangesComponent.prototype.render = function() {
    return H.div(null, H.table(null, this.props.xform.ranges.length > 0 ? H.thead(null, H.tr(null, H.th(null, " "), H.th({
      key: "min",
      colSpan: 2,
      style: {
        textAlign: "center"
      }
    }, "From"), H.th({
      key: "and"
    }, ""), H.th({
      key: "max",
      colSpan: 2,
      style: {
        textAlign: "center"
      }
    }, "To"), H.th({
      key: "label",
      colSpan: 1,
      style: {
        textAlign: "center"
      }
    }, "Label"), H.th({
      key: "remove"
    }))) : void 0, React.createElement(ReorderableListComponent, {
      items: this.props.xform.ranges,
      onReorder: this.handleReorder,
      renderItem: this.renderRange,
      getItemId: (function(_this) {
        return function(range) {
          return range.id;
        };
      })(this),
      element: H.tbody(null)
    })), H.button({
      className: "btn btn-link btn-sm",
      type: "button",
      onClick: this.handleAddRange
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Range"));
  };

  return RangesComponent;

})(React.Component);

RangeComponent = (function(superClass) {
  extend(RangeComponent, superClass);

  function RangeComponent() {
    this.handleMaxOpenChange = bind(this.handleMaxOpenChange, this);
    this.handleMinOpenChange = bind(this.handleMinOpenChange, this);
    return RangeComponent.__super__.constructor.apply(this, arguments);
  }

  RangeComponent.propTypes = {
    range: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired,
    connectDragSource: React.PropTypes.func.isRequired,
    connectDragPreview: React.PropTypes.func.isRequired,
    connectDropTarget: React.PropTypes.func.isRequired
  };

  RangeComponent.prototype.handleMinOpenChange = function(minOpen) {
    return this.props.onChange(update(this.props.range, {
      minOpen: {
        $set: minOpen
      }
    }));
  };

  RangeComponent.prototype.handleMaxOpenChange = function(maxOpen) {
    return this.props.onChange(update(this.props.range, {
      maxOpen: {
        $set: maxOpen
      }
    }));
  };

  RangeComponent.prototype.render = function() {
    var placeholder;
    placeholder = "";
    if (this.props.range.minValue != null) {
      if (this.props.range.minOpen) {
        placeholder = "> " + this.props.range.minValue;
      } else {
        placeholder = ">= " + this.props.range.minValue;
      }
    }
    if (this.props.range.maxValue != null) {
      if (placeholder) {
        placeholder += " and ";
      }
      if (this.props.range.maxOpen) {
        placeholder += "< " + this.props.range.maxValue;
      } else {
        placeholder += "<= " + this.props.range.maxValue;
      }
    }
    return this.props.connectDragPreview(this.props.connectDropTarget(H.tr(null, H.td(null, this.props.connectDragSource(H.span({
      className: "fa fa-bars"
    }))), H.td({
      key: "minOpen"
    }, R(LinkComponent, {
      dropdownItems: [
        {
          id: true,
          name: "greater than"
        }, {
          id: false,
          name: "greater than or equal to"
        }
      ],
      onDropdownItemClicked: this.handleMinOpenChange
    }, this.props.range.minOpen ? "greater than" : "greater than or equal to")), H.td({
      key: "minValue"
    }, R(NumberInputComponent, {
      value: this.props.range.minValue,
      placeholder: "None",
      small: true,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onChange(update(_this.props.range, {
            minValue: {
              $set: v
            }
          }));
        };
      })(this)
    })), H.td({
      key: "and"
    }, "\u00A0and\u00A0"), H.td({
      key: "maxOpen"
    }, R(LinkComponent, {
      dropdownItems: [
        {
          id: true,
          name: "less than"
        }, {
          id: false,
          name: "less than or equal to"
        }
      ],
      onDropdownItemClicked: this.handleMaxOpenChange
    }, this.props.range.maxOpen ? "less than" : "less than or equal to")), H.td({
      key: "maxValue"
    }, R(NumberInputComponent, {
      value: this.props.range.maxValue,
      placeholder: "None",
      small: true,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onChange(update(_this.props.range, {
            maxValue: {
              $set: v
            }
          }));
        };
      })(this)
    })), H.td({
      key: "label"
    }, H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.range.label || "",
      placeholder: placeholder,
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(update(_this.props.range, {
            label: {
              $set: ev.target.value || null
            }
          }));
        };
      })(this)
    })), H.td({
      key: "remove"
    }, H.button({
      className: "btn btn-xs btn-link",
      type: "button",
      onClick: this.props.onRemove
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))))));
  };

  return RangeComponent;

})(React.Component);


},{"./AxisBuilder":1029,"mwater-expressions-ui":362,"react":"react","react-library/lib/NumberInputComponent":789,"react-library/lib/reorderable/ReorderableListComponent":795,"update-object":1003,"uuid":1007}],1036:[function(require,module,exports){
var AutoSizeComponent, DashboardComponent, DashboardUpgrader, DashboardViewComponent, H, LayoutManager, QuickfilterCompiler, QuickfiltersComponent, R, React, SettingsModalComponent, UndoStack, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

UndoStack = require('../UndoStack');

DashboardViewComponent = require('./DashboardViewComponent');

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

QuickfiltersComponent = require('../quickfilter/QuickfiltersComponent');

QuickfilterCompiler = require('../quickfilter/QuickfilterCompiler');

SettingsModalComponent = require('./SettingsModalComponent');

LayoutManager = require('../layouts/LayoutManager');

DashboardUpgrader = require('./DashboardUpgrader');

module.exports = DashboardComponent = (function(superClass) {
  extend(DashboardComponent, superClass);

  DashboardComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    dashboardDataSource: React.PropTypes.object.isRequired,
    titleElem: React.PropTypes.node,
    extraTitleButtonsElem: React.PropTypes.node,
    undoStackKey: React.PropTypes.any,
    printScaling: React.PropTypes.bool,
    onRowClick: React.PropTypes.func,
    namedStrings: React.PropTypes.object,
    quickfilterLocks: React.PropTypes.array,
    filters: React.PropTypes.arrayOf(React.PropTypes.shape({
      table: React.PropTypes.string.isRequired,
      jsonql: React.PropTypes.object.isRequired
    }))
  };

  DashboardComponent.defaultProps = {
    printScaling: true
  };

  DashboardComponent.childContextTypes = {
    locale: React.PropTypes.string
  };

  DashboardComponent.prototype.getChildContext = function() {
    return {
      locale: this.props.design.locale
    };
  };

  function DashboardComponent(props) {
    this.refDashboardView = bind(this.refDashboardView, this);
    this.handleUpgrade = bind(this.handleUpgrade, this);
    this.handleStyleChange = bind(this.handleStyleChange, this);
    this.handleToggleEditing = bind(this.handleToggleEditing, this);
    this.handleSettings = bind(this.handleSettings, this);
    this.handleSaveDesignFile = bind(this.handleSaveDesignFile, this);
    this.handleRedo = bind(this.handleRedo, this);
    this.handleUndo = bind(this.handleUndo, this);
    this.handlePrint = bind(this.handlePrint, this);
    this.getQuickfilterValues = bind(this.getQuickfilterValues, this);
    DashboardComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      undoStack: new UndoStack().push(props.design),
      quickfiltersValues: null,
      quickfiltersHeight: null,
      editing: LayoutManager.createLayoutManager(props.design.layout).isEmpty(props.design.items) && (props.onDesignChange != null)
    };
  }

  DashboardComponent.prototype.componentDidMount = function() {
    return this.updateHeight();
  };

  DashboardComponent.prototype.componentDidUpdate = function() {
    return this.updateHeight();
  };

  DashboardComponent.prototype.updateHeight = function() {
    if (this.refs.quickfilters) {
      if (this.state.quickfiltersHeight !== this.refs.quickfilters.offsetHeight) {
        return this.setState({
          quickfiltersHeight: this.refs.quickfilters.offsetHeight
        });
      }
    } else {
      return this.setState({
        quickfiltersHeight: 0
      });
    }
  };

  DashboardComponent.prototype.getQuickfilterValues = function() {
    return this.state.quickfiltersValues || [];
  };

  DashboardComponent.prototype.componentWillReceiveProps = function(nextProps) {
    var undoStack;
    undoStack = this.state.undoStack;
    if (nextProps.undoStackKey !== this.props.undoStackKey) {
      undoStack = new UndoStack();
    }
    undoStack = undoStack.push(nextProps.design);
    this.setState({
      undoStack: undoStack
    });
    if (!_.isEqual(this.props.design.quickfilters, nextProps.design.quickfilters)) {
      this.setState({
        quickfiltersValues: null
      });
    }
    if (nextProps.onDesignChange == null) {
      return this.setState({
        editing: false
      });
    }
  };

  DashboardComponent.prototype.handlePrint = function() {
    return this.dashboardView.print();
  };

  DashboardComponent.prototype.handleUndo = function() {
    var undoStack;
    undoStack = this.state.undoStack.undo();
    return this.setState({
      undoStack: undoStack
    }, (function(_this) {
      return function() {
        return _this.props.onDesignChange(undoStack.getValue());
      };
    })(this));
  };

  DashboardComponent.prototype.handleRedo = function() {
    var undoStack;
    undoStack = this.state.undoStack.redo();
    return this.setState({
      undoStack: undoStack
    }, (function(_this) {
      return function() {
        return _this.props.onDesignChange(undoStack.getValue());
      };
    })(this));
  };

  DashboardComponent.prototype.handleSaveDesignFile = function() {
    var blob, filesaver;
    blob = new Blob([JSON.stringify(this.props.design, null, 2)], {
      type: "text/json"
    });
    filesaver = require('filesaver.js');
    return filesaver(blob, "Dashboard.json");
  };

  DashboardComponent.prototype.handleSettings = function() {
    return this.refs.settings.show(this.props.design);
  };

  DashboardComponent.prototype.handleToggleEditing = function() {
    return this.setState({
      editing: !this.state.editing
    });
  };

  DashboardComponent.prototype.handleStyleChange = function(style) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      style: style || null
    }));
  };

  DashboardComponent.prototype.handleUpgrade = function() {
    var design;
    if (!confirm("This will upgrade your dashboard to the new kind with enhanced features. You can click Undo immediately afterwards if you wish to revert it. Continue?")) {
      return;
    }
    design = new DashboardUpgrader().upgrade(this.props.design);
    this.props.onDesignChange(design);
    return alert("Upgrade completed. Some widgets may need to be resized. Click Undo to revert back to old dashboard style.");
  };

  DashboardComponent.prototype.renderEditingSwitch = function() {
    return H.a({
      key: "edit",
      className: "btn btn-primary btn-sm " + (this.state.editing ? "active" : ""),
      onClick: this.handleToggleEditing
    }, H.span({
      className: "glyphicon glyphicon-pencil"
    }), this.state.editing ? " Editing" : " Edit");
  };

  DashboardComponent.prototype.renderStyleItem = function(style) {
    var content, isActive;
    isActive = (this.props.design.style || "default") === style;
    content = (function() {
      switch (style) {
        case "default":
          return [
            H.h4({
              key: "name",
              className: "list-group-item-heading"
            }, "Classic Dashboard"), H.p({
              key: "description",
              className: "list-group-item-text"
            }, "Ideal for data display with minimal text")
          ];
        case "greybg":
          return [
            H.h4({
              key: "name",
              className: "list-group-item-heading"
            }, "Framed Dashboard"), H.p({
              key: "description",
              className: "list-group-item-text"
            }, "Each widget is white on a grey background")
          ];
        case "story":
          return [
            H.h4({
              key: "name",
              className: "list-group-item-heading"
            }, "Story"), H.p({
              key: "description",
              className: "list-group-item-text"
            }, "Ideal for data-driven storytelling with lots of text. Responsive and mobile-friendly")
          ];
      }
    })();
    return H.a({
      key: style,
      className: "list-group-item " + (isActive ? "active" : ""),
      onClick: this.handleStyleChange.bind(null, style)
    }, content);
  };

  DashboardComponent.prototype.renderStyle = function() {
    return H.div({
      key: "style",
      className: "btn-group"
    }, H.button({
      type: "button",
      "data-toggle": "dropdown",
      className: "btn btn-link btn-sm dropdown-toggle"
    }, H.span({
      className: "fa fa-th-large"
    }), " Layout ", H.span({
      className: "caret"
    })), H.div({
      className: "dropdown-menu dropdown-menu-right list-group",
      style: {
        padding: 0,
        zIndex: 10000,
        width: 300
      }
    }, this.renderStyleItem("default"), this.renderStyleItem("greybg"), this.renderStyleItem("story")));
  };

  DashboardComponent.prototype.renderActionLinks = function() {
    return H.div(null, this.state.editing && (this.props.design.layout || "grid") === "grid" ? H.a({
      key: "upgrade",
      className: "btn btn-info btn-sm",
      onClick: this.handleUpgrade
    }, "Upgrade Dashboard...") : void 0, this.state.editing ? [
      H.a({
        key: "undo",
        className: "btn btn-link btn-sm " + (!this.state.undoStack.canUndo() ? "disabled" : ""),
        onClick: this.handleUndo
      }, H.span({
        className: "glyphicon glyphicon-triangle-left"
      }), " Undo"), " ", H.a({
        key: "redo",
        className: "btn btn-link btn-sm " + (!this.state.undoStack.canRedo() ? "disabled" : ""),
        onClick: this.handleRedo
      }, H.span({
        className: "glyphicon glyphicon-triangle-right"
      }), " Redo")
    ] : void 0, H.a({
      key: "print",
      className: "btn btn-link btn-sm",
      onClick: this.handlePrint
    }, H.span({
      className: "glyphicon glyphicon-print"
    }), " Print"), this.state.editing ? H.a({
      key: "settings",
      className: "btn btn-link btn-sm",
      onClick: this.handleSettings
    }, H.span({
      className: "glyphicon glyphicon-cog"
    }), " Settings") : void 0, this.state.editing ? this.renderStyle() : void 0, this.props.extraTitleButtonsElem, this.props.onDesignChange != null ? this.renderEditingSwitch() : void 0);
  };

  DashboardComponent.prototype.renderTitleBar = function() {
    return H.div({
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: 40,
        padding: 4
      }
    }, H.div({
      style: {
        float: "right"
      }
    }, this.renderActionLinks()), this.props.titleElem);
  };

  DashboardComponent.prototype.renderQuickfilter = function() {
    return H.div({
      style: {
        position: "absolute",
        top: 40,
        left: 0,
        right: 0
      },
      ref: "quickfilters"
    }, R(QuickfiltersComponent, {
      design: this.props.design.quickfilters,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      values: this.state.quickfiltersValues,
      onValuesChange: (function(_this) {
        return function(values) {
          return _this.setState({
            quickfiltersValues: values
          });
        };
      })(this),
      locks: this.props.quickfilterLocks
    }));
  };

  DashboardComponent.prototype.refDashboardView = function(el) {
    return this.dashboardView = el;
  };

  DashboardComponent.prototype.render = function() {
    var filters;
    filters = this.props.filters || [];
    filters = filters.concat(new QuickfilterCompiler(this.props.schema).compile(this.props.design.quickfilters, this.state.quickfiltersValues, this.props.quickfilterLocks));
    return H.div({
      key: "view",
      style: {
        height: "100%",
        paddingTop: 40 + (this.state.quickfiltersHeight || 0),
        position: "relative"
      }
    }, this.renderTitleBar(), this.renderQuickfilter(), this.props.onDesignChange != null ? R(SettingsModalComponent, {
      onDesignChange: this.props.onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      ref: "settings"
    }) : void 0, R(AutoSizeComponent, {
      injectWidth: true,
      injectHeight: true
    }, (function(_this) {
      return function(size) {
        return R(DashboardViewComponent, {
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          dashboardDataSource: _this.props.dashboardDataSource,
          ref: _this.refDashboardView,
          design: _this.props.design,
          onDesignChange: _this.state.editing ? _this.props.onDesignChange : void 0,
          filters: filters,
          width: size.width,
          standardWidth: _this.props.printScaling ? 1440 : size.width,
          onRowClick: _this.props.onRowClick,
          namedStrings: _this.props.namedStrings
        });
      };
    })(this)));
  };

  return DashboardComponent;

})(React.Component);


},{"../UndoStack":1027,"../layouts/LayoutManager":1058,"../quickfilter/QuickfilterCompiler":1110,"../quickfilter/QuickfiltersComponent":1111,"./DashboardUpgrader":1037,"./DashboardViewComponent":1039,"./SettingsModalComponent":1042,"filesaver.js":275,"lodash":"lodash","react":"react","react-library/lib/AutoSizeComponent":783}],1037:[function(require,module,exports){
var DashboardUpgrader, WidgetFactory, _, uuid;

_ = require('lodash');

uuid = require('uuid');

WidgetFactory = require('../widgets/WidgetFactory');

module.exports = DashboardUpgrader = (function() {
  function DashboardUpgrader() {}

  DashboardUpgrader.prototype.upgrade = function(design) {
    var convertBlock, i, id, item, items, len, li, lineItems, newItems, y;
    items = _.clone(design.items);
    newItems = {
      id: "root",
      type: "root",
      blocks: []
    };
    convertBlock = function(id, item) {
      var block, widget;
      widget = WidgetFactory.createWidget(item.widget.type);
      block = {
        type: "widget",
        widgetType: item.widget.type,
        design: item.widget.design,
        id: id
      };
      if (!widget.isAutoHeight()) {
        block.aspectRatio = item.layout.w / item.layout.h;
      }
      return block;
    };
    y = 0;
    while (_.keys(items).length > 0) {
      lineItems = [];
      for (id in items) {
        item = items[id];
        if (item.layout.y <= y && item.layout.y + item.layout.h > y) {
          lineItems.push(id);
        }
      }
      lineItems = _.sortBy(lineItems, function(id) {
        return items[id].layout.x;
      });
      if (lineItems.length > 1) {
        newItems.blocks.push({
          id: uuid(),
          type: "horizontal",
          blocks: _.map(lineItems, function(li) {
            return convertBlock(li, items[li]);
          })
        });
        for (i = 0, len = lineItems.length; i < len; i++) {
          li = lineItems[i];
          delete items[li];
        }
      } else if (lineItems.length === 1) {
        newItems.blocks.push(convertBlock(lineItems[0], items[lineItems[0]]));
        delete items[lineItems[0]];
      }
      y += 1;
    }
    return {
      items: newItems,
      layout: "blocks",
      style: "default"
    };
  };

  return DashboardUpgrader;

})();


/*

Old style:

items: dashboard items, indexed by id. Each item contains:

 `layout`: layout-engine specific data for layout of item
 `widget`: details of the widget (see below)

`widget` contains:
 `type`: type string of the widget. Understandable by widget factory
 `version`: version of the widget. semver string
 `design`: design of the widget as a JSON object


New style:

id: id of block
type: "root"/"vertical"/"horizontal"/"widget"/"spacer"
widgetType: if a widget
aspectRatio: w/h if not autoHeight
design: widget design
weights: weights for proportioning horizontal blocks. Default is 1
blocks: other blocks if not a widget
 */


},{"../widgets/WidgetFactory":1128,"lodash":"lodash","uuid":1007}],1038:[function(require,module,exports){
var DashboardUtils, LayoutManager, WidgetFactory;

LayoutManager = require('../layouts/LayoutManager');

WidgetFactory = require('../widgets/WidgetFactory');

module.exports = DashboardUtils = (function() {
  function DashboardUtils() {}

  DashboardUtils.getFilterableTables = function(design, schema) {
    var filterableTables, i, layoutManager, len, ref, widget, widgetItem;
    layoutManager = LayoutManager.createLayoutManager(design.layout);
    filterableTables = [];
    ref = layoutManager.getAllWidgets(design.items);
    for (i = 0, len = ref.length; i < len; i++) {
      widgetItem = ref[i];
      widget = WidgetFactory.createWidget(widgetItem.type);
      filterableTables = filterableTables.concat(widget.getFilterableTables(widgetItem.design, schema));
    }
    return filterableTables = _.filter(_.uniq(filterableTables), (function(_this) {
      return function(table) {
        return schema.getTable(table);
      };
    })(this));
  };

  return DashboardUtils;

})();


},{"../layouts/LayoutManager":1058,"../widgets/WidgetFactory":1128}],1039:[function(require,module,exports){
var DashboardUtils, DashboardViewComponent, DragDropContextComponent, ExprCompiler, H, HTML5Backend, ImplicitFilterBuilder, LayoutManager, NestableDragDropContext, R, React, ReactElementPrinter, WidgetFactory, WidgetScoper, WidgetScopesViewComponent, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

HTML5Backend = require('react-dnd-html5-backend');

NestableDragDropContext = require("react-library/lib/NestableDragDropContext");

ImplicitFilterBuilder = require('../ImplicitFilterBuilder');

DashboardUtils = require('./DashboardUtils');

ExprCompiler = require('mwater-expressions').ExprCompiler;

WidgetFactory = require('../widgets/WidgetFactory');

WidgetScoper = require('../widgets/WidgetScoper');

ReactElementPrinter = require('react-library/lib/ReactElementPrinter');

LayoutManager = require('../layouts/LayoutManager');

WidgetScopesViewComponent = require('../widgets/WidgetScopesViewComponent');

module.exports = DashboardViewComponent = (function(superClass) {
  extend(DashboardViewComponent, superClass);

  DashboardViewComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    dashboardDataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    onRowClick: React.PropTypes.func,
    namedStrings: React.PropTypes.object,
    filters: React.PropTypes.arrayOf(React.PropTypes.shape({
      table: React.PropTypes.string.isRequired,
      jsonql: React.PropTypes.object.isRequired
    }))
  };

  DashboardViewComponent.defaultProps = {
    standardWidth: 1440
  };

  DashboardViewComponent.childContextTypes = {
    locale: React.PropTypes.string
  };

  DashboardViewComponent.prototype.getChildContext = function() {
    return {
      locale: this.props.design.locale
    };
  };

  function DashboardViewComponent(props) {
    this.print = bind(this.print, this);
    this.handleItemsChange = bind(this.handleItemsChange, this);
    this.handleRemoveScope = bind(this.handleRemoveScope, this);
    this.handleScopeChange = bind(this.handleScopeChange, this);
    DashboardViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      widgetScoper: new WidgetScoper()
    };
  }

  DashboardViewComponent.prototype.handleScopeChange = function(id, scope) {
    return this.setState({
      widgetScoper: this.state.widgetScoper.applyScope(id, scope)
    });
  };

  DashboardViewComponent.prototype.handleRemoveScope = function(id) {
    return this.setState({
      widgetScoper: this.state.widgetScoper.applyScope(id, null)
    });
  };

  DashboardViewComponent.prototype.handleItemsChange = function(items) {
    var design;
    design = _.extend({}, this.props.design, {
      items: items
    });
    return this.props.onDesignChange(design);
  };

  DashboardViewComponent.prototype.print = function() {
    var elem, printer;
    elem = H.div({
      style: {
        transform: "scale(0.5)",
        transformOrigin: "top left"
      }
    }, H.div({
      style: {
        width: 1440
      }
    }, R(DashboardViewComponent, _.extend({}, this.props, {
      width: 1440,
      standardWidth: 1440,
      onDesignChange: null
    }))));
    printer = new ReactElementPrinter();
    return printer.print(elem, {
      delay: 5000
    });
  };

  DashboardViewComponent.prototype.getCompiledFilters = function() {
    var compiledFilters, expr, exprCompiler, jsonql, ref, table;
    exprCompiler = new ExprCompiler(this.props.schema);
    compiledFilters = [];
    ref = this.props.design.filters || {};
    for (table in ref) {
      expr = ref[table];
      jsonql = exprCompiler.compileExpr({
        expr: expr,
        tableAlias: "{alias}"
      });
      compiledFilters.push({
        table: table,
        jsonql: jsonql
      });
    }
    if (this.props.filters) {
      compiledFilters = compiledFilters.concat(this.props.filters);
    }
    return compiledFilters;
  };

  DashboardViewComponent.prototype.renderScopes = function() {
    return R(WidgetScopesViewComponent, {
      scopes: this.state.widgetScoper.getScopes(),
      onRemoveScope: this.handleRemoveScope
    });
  };

  DashboardViewComponent.prototype.render = function() {
    var compiledFilters, filterableTables, layoutManager, renderWidget, style;
    layoutManager = LayoutManager.createLayoutManager(this.props.design.layout);
    compiledFilters = this.getCompiledFilters();
    filterableTables = DashboardUtils.getFilterableTables(this.props.design, this.props.schema);
    renderWidget = (function(_this) {
      return function(options) {
        var filters, implicitFilterBuilder, widget;
        widget = WidgetFactory.createWidget(options.type);
        filters = compiledFilters.concat(_this.state.widgetScoper.getFilters(options.id));
        implicitFilterBuilder = new ImplicitFilterBuilder(_this.props.schema);
        filters = implicitFilterBuilder.extendFilters(filterableTables, filters);
        return widget.createViewElement({
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          widgetDataSource: _this.props.dashboardDataSource.getWidgetDataSource(options.id),
          design: options.design,
          scope: _this.state.widgetScoper.getScope(options.id),
          filters: filters,
          onScopeChange: _this.handleScopeChange.bind(null, options.id),
          onDesignChange: options.onDesignChange,
          width: options.width,
          height: options.height,
          standardWidth: options.standardWidth,
          onRowClick: _this.props.onRowClick,
          namedStrings: _this.props.namedStrings
        });
      };
    })(this);
    style = {
      height: "100%",
      position: "relative"
    };
    return R(DragDropContextComponent, {
      style: style
    }, this.renderScopes(), layoutManager.renderLayout({
      width: this.props.width,
      standardWidth: this.props.standardWidth,
      items: this.props.design.items,
      onItemsChange: this.props.onDesignChange != null ? this.handleItemsChange : void 0,
      style: this.props.design.style,
      renderWidget: renderWidget
    }));
  };

  return DashboardViewComponent;

})(React.Component);

DragDropContextComponent = (function(superClass) {
  extend(DragDropContextComponent, superClass);

  function DragDropContextComponent() {
    return DragDropContextComponent.__super__.constructor.apply(this, arguments);
  }

  DragDropContextComponent.prototype.render = function() {
    return H.div(this.props);
  };

  return DragDropContextComponent;

})(React.Component);

DragDropContextComponent = NestableDragDropContext(HTML5Backend)(DragDropContextComponent);


},{"../ImplicitFilterBuilder":1020,"../layouts/LayoutManager":1058,"../widgets/WidgetFactory":1128,"../widgets/WidgetScoper":1129,"../widgets/WidgetScopesViewComponent":1130,"./DashboardUtils":1038,"mwater-expressions":14,"react":"react","react-dnd-html5-backend":640,"react-library/lib/NestableDragDropContext":788,"react-library/lib/ReactElementPrinter":791,"uuid":1007}],1040:[function(require,module,exports){
var DirectDashboardDataSource, DirectWidgetDataSource, LayoutManager, WidgetFactory;

WidgetFactory = require('../widgets/WidgetFactory');

DirectWidgetDataSource = require('../widgets/DirectWidgetDataSource');

LayoutManager = require('../layouts/LayoutManager');

module.exports = DirectDashboardDataSource = (function() {
  function DirectDashboardDataSource(options) {
    this.options = options;
  }

  DirectDashboardDataSource.prototype.getWidgetDataSource = function(widgetId) {
    var design, ref, type, widget;
    ref = LayoutManager.createLayoutManager(this.options.design.layout).getWidgetTypeAndDesign(this.options.design.items, widgetId), type = ref.type, design = ref.design;
    widget = WidgetFactory.createWidget(type);
    return new DirectWidgetDataSource({
      apiUrl: this.options.apiUrl,
      client: this.options.client,
      widget: widget,
      schema: this.options.schema,
      dataSource: this.options.dataSource
    });
  };

  return DirectDashboardDataSource;

})();


},{"../layouts/LayoutManager":1058,"../widgets/DirectWidgetDataSource":1117,"../widgets/WidgetFactory":1128}],1041:[function(require,module,exports){
var DirectMapDataSource, ServerDashboardDataSource, ServerWidgetDataSource, ServerWidgetLayerDataSource, ServerWidgetLayerPopupWidgetDataSource, ServerWidgetMapDataSource, WidgetFactory, injectTableAlias, querystring;

querystring = require('querystring');

WidgetFactory = require('../widgets/WidgetFactory');

injectTableAlias = require('mwater-expressions').injectTableAlias;

DirectMapDataSource = require('../maps/DirectMapDataSource');

module.exports = ServerDashboardDataSource = (function() {
  function ServerDashboardDataSource(options) {
    this.options = options;
  }

  ServerDashboardDataSource.prototype.getWidgetDataSource = function(widgetId) {
    return new ServerWidgetDataSource(_.extend({}, this.options, {
      widgetId: widgetId
    }));
  };

  return ServerDashboardDataSource;

})();

ServerWidgetDataSource = (function() {
  function ServerWidgetDataSource(options) {
    this.options = options;
  }

  ServerWidgetDataSource.prototype.getData = function(design, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev
    };
    url = this.options.apiUrl + ("dashboards/" + this.options.dashboardId + "/widgets/" + this.options.widgetId + "/data?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  ServerWidgetDataSource.prototype.getMapDataSource = function(design) {
    return new ServerWidgetMapDataSource(_.extend({}, this.options, {
      design: design
    }));
  };

  ServerWidgetDataSource.prototype.getImageUrl = function(imageId, height) {
    var url;
    url = this.options.apiUrl + ("images/" + imageId);
    if (height) {
      url += "?h=" + height;
    }
    return url;
  };

  return ServerWidgetDataSource;

})();

ServerWidgetMapDataSource = (function() {
  function ServerWidgetMapDataSource(options) {
    this.options = options;
  }

  ServerWidgetMapDataSource.prototype.getLayerDataSource = function(layerId) {
    var layerView;
    layerView = _.findWhere(this.options.design.layerViews, {
      id: layerId
    });
    if (!layerView) {
      return null;
    }
    return new ServerWidgetLayerDataSource(_.extend({}, this.options, {
      layerView: layerView
    }));
  };

  ServerWidgetMapDataSource.prototype.getBounds = function(design, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev
    };
    url = this.options.apiUrl + ("dashboards/" + this.options.dashboardId + "/widgets/" + this.options.widgetId + "/bounds?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  return ServerWidgetMapDataSource;

})();

ServerWidgetLayerDataSource = (function() {
  function ServerWidgetLayerDataSource(options) {
    this.options = options;
  }

  ServerWidgetLayerDataSource.prototype.getTileUrl = function(design, filters) {
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(this.options.layerView.design, "png", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return this.options.layerView.design.tileUrl;
    }
    return this.createUrl(filters, "png");
  };

  ServerWidgetLayerDataSource.prototype.getUtfGridUrl = function(design, filters) {
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(this.options.layerView.design, "grid.json", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return null;
    }
    return this.createUrl(filters, "grid.json");
  };

  ServerWidgetLayerDataSource.prototype.getPopupWidgetDataSource = function(design, widgetId) {
    return new ServerWidgetLayerPopupWidgetDataSource(_.extend({}, this.options, {
      popupWidgetId: widgetId
    }));
  };

  ServerWidgetLayerDataSource.prototype.createUrl = function(filters, extension) {
    var query, url;
    query = {
      type: "dashboard_widget",
      client: this.options.client,
      share: this.options.share,
      dashboard: this.options.dashboardId,
      widget: this.options.widgetId,
      layer: this.options.layerView.id,
      rev: this.options.rev,
      filters: JSON.stringify(filters || [])
    };
    url = (this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?") + querystring.stringify(query);
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    return url;
  };

  ServerWidgetLayerDataSource.prototype.createLegacyUrl = function(design, extension, filters) {
    var relevantFilters, url, where, whereClauses;
    url = this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?type=" + design.type + "&radius=1000";
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    if (this.options.client) {
      url += "&client=" + this.options.client;
    }
    if (this.options.share) {
      url += "&share=" + this.options.share;
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    whereClauses = _.map(relevantFilters, (function(_this) {
      return function(f) {
        return injectTableAlias(f.jsonql, "main");
      };
    })(this));
    if (whereClauses.length > 1) {
      where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      where = whereClauses[0];
    }
    if (where) {
      url += "&where=" + encodeURIComponent(JSON.stringify(where));
    }
    return url;
  };

  return ServerWidgetLayerDataSource;

})();

ServerWidgetLayerPopupWidgetDataSource = (function() {
  function ServerWidgetLayerPopupWidgetDataSource(options) {
    this.options = options;
  }

  ServerWidgetLayerPopupWidgetDataSource.prototype.getData = function(design, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev
    };
    url = this.options.apiUrl + ("dashboards/" + this.options.dashboardId + "/widgets/" + this.options.widgetId + "/layers/" + this.options.layerView.id + "/widgets/" + this.options.popupWidgetId + "/data?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  ServerWidgetLayerPopupWidgetDataSource.prototype.getImageUrl = function(imageId, height) {
    var url;
    url = this.options.apiUrl + ("images/" + imageId);
    if (height) {
      url += "?h=" + height;
    }
    return url;
  };

  return ServerWidgetLayerPopupWidgetDataSource;

})();


},{"../maps/DirectMapDataSource":1082,"../widgets/WidgetFactory":1128,"mwater-expressions":14,"querystring":400}],1042:[function(require,module,exports){
var ActionCancelModalComponent, DashboardUtils, FiltersDesignerComponent, H, QuickfiltersDesignComponent, R, React, ReactSelect, SettingsModalComponent, _, languages, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

update = require('update-object');

languages = require('languages');

ReactSelect = require('react-select');

DashboardUtils = require('./DashboardUtils');

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

QuickfiltersDesignComponent = require('../quickfilter/QuickfiltersDesignComponent');

FiltersDesignerComponent = require('../FiltersDesignerComponent');

module.exports = SettingsModalComponent = (function(superClass) {
  extend(SettingsModalComponent, superClass);

  SettingsModalComponent.propTypes = {
    onDesignChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  function SettingsModalComponent(props) {
    this.handleFiltersChange = bind(this.handleFiltersChange, this);
    this.handleDesignChange = bind(this.handleDesignChange, this);
    this.handleCancel = bind(this.handleCancel, this);
    this.handleSave = bind(this.handleSave, this);
    SettingsModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      design: null
    };
  }

  SettingsModalComponent.prototype.show = function(design) {
    return this.setState({
      design: design
    });
  };

  SettingsModalComponent.prototype.handleSave = function() {
    this.props.onDesignChange(this.state.design);
    return this.setState({
      design: null
    });
  };

  SettingsModalComponent.prototype.handleCancel = function() {
    return this.setState({
      design: null
    });
  };

  SettingsModalComponent.prototype.handleDesignChange = function(design) {
    return this.setState({
      design: design
    });
  };

  SettingsModalComponent.prototype.handleFiltersChange = function(filters) {
    var design;
    design = _.extend({}, this.state.design, {
      filters: filters
    });
    return this.handleDesignChange(design);
  };

  SettingsModalComponent.prototype.render = function() {
    var filterableTables, localeOptions;
    if (!this.state.design) {
      return null;
    }
    filterableTables = DashboardUtils.getFilterableTables(this.state.design, this.props.schema);
    localeOptions = _.map(languages.getAllLanguageCode(), (function(_this) {
      return function(code) {
        return {
          value: code,
          label: languages.getLanguageInfo(code).name + " (" + languages.getLanguageInfo(code).nativeName + ")"
        };
      };
    })(this));
    return R(ActionCancelModalComponent, {
      size: "large",
      onCancel: this.handleCancel,
      onAction: this.handleSave
    }, H.div({
      style: {
        paddingBottom: 200
      }
    }, H.h4(null, "Quick Filters"), H.div({
      className: "text-muted"
    }, "Quick filters are shown to the user as a dropdown at the top of the dashboard and can be used to filter data of widgets."), R(QuickfiltersDesignComponent, {
      design: this.state.design.quickfilters,
      onDesignChange: (function(_this) {
        return function(design) {
          return _this.handleDesignChange(update(_this.state.design, {
            quickfilters: {
              $set: design
            }
          }));
        };
      })(this),
      schema: this.props.schema,
      dataSource: this.props.dataSource
    }), H.h4({
      style: {
        paddingTop: 10
      }
    }, "Filters"), H.div({
      className: "text-muted"
    }, "Filters are built in to the dashboard and cannot be changed by viewers of the dashboard."), filterableTables.length > 0 ? R(FiltersDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      filters: this.state.design.filters,
      onFiltersChange: this.handleFiltersChange,
      filterableTables: filterableTables
    }) : "Nothing to filter. Add widgets to the dashboard", H.h4({
      style: {
        paddingTop: 10
      }
    }, "Language"), H.div({
      className: "text-muted"
    }, "Controls the preferred language of widgets and uses specified language when available"), R(ReactSelect, {
      value: this.state.design.locale || "en",
      options: localeOptions,
      clearable: false,
      onChange: (function(_this) {
        return function(value) {
          return _this.handleDesignChange(update(_this.state.design, {
            locale: {
              $set: value
            }
          }));
        };
      })(this)
    })));
  };

  return SettingsModalComponent;

})(React.Component);


},{"../FiltersDesignerComponent":1019,"../quickfilter/QuickfiltersDesignComponent":1112,"./DashboardUtils":1038,"languages":328,"lodash":"lodash","react":"react","react-library/lib/ActionCancelModalComponent":781,"react-select":818,"update-object":1003}],1043:[function(require,module,exports){
var ActionCancelModalComponent, AutoSizeComponent, DatagridComponent, DatagridDesignerComponent, DatagridUtils, DatagridViewComponent, FindReplaceModalComponent, H, QuickfilterCompiler, QuickfiltersComponent, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

DatagridViewComponent = require('./DatagridViewComponent');

DatagridDesignerComponent = require('./DatagridDesignerComponent');

DatagridUtils = require('./DatagridUtils');

QuickfiltersComponent = require('../quickfilter/QuickfiltersComponent');

QuickfilterCompiler = require('../quickfilter/QuickfilterCompiler');

FindReplaceModalComponent = require('./FindReplaceModalComponent');

module.exports = DatagridComponent = (function(superClass) {
  extend(DatagridComponent, superClass);

  DatagridComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    datagridDataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    titleElem: React.PropTypes.node,
    extraTitleButtonsElem: React.PropTypes.node,
    canEditValue: React.PropTypes.func,
    updateValue: React.PropTypes.func,
    onRowDoubleClick: React.PropTypes.func,
    quickfilterLocks: React.PropTypes.array
  };

  function DatagridComponent(props) {
    this.handleEdit = bind(this.handleEdit, this);
    this.handleCellEditingToggle = bind(this.handleCellEditingToggle, this);
    this.getQuickfilterValues = bind(this.getQuickfilterValues, this);
    DatagridComponent.__super__.constructor.call(this, props);
    this.state = {
      editingDesign: null,
      cellEditingEnabled: false,
      quickfiltersHeight: null,
      quickfiltersValues: null
    };
  }

  DatagridComponent.prototype.componentDidMount = function() {
    return this.updateHeight();
  };

  DatagridComponent.prototype.componentDidUpdate = function() {
    return this.updateHeight();
  };

  DatagridComponent.prototype.updateHeight = function() {
    if (this.refs.quickfilters) {
      if (this.state.quickfiltersHeight !== this.refs.quickfilters.offsetHeight) {
        return this.setState({
          quickfiltersHeight: this.refs.quickfilters.offsetHeight
        });
      }
    } else {
      return this.setState({
        quickfiltersHeight: 0
      });
    }
  };

  DatagridComponent.prototype.getQuickfilterValues = function() {
    return this.state.quickfiltersValues || [];
  };

  DatagridComponent.prototype.handleCellEditingToggle = function() {
    if (this.state.cellEditingEnabled) {
      return this.setState({
        cellEditingEnabled: false
      });
    } else {
      if (confirm("Turn on cell editing? This is allow you to edit the live data and is an advanced feature.")) {
        return this.setState({
          cellEditingEnabled: true
        });
      }
    }
  };

  DatagridComponent.prototype.handleEdit = function() {
    return this.setState({
      editingDesign: this.props.design
    });
  };

  DatagridComponent.prototype.renderCellEdit = function() {
    var label;
    if (!this.props.canEditValue || (this.props.onDesignChange == null)) {
      return null;
    }
    label = [
      H.i({
        className: this.state.cellEditingEnabled ? "fa fa-fw fa-check-square" : "fa fa-fw fa-square-o"
      }), " ", "Cell Editing"
    ];
    return H.a({
      key: "cell-edit",
      className: "btn btn-link btn-sm",
      onClick: this.handleCellEditingToggle
    }, label);
  };

  DatagridComponent.prototype.renderEditButton = function() {
    if (!this.props.onDesignChange) {
      return null;
    }
    return H.button({
      type: "button",
      className: "btn btn-primary",
      onClick: this.handleEdit
    }, H.span({
      className: "glyphicon glyphicon-cog"
    }), " ", "Settings");
  };

  DatagridComponent.prototype.renderFindReplace = function() {
    if (!this.state.cellEditingEnabled) {
      return null;
    }
    return H.a({
      key: "findreplace",
      className: "btn btn-link btn-sm",
      onClick: ((function(_this) {
        return function() {
          return _this.refs.findReplaceModal.show();
        };
      })(this))
    }, "Find/Replace");
  };

  DatagridComponent.prototype.renderTitleBar = function() {
    return H.div({
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: 40,
        padding: 4
      }
    }, H.div({
      style: {
        float: "right"
      }
    }, this.renderFindReplace(), this.renderCellEdit(), this.renderEditButton(), this.props.extraTitleButtonsElem), this.props.titleElem);
  };

  DatagridComponent.prototype.renderQuickfilter = function() {
    return H.div({
      style: {
        position: "absolute",
        top: 40,
        left: 0,
        right: 0
      },
      ref: "quickfilters"
    }, R(QuickfiltersComponent, {
      design: this.props.design.quickfilters,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      values: this.state.quickfiltersValues,
      table: this.props.design.table,
      onValuesChange: (function(_this) {
        return function(values) {
          return _this.setState({
            quickfiltersValues: values
          });
        };
      })(this),
      locks: this.props.quickfilterLocks
    }));
  };

  DatagridComponent.prototype.renderEditor = function() {
    if (!this.state.editingDesign) {
      return;
    }
    return R(ActionCancelModalComponent, {
      onAction: (function(_this) {
        return function() {
          _this.props.onDesignChange(_this.state.editingDesign);
          return _this.setState({
            editingDesign: null
          });
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            editingDesign: null
          });
        };
      })(this),
      size: "large"
    }, R(DatagridDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.state.editingDesign,
      onDesignChange: (function(_this) {
        return function(design) {
          return _this.setState({
            editingDesign: design
          });
        };
      })(this)
    }));
  };

  DatagridComponent.prototype.renderFindReplaceModal = function(filters) {
    return R(FindReplaceModalComponent, {
      ref: "findReplaceModal",
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      datagridDataSource: this.props.datagridDataSource,
      design: this.props.design,
      filters: filters,
      canEditValue: this.props.canEditValue,
      updateValue: this.props.updateValue,
      onUpdate: (function(_this) {
        return function() {
          var ref;
          return (ref = _this.datagridView) != null ? ref.reload() : void 0;
        };
      })(this)
    });
  };

  DatagridComponent.prototype.render = function() {
    var filters, hasQuickfilters, ref;
    filters = new QuickfilterCompiler(this.props.schema).compile(this.props.design.quickfilters, this.state.quickfiltersValues, this.props.quickfilterLocks);
    hasQuickfilters = ((ref = this.props.design.quickfilters) != null ? ref[0] : void 0) != null;
    return H.div({
      style: {
        width: "100%",
        height: "100%",
        position: "relative",
        paddingTop: 40 + (this.state.quickfiltersHeight || 0)
      }
    }, this.renderTitleBar(filters), this.renderQuickfilter(), this.renderEditor(), this.renderFindReplaceModal(filters), R(AutoSizeComponent, {
      injectWidth: true,
      injectHeight: true
    }, (function(_this) {
      return function(size) {
        var design;
        design = new DatagridUtils(_this.props.schema).cleanDesign(_this.props.design);
        if (!new DatagridUtils(_this.props.schema).validateDesign(design)) {
          return R(DatagridViewComponent, {
            ref: function(view) {
              return _this.datagridView = view;
            },
            width: size.width,
            height: size.height,
            pageSize: 100,
            schema: _this.props.schema,
            dataSource: _this.props.dataSource,
            datagridDataSource: _this.props.datagridDataSource,
            design: design,
            filters: filters,
            onDesignChange: _this.props.onDesignChange,
            onRowDoubleClick: _this.props.onRowDoubleClick,
            canEditCell: _this.state.cellEditingEnabled ? _this.props.canEditValue : void 0,
            updateCell: _this.state.cellEditingEnabled ? _this.props.updateValue : void 0
          });
        } else {
          return H.div({
            style: {
              textAlign: "center",
              marginTop: size.height / 2
            }
          }, H.a({
            className: "btn btn-link",
            onClick: _this.handleEdit
          }, "Click Here to Configure"));
        }
      };
    })(this)));
  };

  return DatagridComponent;

})(React.Component);


},{"../quickfilter/QuickfilterCompiler":1110,"../quickfilter/QuickfiltersComponent":1111,"./DatagridDesignerComponent":1045,"./DatagridUtils":1047,"./DatagridViewComponent":1048,"./FindReplaceModalComponent":1052,"lodash":"lodash","react":"react","react-library/lib/ActionCancelModalComponent":781,"react-library/lib/AutoSizeComponent":783}],1044:[function(require,module,exports){
var DashboardDataSource;

module.exports = DashboardDataSource = (function() {
  function DashboardDataSource() {}

  DashboardDataSource.prototype.getRows = function(design, offset, limit, filters, callback) {
    throw new Error("Not implemented");
  };

  return DashboardDataSource;

})();


},{}],1045:[function(require,module,exports){
var ColumnDesignerComponent, ColumnsDesignerComponent, DatagridDesignerComponent, ExprComponent, ExprUtils, FilterExprComponent, H, LabeledExprGenerator, OrderBysDesignerComponent, QuickfiltersDesignComponent, R, React, ReorderableListComponent, TabbedComponent, TableSelectComponent, _, update, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ExprUtils = require("mwater-expressions").ExprUtils;

TabbedComponent = require('react-library/lib/TabbedComponent');

ExprComponent = require('mwater-expressions-ui').ExprComponent;

FilterExprComponent = require('mwater-expressions-ui').FilterExprComponent;

OrderBysDesignerComponent = require('./OrderBysDesignerComponent');

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

QuickfiltersDesignComponent = require('../quickfilter/QuickfiltersDesignComponent');

LabeledExprGenerator = require('./LabeledExprGenerator');

TableSelectComponent = require('../TableSelectComponent');

uuid = require('uuid');

update = require('update-object');

module.exports = DatagridDesignerComponent = (function(superClass) {
  extend(DatagridDesignerComponent, superClass);

  function DatagridDesignerComponent() {
    this.handleOrderBysChange = bind(this.handleOrderBysChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleColumnsChange = bind(this.handleColumnsChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    return DatagridDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  DatagridDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  DatagridDesignerComponent.prototype.handleTableChange = function(table) {
    var design;
    design = {
      table: table,
      columns: []
    };
    return this.props.onDesignChange(design);
  };

  DatagridDesignerComponent.prototype.handleColumnsChange = function(columns) {
    return this.props.onDesignChange(update(this.props.design, {
      columns: {
        $set: columns
      }
    }));
  };

  DatagridDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.props.onDesignChange(update(this.props.design, {
      filter: {
        $set: filter
      }
    }));
  };

  DatagridDesignerComponent.prototype.handleOrderBysChange = function(orderBys) {
    return this.props.onDesignChange(update(this.props.design, {
      orderBys: {
        $set: orderBys
      }
    }));
  };

  DatagridDesignerComponent.prototype.renderTabs = function() {
    return R(TabbedComponent, {
      initialTabId: "columns",
      tabs: [
        {
          id: "columns",
          label: "Columns",
          elem: R(ColumnsDesignerComponent, {
            schema: this.props.schema,
            dataSource: this.props.dataSource,
            table: this.props.design.table,
            columns: this.props.design.columns,
            onColumnsChange: this.handleColumnsChange
          })
        }, {
          id: "filter",
          label: "Filter",
          elem: H.div({
            style: {
              marginBottom: 200
            }
          }, R(FilterExprComponent, {
            schema: this.props.schema,
            dataSource: this.props.dataSource,
            table: this.props.design.table,
            value: this.props.design.filter,
            onChange: this.handleFilterChange
          }))
        }, {
          id: "order",
          label: "Sorting",
          elem: H.div({
            style: {
              marginBottom: 200
            }
          }, R(OrderBysDesignerComponent, {
            schema: this.props.schema,
            dataSource: this.props.dataSource,
            table: this.props.design.table,
            orderBys: this.props.design.orderBys,
            onChange: this.handleOrderBysChange
          }))
        }, {
          id: "quickfilters",
          label: "Quickfilters",
          elem: H.div({
            style: {
              marginBottom: 200
            }
          }, R(QuickfiltersDesignComponent, {
            design: this.props.design.quickfilters,
            onDesignChange: (function(_this) {
              return function(design) {
                return _this.props.onDesignChange(update(_this.props.design, {
                  quickfilters: {
                    $set: design
                  }
                }));
              };
            })(this),
            schema: this.props.schema,
            dataSource: this.props.dataSource
          }))
        }
      ]
    });
  };

  DatagridDesignerComponent.prototype.render = function() {
    return H.div(null, H.label(null, "Data Source:"), R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    }), this.props.design.table ? this.renderTabs() : void 0);
  };

  return DatagridDesignerComponent;

})(React.Component);

ColumnsDesignerComponent = (function(superClass) {
  extend(ColumnsDesignerComponent, superClass);

  function ColumnsDesignerComponent() {
    this.renderColumn = bind(this.renderColumn, this);
    this.handleRemoveAllColumns = bind(this.handleRemoveAllColumns, this);
    this.handleAddDefaultColumns = bind(this.handleAddDefaultColumns, this);
    this.handleAddIdColumn = bind(this.handleAddIdColumn, this);
    this.handleAddColumn = bind(this.handleAddColumn, this);
    this.handleColumnChange = bind(this.handleColumnChange, this);
    return ColumnsDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  ColumnsDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    columns: React.PropTypes.array.isRequired,
    onColumnsChange: React.PropTypes.func.isRequired
  };

  ColumnsDesignerComponent.prototype.handleColumnChange = function(columnIndex, column) {
    var columns;
    columns = this.props.columns.slice();
    if (!column) {
      columns.splice(columnIndex, 1);
    } else if (_.isArray(column)) {
      Array.prototype.splice.apply(columns, [columnIndex, 1].concat(column));
    } else {
      columns[columnIndex] = column;
    }
    return this.props.onColumnsChange(columns);
  };

  ColumnsDesignerComponent.prototype.handleAddColumn = function() {
    var columns;
    columns = this.props.columns.slice();
    columns.push({
      id: uuid(),
      type: "expr",
      width: 150
    });
    return this.props.onColumnsChange(columns);
  };

  ColumnsDesignerComponent.prototype.handleAddIdColumn = function() {
    var columns;
    columns = this.props.columns.slice();
    columns.push({
      id: uuid(),
      type: "expr",
      width: 150,
      expr: {
        type: "id",
        table: this.props.table
      },
      label: "Unique Id"
    });
    return this.props.onColumnsChange(columns);
  };

  ColumnsDesignerComponent.prototype.handleAddDefaultColumns = function() {
    var columns, i, labeledExpr, labeledExprs, len;
    labeledExprs = new LabeledExprGenerator(this.props.schema).generate(this.props.table, {
      headerFormat: "text"
    });
    columns = [];
    for (i = 0, len = labeledExprs.length; i < len; i++) {
      labeledExpr = labeledExprs[i];
      columns.push({
        id: uuid(),
        width: 150,
        type: "expr",
        label: null,
        expr: labeledExpr.expr
      });
    }
    columns = this.props.columns.concat(columns);
    return this.props.onColumnsChange(columns);
  };

  ColumnsDesignerComponent.prototype.handleRemoveAllColumns = function() {
    return this.props.onColumnsChange([]);
  };

  ColumnsDesignerComponent.prototype.renderColumn = function(column, columnIndex, connectDragSource, connectDragPreview, connectDropTarget) {
    return R(ColumnDesignerComponent, {
      key: columnIndex,
      schema: this.props.schema,
      table: this.props.table,
      dataSource: this.props.dataSource,
      column: column,
      onColumnChange: this.handleColumnChange.bind(null, columnIndex),
      connectDragSource: connectDragSource,
      connectDragPreview: connectDragPreview,
      connectDropTarget: connectDropTarget
    });
  };

  ColumnsDesignerComponent.prototype.render = function() {
    return H.div({
      style: {
        height: "auto",
        overflowY: "auto",
        overflowX: "hidden"
      }
    }, H.div({
      style: {
        textAlign: "right"
      },
      key: "options"
    }, H.button({
      key: "addAll",
      type: "button",
      className: "btn btn-link btn-xs",
      onClick: this.handleAddDefaultColumns
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Default Columns"), H.button({
      key: "removeAll",
      type: "button",
      className: "btn btn-link btn-xs",
      onClick: this.handleRemoveAllColumns
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }), " Remove All Columns")), R(ReorderableListComponent, {
      items: this.props.columns,
      onReorder: this.props.onColumnsChange,
      renderItem: this.renderColumn,
      getItemId: (function(_this) {
        return function(item) {
          return item.id;
        };
      })(this)
    }), H.button({
      key: "add",
      type: "button",
      className: "btn btn-link",
      onClick: this.handleAddColumn
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Column"), H.button({
      key: "add-id",
      type: "button",
      className: "btn btn-link",
      onClick: this.handleAddIdColumn
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Unique Id (advanced)"));
  };

  return ColumnsDesignerComponent;

})(React.Component);

ColumnDesignerComponent = (function(superClass) {
  extend(ColumnDesignerComponent, superClass);

  function ColumnDesignerComponent() {
    this.render = bind(this.render, this);
    this.handleSplitGeometry = bind(this.handleSplitGeometry, this);
    this.handleSplitEnumset = bind(this.handleSplitEnumset, this);
    this.handleLabelChange = bind(this.handleLabelChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    return ColumnDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  ColumnDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    column: React.PropTypes.object.isRequired,
    onColumnChange: React.PropTypes.func.isRequired,
    connectDragSource: React.PropTypes.func.isRequired,
    connectDragPreview: React.PropTypes.func.isRequired,
    connectDropTarget: React.PropTypes.func.isRequired
  };

  ColumnDesignerComponent.prototype.handleExprChange = function(expr) {
    return this.props.onColumnChange(update(this.props.column, {
      expr: {
        $set: expr
      }
    }));
  };

  ColumnDesignerComponent.prototype.handleLabelChange = function(label) {
    return this.props.onColumnChange(update(this.props.column, {
      label: {
        $set: label
      }
    }));
  };

  ColumnDesignerComponent.prototype.handleSplitEnumset = function() {
    var exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    return this.props.onColumnChange(_.map(exprUtils.getExprEnumValues(this.props.column.expr), (function(_this) {
      return function(enumVal) {
        return {
          id: uuid(),
          type: "expr",
          width: 150,
          expr: {
            type: "op",
            op: "contains",
            table: _this.props.table,
            exprs: [
              _this.props.column.expr, {
                type: "literal",
                valueType: "enumset",
                value: [enumVal.id]
              }
            ]
          }
        };
      };
    })(this)));
  };

  ColumnDesignerComponent.prototype.handleSplitGeometry = function() {
    return this.props.onColumnChange([
      {
        id: uuid(),
        type: "expr",
        width: 150,
        expr: {
          type: "op",
          op: "latitude",
          table: this.props.table,
          exprs: [this.props.column.expr]
        }
      }, {
        id: uuid(),
        type: "expr",
        width: 150,
        expr: {
          type: "op",
          op: "longitude",
          table: this.props.table,
          exprs: [this.props.column.expr]
        }
      }
    ]);
  };

  ColumnDesignerComponent.prototype.renderSplit = function() {
    var exprType, exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType(this.props.column.expr);
    switch (exprType) {
      case "enumset":
        return H.a({
          className: "btn btn-xs btn-link",
          onClick: this.handleSplitEnumset
        }, H.i({
          className: "fa fa-chain-broken"
        }), " Split by options");
      case "geometry":
        return H.a({
          className: "btn btn-xs btn-link",
          onClick: this.handleSplitGeometry
        }, H.i({
          className: "fa fa-chain-broken"
        }), " Split by lat/lng");
    }
    return null;
  };

  ColumnDesignerComponent.prototype.render = function() {
    var allowedTypes, elem, exprUtils, type;
    exprUtils = new ExprUtils(this.props.schema);
    type = exprUtils.getExprType(this.props.column.expr);
    allowedTypes = ['text', 'number', 'enum', 'enumset', 'boolean', 'date', 'datetime', 'image', 'imagelist', 'text[]', 'geometry'];
    if (type === "id") {
      allowedTypes.push("id");
    }
    elem = H.div({
      className: "row"
    }, H.div({
      className: "col-xs-1"
    }, this.props.connectDragSource(H.span({
      className: "text-muted fa fa-bars"
    }))), H.div({
      className: "col-xs-5"
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      value: this.props.column.expr,
      aggrStatuses: ['literal', 'individual', 'aggregate'],
      types: allowedTypes,
      onChange: this.handleExprChange
    }), this.renderSplit()), H.div({
      className: "col-xs-5"
    }, H.input({
      type: "text",
      className: "form-control",
      placeholder: exprUtils.summarizeExpr(this.props.column.expr),
      value: this.props.column.label,
      onChange: (function(_this) {
        return function(ev) {
          return _this.handleLabelChange(ev.target.value);
        };
      })(this)
    })), H.div({
      className: "col-xs-1"
    }, H.a({
      onClick: this.props.onColumnChange.bind(null, null)
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))));
    return this.props.connectDropTarget(this.props.connectDragPreview(elem));
  };

  return ColumnDesignerComponent;

})(React.Component);


},{"../TableSelectComponent":1025,"../quickfilter/QuickfiltersDesignComponent":1112,"./LabeledExprGenerator":1053,"./OrderBysDesignerComponent":1054,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/TabbedComponent":792,"react-library/lib/reorderable/ReorderableListComponent":795,"update-object":1003,"uuid":1007}],1046:[function(require,module,exports){
var DatagridQueryBuilder, ExprCompiler, ExprUtils, _, injectTableAlias;

_ = require('lodash');

ExprCompiler = require("mwater-expressions").ExprCompiler;

ExprUtils = require("mwater-expressions").ExprUtils;

injectTableAlias = require('mwater-expressions').injectTableAlias;

module.exports = DatagridQueryBuilder = (function() {
  function DatagridQueryBuilder(schema) {
    this.schema = schema;
  }

  DatagridQueryBuilder.prototype.createQuery = function(design, options) {
    if (options == null) {
      options = {};
    }
    if (!design.subtables || design.subtables.length === 0) {
      return this.createSimpleQuery(design, options);
    } else {
      return this.createComplexQuery(design, options);
    }
  };

  DatagridQueryBuilder.prototype.createSimpleQuery = function(design, options) {
    var column, direction, exprCompiler, exprUtils, extraFilter, i, isAggr, j, k, l, len, len1, len2, len3, m, orderBy, query, ref, ref1, ref2, ref3, wheres;
    exprUtils = new ExprUtils(this.schema);
    exprCompiler = new ExprCompiler(this.schema);
    isAggr = this.isMainAggr(design);
    query = {
      type: "query",
      selects: this.createSimpleSelects(design, isAggr),
      from: {
        type: "table",
        table: design.table,
        alias: "main"
      },
      orderBy: [],
      offset: options.offset,
      limit: options.limit
    };
    wheres = [];
    if (design.filter) {
      wheres.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    ref = options.extraFilters || [];
    for (j = 0, len = ref.length; j < len; j++) {
      extraFilter = ref[j];
      if (extraFilter.table === design.table) {
        wheres.push(injectTableAlias(extraFilter.jsonql, "main"));
      }
    }
    wheres = _.compact(wheres);
    if (wheres.length === 1) {
      query.where = wheres[0];
    } else if (wheres.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: wheres
      };
    }
    ref1 = this.getMainOrderByDirections(design, isAggr);
    for (i = k = 0, len1 = ref1.length; k < len1; i = ++k) {
      direction = ref1[i];
      query.orderBy.push({
        ordinal: i + (isAggr ? 1 : 2) + design.columns.length,
        direction: direction
      });
    }
    if (isAggr) {
      query.groupBy = [];
      ref2 = design.columns;
      for (i = l = 0, len2 = ref2.length; l < len2; i = ++l) {
        column = ref2[i];
        if (exprUtils.getExprAggrStatus(column.expr) === "individual") {
          query.groupBy.push(i + 1);
        }
      }
      ref3 = design.orderBys || [];
      for (i = m = 0, len3 = ref3.length; m < len3; i = ++m) {
        orderBy = ref3[i];
        if (exprUtils.getExprAggrStatus(orderBy.expr) === "individual") {
          query.groupBy.push(i + 1 + design.columns.length);
        }
      }
    }
    return query;
  };

  DatagridQueryBuilder.prototype.createComplexQuery = function(design, options) {
    var column, direction, i, index, j, k, l, len, len1, len2, len3, len4, m, n, query, ref, ref1, ref2, ref3, ref4, stindex, subtable, unionQueries, unionQuery;
    unionQueries = [];
    unionQueries.push(this.createComplexMainQuery(design, options));
    ref = design.subtables;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      subtable = ref[index];
      unionQueries.push(this.createComplexSubtableQuery(design, options, subtable, index));
    }
    unionQuery = {
      type: "union all",
      queries: unionQueries
    };
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "unioned",
            column: "id"
          },
          alias: "id"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "unioned",
            column: "subtable"
          },
          alias: "subtable"
        }
      ],
      from: {
        type: "subquery",
        query: unionQuery,
        alias: "unioned"
      },
      orderBy: [],
      offset: options.offset,
      limit: options.limit
    };
    ref1 = design.columns;
    for (index = k = 0, len1 = ref1.length; k < len1; index = ++k) {
      column = ref1[index];
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "unioned",
          column: "c" + index
        },
        alias: "c" + index
      });
    }
    ref2 = this.getMainOrderByDirections(design);
    for (i = l = 0, len2 = ref2.length; l < len2; i = ++l) {
      direction = ref2[i];
      query.orderBy.push({
        expr: {
          type: "field",
          tableAlias: "unioned",
          column: "s" + i
        },
        direction: direction
      });
    }
    query.orderBy.push({
      expr: {
        type: "field",
        tableAlias: "unioned",
        column: "subtable"
      },
      direction: "asc"
    });
    ref3 = design.subtables;
    for (stindex = m = 0, len3 = ref3.length; m < len3; stindex = ++m) {
      subtable = ref3[stindex];
      ref4 = this.getSubtableOrderByDirections(design, subtable);
      for (i = n = 0, len4 = ref4.length; n < len4; i = ++n) {
        direction = ref4[i];
        query.orderBy.push({
          expr: {
            type: "field",
            tableAlias: "unioned",
            column: "st" + stindex + "s" + i
          },
          direction: direction
        });
      }
    }
    return query;
  };

  DatagridQueryBuilder.prototype.createComplexMainQuery = function(design, options) {
    var expr, exprCompiler, extraFilter, i, j, k, l, len, len1, len2, len3, m, query, ref, ref1, ref2, ref3, selects, stindex, subtable, type, wheres;
    exprCompiler = new ExprCompiler(this.schema);
    selects = [
      {
        type: "select",
        expr: {
          type: "field",
          tableAlias: "main",
          column: this.schema.getTable(design.table).primaryKey
        },
        alias: "id"
      }, {
        type: "select",
        expr: -1,
        alias: "subtable"
      }
    ];
    ref = this.getMainOrderByExprs(design);
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      expr = ref[i];
      selects.push({
        type: "select",
        expr: expr,
        alias: "s" + i
      });
    }
    ref1 = design.subtables;
    for (stindex = k = 0, len1 = ref1.length; k < len1; stindex = ++k) {
      subtable = ref1[stindex];
      ref2 = this.getSubtableOrderByExprTypes(design, subtable);
      for (i = l = 0, len2 = ref2.length; l < len2; i = ++l) {
        type = ref2[i];
        selects.push({
          type: "select",
          expr: this.createNullExpr(type),
          alias: "st" + stindex + "s" + i
        });
      }
    }
    selects = selects.concat(_.map(design.columns, (function(_this) {
      return function(column, columnIndex) {
        return _this.createColumnSelect(column, columnIndex);
      };
    })(this)));
    query = {
      type: "query",
      selects: selects,
      from: {
        type: "table",
        table: design.table,
        alias: "main"
      }
    };
    wheres = [];
    if (design.filter) {
      wheres.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    ref3 = options.extraFilters || [];
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      extraFilter = ref3[m];
      if (extraFilter.table === design.table) {
        wheres.push(injectTableAlias(extraFilter.jsonql, "main"));
      }
    }
    wheres = _.compact(wheres);
    if (wheres.length === 1) {
      query.where = wheres[0];
    } else if (wheres.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: wheres
      };
    }
    return query;
  };

  DatagridQueryBuilder.prototype.createComplexSubtableQuery = function(design, options, subtable, subtableIndex) {
    var expr, exprCompiler, exprUtils, extraFilter, i, j, k, l, len, len1, len2, len3, m, query, ref, ref1, ref2, ref3, selects, st, stindex, subtableTable, types, wheres;
    exprUtils = new ExprUtils(this.schema);
    exprCompiler = new ExprCompiler(this.schema);
    selects = [
      {
        type: "select",
        expr: {
          type: "field",
          tableAlias: "main",
          column: this.schema.getTable(design.table).primaryKey
        },
        alias: "id"
      }, {
        type: "select",
        expr: subtableIndex,
        alias: "subtable"
      }
    ];
    ref = this.getMainOrderByExprs(design);
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      expr = ref[i];
      selects.push({
        type: "select",
        expr: expr,
        alias: "s" + i
      });
    }
    ref1 = design.subtables;
    for (stindex = k = 0, len1 = ref1.length; k < len1; stindex = ++k) {
      st = ref1[stindex];
      ref2 = this.getSubtableOrderByExprs(design, st);
      for (i = l = 0, len2 = ref2.length; l < len2; i = ++l) {
        expr = ref2[i];
        if (stindex === subtableIndex) {
          selects.push({
            type: "select",
            expr: expr,
            alias: "st" + stindex + "s" + i
          });
        } else {
          types = this.getSubtableOrderByExprTypes(design, st);
          selects.push({
            type: "select",
            expr: this.createNullExpr(types[i]),
            alias: "st" + stindex + "s" + i
          });
        }
      }
    }
    selects = selects.concat(_.map(design.columns, (function(_this) {
      return function(column, columnIndex) {
        return _this.createColumnSelect(column, columnIndex, subtable);
      };
    })(this)));
    subtableTable = exprUtils.followJoins(design.table, subtable.joins);
    if (subtable.joins.length > 1) {
      throw new Error("Multiple subtable joins not implemented");
    }
    query = {
      type: "query",
      selects: selects,
      from: {
        type: "join",
        kind: "inner",
        left: {
          type: "table",
          table: design.table,
          alias: "main"
        },
        right: {
          type: "table",
          table: subtableTable,
          alias: "st"
        },
        on: exprCompiler.compileJoin(this.schema.getColumn(design.table, subtable.joins[0]).join, "main", "st")
      }
    };
    wheres = [];
    if (design.filter) {
      wheres.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    ref3 = options.extraFilters || [];
    for (m = 0, len3 = ref3.length; m < len3; m++) {
      extraFilter = ref3[m];
      if (extraFilter.table === design.table) {
        wheres.push(injectTableAlias(extraFilter.jsonql, "main"));
      }
      if (extraFilter.table === subtableTable) {
        wheres.push(injectTableAlias(extraFilter.jsonql, "st"));
      }
    }
    wheres = _.compact(wheres);
    if (wheres.length === 1) {
      query.where = wheres[0];
    } else if (wheres.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: wheres
      };
    }
    return query;
  };

  DatagridQueryBuilder.prototype.getMainOrderByExprs = function(design, isAggr) {
    var exprCompiler, exprs, j, len, orderBy, ordering, ref;
    if (isAggr == null) {
      isAggr = false;
    }
    exprCompiler = new ExprCompiler(this.schema);
    exprs = [];
    ref = design.orderBys || [];
    for (j = 0, len = ref.length; j < len; j++) {
      orderBy = ref[j];
      exprs.push(exprCompiler.compileExpr({
        expr: orderBy.expr,
        tableAlias: "main"
      }));
    }
    if (!isAggr) {
      ordering = this.schema.getTable(design.table).ordering;
      if (ordering) {
        exprs.push({
          type: "field",
          tableAlias: "main",
          column: ordering
        });
      }
      exprs.push({
        type: "field",
        tableAlias: "main",
        column: this.schema.getTable(design.table).primaryKey
      });
    }
    return exprs;
  };

  DatagridQueryBuilder.prototype.getMainOrderByDirections = function(design, isAggr) {
    var directions, j, len, orderBy, ordering, ref;
    if (isAggr == null) {
      isAggr = false;
    }
    directions = [];
    ref = design.orderBys || [];
    for (j = 0, len = ref.length; j < len; j++) {
      orderBy = ref[j];
      directions.push(orderBy.direction);
    }
    if (!isAggr) {
      ordering = this.schema.getTable(design.table).ordering;
      if (ordering) {
        directions.push("asc");
      }
      directions.push("asc");
    }
    return directions;
  };

  DatagridQueryBuilder.prototype.getSubtableOrderByExprs = function(design, subtable) {
    var exprCompiler, exprUtils, exprs, j, len, orderBy, ordering, ref, subtableTable;
    exprUtils = new ExprUtils(this.schema);
    exprCompiler = new ExprCompiler(this.schema);
    subtableTable = exprUtils.followJoins(design.table, subtable.joins);
    exprs = [];
    ref = subtable.orderBys || [];
    for (j = 0, len = ref.length; j < len; j++) {
      orderBy = ref[j];
      exprs.push(exprCompiler.compileExpr({
        expr: orderBy.expr,
        tableAlias: "st"
      }));
    }
    ordering = this.schema.getTable(subtableTable).ordering;
    if (ordering) {
      exprs.push({
        type: "field",
        tableAlias: "st",
        column: ordering
      });
    }
    exprs.push({
      type: "field",
      tableAlias: "st",
      column: this.schema.getTable(subtableTable).primaryKey
    });
    return exprs;
  };

  DatagridQueryBuilder.prototype.getSubtableOrderByDirections = function(design, subtable) {
    var directions, exprUtils, j, len, orderBy, ordering, ref, subtableTable;
    exprUtils = new ExprUtils(this.schema);
    subtableTable = exprUtils.followJoins(design.table, subtable.joins);
    directions = [];
    ref = subtable.orderBys || [];
    for (j = 0, len = ref.length; j < len; j++) {
      orderBy = ref[j];
      directions.push(orderBy.direction);
    }
    ordering = this.schema.getTable(subtableTable).ordering;
    if (ordering) {
      directions.push("asc");
    }
    directions.push("asc");
    return directions;
  };

  DatagridQueryBuilder.prototype.getSubtableOrderByExprTypes = function(design, subtable) {
    var exprUtils, j, len, orderBy, ordering, ref, subtableTable, types;
    exprUtils = new ExprUtils(this.schema);
    subtableTable = exprUtils.followJoins(design.table, subtable.joins);
    types = [];
    ref = subtable.orderBys || [];
    for (j = 0, len = ref.length; j < len; j++) {
      orderBy = ref[j];
      types.push(exprUtils.getExprType(orderBy.expr));
    }
    ordering = this.schema.getTable(subtableTable).ordering;
    if (ordering) {
      types.push(this.schema.getColumn(subtableTable, ordering).type);
    }
    types.push("text");
    return types;
  };

  DatagridQueryBuilder.prototype.createColumnSelect = function(column, columnIndex, subtable) {
    var compiledExpr, exprCompiler, exprType, exprUtils;
    exprUtils = new ExprUtils(this.schema);
    exprType = exprUtils.getExprType(column.expr);
    if (column.subtable && !subtable) {
      return {
        type: "select",
        expr: this.createNullExpr(exprType),
        alias: "c" + columnIndex
      };
    }
    if (column.subtable && subtable) {
      if (subtable.id !== column.subtable) {
        return {
          type: "select",
          expr: this.createNullExpr(exprType),
          alias: "c" + columnIndex
        };
      }
    }
    if (!column.subtable && subtable) {
      return {
        type: "select",
        expr: this.createNullExpr(exprType),
        alias: "c" + columnIndex
      };
    }
    exprCompiler = new ExprCompiler(this.schema);
    compiledExpr = exprCompiler.compileExpr({
      expr: column.expr,
      tableAlias: column.subtable ? "st" : "main"
    });
    if (exprType === "geometry") {
      compiledExpr = {
        type: "op",
        op: "ST_AsGeoJSON",
        exprs: [
          {
            type: "op",
            op: "ST_Transform",
            exprs: [
              {
                type: "op",
                op: "::geometry",
                exprs: [compiledExpr]
              }, 4326
            ]
          }
        ]
      };
    }
    return {
      type: "select",
      expr: compiledExpr,
      alias: "c" + columnIndex
    };
  };

  DatagridQueryBuilder.prototype.createSimpleSelects = function(design, isAggr) {
    var expr, i, j, len, ref, selects;
    selects = [];
    if (!isAggr) {
      selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "main",
          column: this.schema.getTable(design.table).primaryKey
        },
        alias: "id"
      });
    }
    selects = selects.concat(_.map(design.columns, (function(_this) {
      return function(column, columnIndex) {
        return _this.createColumnSelect(column, columnIndex);
      };
    })(this)));
    ref = this.getMainOrderByExprs(design, isAggr);
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      expr = ref[i];
      selects.push({
        type: "select",
        expr: expr,
        alias: "s" + i
      });
    }
    return selects;
  };

  DatagridQueryBuilder.prototype.createNullExpr = function(exprType) {
    switch (exprType) {
      case "text":
      case "enum":
      case "geometry":
      case "id":
      case "date":
      case "datetime":
        return {
          type: "op",
          op: "::text",
          exprs: [null]
        };
      case "boolean":
        return {
          type: "op",
          op: "::boolean",
          exprs: [null]
        };
      case "number":
        return {
          type: "op",
          op: "::decimal",
          exprs: [null]
        };
      case "enumset":
      case "text[]":
      case "image":
      case "imagelist":
        return {
          type: "op",
          op: "::jsonb",
          exprs: [null]
        };
      default:
        return null;
    }
  };

  DatagridQueryBuilder.prototype.isMainAggr = function(design) {
    var column, exprUtils, j, k, len, len1, orderBy, ref, ref1;
    exprUtils = new ExprUtils(this.schema);
    ref = design.columns;
    for (j = 0, len = ref.length; j < len; j++) {
      column = ref[j];
      if (exprUtils.getExprAggrStatus(column.expr) === "aggregate") {
        return true;
      }
    }
    ref1 = design.orderBys || [];
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      orderBy = ref1[k];
      if (exprUtils.getExprAggrStatus(orderBy.expr) === "aggregate") {
        return true;
      }
    }
    return false;
  };

  return DatagridQueryBuilder;

})();


},{"lodash":"lodash","mwater-expressions":14}],1047:[function(require,module,exports){
var DatagridUtils, ExprCleaner, ExprUtils, _, update;

_ = require('lodash');

update = require('update-object');

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require("mwater-expressions").ExprUtils;

module.exports = DatagridUtils = (function() {
  function DatagridUtils(schema) {
    this.schema = schema;
  }

  DatagridUtils.prototype.cleanDesign = function(design) {
    var column, exprCleaner, i, len, ref, subtable, table;
    exprCleaner = new ExprCleaner(this.schema);
    if (!this.schema.getTable(design.table)) {
      return {};
    }
    design = _.cloneDeep(design);
    ref = design.columns;
    for (i = 0, len = ref.length; i < len; i++) {
      column = ref[i];
      if (column.type === "expr") {
        if (column.subtable) {
          subtable = _.findWhere(design.subtables, {
            id: column.subtable
          });
          table = new ExprUtils(this.schema).followJoins(design.table, subtable.joins);
        } else {
          table = design.table;
        }
        column.expr = exprCleaner.cleanExpr(column.expr, {
          table: table,
          aggrStatuses: ["individual", "literal", "aggregate"]
        });
      }
    }
    return design;
  };

  DatagridUtils.prototype.validateDesign = function(design) {
    var ref;
    if (!design.table) {
      return "Missing table";
    }
    if (!((ref = design.columns) != null ? ref[0] : void 0)) {
      return "No columns";
    }
  };

  return DatagridUtils;

})();


},{"lodash":"lodash","mwater-expressions":14,"update-object":1003}],1048:[function(require,module,exports){
var Cell, Column, DatagridQueryBuilder, DatagridViewComponent, EditExprCellComponent, ExprCellComponent, ExprUtils, H, R, React, Table, _, moment, ref,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

moment = require('moment');

ref = require('fixed-data-table'), Table = ref.Table, Column = ref.Column, Cell = ref.Cell;

DatagridQueryBuilder = require('./DatagridQueryBuilder');

ExprUtils = require("mwater-expressions").ExprUtils;

ExprCellComponent = require('./ExprCellComponent');

EditExprCellComponent = require('./EditExprCellComponent');

module.exports = DatagridViewComponent = (function(superClass) {
  extend(DatagridViewComponent, superClass);

  DatagridViewComponent.propTypes = {
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    pageSize: React.PropTypes.number,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    datagridDataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    filters: React.PropTypes.arrayOf(React.PropTypes.shape({
      table: React.PropTypes.string.isRequired,
      jsonql: React.PropTypes.object.isRequired
    })),
    canEditCell: React.PropTypes.func,
    updateCell: React.PropTypes.func,
    onRowDoubleClick: React.PropTypes.func,
    onRowClick: React.PropTypes.func
  };

  DatagridViewComponent.defaultProps = {
    pageSize: 100
  };

  function DatagridViewComponent(props) {
    this.renderCell = bind(this.renderCell, this);
    this.handleRowClick = bind(this.handleRowClick, this);
    this.handleRowDoubleClick = bind(this.handleRowDoubleClick, this);
    this.refEditCell = bind(this.refEditCell, this);
    this.handleCancelEdit = bind(this.handleCancelEdit, this);
    this.handleSaveEdit = bind(this.handleSaveEdit, this);
    this.handleCellClick = bind(this.handleCellClick, this);
    this.handleColumnResize = bind(this.handleColumnResize, this);
    this.reload = bind(this.reload, this);
    DatagridViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      rows: [],
      entirelyLoaded: false,
      editingCell: null,
      savingCell: false
    };
  }

  DatagridViewComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (!_.isEqual(nextProps.design, this.props.design) || !_.isEqual(nextProps.filters, this.props.filters)) {
      return this.setState({
        rows: [],
        entirelyLoaded: false
      });
    }
  };

  DatagridViewComponent.prototype.loadMoreRows = function() {
    var loadState;
    loadState = {
      design: this.props.design,
      offset: this.state.rows.length,
      limit: this.props.pageSize,
      filters: this.props.filters
    };
    if (_.isEqual(loadState, this.loadState)) {
      return;
    }
    this.loadState = loadState;
    return this.props.datagridDataSource.getRows(loadState.design, loadState.offset, loadState.limit, loadState.filters, (function(_this) {
      return function(error, newRows) {
        var rows;
        if (error) {
          console.error(error);
          alert("Error loading data");
          return;
        }
        if (_.isEqual(loadState, _this.loadState)) {
          _this.loadState = null;
          rows = _this.state.rows.concat(newRows);
          return _this.setState({
            rows: rows,
            entirelyLoaded: newRows.length < _this.props.pageSize
          });
        }
      };
    })(this));
  };

  DatagridViewComponent.prototype.reload = function() {
    return this.setState({
      rows: [],
      entirelyLoaded: false
    });
  };

  DatagridViewComponent.prototype.deleteRow = function(rowIndex, callback) {
    var newRows;
    newRows = this.state.rows.slice();
    _.pullAt(newRows, rowIndex);
    this.setState({
      rows: newRows
    });
    return callback();
  };

  DatagridViewComponent.prototype.reloadRow = function(rowIndex, callback) {
    return this.props.datagridDataSource.getRows(this.props.design, rowIndex, 1, this.props.filters, (function(_this) {
      return function(error, rows) {
        var newRows;
        if (error || !rows[0]) {
          console.error(error);
          alert("Error loading data");
          callback();
          return;
        }
        newRows = _this.state.rows.slice();
        newRows[rowIndex] = rows[0];
        _this.setState({
          rows: newRows
        });
        return callback();
      };
    })(this));
  };

  DatagridViewComponent.prototype.handleColumnResize = function(newColumnWidth, columnKey) {
    var column, columnIndex, columns;
    columnIndex = _.findIndex(this.props.design.columns, {
      id: columnKey
    });
    column = this.props.design.columns[columnIndex];
    column = _.extend({}, column, {
      width: newColumnWidth
    });
    columns = this.props.design.columns.slice();
    columns[columnIndex] = column;
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      columns: columns
    }));
  };

  DatagridViewComponent.prototype.handleCellClick = function(rowIndex, columnIndex) {
    var column, exprType, ref1, ref2;
    if (((ref1 = this.state.editingCell) != null ? ref1.rowIndex : void 0) === rowIndex && ((ref2 = this.state.editingCell) != null ? ref2.columnIndex : void 0) === columnIndex) {
      return;
    }
    if (this.state.savingCell) {
      return;
    }
    if (this.state.editingCell) {
      this.handleSaveEdit();
      return;
    }
    if (!this.props.canEditCell) {
      return;
    }
    column = this.props.design.columns[columnIndex];
    if (!column.type === "expr") {
      return;
    }
    exprType = new ExprUtils(this.props.schema).getExprType(column.expr);
    if (exprType !== 'text' && exprType !== 'number' && exprType !== 'enum') {
      return;
    }
    return this.props.canEditCell(this.props.design.table, this.state.rows[rowIndex].id, column.expr, (function(_this) {
      return function(error, canEdit) {
        if (error) {
          throw error;
        }
        if (canEdit) {
          return _this.setState({
            editingCell: {
              rowIndex: rowIndex,
              columnIndex: columnIndex
            }
          });
        }
      };
    })(this));
  };

  DatagridViewComponent.prototype.handleSaveEdit = function() {
    var expr, rowId, value;
    if (!this.editCellComp.hasChanged()) {
      this.setState({
        editingCell: null,
        savingCell: false
      });
      return;
    }
    rowId = this.state.rows[this.state.editingCell.rowIndex].id;
    expr = this.props.design.columns[this.state.editingCell.columnIndex].expr;
    value = this.editCellComp.getValue();
    return this.setState({
      savingCell: true
    }, (function(_this) {
      return function() {
        return _this.props.updateCell(_this.props.design.table, rowId, expr, value, function(error) {
          return _this.reloadRow(_this.state.editingCell.rowIndex, function() {
            return _this.setState({
              editingCell: null,
              savingCell: false
            });
          });
        });
      };
    })(this));
  };

  DatagridViewComponent.prototype.handleCancelEdit = function() {
    return this.setState({
      editingCell: null,
      savingCell: false
    });
  };

  DatagridViewComponent.prototype.refEditCell = function(comp) {
    return this.editCellComp = comp;
  };

  DatagridViewComponent.prototype.handleRowDoubleClick = function(ev, rowIndex) {
    if ((this.props.onRowDoubleClick != null) && this.state.rows[rowIndex].id) {
      return this.props.onRowDoubleClick(this.props.design.table, this.state.rows[rowIndex].id, rowIndex);
    }
  };

  DatagridViewComponent.prototype.handleRowClick = function(ev, rowIndex) {
    if ((this.props.onRowClick != null) && this.state.rows[rowIndex].id) {
      return this.props.onRowClick(this.props.design.table, this.state.rows[rowIndex].id, rowIndex);
    }
  };

  DatagridViewComponent.prototype.renderCell = function(column, columnIndex, exprType, cellProps) {
    var muted, ref1, ref2, value;
    if (cellProps.rowIndex >= this.state.rows.length) {
      _.defer((function(_this) {
        return function() {
          return _this.loadMoreRows();
        };
      })(this));
      return R(Cell, cellProps, H.i({
        className: "fa fa-spinner fa-spin"
      }));
    }
    value = this.state.rows[cellProps.rowIndex]["c" + columnIndex];
    if (((ref1 = this.state.editingCell) != null ? ref1.rowIndex : void 0) === cellProps.rowIndex && ((ref2 = this.state.editingCell) != null ? ref2.columnIndex : void 0) === columnIndex) {
      if (this.state.savingCell) {
        return R(Cell, cellProps, H.i({
          className: "fa fa-spinner fa-spin"
        }));
      }
      return R(EditExprCellComponent, {
        ref: this.refEditCell,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        locale: this.props.design.locale,
        width: cellProps.width,
        height: cellProps.height,
        value: value,
        expr: column.expr,
        onSave: this.handleSaveEdit,
        onCancel: this.handleCancelEdit
      });
    }
    if (column.type === "expr") {
      muted = !column.subtable && this.state.rows[cellProps.rowIndex].subtable >= 0;
      return R(ExprCellComponent, {
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        locale: this.props.design.locale,
        width: cellProps.width,
        height: cellProps.height,
        value: value,
        expr: column.expr,
        exprType: exprType,
        muted: muted,
        onClick: this.handleCellClick.bind(null, cellProps.rowIndex, columnIndex)
      });
    }
  };

  DatagridViewComponent.prototype.renderColumn = function(column, columnIndex) {
    var exprType, exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType(column.expr);
    return R(Column, {
      key: column.id,
      header: R(Cell, {
        style: {
          whiteSpace: "nowrap"
        }
      }, column.label || exprUtils.summarizeExpr(column.expr, this.props.design.locale)),
      width: column.width,
      allowCellsRecycling: true,
      cell: this.renderCell.bind(null, column, columnIndex, exprType),
      columnKey: column.id,
      isResizable: this.props.onDesignChange != null
    });
  };

  DatagridViewComponent.prototype.renderColumns = function() {
    return _.map(this.props.design.columns, (function(_this) {
      return function(column, columnIndex) {
        return _this.renderColumn(column, columnIndex);
      };
    })(this));
  };

  DatagridViewComponent.prototype.render = function() {
    var rowsCount;
    rowsCount = this.state.rows.length;
    if (!this.state.entirelyLoaded) {
      rowsCount += 1;
    }
    return R(Table, {
      rowsCount: rowsCount,
      rowHeight: 40,
      headerHeight: 40,
      width: this.props.width,
      height: this.props.height,
      onRowDoubleClick: this.handleRowDoubleClick,
      onRowClick: this.handleRowClick,
      isColumnResizing: false,
      onColumnResizeEndCallback: this.handleColumnResize
    }, this.renderColumns());
  };

  return DatagridViewComponent;

})(React.Component);


},{"./DatagridQueryBuilder":1046,"./EditExprCellComponent":1050,"./ExprCellComponent":1051,"fixed-data-table":325,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],1049:[function(require,module,exports){
var DatagridDataSource, DatagridQueryBuilder, DirectDatagridDataSource;

DatagridDataSource = require('./DatagridDataSource');

DatagridQueryBuilder = require('./DatagridQueryBuilder');

module.exports = DirectDatagridDataSource = (function() {
  function DirectDatagridDataSource(options) {
    this.options = options;
  }

  DirectDatagridDataSource.prototype.getRows = function(design, offset, limit, filters, callback) {
    var query, queryBuilder;
    queryBuilder = new DatagridQueryBuilder(this.options.schema);
    query = queryBuilder.createQuery(design, {
      offset: offset,
      limit: limit,
      extraFilters: filters
    });
    return this.options.dataSource.performQuery(query, callback);
  };

  return DirectDatagridDataSource;

})();


},{"./DatagridDataSource":1044,"./DatagridQueryBuilder":1046}],1050:[function(require,module,exports){
var Cell, EditExprCellComponent, EnumEditComponent, ExprUtils, H, NumberEditComponent, R, React, TextEditComponent, _, moment,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

moment = require('moment');

ExprUtils = require("mwater-expressions").ExprUtils;

Cell = require('fixed-data-table').Cell;

module.exports = EditExprCellComponent = (function(superClass) {
  extend(EditExprCellComponent, superClass);

  EditExprCellComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    locale: React.PropTypes.string,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    value: React.PropTypes.any,
    expr: React.PropTypes.object.isRequired,
    onSave: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  function EditExprCellComponent(props) {
    this.handleChange = bind(this.handleChange, this);
    EditExprCellComponent.__super__.constructor.call(this, props);
    this.state = {
      value: props.value
    };
  }

  EditExprCellComponent.prototype.getValue = function() {
    return this.state.value;
  };

  EditExprCellComponent.prototype.hasChanged = function() {
    return !_.isEqual(this.props.value, this.state.value);
  };

  EditExprCellComponent.prototype.handleChange = function(value) {
    return this.setState({
      value: value
    });
  };

  EditExprCellComponent.prototype.render = function() {
    var exprType, exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType(this.props.expr);
    switch (exprType) {
      case "text":
        return R(TextEditComponent, {
          value: this.state.value,
          onChange: this.handleChange,
          onSave: this.props.onSave,
          onCancel: this.props.onCancel
        });
      case "number":
        return R(NumberEditComponent, {
          value: this.state.value,
          onChange: this.handleChange,
          onSave: this.props.onSave,
          onCancel: this.props.onCancel
        });
      case "enum":
        return R(EnumEditComponent, {
          value: this.state.value,
          onChange: this.handleChange,
          enumValues: exprUtils.getExprEnumValues(this.props.expr),
          onSave: this.props.onSave,
          onCancel: this.props.onCancel,
          locale: this.props.locale
        });
    }
    throw new Error("Unsupported type " + exprType + " for editing");
  };

  return EditExprCellComponent;

})(React.Component);

TextEditComponent = (function(superClass) {
  extend(TextEditComponent, superClass);

  function TextEditComponent() {
    return TextEditComponent.__super__.constructor.apply(this, arguments);
  }

  TextEditComponent.propTypes = {
    value: React.PropTypes.any,
    onChange: React.PropTypes.func.isRequired,
    onSave: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  TextEditComponent.prototype.componentDidMount = function() {
    var ref;
    return (ref = this.refs.input) != null ? ref.focus() : void 0;
  };

  TextEditComponent.prototype.render = function() {
    return H.div({
      style: {
        paddingTop: 3
      }
    }, H.input({
      ref: "input",
      type: "text",
      className: "form-control",
      value: this.props.value || "",
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(ev.target.value || null);
        };
      })(this),
      onKeyUp: (function(_this) {
        return function(ev) {
          if (ev.keyCode === 27) {
            _this.props.onCancel();
          }
          if (ev.keyCode === 13) {
            return _this.props.onSave();
          }
        };
      })(this)
    }));
  };

  return TextEditComponent;

})(React.Component);

NumberEditComponent = (function(superClass) {
  extend(NumberEditComponent, superClass);

  function NumberEditComponent() {
    this.handleChange = bind(this.handleChange, this);
    return NumberEditComponent.__super__.constructor.apply(this, arguments);
  }

  NumberEditComponent.propTypes = {
    value: React.PropTypes.any,
    onChange: React.PropTypes.func.isRequired,
    onSave: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  NumberEditComponent.prototype.componentDidMount = function() {
    var ref;
    return (ref = this.refs.input) != null ? ref.focus() : void 0;
  };

  NumberEditComponent.prototype.handleChange = function(ev) {
    if (ev.target.value) {
      return this.props.onChange(parseFloat(ev.target.value));
    } else {
      return this.props.onChange(null);
    }
  };

  NumberEditComponent.prototype.render = function() {
    return H.div({
      style: {
        paddingTop: 3
      }
    }, H.input({
      ref: "input",
      type: "number",
      step: "any",
      className: "form-control",
      value: this.props.value != null ? this.props.value : "",
      onChange: this.handleChange,
      onKeyUp: (function(_this) {
        return function(ev) {
          if (ev.keyCode === 27) {
            _this.props.onCancel();
          }
          if (ev.keyCode === 13) {
            return _this.props.onSave();
          }
        };
      })(this)
    }));
  };

  return NumberEditComponent;

})(React.Component);

EnumEditComponent = (function(superClass) {
  extend(EnumEditComponent, superClass);

  function EnumEditComponent() {
    return EnumEditComponent.__super__.constructor.apply(this, arguments);
  }

  EnumEditComponent.propTypes = {
    value: React.PropTypes.any,
    enumValues: React.PropTypes.array.isRequired,
    locale: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired,
    onSave: React.PropTypes.func.isRequired,
    onCancel: React.PropTypes.func.isRequired
  };

  EnumEditComponent.prototype.render = function() {
    return H.div({
      style: {
        paddingTop: 3
      }
    }, H.select({
      value: this.props.value || "",
      onChange: (function(_this) {
        return function(ev) {
          return _this.props.onChange(ev.target.value || null);
        };
      })(this),
      className: "form-control"
    }, H.option({
      key: "",
      value: ""
    }, ""), _.map(this.props.enumValues, (function(_this) {
      return function(ev) {
        return H.option({
          key: ev.id,
          value: ev.id
        }, ExprUtils.localizeString(ev.name, _this.props.locale));
      };
    })(this))));
  };

  return EnumEditComponent;

})(React.Component);


},{"fixed-data-table":325,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],1051:[function(require,module,exports){
var Cell, ExprCellComponent, ExprUtils, H, R, React, _, moment,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

moment = require('moment');

ExprUtils = require("mwater-expressions").ExprUtils;

Cell = require('fixed-data-table').Cell;

module.exports = ExprCellComponent = (function(superClass) {
  extend(ExprCellComponent, superClass);

  function ExprCellComponent() {
    this.handleClick = bind(this.handleClick, this);
    return ExprCellComponent.__super__.constructor.apply(this, arguments);
  }

  ExprCellComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    locale: React.PropTypes.string,
    exprType: React.PropTypes.string,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    value: React.PropTypes.any,
    expr: React.PropTypes.object,
    muted: React.PropTypes.bool,
    onClick: React.PropTypes.func
  };

  ExprCellComponent.prototype.handleClick = function() {
    return this.setState({
      editing: true
    });
  };

  ExprCellComponent.prototype.renderImage = function(id) {
    var url;
    url = this.props.dataSource.getImageUrl(id);
    return H.a({
      href: url,
      key: id,
      target: "_blank",
      style: {
        paddingLeft: 5,
        paddingRight: 5
      }
    }, "Image");
  };

  ExprCellComponent.prototype.render = function() {
    var exprUtils, node, ref, ref1, value;
    exprUtils = new ExprUtils(this.props.schema);
    value = this.props.value;
    if ((value == null) || !this.props.expr) {
      node = null;
    } else {
      if (((ref = this.props.exprType) === 'image' || ref === 'imagelist' || ref === 'geometry' || ref === 'text[]') && _.isString(value)) {
        value = JSON.parse(value);
      }
      switch (this.props.exprType) {
        case "text":
        case "number":
          node = value;
          break;
        case "boolean":
        case "enum":
        case "enumset":
        case "text[]":
          node = exprUtils.stringifyExprLiteral(this.props.expr, value, this.props.locale);
          break;
        case "date":
          node = moment(value, "YYYY-MM-DD").format("ll");
          break;
        case "datetime":
          node = moment(value, moment.ISO_8601).format("lll");
          break;
        case "image":
          node = this.renderImage(value.id);
          break;
        case "imagelist":
          node = _.map(value, (function(_this) {
            return function(v) {
              return _this.renderImage(v.id);
            };
          })(this));
          break;
        case "geometry":
          if (value.type === "Point") {
            node = (value.coordinates[1].toFixed(6)) + " " + (value.coordinates[0].toFixed(6));
          } else {
            node = value.type;
          }
          break;
        default:
          node = "" + value;
      }
    }
    return R(Cell, {
      width: this.props.width,
      height: this.props.height,
      onClick: this.props.onClick,
      style: {
        whiteSpace: "nowrap",
        textAlign: (ref1 = this.props.exprType) === 'number' ? "right" : "left",
        opacity: this.props.muted ? 0.4 : void 0
      }
    }, node);
  };

  return ExprCellComponent;

})(React.Component);


},{"fixed-data-table":325,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],1052:[function(require,module,exports){
var AutoSizeComponent, DatagridViewComponent, DirectDatagridDataSource, ExprCompiler, ExprComponent, ExprUtils, FindReplaceModalComponent, H, ModalPopupComponent, R, React, ReactSelect, _, async, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

async = require('async');

ReactSelect = require('react-select');

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

DatagridViewComponent = require('./DatagridViewComponent');

DirectDatagridDataSource = require('./DirectDatagridDataSource');

ModalPopupComponent = require('react-library/lib/ModalPopupComponent');

ExprComponent = require("mwater-expressions-ui").ExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

module.exports = FindReplaceModalComponent = (function(superClass) {
  extend(FindReplaceModalComponent, superClass);

  FindReplaceModalComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    filters: React.PropTypes.arrayOf(React.PropTypes.shape({
      table: React.PropTypes.string.isRequired,
      jsonql: React.PropTypes.object.isRequired
    })),
    canEditValue: React.PropTypes.func,
    updateValue: React.PropTypes.func,
    onUpdate: React.PropTypes.func
  };

  function FindReplaceModalComponent(props) {
    FindReplaceModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      replaceColumn: null,
      withExpr: null,
      conditionExpr: null,
      progress: null
    };
  }

  FindReplaceModalComponent.prototype.show = function() {
    return this.setState({
      open: true,
      progress: null
    });
  };

  FindReplaceModalComponent.prototype.performReplace = function() {
    var completed, exprCompiler, exprUtils, extraFilter, i, len, query, ref, replaceExpr, wheres;
    exprUtils = new ExprUtils(this.props.schema);
    exprCompiler = new ExprCompiler(this.props.schema);
    replaceExpr = _.findWhere(this.props.design.columns, {
      id: this.state.replaceColumn
    }).expr;
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "main",
            column: this.props.schema.getTable(this.props.design.table).primaryKey
          },
          alias: "id"
        }, {
          type: "select",
          expr: exprCompiler.compileExpr({
            expr: this.state.withExpr,
            tableAlias: "main"
          }),
          alias: "withValue"
        }
      ],
      from: {
        type: "table",
        table: this.props.design.table,
        alias: "main"
      }
    };
    wheres = [];
    if (this.props.design.filter) {
      wheres.push(exprCompiler.compileExpr({
        expr: this.props.design.filter,
        tableAlias: "main"
      }));
    }
    if (this.state.conditionExpr) {
      wheres.push(exprCompiler.compileExpr({
        expr: this.state.conditionExpr,
        tableAlias: "main"
      }));
    }
    ref = this.props.filters || [];
    for (i = 0, len = ref.length; i < len; i++) {
      extraFilter = ref[i];
      if (extraFilter.table === this.props.design.table) {
        wheres.push(injectTableAlias(extraFilter.jsonql, "main"));
      }
    }
    query.where = {
      type: "op",
      op: "and",
      exprs: _.compact(wheres)
    };
    this.setState({
      progress: 0
    });
    completed = 0;
    return this.props.dataSource.performQuery(query, (function(_this) {
      return function(error, rows) {
        if (error) {
          _this.setState({
            progress: null
          });
          alert("Error: " + error.message);
          return;
        }
        return async.mapLimit(rows, 10, function(row, cb) {
          if (!_this.state.open) {
            return;
          }
          return _.defer(function() {
            completed += 1;
            _this.setState({
              progress: completed * 50 / rows.length
            });
            return _this.props.canEditValue(_this.props.design.table, row.id, replaceExpr, cb);
          });
        }, function(error, canEdits) {
          if (error) {
            _this.setState({
              progress: null
            });
            alert("Error: " + error.message);
            return;
          }
          if (!_.all(canEdits)) {
            _this.setState({
              progress: null
            });
            alert("You do not have permission to replace all values");
            return;
          }
          if (!confirm("Replace " + canEdits.length + " values? This cannot be undone.")) {
            _this.setState({
              progress: null
            });
            return;
          }
          return async.eachLimit(rows, 10, function(row, cb) {
            if (!_this.state.open) {
              return;
            }
            return _.defer(function() {
              completed += 1;
              _this.setState({
                progress: completed * 50 / rows.length
              });
              return _this.props.updateValue(_this.props.design.table, row.id, replaceExpr, row.withValue, cb);
            });
          }, function(error) {
            var base;
            if (error) {
              _this.setState({
                progress: null
              });
              alert("Error: " + error.message);
              return;
            }
            alert("Success");
            _this.setState({
              progress: null,
              open: false
            });
            return typeof (base = _this.props).onUpdate === "function" ? base.onUpdate() : void 0;
          });
        });
      };
    })(this));
  };

  FindReplaceModalComponent.prototype.renderPreview = function() {
    var design, exprUtils;
    exprUtils = new ExprUtils(this.props.schema);
    design = _.clone(this.props.design);
    design.columns = _.map(design.columns, (function(_this) {
      return function(column) {
        var expr;
        if (column.id !== _this.state.replaceColumn) {
          return column;
        }
        expr = {
          type: "case",
          table: _this.props.design.table,
          cases: [
            {
              when: _this.state.conditionExpr || {
                type: "literal",
                valueType: "boolean",
                value: true
              },
              then: _this.state.withExpr
            }
          ],
          "else": column.expr
        };
        return _.extend({}, column, {
          expr: expr,
          label: column.label || exprUtils.summarizeExpr(column.expr, _this.props.design.locale)
        });
      };
    })(this));
    return R(AutoSizeComponent, {
      injectWidth: true
    }, (function(_this) {
      return function(size) {
        return R(DatagridViewComponent, {
          width: size.width,
          height: 400,
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          datagridDataSource: new DirectDatagridDataSource({
            schema: _this.props.schema,
            dataSource: _this.props.dataSource
          }),
          design: design,
          filters: _this.props.filters
        });
      };
    })(this));
  };

  FindReplaceModalComponent.prototype.renderContents = function() {
    var exprUtils, replaceColumnOptions, replaceColumns, replaceExpr;
    exprUtils = new ExprUtils(this.props.schema);
    replaceColumns = _.filter(this.props.design.columns, function(column) {
      return !column.subtable && exprUtils.getExprAggrStatus(column.expr) === "individual";
    });
    replaceColumnOptions = _.map(replaceColumns, (function(_this) {
      return function(column) {
        return {
          value: column.id,
          label: column.label || exprUtils.summarizeExpr(column.expr, _this.props.design.locale)
        };
      };
    })(this));
    if (this.state.progress != null) {
      return H.div(null, H.h3(null, "Working..."), H.div({
        className: 'progress'
      }, H.div({
        className: 'progress-bar',
        style: {
          width: this.state.progress + "%"
        }
      })));
    }
    return H.div(null, H.div({
      key: "replace",
      className: "form-group"
    }, H.label(null, "Column with data to replace: "), R(ReactSelect, {
      options: replaceColumnOptions,
      clearable: false,
      value: this.state.replaceColumn,
      onChange: (function(_this) {
        return function(value) {
          return _this.setState({
            replaceColumn: value
          });
        };
      })(this),
      placeholder: "Select Column..."
    })), this.state.replaceColumn ? (replaceExpr = _.findWhere(this.props.design.columns, {
      id: this.state.replaceColumn
    }).expr, H.div({
      key: "with",
      className: "form-group"
    }, H.label(null, "Value to replace data with: "), R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      value: this.state.withExpr,
      onChange: (function(_this) {
        return function(value) {
          return _this.setState({
            withExpr: value
          });
        };
      })(this),
      types: [exprUtils.getExprType(replaceExpr)],
      enumValues: exprUtils.getExprEnumValues(replaceExpr),
      idTable: exprUtils.getExprIdTable(replaceExpr),
      preferLiteral: true,
      placeholder: "(Blank)"
    }))) : void 0, H.div({
      key: "condition",
      className: "form-group"
    }, H.label(null, "Only in rows that (optional):"), R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      value: this.state.conditionExpr,
      onChange: (function(_this) {
        return function(value) {
          return _this.setState({
            conditionExpr: value
          });
        };
      })(this),
      types: ["boolean"],
      placeholder: "All Rows"
    })), H.div({
      key: "preview"
    }, H.h4(null, "Preview"), this.renderPreview()));
  };

  FindReplaceModalComponent.prototype.render = function() {
    if (!this.state.open) {
      return null;
    }
    return R(ModalPopupComponent, {
      size: "large",
      header: "Find/Replace",
      footer: [
        H.button({
          key: "cancel",
          type: "button",
          onClick: (function(_this) {
            return function() {
              return _this.setState({
                open: false
              });
            };
          })(this),
          className: "btn btn-default"
        }, "Cancel"), H.button({
          key: "apply",
          type: "button",
          disabled: !this.state.replaceColumn || (this.state.progress != null),
          onClick: (function(_this) {
            return function() {
              return _this.performReplace();
            };
          })(this),
          className: "btn btn-primary"
        }, "Apply")
      ]
    }, this.renderContents());
  };

  return FindReplaceModalComponent;

})(React.Component);


},{"./DatagridViewComponent":1048,"./DirectDatagridDataSource":1049,"async":29,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/AutoSizeComponent":783,"react-library/lib/ModalPopupComponent":786,"react-select":818}],1053:[function(require,module,exports){
var ExprUtils, LabeledExprGenerator, _;

_ = require('lodash');

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = LabeledExprGenerator = (function() {
  function LabeledExprGenerator(schema) {
    this.schema = schema;
  }

  LabeledExprGenerator.prototype.generate = function(table, options) {
    var column, convertColumn, createLabel, i, labeledExprs, len, ref;
    if (options == null) {
      options = {};
    }
    _.defaults(options, {
      locale: null,
      headerFormat: "code",
      enumFormat: "code",
      splitLatLng: false,
      splitEnumset: false,
      useJoinIds: false,
      columnFilter: null,
      multipleJoinCondition: null
    });
    createLabel = function(column, suffix) {
      var label;
      if (options.headerFormat === "code" && column.code) {
        label = column.code;
        if (suffix) {
          label += " (" + (ExprUtils.localizeString(suffix, options.locale)) + ")";
        }
      } else if (options.headerFormat === "both" && column.code) {
        label = column.code;
        if (suffix) {
          label += " (" + (ExprUtils.localizeString(suffix, options.locale)) + ")";
        }
        label += "\n" + ExprUtils.localizeString(column.name, options.locale);
        if (suffix) {
          label += " (" + (ExprUtils.localizeString(suffix, options.locale)) + ")";
        }
      } else {
        label = ExprUtils.localizeString(column.name, options.locale);
        if (suffix) {
          label += " (" + (ExprUtils.localizeString(suffix, options.locale)) + ")";
        }
      }
      return label;
    };
    convertColumn = (function(_this) {
      return function(table, column, joins) {
        var childColumn, childExprs, i, joinColumn, len, ref, ref1, ref2;
        if (options.columnFilter && !options.columnFilter(table, column)) {
          return [];
        }
        if (column.type === "join") {
          if ((ref = column.join.type) === "n-1" || ref === "1-1") {
            if (options.useJoinIds) {
              return [
                {
                  expr: {
                    type: "scalar",
                    table: table,
                    joins: [column.id],
                    expr: {
                      type: "id",
                      table: column.join.toTable
                    }
                  },
                  label: createLabel(column),
                  joins: joins
                }
              ];
            } else {
              joinColumn = _this.schema.getColumn(column.join.toTable, "code");
              joinColumn = joinColumn || _this.schema.getColumn(column.join.toTable, "full_name");
              joinColumn = joinColumn || _this.schema.getColumn(column.join.toTable, "name");
              joinColumn = joinColumn || _this.schema.getColumn(column.join.toTable, "username");
              if (joinColumn) {
                return [
                  {
                    expr: {
                      type: "scalar",
                      table: table,
                      joins: [column.id],
                      expr: {
                        type: "field",
                        table: column.join.toTable,
                        column: joinColumn.id
                      }
                    },
                    label: createLabel(column),
                    joins: joins
                  }
                ];
              } else {
                return [];
              }
            }
          }
          if (((ref1 = column.join.type) === "1-n" || ref1 === "n-n") && options.multipleJoinCondition && options.multipleJoinCondition(table, column)) {
            childExprs = [];
            ref2 = _this.schema.getColumns(column.join.toTable);
            for (i = 0, len = ref2.length; i < len; i++) {
              childColumn = ref2[i];
              childExprs = childExprs.concat(convertColumn(column.join.toTable, childColumn, joins.concat([column.id])));
            }
            return childExprs;
          }
        } else if (column.type === "geometry" && options.splitLatLng) {
          return [
            {
              expr: {
                table: table,
                type: "op",
                op: "latitude",
                exprs: [
                  {
                    type: "field",
                    table: table,
                    column: column.id
                  }
                ]
              },
              label: createLabel(column, "latitude"),
              joins: joins
            }, {
              expr: {
                table: table,
                type: "op",
                op: "longitude",
                exprs: [
                  {
                    type: "field",
                    table: table,
                    column: column.id
                  }
                ]
              },
              label: createLabel(column, "longitude"),
              joins: joins
            }
          ];
        } else if (column.type === "enumset" && options.splitEnumset) {
          return _.map(column.enumValues, function(ev) {
            return {
              expr: {
                table: table,
                type: "op",
                op: "contains",
                exprs: [
                  {
                    type: "field",
                    table: table,
                    column: column.id
                  }, {
                    type: "literal",
                    valueType: "enumset",
                    value: [ev.id]
                  }
                ]
              },
              label: createLabel(column, options.enumFormat === "text" ? ev.name : ev.code || ev.name),
              joins: joins
            };
          });
        } else {
          return [
            {
              expr: {
                type: "field",
                table: table,
                column: column.id
              },
              label: createLabel(column),
              joins: joins
            }
          ];
        }
      };
    })(this);
    labeledExprs = [];
    ref = this.schema.getColumns(table);
    for (i = 0, len = ref.length; i < len; i++) {
      column = ref[i];
      if (column.deprecated) {
        continue;
      }
      labeledExprs = labeledExprs.concat(convertColumn(table, column, []));
    }
    return _.compact(labeledExprs);
  };

  return LabeledExprGenerator;

})();


},{"lodash":"lodash","mwater-expressions":14}],1054:[function(require,module,exports){
var ExprComponent, ExprUtils, H, OrderByDesignerComponent, OrderBysDesignerComponent, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ExprUtils = require("mwater-expressions").ExprUtils;

ExprComponent = require('mwater-expressions-ui').ExprComponent;

module.exports = OrderBysDesignerComponent = (function(superClass) {
  extend(OrderBysDesignerComponent, superClass);

  function OrderBysDesignerComponent() {
    this.handleAdd = bind(this.handleAdd, this);
    this.handleRemove = bind(this.handleRemove, this);
    this.handleChange = bind(this.handleChange, this);
    return OrderBysDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  OrderBysDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    orderBys: React.PropTypes.array.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  OrderBysDesignerComponent.defaultProps = {
    orderBys: []
  };

  OrderBysDesignerComponent.prototype.handleChange = function(index, orderBy) {
    var orderBys;
    orderBys = this.props.orderBys.slice();
    orderBys[index] = orderBy;
    return this.props.onChange(orderBys);
  };

  OrderBysDesignerComponent.prototype.handleRemove = function(index) {
    var orderBys;
    orderBys = this.props.orderBys.slice();
    orderBys.splice(index, 1);
    return this.props.onChange(orderBys);
  };

  OrderBysDesignerComponent.prototype.handleAdd = function() {
    var orderBys;
    orderBys = this.props.orderBys.slice();
    orderBys.push({
      expr: null,
      direction: "asc"
    });
    return this.props.onChange(orderBys);
  };

  OrderBysDesignerComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.orderBys, (function(_this) {
      return function(orderBy, index) {
        return R(OrderByDesignerComponent, {
          key: index,
          schema: _this.props.schema,
          table: _this.props.table,
          dataSource: _this.props.dataSource,
          orderBy: orderBy,
          onChange: _this.handleChange.bind(null, index),
          onRemove: _this.handleRemove.bind(null, index)
        });
      };
    })(this)), H.button({
      key: "add",
      type: "button",
      className: "btn btn-link",
      onClick: this.handleAdd
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Ordering"));
  };

  return OrderBysDesignerComponent;

})(React.Component);

OrderByDesignerComponent = (function(superClass) {
  extend(OrderByDesignerComponent, superClass);

  function OrderByDesignerComponent() {
    this.handleDirectionChange = bind(this.handleDirectionChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    return OrderByDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  OrderByDesignerComponent.propTypes = {
    orderBy: React.PropTypes.array.isRequired,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string
  };

  OrderByDesignerComponent.prototype.handleExprChange = function(expr) {
    return this.props.onChange(_.extend({}, this.props.orderBy, {
      expr: expr
    }));
  };

  OrderByDesignerComponent.prototype.handleDirectionChange = function(ev) {
    return this.props.onChange(_.extend({}, this.props.orderBy, {
      direction: ev.target.checked ? "desc" : "asc"
    }));
  };

  OrderByDesignerComponent.prototype.render = function() {
    return H.div({
      className: "row"
    }, H.div({
      className: "col-xs-7"
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ['text', 'number', 'boolean', 'date', 'datetime'],
      aggrStatuses: ["individual", "literal", "aggregate"],
      value: this.props.orderBy.expr,
      onChange: this.handleExprChange
    })), H.div({
      className: "col-xs-3"
    }, H.div({
      className: "checkbox-inline"
    }, H.label(null, H.input({
      type: "checkbox",
      checked: this.props.orderBy.direction === "desc",
      onChange: this.handleDirectionChange
    }), "Reverse"))), H.div({
      className: "col-xs-1"
    }, H.button({
      className: "btn btn-xs btn-link",
      type: "button",
      onClick: this.props.onRemove
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))));
  };

  return OrderByDesignerComponent;

})(React.Component);


},{"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1055:[function(require,module,exports){
var DatagridDataSource, ServerDatagridDataSource, querystring,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

querystring = require('querystring');

DatagridDataSource = require('./DatagridDataSource');

module.exports = ServerDatagridDataSource = (function(superClass) {
  extend(ServerDatagridDataSource, superClass);

  function ServerDatagridDataSource(options) {
    this.options = options;
  }

  ServerDatagridDataSource.prototype.getRows = function(design, offset, limit, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev,
      offset: offset,
      limit: limit
    };
    url = this.options.apiUrl + ("datagrids/" + this.options.datagridId + "/data?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  return ServerDatagridDataSource;

})(DatagridDataSource);


},{"./DatagridDataSource":1044,"querystring":400}],1056:[function(require,module,exports){
var DecoratedBlockComponent, H, R, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

module.exports = DecoratedBlockComponent = (function(superClass) {
  extend(DecoratedBlockComponent, superClass);

  DecoratedBlockComponent.propTypes = {
    style: React.PropTypes.object,
    onBlockRemove: React.PropTypes.func.isRequired,
    connectMoveHandle: React.PropTypes.func,
    connectDragPreview: React.PropTypes.func,
    connectResizeHandle: React.PropTypes.func,
    aspectRatio: React.PropTypes.number,
    onAspectRatioChange: React.PropTypes.func
  };

  function DecoratedBlockComponent() {
    this.handleMouseUp = bind(this.handleMouseUp, this);
    this.handleMouseMove = bind(this.handleMouseMove, this);
    this.handleAspectMouseDown = bind(this.handleAspectMouseDown, this);
    DecoratedBlockComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      aspectDragY: null,
      initialAspectDragY: null,
      initialClientY: null
    };
  }

  DecoratedBlockComponent.prototype.componentWillUnmount = function() {
    document.removeEventListener("mousemove", this.handleMouseMove);
    return document.removeEventListener("mouseup", this.handleMouseUp);
  };

  DecoratedBlockComponent.prototype.handleAspectMouseDown = function(ev) {
    ev.preventDefault();
    this.setState({
      aspectDragY: ev.currentTarget.parentElement.offsetHeight,
      initialAspectDragY: ev.currentTarget.parentElement.offsetHeight
    });
    document.addEventListener("mousemove", this.handleMouseMove);
    return document.addEventListener("mouseup", this.handleMouseUp);
  };

  DecoratedBlockComponent.prototype.handleMouseMove = function(ev) {
    var aspectDragY;
    if (this.state.initialClientY != null) {
      aspectDragY = this.state.initialAspectDragY + ev.clientY - this.state.initialClientY;
      if (aspectDragY > 20) {
        return this.setState({
          aspectDragY: aspectDragY
        });
      }
    } else {
      return this.setState({
        initialClientY: ev.clientY
      });
    }
  };

  DecoratedBlockComponent.prototype.handleMouseUp = function(ev) {
    document.removeEventListener("mousemove", this.handleMouseMove);
    document.removeEventListener("mouseup", this.handleMouseUp);
    this.props.onAspectRatioChange(this.props.aspectRatio / (this.state.aspectDragY / this.state.initialAspectDragY));
    return this.setState({
      aspectDragY: null,
      initialAspectDragY: null,
      initialClientY: null
    });
  };

  DecoratedBlockComponent.prototype.renderAspectDrag = function() {
    var lineStyle;
    if (this.state.aspectDragY != null) {
      lineStyle = {
        position: "absolute",
        borderTop: "solid 3px #38D",
        top: this.state.aspectDragY,
        left: 0,
        right: 0
      };
      return H.div({
        style: lineStyle,
        key: "aspectDrag"
      });
    } else {
      return null;
    }
  };

  DecoratedBlockComponent.prototype.render = function() {
    var elem, preview;
    elem = H.div({
      className: "mwater-visualization-decorated-block",
      style: this.props.style
    }, this.props.children, this.renderAspectDrag(), !this.props.isDragging && (this.props.connectMoveHandle != null) ? this.props.connectMoveHandle(H.div({
      key: "move",
      className: "mwater-visualization-decorated-block-move"
    }, H.i({
      className: "fa fa-arrows"
    }))) : void 0, !this.props.isDragging && (this.props.onBlockRemove != null) ? H.div({
      key: "remove",
      className: "mwater-visualization-decorated-block-remove",
      onClick: this.props.onBlockRemove
    }, H.i({
      className: "fa fa-times"
    })) : void 0, !this.props.isDragging && (this.props.onAspectRatioChange != null) ? H.div({
      key: "aspect",
      className: "mwater-visualization-decorated-block-aspect",
      onMouseDown: this.handleAspectMouseDown
    }, H.i({
      className: "fa fa-arrows-v"
    })) : void 0, !this.props.isDragging && (this.props.connectResizeHandle != null) ? this.props.connectResizeHandle(H.div({
      key: "resize",
      className: "mwater-visualization-decorated-block-resize"
    }, H.i({
      className: "fa fa-expand fa-rotate-90"
    }))) : void 0, this.props.connectDragPreview ? (preview = H.div({
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        pointerEvents: "none"
      }
    }, " "), this.props.connectDragPreview(preview)) : void 0);
    return elem;
  };

  return DecoratedBlockComponent;

})(React.Component);


},{"react":"react"}],1057:[function(require,module,exports){
var DragSource, DragSourceComponent, H, R, React, _, collectSource, sourceSpec,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

DragSource = require('react-dnd').DragSource;

sourceSpec = {
  beginDrag: function(props, monitor, component) {
    return props.createDragItem();
  }
};

collectSource = function(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview()
  };
};

DragSourceComponent = (function(superClass) {
  extend(DragSourceComponent, superClass);

  function DragSourceComponent() {
    return DragSourceComponent.__super__.constructor.apply(this, arguments);
  }

  DragSourceComponent.propTypes = {
    createDragItem: React.PropTypes.func.isRequired,
    connectDragSource: React.PropTypes.func.isRequired,
    connectDragPreview: React.PropTypes.func.isRequired
  };

  DragSourceComponent.prototype.render = function() {
    return this.props.connectDragPreview(this.props.connectDragSource(this.props.children));
  };

  return DragSourceComponent;

})(React.Component);

module.exports = function(type) {
  return DragSource(type, sourceSpec, collectSource)(DragSourceComponent);
};


},{"lodash":"lodash","react":"react","react-dnd":753}],1058:[function(require,module,exports){
var LayoutManager;

module.exports = LayoutManager = (function() {
  function LayoutManager() {}

  LayoutManager.prototype.renderLayout = function(options) {
    return null;
  };

  LayoutManager.prototype.isEmpty = function(items) {
    return true;
  };

  LayoutManager.prototype.getWidgetTypeAndDesign = function(items, widgetId) {
    return null;
  };

  LayoutManager.prototype.getAllWidgets = function(items) {
    return [];
  };

  LayoutManager.createLayoutManager = function(type) {
    var BlocksLayoutManager, GridLayoutManager;
    type = type || "grid";
    switch (type) {
      case "grid":
        GridLayoutManager = require('./grid/GridLayoutManager');
        return new GridLayoutManager();
      case "blocks":
        BlocksLayoutManager = require('./blocks/BlocksLayoutManager');
        return new BlocksLayoutManager();
      default:
        throw new Error("Unknown layout manager type " + type);
    }
    return {
      addWidget: function(items, widgetType, widgetDesign) {
        throw new Error("Not implemented");
      }
    };
  };

  return LayoutManager;

})();


},{"./blocks/BlocksLayoutManager":1060,"./grid/GridLayoutManager":1066}],1059:[function(require,module,exports){
var AutoSizeComponent, BlocksDisplayComponent, DecoratedBlockComponent, DraggableBlockComponent, H, HTML5Backend, HorizontalBlockComponent, NestableDragDropContext, PaletteItemComponent, R, React, RootBlockComponent, VerticalBlockComponent, _, blockUtils, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

HTML5Backend = require('react-dnd-html5-backend');

NestableDragDropContext = require("react-library/lib/NestableDragDropContext");

DraggableBlockComponent = require("./DraggableBlockComponent");

DecoratedBlockComponent = require('../DecoratedBlockComponent');

PaletteItemComponent = require('./PaletteItemComponent');

blockUtils = require('./blockUtils');

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

HorizontalBlockComponent = require('./HorizontalBlockComponent');

BlocksDisplayComponent = (function(superClass) {
  extend(BlocksDisplayComponent, superClass);

  function BlocksDisplayComponent() {
    this.renderBlock = bind(this.renderBlock, this);
    this.handleBlockUpdate = bind(this.handleBlockUpdate, this);
    this.handleBlockRemove = bind(this.handleBlockRemove, this);
    this.handleBlockDrop = bind(this.handleBlockDrop, this);
    return BlocksDisplayComponent.__super__.constructor.apply(this, arguments);
  }

  BlocksDisplayComponent.propTypes = {
    items: React.PropTypes.object.isRequired,
    onItemsChange: React.PropTypes.func,
    style: React.PropTypes.string,
    renderWidget: React.PropTypes.func.isRequired,
    disableMaps: React.PropTypes.bool
  };

  BlocksDisplayComponent.prototype.handleBlockDrop = function(sourceBlock, targetBlock, side) {
    var items;
    items = blockUtils.removeBlock(this.props.items, sourceBlock);
    targetBlock = blockUtils.removeBlock(targetBlock, sourceBlock);
    items = blockUtils.dropBlock(items, sourceBlock, targetBlock, side);
    items = blockUtils.cleanBlock(items);
    return this.props.onItemsChange(items);
  };

  BlocksDisplayComponent.prototype.handleBlockRemove = function(block) {
    var items;
    items = blockUtils.removeBlock(this.props.items, block);
    items = blockUtils.cleanBlock(items);
    return this.props.onItemsChange(items);
  };

  BlocksDisplayComponent.prototype.handleBlockUpdate = function(block) {
    var items;
    items = blockUtils.updateBlock(this.props.items, block);
    items = blockUtils.cleanBlock(items);
    return this.props.onItemsChange(items);
  };

  BlocksDisplayComponent.prototype.renderBlock = function(block) {
    var elem;
    elem = null;
    switch (block.type) {
      case "root":
        return R(RootBlockComponent, {
          key: block.id,
          block: block,
          renderBlock: this.renderBlock,
          onBlockDrop: this.props.onItemsChange != null ? this.handleBlockDrop : void 0,
          onBlockRemove: this.props.onItemsChange != null ? this.handleBlockRemove : void 0
        });
      case "vertical":
        return R(VerticalBlockComponent, {
          key: block.id,
          block: block,
          renderBlock: this.renderBlock,
          onBlockDrop: this.props.onItemsChange != null ? this.handleBlockDrop : void 0,
          onBlockRemove: this.props.onItemsChange != null ? this.handleBlockRemove : void 0
        });
      case "horizontal":
        return R(HorizontalBlockComponent, {
          key: block.id,
          block: block,
          renderBlock: this.renderBlock,
          onBlockDrop: this.props.onItemsChange != null ? this.handleBlockDrop : void 0,
          onBlockRemove: this.props.onItemsChange != null ? this.handleBlockRemove : void 0,
          onBlockUpdate: this.props.onItemsChange != null ? this.handleBlockUpdate : void 0
        });
      case "spacer":
        elem = R(AutoSizeComponent, {
          injectWidth: true,
          key: block.id
        }, (function(_this) {
          return function(size) {
            return H.div({
              id: block.id,
              style: {
                width: size.width,
                height: block.aspectRatio != null ? size.width / block.aspectRatio : void 0
              }
            });
          };
        })(this));
        if (this.props.onItemsChange) {
          elem = R(DraggableBlockComponent, {
            key: block.id,
            block: block,
            onBlockDrop: this.handleBlockDrop
          }, R(DecoratedBlockComponent, {
            key: block.id,
            aspectRatio: block.aspectRatio,
            onAspectRatioChange: block.aspectRatio != null ? (function(_this) {
              return function(aspectRatio) {
                return _this.props.onItemsChange(blockUtils.updateBlock(_this.props.items, _.extend({}, block, {
                  aspectRatio: aspectRatio
                })));
              };
            })(this) : void 0,
            onBlockRemove: (this.props.onItemsChange ? this.handleBlockDrop.bind(null, block) : void 0)
          }, elem));
        }
        break;
      case "widget":
        elem = R(AutoSizeComponent, {
          injectWidth: true,
          key: block.id
        }, (function(_this) {
          return function(size) {
            return _this.props.renderWidget({
              id: block.id,
              type: block.widgetType,
              design: block.design,
              onDesignChange: _this.props.onItemsChange ? function(design) {
                return _this.props.onItemsChange(blockUtils.updateBlock(_this.props.items, _.extend({}, block, {
                  design: design
                })));
              } : void 0,
              width: size.width,
              standardWidth: size.width,
              height: block.aspectRatio != null ? size.width / block.aspectRatio : void 0
            });
          };
        })(this));
        if (this.props.onItemsChange) {
          elem = R(DraggableBlockComponent, {
            key: block.id,
            block: block,
            onBlockDrop: this.handleBlockDrop
          }, R(DecoratedBlockComponent, {
            key: block.id,
            aspectRatio: block.aspectRatio,
            onAspectRatioChange: block.aspectRatio != null ? (function(_this) {
              return function(aspectRatio) {
                return _this.props.onItemsChange(blockUtils.updateBlock(_this.props.items, _.extend({}, block, {
                  aspectRatio: aspectRatio
                })));
              };
            })(this) : void 0,
            onBlockRemove: (this.props.onItemsChange ? this.handleBlockDrop.bind(null, block) : void 0)
          }, elem));
        }
        break;
      default:
        throw new Error("Unknown block type " + block.type);
    }
    return H.div({
      key: block.id,
      className: "mwater-visualization-block mwater-visualization-block-" + block.type
    }, elem);
  };

  BlocksDisplayComponent.prototype.createBlockItem = function(block) {
    return function() {
      return {
        block: _.extend({}, block, {
          id: uuid()
        })
      };
    };
  };

  BlocksDisplayComponent.prototype.renderPalette = function() {
    return H.div({
      key: "palette",
      style: {
        width: 185,
        height: "100%",
        position: "absolute",
        top: 0,
        left: 0
      }
    }, H.div({
      className: "mwater-visualization-palette",
      style: {
        height: "100%"
      }
    }, R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        widgetType: "Text",
        design: {
          style: "title"
        }
      }),
      title: H.i({
        className: "fa fa-font"
      }),
      subtitle: "Title"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        widgetType: "Text",
        design: {}
      }),
      title: H.i({
        className: "fa fa-align-left"
      }),
      subtitle: "Text"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "Image",
        design: {}
      }),
      title: H.i({
        className: "fa fa-picture-o"
      }),
      subtitle: "Image"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "LayeredChart",
        design: {}
      }),
      title: H.i({
        className: "fa fa-bar-chart"
      }),
      subtitle: "Chart"
    }), !this.props.disableMaps ? R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "Map",
        design: {
          baseLayer: "bing_road",
          layerViews: [],
          filters: {},
          bounds: {
            w: -40,
            n: 25,
            e: 40,
            s: -25
          }
        }
      }),
      title: H.i({
        className: "fa fa-map-o"
      }),
      subtitle: "Map"
    }) : void 0, R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "TableChart",
        design: {}
      }),
      title: H.i({
        className: "fa fa-table"
      }),
      subtitle: "Table"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        widgetType: "PivotChart",
        design: {}
      }),
      title: H.img({
        width: 24,
        height: 24,
        src: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAb0lEQVRIx91VQQrAIAwzo/7/ydllG0MQS21EzMW2ICFtoyBZlLDn/LOgySPAG1xFDDmBtZI6efoMvODozkyL2IlTCOisfS2KrqG0RXus6fkEVBIw08khE62aQY0ogMdEswqwYouwvQ8s+4M576m4Ae/tET/u1taEAAAAAElFTkSuQmCC"
      }),
      subtitle: "Pivot"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "CalendarChart",
        design: {}
      }),
      title: H.i({
        className: "fa fa-calendar"
      }),
      subtitle: "Calendar"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 1.4,
        widgetType: "ImageMosaicChart",
        design: {}
      }),
      title: H.i({
        className: "fa fa-th"
      }),
      subtitle: "Mosaic"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "spacer",
        aspectRatio: 1.4
      }),
      title: H.i({
        className: "fa fa-square-o"
      }),
      subtitle: "Spacer"
    }), R(PaletteItemComponent, {
      createItem: this.createBlockItem({
        type: "widget",
        aspectRatio: 16.0 / 9.0,
        widgetType: "IFrame",
        design: {}
      }),
      title: H.i({
        className: "fa fa-youtube-play"
      }),
      subtitle: "Video"
    })));
  };

  BlocksDisplayComponent.prototype.render = function() {
    if (this.props.onItemsChange) {
      return H.div({
        style: {
          width: "100%",
          height: "100%",
          overflow: "hidden",
          position: "relative"
        }
      }, this.renderPalette(), H.div({
        style: {
          position: "absolute",
          left: 185,
          top: 0,
          bottom: 0,
          right: 0,
          overflow: "auto"
        },
        className: "mwater-visualization-block-parent-outer mwater-visualization-block-parent-outer-" + (this.props.style || "default") + " mwater-visualization-block-editing"
      }, H.div({
        key: "inner",
        className: "mwater-visualization-block-parent-inner mwater-visualization-block-parent-inner-" + (this.props.style || "default")
      }, this.renderBlock(this.props.items))));
    } else {
      return H.div({
        style: {
          width: "100%",
          height: "100%",
          overflowX: "auto"
        },
        className: "mwater-visualization-block-parent-outer mwater-visualization-block-parent-outer-" + (this.props.style || "default") + " mwater-visualization-block-viewing"
      }, H.div({
        key: "inner",
        className: "mwater-visualization-block-parent-inner mwater-visualization-block-parent-inner-" + (this.props.style || "default")
      }, this.renderBlock(this.props.items)));
    }
  };

  return BlocksDisplayComponent;

})(React.Component);

module.exports = NestableDragDropContext(HTML5Backend)(BlocksDisplayComponent);

RootBlockComponent = (function(superClass) {
  extend(RootBlockComponent, superClass);

  function RootBlockComponent() {
    return RootBlockComponent.__super__.constructor.apply(this, arguments);
  }

  RootBlockComponent.propTypes = {
    block: React.PropTypes.object.isRequired,
    renderBlock: React.PropTypes.func.isRequired,
    onBlockDrop: React.PropTypes.func,
    onBlockRemove: React.PropTypes.func
  };

  RootBlockComponent.prototype.render = function() {
    var elem;
    elem = H.div({
      key: "root"
    }, _.map(this.props.block.blocks, (function(_this) {
      return function(block) {
        return _this.props.renderBlock(block);
      };
    })(this)));
    if (this.props.onBlockDrop != null) {
      return R(DraggableBlockComponent, {
        block: this.props.block,
        onBlockDrop: this.props.onBlockDrop,
        style: {
          height: "100%"
        },
        onlyBottom: true
      }, elem);
    } else {
      return elem;
    }
  };

  return RootBlockComponent;

})(React.Component);

VerticalBlockComponent = (function(superClass) {
  extend(VerticalBlockComponent, superClass);

  function VerticalBlockComponent() {
    return VerticalBlockComponent.__super__.constructor.apply(this, arguments);
  }

  VerticalBlockComponent.propTypes = {
    block: React.PropTypes.object.isRequired,
    renderBlock: React.PropTypes.func.isRequired,
    onBlockDrop: React.PropTypes.func,
    onBlockRemove: React.PropTypes.func
  };

  VerticalBlockComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.block.blocks, (function(_this) {
      return function(block) {
        return _this.props.renderBlock(block);
      };
    })(this)));
  };

  return VerticalBlockComponent;

})(React.Component);


},{"../DecoratedBlockComponent":1056,"./DraggableBlockComponent":1061,"./HorizontalBlockComponent":1062,"./PaletteItemComponent":1063,"./blockUtils":1064,"lodash":"lodash","react":"react","react-dnd-html5-backend":640,"react-library/lib/AutoSizeComponent":783,"react-library/lib/NestableDragDropContext":788,"uuid":1007}],1060:[function(require,module,exports){
var BlocksLayoutManager, H, LayoutManager, R, React, _, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

LayoutManager = require('../LayoutManager');

module.exports = BlocksLayoutManager = (function(superClass) {
  extend(BlocksLayoutManager, superClass);

  function BlocksLayoutManager() {
    return BlocksLayoutManager.__super__.constructor.apply(this, arguments);
  }

  BlocksLayoutManager.prototype.renderLayout = function(options) {
    var BlocksDisplayComponent;
    BlocksDisplayComponent = require('./BlocksDisplayComponent');
    return R(BlocksDisplayComponent, {
      items: options.items || {
        id: "root",
        type: "root",
        blocks: []
      },
      onItemsChange: options.onItemsChange,
      style: options.style,
      renderWidget: options.renderWidget,
      disableMaps: options.disableMaps
    });
  };

  BlocksLayoutManager.prototype.isEmpty = function(items) {
    var ref;
    return !items || ((ref = items.blocks) != null ? ref.length : void 0) === 0;
  };

  BlocksLayoutManager.prototype.getWidgetTypeAndDesign = function(items, widgetId) {
    var block, i, len, ref, value;
    if (items.type === "widget" && items.id === widgetId) {
      return {
        type: items.widgetType,
        design: items.design
      };
    }
    if (items.blocks) {
      ref = items.blocks;
      for (i = 0, len = ref.length; i < len; i++) {
        block = ref[i];
        value = this.getWidgetTypeAndDesign(block, widgetId);
        if (value) {
          return value;
        }
      }
    }
    return null;
  };

  BlocksLayoutManager.prototype.getAllWidgets = function(items) {
    if (items.type === "widget") {
      return [
        {
          type: items.widgetType,
          design: items.design
        }
      ];
    }
    if (items.blocks) {
      return _.flatten(_.map(items.blocks, (function(_this) {
        return function(item) {
          return _this.getAllWidgets(item);
        };
      })(this)));
    }
    return [];
  };

  BlocksLayoutManager.prototype.addWidget = function(items, widgetType, widgetDesign) {
    items = items || {
      type: "root",
      id: "root",
      blocks: []
    };
    items.blocks.push({
      type: "widget",
      id: uuid(),
      widgetType: widgetType,
      design: widgetDesign,
      aspectRatio: 1.4
    });
    return items;
  };

  return BlocksLayoutManager;

})(LayoutManager);


},{"../LayoutManager":1058,"./BlocksDisplayComponent":1059,"lodash":"lodash","react":"react","uuid":1007}],1061:[function(require,module,exports){
var DragSource, DraggableBlockComponent, DropTarget, H, R, React, ReactDOM, blockSourceSpec, blockTargetSpec, collectSource, collectTarget, getDropSide,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

R = React.createElement;

DragSource = require('react-dnd').DragSource;

DropTarget = require('react-dnd').DropTarget;

DraggableBlockComponent = (function(superClass) {
  extend(DraggableBlockComponent, superClass);

  DraggableBlockComponent.propTypes = {
    block: React.PropTypes.object.isRequired,
    onBlockDrop: React.PropTypes.func.isRequired,
    style: React.PropTypes.object,
    onlyBottom: React.PropTypes.bool,
    isDragging: React.PropTypes.bool.isRequired,
    isOver: React.PropTypes.bool.isRequired,
    connectDragSource: React.PropTypes.func.isRequired,
    connectDropTarget: React.PropTypes.func.isRequired,
    connectDragPreview: React.PropTypes.func.isRequired
  };

  function DraggableBlockComponent(props) {
    DraggableBlockComponent.__super__.constructor.call(this, props);
    this.state = {
      hoverSide: null
    };
  }

  DraggableBlockComponent.prototype.renderHover = function() {
    var lineStyle;
    lineStyle = {
      position: "absolute"
    };
    if (this.props.isOver) {
      switch (this.state.hoverSide) {
        case "left":
          lineStyle.borderLeft = "solid 3px #38D";
          lineStyle.top = 0;
          lineStyle.bottom = 0;
          lineStyle.left = 0;
          break;
        case "right":
          lineStyle.borderRight = "solid 3px #38D";
          lineStyle.top = 0;
          lineStyle.right = 0;
          lineStyle.bottom = 0;
          break;
        case "top":
          lineStyle.borderTop = "solid 3px #38D";
          lineStyle.top = 0;
          lineStyle.left = 0;
          lineStyle.right = 0;
          break;
        case "bottom":
          lineStyle.borderBottom = "solid 3px #38D";
          lineStyle.bottom = 0;
          lineStyle.left = 0;
          lineStyle.right = 0;
      }
      return H.div({
        style: lineStyle
      });
    } else {
      return null;
    }
  };

  DraggableBlockComponent.prototype.render = function() {
    var style;
    style = {};
    if (this.props.isDragging) {
      style.visibility = "hidden";
    }
    return this.props.connectDropTarget(H.div({
      style: this.props.style
    }, H.div({
      style: {
        position: "relative"
      }
    }, this.renderHover(), React.cloneElement(React.Children.only(this.props.children), {
      connectMoveHandle: this.props.connectDragSource,
      connectDragPreview: this.props.connectDragPreview
    }))));
  };

  return DraggableBlockComponent;

})(React.Component);

getDropSide = function(monitor, component) {
  var blockComponent, clientOffset, fractionX, fractionY, hoverBoundingRect, hoverClientX, hoverClientY, pos;
  blockComponent = component.getDecoratedComponentInstance();
  hoverBoundingRect = ReactDOM.findDOMNode(blockComponent).getBoundingClientRect();
  clientOffset = monitor.getClientOffset();
  hoverClientX = clientOffset.x - hoverBoundingRect.left;
  hoverClientY = clientOffset.y - hoverBoundingRect.top;
  fractionX = hoverClientX / (hoverBoundingRect.right - hoverBoundingRect.left);
  fractionY = hoverClientY / (hoverBoundingRect.bottom - hoverBoundingRect.top);
  if (fractionX > fractionY) {
    if ((1 - fractionX) > fractionY) {
      pos = "top";
    } else {
      pos = "right";
    }
  } else {
    if ((1 - fractionX) > fractionY) {
      pos = "left";
    } else {
      pos = "bottom";
    }
  }
  return pos;
};

blockTargetSpec = {
  hover: function(props, monitor, component) {
    var hoveringId, myId, side;
    hoveringId = monitor.getItem().block.id;
    myId = props.block.id;
    if (hoveringId === myId) {
      return;
    }
    if (props.onlyBottom) {
      side = "bottom";
    } else {
      side = getDropSide(monitor, component);
    }
    return component.getDecoratedComponentInstance().setState({
      hoverSide: side
    });
  },
  canDrop: function(props, monitor) {
    var hoveringId, myId;
    hoveringId = monitor.getItem().block.id;
    myId = props.block.id;
    if (hoveringId === myId) {
      return false;
    }
    return true;
  },
  drop: function(props, monitor, component) {
    var side;
    if (monitor.didDrop()) {
      return;
    }
    side = component.getDecoratedComponentInstance().state.hoverSide;
    props.onBlockDrop(monitor.getItem().block, props.block, side);
  }
};

blockSourceSpec = {
  beginDrag: function(props, monitor, component) {
    return {
      block: props.block
    };
  },
  isDragging: function(props, monitor) {
    return props.block.id === monitor.getItem().block.id;
  }
};

collectTarget = function(connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver({
      shallow: true
    }),
    canDrop: monitor.canDrop()
  };
};

collectSource = function(connect, monitor) {
  return {
    connectDragSource: connect.dragSource(),
    connectDragPreview: connect.dragPreview(),
    isDragging: monitor.isDragging()
  };
};

module.exports = _.flow(DragSource("block", blockSourceSpec, collectSource), DropTarget("block", blockTargetSpec, collectTarget))(DraggableBlockComponent);


},{"react":"react","react-dnd":753,"react-dom":"react-dom"}],1062:[function(require,module,exports){
var DraggableBlockComponent, H, HorizontalBlockComponent, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

DraggableBlockComponent = require("./DraggableBlockComponent");

module.exports = HorizontalBlockComponent = (function(superClass) {
  extend(HorizontalBlockComponent, superClass);

  HorizontalBlockComponent.propTypes = {
    block: React.PropTypes.object.isRequired,
    renderBlock: React.PropTypes.func.isRequired,
    onBlockDrop: React.PropTypes.func,
    onBlockRemove: React.PropTypes.func,
    onBlockUpdate: React.PropTypes.func
  };

  function HorizontalBlockComponent() {
    this.handleMouseUp = bind(this.handleMouseUp, this);
    this.handleMouseMove = bind(this.handleMouseMove, this);
    this.handleMouseDown = bind(this.handleMouseDown, this);
    HorizontalBlockComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      dragIndex: null,
      dragInitialX: null,
      dragXOffset: null,
      leftSize: null,
      rightSize: null
    };
  }

  HorizontalBlockComponent.prototype.componentWillUnmount = function() {
    document.removeEventListener("mousemove", this.handleMouseMove);
    return document.removeEventListener("mouseup", this.handleMouseUp);
  };

  HorizontalBlockComponent.prototype.handleMouseDown = function(index, ev) {
    ev.preventDefault();
    this.setState({
      dragIndex: index,
      leftSize: this.refs["block" + index].offsetWidth,
      rightSize: this.refs["block" + (index + 1)].offsetWidth
    });
    document.addEventListener("mousemove", this.handleMouseMove);
    return document.addEventListener("mouseup", this.handleMouseUp);
  };

  HorizontalBlockComponent.prototype.handleMouseMove = function(ev) {
    var dragXOffset;
    if (!this.state.dragInitialX) {
      this.setState({
        dragInitialX: ev.clientX
      });
      return;
    }
    dragXOffset = ev.clientX - this.state.dragInitialX;
    if (dragXOffset < -this.state.leftSize + 100) {
      dragXOffset = -this.state.leftSize + 100;
    }
    if (dragXOffset > this.state.rightSize - 100) {
      dragXOffset = this.state.rightSize - 100;
    }
    return this.setState({
      dragXOffset: dragXOffset
    });
  };

  HorizontalBlockComponent.prototype.handleMouseUp = function(ev) {
    var block, leftWeight, newLeftSize, newRightSize, rightWeight, weights;
    document.removeEventListener("mousemove", this.handleMouseMove);
    document.removeEventListener("mouseup", this.handleMouseUp);
    weights = this.props.block.weights || [];
    newLeftSize = this.state.leftSize + this.state.dragXOffset;
    newRightSize = this.state.rightSize - this.state.dragXOffset;
    leftWeight = weights[this.state.dragIndex] || 1;
    rightWeight = weights[this.state.dragIndex + 1] || 1;
    weights[this.state.dragIndex] = (leftWeight + rightWeight) * newLeftSize / (newLeftSize + newRightSize);
    weights[this.state.dragIndex + 1] = (leftWeight + rightWeight) * newRightSize / (newLeftSize + newRightSize);
    block = _.extend({}, this.props.block, {
      weights: weights
    });
    this.props.onBlockUpdate(block);
    return this.setState({
      dragIndex: null,
      dragInitialX: null,
      dragXOffset: null
    });
  };

  HorizontalBlockComponent.prototype.render = function() {
    var elem, i, index, j, percentages, ref, ref1, totalWeight, weight;
    totalWeight = 0;
    for (index = i = 0, ref = this.props.block.blocks.length; 0 <= ref ? i < ref : i > ref; index = 0 <= ref ? ++i : --i) {
      weight = (this.props.block.weights || [])[index] || 1;
      totalWeight += (this.props.block.weights || [])[index] || 1;
    }
    percentages = [];
    for (index = j = 0, ref1 = this.props.block.blocks.length; 0 <= ref1 ? j < ref1 : j > ref1; index = 0 <= ref1 ? ++j : --j) {
      weight = (this.props.block.weights || [])[index] || 1;
      percentages[index] = (weight * 100) / totalWeight;
    }
    if (this.props.onBlockUpdate != null) {
      elem = H.table({
        style: {
          width: "100%",
          tableLayout: "fixed",
          position: "relative",
          paddingTop: 5
        },
        className: "mwater-visualization-horizontal-block"
      }, H.tbody(null, H.tr(null, _.map(this.props.block.blocks, (function(_this) {
        return function(block, index) {
          return [
            index > 0 && (_this.props.onBlockUpdate != null) ? H.td({
              style: {
                width: 5,
                position: "relative",
                left: _this.state.dragXOffset
              },
              key: "splitter" + index,
              className: "mwater-visualization-horizontal-block-splitter " + (index - 1 === _this.state.dragIndex ? "active" : ""),
              onMouseDown: _this.handleMouseDown.bind(null, index - 1)
            }) : void 0, H.td({
              style: {
                width: percentages[index] + "%",
                verticalAlign: "top"
              },
              key: block.id,
              ref: "block" + index
            }, _this.props.renderBlock(block))
          ];
        };
      })(this)))));
      elem = R(DraggableBlockComponent, {
        block: this.props.block,
        onBlockDrop: this.props.onBlockDrop
      }, elem);
      return elem;
    } else {
      return H.div({
        className: "mwater-visualization-horizontal-block"
      }, _.map(this.props.block.blocks, (function(_this) {
        return function(block, index) {
          return [
            H.div({
              style: {
                width: percentages[index] + "%",
                verticalAlign: "top",
                display: "inline-block"
              },
              key: block.id,
              ref: "block" + index,
              className: "mwater-visualization-horizontal-block-item"
            }, _this.props.renderBlock(block))
          ];
        };
      })(this)));
    }
  };

  return HorizontalBlockComponent;

})(React.Component);


},{"./DraggableBlockComponent":1061,"lodash":"lodash","react":"react"}],1063:[function(require,module,exports){
var DragSourceComponent, H, PaletteItemComponent, R, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

DragSourceComponent = require('../DragSourceComponent')("block");

module.exports = PaletteItemComponent = (function(superClass) {
  extend(PaletteItemComponent, superClass);

  function PaletteItemComponent() {
    return PaletteItemComponent.__super__.constructor.apply(this, arguments);
  }

  PaletteItemComponent.propTypes = {
    createItem: React.PropTypes.func.isRequired,
    title: React.PropTypes.any,
    subtitle: React.PropTypes.any
  };

  PaletteItemComponent.prototype.render = function() {
    return R(DragSourceComponent, {
      createDragItem: this.props.createItem
    }, H.div({
      className: "mwater-visualization-palette-item"
    }, H.div({
      className: "title",
      key: "title"
    }, this.props.title), H.div({
      className: "subtitle",
      key: "subtitle"
    }, this.props.subtitle)));
  };

  return PaletteItemComponent;

})(React.Component);


},{"../DragSourceComponent":1057,"react":"react"}],1064:[function(require,module,exports){
var _, uuid;

_ = require('lodash');

uuid = require('uuid');

exports.dropBlock = function(rootBlock, sourceBlock, targetBlock, side) {
  var blocks, index, ref;
  if (targetBlock.type === "root" && rootBlock.id === targetBlock.id) {
    blocks = rootBlock.blocks.slice();
    blocks.push(sourceBlock);
    return _.extend({}, rootBlock, {
      blocks: blocks
    });
  }
  if ((ref = rootBlock.type) === 'vertical' || ref === 'root') {
    blocks = rootBlock.blocks;
    index = _.findIndex(blocks, {
      id: targetBlock.id
    });
    if (index >= 0) {
      blocks = blocks.slice();
      switch (side) {
        case "top":
          blocks.splice(index, 0, sourceBlock);
          break;
        case "bottom":
          blocks.splice(index + 1, 0, sourceBlock);
          break;
        case "left":
          blocks.splice(index, 1, {
            id: uuid(),
            type: "horizontal",
            blocks: [sourceBlock, targetBlock]
          });
          break;
        case "right":
          blocks.splice(index, 1, {
            id: uuid(),
            type: "horizontal",
            blocks: [targetBlock, sourceBlock]
          });
      }
      return _.extend({}, rootBlock, {
        blocks: blocks
      });
    } else {
      blocks = _.map(blocks, function(block) {
        return exports.dropBlock(block, sourceBlock, targetBlock, side);
      });
      return _.extend({}, rootBlock, {
        blocks: blocks
      });
    }
  }
  if (rootBlock.type === "horizontal") {
    blocks = rootBlock.blocks;
    index = _.findIndex(blocks, {
      id: targetBlock.id
    });
    if (index >= 0) {
      blocks = blocks.slice();
      switch (side) {
        case "left":
          blocks.splice(index, 0, sourceBlock);
          break;
        case "right":
          blocks.splice(index + 1, 0, sourceBlock);
          break;
        case "top":
          blocks.splice(index, 1, {
            id: uuid(),
            type: "vertical",
            blocks: [sourceBlock, targetBlock]
          });
          break;
        case "bottom":
          blocks.splice(index, 1, {
            id: uuid(),
            type: "vertical",
            blocks: [targetBlock, sourceBlock]
          });
      }
      return _.extend({}, rootBlock, {
        blocks: blocks
      });
    } else {
      blocks = _.map(blocks, function(block) {
        return exports.dropBlock(block, sourceBlock, targetBlock, side);
      });
      return _.extend({}, rootBlock, {
        blocks: blocks
      });
    }
  }
  return rootBlock;
};

exports.updateBlock = function(rootBlock, block) {
  var blocks, ref;
  if ((ref = rootBlock.type) === 'vertical' || ref === 'horizontal' || ref === 'root') {
    blocks = rootBlock.blocks;
    blocks = _.map(blocks, function(b) {
      if (b.id === block.id) {
        return block;
      } else {
        return b;
      }
    });
    blocks = _.map(blocks, function(b) {
      return exports.updateBlock(b, block);
    });
    return _.extend({}, rootBlock, {
      blocks: blocks
    });
  }
  return rootBlock;
};

exports.removeBlock = function(rootBlock, block) {
  var blocks, ref;
  if ((ref = rootBlock.type) === 'vertical' || ref === 'horizontal' || ref === 'root') {
    blocks = rootBlock.blocks;
    blocks = _.filter(blocks, function(b) {
      return b.id !== block.id;
    });
    blocks = _.compact(_.map(blocks, function(b) {
      return exports.removeBlock(b, block);
    }));
    if (blocks.length === 0 && rootBlock.type !== "root") {
      return null;
    }
    return _.extend({}, rootBlock, {
      blocks: blocks
    });
  }
  return rootBlock;
};

exports.cleanBlock = function(rootBlock) {
  var blocks, ref;
  if ((ref = rootBlock.type) === 'vertical' || ref === 'horizontal' || ref === 'root') {
    blocks = rootBlock.blocks;
    if (blocks.length === 1 && rootBlock.type !== "root") {
      return blocks[0];
    }
    blocks = _.flatten(_.map(blocks, function(b) {
      var ref1;
      if (b.type === "horizontal" && rootBlock.type === "horizontal") {
        return b.blocks;
      }
      if (b.type === "vertical" && ((ref1 = rootBlock.type) === "root" || ref1 === "vertical")) {
        return b.blocks;
      }
      return b;
    }));
    blocks = _.map(blocks, function(b) {
      return exports.cleanBlock(b);
    });
    return _.extend({}, rootBlock, {
      blocks: blocks
    });
  }
  return rootBlock;
};


},{"lodash":"lodash","uuid":1007}],1065:[function(require,module,exports){
var GridLayoutComponent, H, LegoLayoutEngine, R, React, WidgetContainerComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

WidgetContainerComponent = require('./WidgetContainerComponent');

LegoLayoutEngine = require('./LegoLayoutEngine');

module.exports = GridLayoutComponent = (function(superClass) {
  extend(GridLayoutComponent, superClass);

  function GridLayoutComponent() {
    return GridLayoutComponent.__super__.constructor.apply(this, arguments);
  }

  GridLayoutComponent.propTypes = {
    width: React.PropTypes.number.isRequired,
    standardWidth: React.PropTypes.number.isRequired,
    items: React.PropTypes.any,
    onItemsChange: React.PropTypes.func,
    renderWidget: React.PropTypes.func.isRequired
  };

  GridLayoutComponent.prototype.renderPageBreaks = function(layoutEngine, layouts) {
    var elems, height, i, j, number, pageHeight, ref;
    height = layoutEngine.calculateHeight(layouts);
    pageHeight = this.props.width / 7.5 * 10;
    number = Math.floor(height / pageHeight);
    elems = [];
    if (number > 0) {
      for (i = j = 1, ref = number; 1 <= ref ? j <= ref : j >= ref; i = 1 <= ref ? ++j : --j) {
        elems.push(H.div({
          className: "mwater-visualization-page-break",
          key: "page" + i,
          style: {
            position: "absolute",
            top: i * pageHeight
          }
        }));
      }
    }
    return elems;
  };

  GridLayoutComponent.prototype.render = function() {
    var layoutEngine, layouts, style;
    layoutEngine = new LegoLayoutEngine(this.props.width, 24);
    layouts = _.mapValues(this.props.items, "layout");
    style = {
      height: "100%",
      position: "relative"
    };
    return H.div({
      style: style
    }, R(WidgetContainerComponent, {
      layoutEngine: layoutEngine,
      items: this.props.items,
      onItemsChange: this.props.onItemsChange,
      renderWidget: this.props.renderWidget,
      width: this.props.width,
      standardWidth: this.props.standardWidth
    }), this.renderPageBreaks(layoutEngine, layouts));
  };

  return GridLayoutComponent;

})(React.Component);


},{"./LegoLayoutEngine":1067,"./WidgetContainerComponent":1069,"lodash":"lodash","react":"react"}],1066:[function(require,module,exports){
var GridLayoutManager, H, LayoutManager, LegoLayoutEngine, R, React, _, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

LayoutManager = require('../LayoutManager');

LegoLayoutEngine = require('./LegoLayoutEngine');

module.exports = GridLayoutManager = (function(superClass) {
  extend(GridLayoutManager, superClass);

  function GridLayoutManager() {
    return GridLayoutManager.__super__.constructor.apply(this, arguments);
  }

  GridLayoutManager.prototype.renderPalette = function(width) {
    var PaletteItemComponent, createWidgetItem;
    PaletteItemComponent = require('./PaletteItemComponent');
    createWidgetItem = function(type, design) {
      return function() {
        return {
          id: uuid(),
          widget: {
            type: type,
            design: design
          },
          bounds: {
            x: 0,
            y: 0,
            width: width / 3,
            height: width / 4
          }
        };
      };
    };
    return H.div({
      className: "mwater-visualization-palette",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        bottom: 0,
        width: 185
      }
    }, R(PaletteItemComponent, {
      createItem: createWidgetItem("Text", {
        style: "title"
      }),
      title: H.i({
        className: "fa fa-font"
      }),
      subtitle: "Title"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("Text", {}),
      title: H.i({
        className: "fa fa-align-left"
      }),
      subtitle: "Text"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("LayeredChart", {}),
      title: H.i({
        className: "fa fa-bar-chart"
      }),
      subtitle: "Chart"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("Image", {}),
      title: H.i({
        className: "fa fa-image"
      }),
      subtitle: "Image"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("Map", {
        baseLayer: "bing_road",
        layerViews: [],
        filters: {},
        bounds: {
          w: -40,
          n: 25,
          e: 40,
          s: -25
        }
      }),
      title: H.i({
        className: "fa fa-map-o"
      }),
      subtitle: "Map"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("TableChart", {}),
      title: H.i({
        className: "fa fa-table"
      }),
      subtitle: "Table"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("CalendarChart", {}),
      title: H.i({
        className: "fa fa-calendar"
      }),
      subtitle: "Calendar"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("ImageMosaicChart", {}),
      title: H.i({
        className: "fa fa-th"
      }),
      subtitle: "Mosaic"
    }), R(PaletteItemComponent, {
      createItem: createWidgetItem("IFrame", {}),
      title: H.i({
        className: "fa fa-youtube-play"
      }),
      subtitle: "Video"
    }));
  };

  GridLayoutManager.prototype.renderLayout = function(options) {
    var GridLayoutComponent;
    GridLayoutComponent = require('./GridLayoutComponent');
    if (options.onItemsChange != null) {
      return H.div({
        style: {
          position: "relative",
          height: "100%",
          overflow: "hidden"
        }
      }, this.renderPalette(options.width), H.div({
        style: {
          position: "absolute",
          left: 185,
          top: 0,
          right: 0,
          bottom: 0,
          overflow: "scroll"
        }
      }, H.div({
        style: {
          position: "absolute",
          left: 20,
          top: 20,
          right: 20,
          bottom: 20
        }
      }, R(GridLayoutComponent, {
        width: options.width - 40 - 185,
        standardWidth: options.standardWidth - 40 - 185,
        items: options.items,
        onItemsChange: options.onItemsChange,
        renderWidget: options.renderWidget
      }))));
    } else {
      return H.div({
        style: {
          position: "relative",
          height: "100%",
          width: options.width,
          padding: 20
        }
      }, R(GridLayoutComponent, {
        width: options.width - 40,
        standardWidth: options.standardWidth - 40,
        items: options.items,
        onItemsChange: options.onItemsChange,
        renderWidget: options.renderWidget
      }));
    }
  };

  GridLayoutManager.prototype.isEmpty = function(items) {
    return _.isEmpty(items);
  };

  GridLayoutManager.prototype.getWidgetTypeAndDesign = function(items, widgetId) {
    var ref;
    return (ref = items[widgetId]) != null ? ref.widget : void 0;
  };

  GridLayoutManager.prototype.getAllWidgets = function(items) {
    var id, item, widgets;
    widgets = [];
    for (id in items) {
      item = items[id];
      widgets.push({
        type: item.widget.type,
        design: item.widget.design
      });
    }
    return widgets;
  };

  GridLayoutManager.prototype.addWidget = function(items, widgetType, widgetDesign) {
    var id, item, layout;
    layout = this.findOpenLayout(items, 12, 12);
    item = {
      layout: layout,
      widget: {
        type: widgetType,
        design: widgetDesign
      }
    };
    id = uuid();
    items = _.clone(items);
    items[id] = item;
    return items;
  };

  GridLayoutManager.prototype.findOpenLayout = function(items, width, height) {
    var layoutEngine, layouts;
    layoutEngine = new LegoLayoutEngine(100, 24);
    layouts = _.pluck(_.values(items), "layout");
    return layoutEngine.appendLayout(layouts, width, height);
  };

  return GridLayoutManager;

})(LayoutManager);


},{"../LayoutManager":1058,"./GridLayoutComponent":1065,"./LegoLayoutEngine":1067,"./PaletteItemComponent":1068,"lodash":"lodash","react":"react","uuid":1007}],1067:[function(require,module,exports){
var LegoLayoutEngine, _;

_ = require('lodash');

module.exports = LegoLayoutEngine = (function() {
  function LegoLayoutEngine(width, blocksAcross) {
    this.width = width;
    this.blocksAcross = blocksAcross;
    this.scale = this.width / this.blocksAcross;
  }

  LegoLayoutEngine.prototype.calculateHeight = function(layouts) {
    var bottom;
    bottom = _.max(_.map(layouts, (function(_this) {
      return function(l) {
        return _this.getLayoutBounds(l).y + _this.getLayoutBounds(l).height;
      };
    })(this)));
    return bottom + this.scale;
  };

  LegoLayoutEngine.prototype.getLayoutBounds = function(layout) {
    return {
      x: this.scale * layout.x,
      y: this.scale * layout.y,
      width: this.scale * layout.w,
      height: this.scale * layout.h
    };
  };

  LegoLayoutEngine.prototype.rectToLayout = function(rect) {
    var h, w, x, y;
    x = Math.round(rect.x / this.scale);
    y = Math.round(rect.y / this.scale);
    w = Math.round(rect.width / this.scale);
    h = Math.round(rect.height / this.scale);
    if (x < 0) {
      x = 0;
    }
    if (y < 0) {
      y = 0;
    }
    if (x >= this.blocksAcross) {
      x = this.blocksAcross - 1;
    }
    if (w < 1) {
      w = 1;
    }
    if (x + w > this.blocksAcross) {
      w = this.blocksAcross - x;
    }
    if (h < 1) {
      h = 1;
    }
    return {
      x: x,
      y: y,
      w: w,
      h: h
    };
  };

  LegoLayoutEngine.prototype.performLayout = function(layouts, priority) {
    var i, id, layout, len, placedLayouts, results, toProcess;
    placedLayouts = [];
    results = {};
    if (priority) {
      placedLayouts.push(layouts[priority]);
      results[priority] = layouts[priority];
    }
    toProcess = _.sortBy(_.keys(layouts), (function(_this) {
      return function(id) {
        var l;
        l = layouts[id];
        return l.x + l.y * _this.blocksAcross;
      };
    })(this));
    for (i = 0, len = toProcess.length; i < len; i++) {
      id = toProcess[i];
      if (id === priority) {
        continue;
      }
      layout = layouts[id];
      while (_.any(placedLayouts, (function(_this) {
          return function(pl) {
            return _this.overlaps(pl, layout);
          };
        })(this))) {
        layout = this.shiftLayout(layout);
      }
      placedLayouts.push(layout);
      results[id] = layout;
    }
    return results;
  };

  LegoLayoutEngine.prototype.appendLayout = function(layouts, w, h) {
    var layout;
    layout = {
      x: 0,
      y: 0,
      w: w,
      h: h
    };
    while (_.any(_.values(layouts), (function(_this) {
        return function(pl) {
          return _this.overlaps(pl, layout);
        };
      })(this))) {
      layout = this.shiftLayout(layout);
    }
    return layout;
  };

  LegoLayoutEngine.prototype.overlaps = function(a, b) {
    if (a.x + a.w <= b.x) {
      return false;
    }
    if (a.y + a.h <= b.y) {
      return false;
    }
    if (a.x >= b.x + b.w) {
      return false;
    }
    if (a.y >= b.y + b.h) {
      return false;
    }
    return true;
  };

  LegoLayoutEngine.prototype.shiftLayout = function(layout) {
    if (layout.x + layout.w < this.blocksAcross) {
      return {
        x: layout.x + 1,
        y: layout.y,
        w: layout.w,
        h: layout.h
      };
    }
    return {
      x: 0,
      y: layout.y + 1,
      w: layout.w,
      h: layout.h
    };
  };

  return LegoLayoutEngine;

})();


},{"lodash":"lodash"}],1068:[function(require,module,exports){
var DragSourceComponent, H, PaletteItemComponent, R, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

DragSourceComponent = require('../DragSourceComponent')("block-move");

module.exports = PaletteItemComponent = (function(superClass) {
  extend(PaletteItemComponent, superClass);

  function PaletteItemComponent() {
    return PaletteItemComponent.__super__.constructor.apply(this, arguments);
  }

  PaletteItemComponent.propTypes = {
    createItem: React.PropTypes.func.isRequired,
    title: React.PropTypes.any,
    subtitle: React.PropTypes.any
  };

  PaletteItemComponent.prototype.render = function() {
    return R(DragSourceComponent, {
      createDragItem: this.props.createItem
    }, H.div({
      className: "mwater-visualization-palette-item"
    }, H.div({
      className: "title",
      key: "title"
    }, this.props.title), H.div({
      className: "subtitle",
      key: "subtitle"
    }, this.props.subtitle)));
  };

  return PaletteItemComponent;

})(React.Component);


},{"../DragSourceComponent":1057,"react":"react"}],1069:[function(require,module,exports){
var Container, DecoratedBlockComponent, DragDropContext, DragSource, DropTarget, H, HTML5Backend, LayoutComponent, MoveLayoutComponent, MoveResizeLayoutComponent, React, ReactDOM, _, moveCollect, moveSpec, resizeCollect, resizeSpec, targetCollect, targetSpec,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

React = require('react');

ReactDOM = require('react-dom');

_ = require('lodash');

H = React.DOM;

DragSource = require('react-dnd').DragSource;

DropTarget = require('react-dnd').DropTarget;

DragDropContext = require('react-dnd').DragDropContext;

HTML5Backend = require('react-dnd-html5-backend');

DecoratedBlockComponent = require('../DecoratedBlockComponent');

LayoutComponent = (function(superClass) {
  extend(LayoutComponent, superClass);

  function LayoutComponent() {
    return LayoutComponent.__super__.constructor.apply(this, arguments);
  }

  LayoutComponent.propTypes = {
    dragInfo: React.PropTypes.object.isRequired,
    canDrag: React.PropTypes.bool.isRequired
  };

  LayoutComponent.prototype.render = function() {
    if (this.props.canDrag) {
      return React.cloneElement(React.Children.only(this.props.children), {
        connectMoveHandle: this.props.connectMoveHandle,
        connectResizeHandle: this.props.connectResizeHandle
      });
    } else {
      return this.props.children;
    }
  };

  return LayoutComponent;

})(React.Component);

moveSpec = {
  beginDrag: function(props, monitor, component) {
    return props.dragInfo;
  },
  canDrag: function(props, monitor) {
    return props.canDrag;
  }
};

moveCollect = function(connect, monitor) {
  return {
    connectMoveHandle: connect.dragSource()
  };
};

MoveLayoutComponent = DragSource("block-move", moveSpec, moveCollect)(LayoutComponent);

resizeSpec = {
  beginDrag: function(props, monitor, component) {
    return props.dragInfo;
  },
  canDrag: function(props, monitor) {
    return props.canDrag;
  }
};

resizeCollect = function(connect, monitor) {
  return {
    connectResizeHandle: connect.dragSource()
  };
};

MoveResizeLayoutComponent = DragSource("block-resize", resizeSpec, resizeCollect)(MoveLayoutComponent);

Container = (function(superClass) {
  extend(Container, superClass);

  Container.propTypes = {
    layoutEngine: React.PropTypes.object.isRequired,
    items: React.PropTypes.object.isRequired,
    onItemsChange: React.PropTypes.func,
    renderWidget: React.PropTypes.func.isRequired,
    width: React.PropTypes.number.isRequired,
    standardWidth: React.PropTypes.number.isRequired,
    connectDropTarget: React.PropTypes.func.isRequired
  };

  function Container(props) {
    this.renderItem = bind(this.renderItem, this);
    this.handleWidgetDesignChange = bind(this.handleWidgetDesignChange, this);
    this.handleRemove = bind(this.handleRemove, this);
    Container.__super__.constructor.apply(this, arguments);
    this.state = {
      moveHover: null,
      resizeHover: null
    };
  }

  Container.prototype.setMoveHover = function(hoverInfo) {
    return this.setState({
      moveHover: hoverInfo
    });
  };

  Container.prototype.setResizeHover = function(hoverInfo) {
    return this.setState({
      resizeHover: hoverInfo
    });
  };

  Container.prototype.dropLayout = function(id, droppedRect, widget) {
    var droppedLayout, item, items, layouts;
    this.setState({
      moveHover: null,
      resizeHover: null
    });
    droppedLayout = this.props.layoutEngine.rectToLayout(droppedRect);
    items = _.clone(this.props.items);
    items[id] = {
      layout: droppedLayout,
      widget: widget
    };
    layouts = {};
    for (id in items) {
      item = items[id];
      layouts[id] = item.layout;
    }
    layouts = this.props.layoutEngine.performLayout(layouts, id);
    items = _.mapValues(items, (function(_this) {
      return function(item, id) {
        return _.extend({}, item, {
          layout: layouts[id]
        });
      };
    })(this));
    return this.props.onItemsChange(items);
  };

  Container.prototype.dropMoveLayout = function(dropInfo) {
    var droppedRect;
    droppedRect = {
      x: dropInfo.x,
      y: dropInfo.y,
      width: dropInfo.dragInfo.bounds.width,
      height: dropInfo.dragInfo.bounds.height
    };
    return this.dropLayout(dropInfo.dragInfo.id, droppedRect, dropInfo.dragInfo.widget);
  };

  Container.prototype.dropResizeLayout = function(dropInfo) {
    var droppedRect;
    droppedRect = {
      x: dropInfo.dragInfo.bounds.x,
      y: dropInfo.dragInfo.bounds.y,
      width: dropInfo.width,
      height: dropInfo.height
    };
    return this.dropLayout(dropInfo.dragInfo.id, droppedRect, dropInfo.dragInfo.widget);
  };

  Container.prototype.componentWillReceiveProps = function(nextProps) {
    if (!nextProps.isOver && (this.state.moveHover || this.state.resizeHover)) {
      return _.defer((function(_this) {
        return function() {
          return _this.setState({
            moveHover: null,
            resizeHover: null
          });
        };
      })(this));
    }
  };

  Container.prototype.handleRemove = function(id) {
    var items;
    items = _.omit(this.props.items, id);
    return this.props.onItemsChange(items);
  };

  Container.prototype.handleWidgetDesignChange = function(id, widgetDesign) {
    var item, items, widget;
    widget = this.props.items[id].widget;
    widget = _.extend({}, widget, {
      design: widgetDesign
    });
    item = this.props.items[id];
    item = _.extend({}, item, {
      widget: widget
    });
    items = _.clone(this.props.items);
    items[id] = item;
    return this.props.onItemsChange(items);
  };

  Container.prototype.renderPlaceholder = function(bounds) {
    return H.div({
      key: "placeholder",
      style: {
        position: "absolute",
        left: bounds.x,
        top: bounds.y,
        width: bounds.width,
        height: bounds.height,
        border: "dashed 3px #AAA",
        borderRadius: 5,
        padding: 5,
        position: "absolute"
      }
    });
  };

  Container.prototype.renderItem = function(id, item, layout, visible) {
    var bounds, dragInfo, elem, style;
    if (visible == null) {
      visible = true;
    }
    bounds = this.props.layoutEngine.getLayoutBounds(layout);
    style = {
      position: "absolute",
      left: bounds.x,
      top: bounds.y
    };
    if (!visible) {
      style.display = "none";
    }
    dragInfo = {
      id: id,
      bounds: bounds,
      widget: item.widget
    };
    elem = this.props.renderWidget({
      id: id,
      type: item.widget.type,
      design: item.widget.design,
      onDesignChange: this.props.onItemsChange != null ? this.handleWidgetDesignChange.bind(null, id) : void 0,
      width: bounds.width - 10,
      height: bounds.height - 10,
      standardWidth: ((bounds.width - 10) / this.props.width) * this.props.standardWidth
    });
    if (this.props.onItemsChange) {
      elem = React.createElement(DecoratedBlockComponent, {
        onBlockRemove: this.handleRemove.bind(null, id)
      }, elem);
    } else {
      elem = H.div({
        className: "mwater-visualization-block-view"
      }, elem);
    }
    return H.div({
      style: style,
      key: id
    }, React.createElement(MoveResizeLayoutComponent, {
      dragInfo: dragInfo,
      canDrag: this.props.onItemsChange != null
    }, elem));
  };

  Container.prototype.calculateLayouts = function(props, state) {
    var hoveredDragInfo, hoveredLayout, hoveredRect, id, item, layouts, ref;
    hoveredDragInfo = null;
    hoveredLayout = null;
    if (state.moveHover) {
      hoveredDragInfo = state.moveHover.dragInfo;
      hoveredRect = {
        x: state.moveHover.x,
        y: state.moveHover.y,
        width: state.moveHover.dragInfo.bounds.width,
        height: state.moveHover.dragInfo.bounds.height
      };
      hoveredLayout = props.layoutEngine.rectToLayout(hoveredRect);
    }
    if (state.resizeHover) {
      hoveredDragInfo = state.resizeHover.dragInfo;
      hoveredRect = {
        x: state.resizeHover.dragInfo.bounds.x,
        y: state.resizeHover.dragInfo.bounds.y,
        width: state.resizeHover.width,
        height: state.resizeHover.height
      };
      hoveredLayout = props.layoutEngine.rectToLayout(hoveredRect);
    }
    layouts = {};
    ref = props.items;
    for (id in ref) {
      item = ref[id];
      layouts[id] = item.layout;
    }
    if (hoveredDragInfo) {
      layouts[hoveredDragInfo.id] = hoveredLayout;
    }
    layouts = props.layoutEngine.performLayout(layouts, hoveredDragInfo ? hoveredDragInfo.id : void 0);
    return layouts;
  };

  Container.prototype.renderItems = function(items) {
    var hover, i, id, ids, item, layouts, len, ref, ref1, renderElems;
    layouts = this.calculateLayouts(this.props, this.state);
    renderElems = [];
    hover = this.state.moveHover || this.state.resizeHover;
    ids = [];
    for (id in items) {
      ids.push(id);
    }
    if (hover && (ref = hover.dragInfo.id, indexOf.call(ids, ref) < 0)) {
      ids.push(hover.dragInfo.id);
    }
    ref1 = _.sortBy(ids);
    for (i = 0, len = ref1.length; i < len; i++) {
      id = ref1[i];
      item = items[id];
      if (!hover || id !== hover.dragInfo.id) {
        renderElems.push(this.renderItem(id, item, layouts[id]));
      } else {
        if (item) {
          renderElems.push(this.renderItem(id, item, layouts[id], false));
        }
        renderElems.push(this.renderPlaceholder(this.props.layoutEngine.getLayoutBounds(layouts[id])));
      }
    }
    return renderElems;
  };

  Container.prototype.shouldComponentUpdate = function(nextProps, nextState) {
    var layouts, nextLayouts;
    if (this.props.width !== nextProps.width) {
      return true;
    }
    if (this.props.layoutEngine !== nextProps.layoutEngine) {
      return true;
    }
    layouts = this.calculateLayouts(this.props, this.state);
    nextLayouts = this.calculateLayouts(nextProps, nextState);
    if (!_.isEqual(layouts, nextLayouts)) {
      return true;
    }
    if (!_.isEqual(this.props.elems, nextProps.elems)) {
      return true;
    }
    return false;
  };

  Container.prototype.render = function() {
    var style;
    style = {
      width: this.props.width,
      height: "100%",
      position: "relative"
    };
    return this.props.connectDropTarget(H.div({
      style: style
    }, this.renderItems(this.props.items)));
  };

  return Container;

})(React.Component);

targetSpec = {
  drop: function(props, monitor, component) {
    var rect;
    if (monitor.getItemType() === "block-move") {
      rect = ReactDOM.findDOMNode(component).getBoundingClientRect();
      component.dropMoveLayout({
        dragInfo: monitor.getItem(),
        x: monitor.getClientOffset().x - (monitor.getInitialClientOffset().x - monitor.getInitialSourceClientOffset().x) - rect.left,
        y: monitor.getClientOffset().y - (monitor.getInitialClientOffset().y - monitor.getInitialSourceClientOffset().y) - rect.top
      });
    }
    if (monitor.getItemType() === "block-resize") {
      component.dropResizeLayout({
        dragInfo: monitor.getItem(),
        width: monitor.getItem().bounds.width + monitor.getDifferenceFromInitialOffset().x,
        height: monitor.getItem().bounds.height + monitor.getDifferenceFromInitialOffset().y
      });
    }
  },
  hover: function(props, monitor, component) {
    var rect;
    if (monitor.getItemType() === "block-move") {
      rect = ReactDOM.findDOMNode(component).getBoundingClientRect();
      component.setMoveHover({
        dragInfo: monitor.getItem(),
        x: monitor.getClientOffset().x - (monitor.getInitialClientOffset().x - monitor.getInitialSourceClientOffset().x) - rect.left,
        y: monitor.getClientOffset().y - (monitor.getInitialClientOffset().y - monitor.getInitialSourceClientOffset().y) - rect.top
      });
    }
    if (monitor.getItemType() === "block-resize") {
      component.setResizeHover({
        dragInfo: monitor.getItem(),
        width: monitor.getItem().bounds.width + monitor.getDifferenceFromInitialOffset().x,
        height: monitor.getItem().bounds.height + monitor.getDifferenceFromInitialOffset().y
      });
    }
  }
};

targetCollect = function(connect, monitor) {
  return {
    connectDropTarget: connect.dropTarget(),
    isOver: monitor.isOver(),
    clientOffset: monitor.getClientOffset()
  };
};

module.exports = DropTarget(["block-move", "block-resize"], targetSpec, targetCollect)(Container);


},{"../DecoratedBlockComponent":1056,"lodash":"lodash","react":"react","react-dnd":753,"react-dnd-html5-backend":640,"react-dom":"react-dom"}],1070:[function(require,module,exports){
var MWaterDataSource, Schema, _, querystring;

_ = require('lodash');

Schema = require('mwater-expressions').Schema;

MWaterDataSource = require('mwater-expressions/lib/MWaterDataSource');

querystring = require('querystring');

module.exports = function(options, callback) {
  var query, url;
  query = {};
  if (options.client) {
    query.client = options.client;
  }
  if (options.share) {
    query.share = options.share;
  }
  if (options.asUser) {
    query.asUser = options.asUser;
  }
  if (options.extraTables && options.extraTables.length > 0) {
    query.extraTables = options.extraTables.join(',');
  }
  url = options.apiUrl + "jsonql/schema?" + querystring.stringify(query);
  return $.getJSON(url, (function(_this) {
    return function(schemaJson) {
      var dataSource, schema;
      schema = new Schema(schemaJson);
      dataSource = new MWaterDataSource(options.apiUrl, options.client, {
        serverCaching: false,
        localCaching: true
      });
      return callback(null, {
        schema: schema,
        dataSource: dataSource
      });
    };
  })(this)).fail((function(_this) {
    return function(xhr) {
      console.error(xhr.responseText);
      return callback(new Error(xhr.responseText));
    };
  })(this));
};


},{"lodash":"lodash","mwater-expressions":14,"mwater-expressions/lib/MWaterDataSource":8,"querystring":400}],1071:[function(require,module,exports){
var AddLayerComponent, H, LayerFactory, R, React, _, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

LayerFactory = require('./LayerFactory');

module.exports = AddLayerComponent = (function(superClass) {
  extend(AddLayerComponent, superClass);

  function AddLayerComponent() {
    this.handleAddLayerView = bind(this.handleAddLayerView, this);
    this.handleAddLayer = bind(this.handleAddLayer, this);
    return AddLayerComponent.__super__.constructor.apply(this, arguments);
  }

  AddLayerComponent.propTypes = {
    layerNumber: React.PropTypes.number.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  AddLayerComponent.contextTypes = {
    addLayerElementFactory: React.PropTypes.func
  };

  AddLayerComponent.prototype.handleAddLayer = function(newLayer) {
    var layer, layerView;
    layerView = {
      id: uuid(),
      name: newLayer.name,
      desc: "",
      type: newLayer.type,
      visible: true,
      opacity: 1
    };
    layer = LayerFactory.createLayer(layerView.type);
    layerView.design = layer.cleanDesign(newLayer.design, this.props.schema);
    return this.handleAddLayerView(layerView);
  };

  AddLayerComponent.prototype.handleAddLayerView = function(layerView) {
    var design, layerViews;
    layerViews = this.props.design.layerViews.slice();
    layerViews.push(layerView);
    design = _.extend({}, this.props.design, {
      layerViews: layerViews
    });
    return this.props.onDesignChange(design);
  };

  AddLayerComponent.prototype.render = function() {
    var newLayers;
    if (this.context.addLayerElementFactory) {
      return this.context.addLayerElementFactory(this.props);
    }
    newLayers = [
      {
        label: "Marker Layer",
        name: "Untitled Layer",
        type: "Markers",
        design: {}
      }, {
        label: "Radius (circles) Layer",
        name: "Untitled Layer",
        type: "Buffer",
        design: {}
      }, {
        label: "Choropleth Layer",
        name: "Untitled Layer",
        type: "AdminChoropleth",
        design: {}
      }, {
        label: "Cluster Layer",
        name: "Untitled Layer",
        type: "Cluster",
        design: {}
      }, {
        label: "Custom Tile Url (advanced)",
        name: "Untitled Layer",
        type: "TileUrl",
        design: {}
      }
    ];
    return H.div({
      style: {
        margin: 5
      },
      key: "addLayer",
      className: "btn-group"
    }, H.button({
      type: "button",
      "data-toggle": "dropdown",
      className: "btn btn-primary dropdown-toggle"
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Layer ", H.span({
      className: "caret"
    })), H.ul({
      className: "dropdown-menu"
    }, _.map(newLayers, (function(_this) {
      return function(layer, i) {
        return H.li({
          key: "" + i
        }, H.a({
          onClick: _this.handleAddLayer.bind(null, layer)
        }, layer.label || layer.name));
      };
    })(this))));
  };

  return AddLayerComponent;

})(React.Component);


},{"./LayerFactory":1085,"lodash":"lodash","react":"react","uuid":1007}],1072:[function(require,module,exports){
var AdminChoroplethLayer, AxisBuilder, ExprCleaner, ExprCompiler, ExprUtils, H, Layer, LayerLegendComponent, LegendGroup, React, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprUtils = require('mwater-expressions').ExprUtils;

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');

LayerLegendComponent = require('./LayerLegendComponent');


/*
Layer that is composed of administrative regions colored
Design is:
  scope: _id of overall admin region. Null for whole world.
  scopeLevel: admin level of scope. Default is 0 (entire country) if scope is set
  detailLevel: admin level to disaggregate to

  table: table to get data from
  adminRegionExpr: expression to get admin region id for calculations

  axes: axes (see below)

  filter: optional logical expression to filter by
  color: default color (e.g. #FF8800). Color axis overrides
  fillOpacity: opacity of fill of regions (0-1)

  displayNames: true to display name labels on admin regions

  popup: contains items: which is BlocksLayoutManager items. Will be displayed when the region is clicked
  minZoom: minimum zoom level
  maxZoom: maximum zoom level

axes:
  color: color axis
  label: overrides the nameLabels to display text on each region
 */

module.exports = AdminChoroplethLayer = (function(superClass) {
  extend(AdminChoroplethLayer, superClass);

  function AdminChoroplethLayer() {
    return AdminChoroplethLayer.__super__.constructor.apply(this, arguments);
  }

  AdminChoroplethLayer.prototype.getJsonQLCss = function(design, schema, filters) {
    var layerDef;
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createJsonQL(design, schema, filters)
        }
      ],
      css: this.createCss(design, schema, filters),
      interactivity: {
        layer: "layer0",
        fields: ["id", "name"]
      }
    };
    return layerDef;
  };

  AdminChoroplethLayer.prototype.createJsonQL = function(design, schema, filters) {
    var axisBuilder, colorExpr, compiledAdminRegionExpr, exprCompiler, filter, i, innerQuery, labelExpr, len, query, ref, ref1, relevantFilters, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);

    /*
    E.g:
    select name, shape_simplified, regions.color from
    admin_regions as admin_regions2
    left outer join
    (
      select admin_regions.level2 as id,
      count(innerquery.*) as color
      from
      admin_regions inner join
      entities.water_point as innerquery
      on innerquery.admin_region = admin_regions._id
      where admin_regions.level0 = 'eb3e12a2-de1e-49a9-8afd-966eb55d47eb'
      group by 1
    ) as regions on regions.id = admin_regions2._id
    where admin_regions2.level = 2 and admin_regions2.level0 = 'eb3e12a2-de1e-49a9-8afd-966eb55d47eb'
     */
    if ((design.scopeLevel != null) && ((ref = design.scopeLevel) !== 0 && ref !== 1 && ref !== 2 && ref !== 3 && ref !== 4 && ref !== 5)) {
      throw new Error("Invalid scope level");
    }
    if ((ref1 = design.detailLevel) !== 0 && ref1 !== 1 && ref1 !== 2 && ref1 !== 3 && ref1 !== 4 && ref1 !== 5) {
      throw new Error("Invalid detail level");
    }
    compiledAdminRegionExpr = exprCompiler.compileExpr({
      expr: design.adminRegionExpr,
      tableAlias: "innerquery"
    });
    innerQuery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions",
            column: "level" + design.detailLevel
          },
          alias: "id"
        }
      ],
      from: {
        type: "join",
        kind: "inner",
        left: {
          type: "table",
          table: "admin_regions",
          alias: "admin_regions"
        },
        right: exprCompiler.compileTable(design.table, "innerquery"),
        on: {
          type: "op",
          op: "=",
          exprs: [
            compiledAdminRegionExpr, {
              type: "field",
              tableAlias: "admin_regions",
              column: "_id"
            }
          ]
        }
      },
      groupBy: [1]
    };
    if (design.axes.color) {
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "innerquery"
      });
      innerQuery.selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
    }
    if (design.axes.label) {
      labelExpr = axisBuilder.compileAxis({
        axis: design.axes.label,
        tableAlias: "innerquery"
      });
      innerQuery.selects.push({
        type: "select",
        expr: labelExpr,
        alias: "label"
      });
    }
    whereClauses = [];
    if (design.scope) {
      whereClauses.push({
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "admin_regions",
            column: "level" + (design.scopeLevel || 0)
          }, design.scope
        ]
      });
    }
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "innerquery"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (i = 0, len = relevantFilters.length; i < len; i++) {
      filter = relevantFilters[i];
      whereClauses.push(injectTableAlias(filter.jsonql, "innerquery"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 0) {
      innerQuery.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions2",
            column: "_id"
          },
          alias: "id"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions2",
            column: "shape_simplified"
          },
          alias: "the_geom_webmercator"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions2",
            column: "name"
          },
          alias: "name"
        }
      ],
      from: {
        type: "join",
        kind: "left",
        left: {
          type: "table",
          table: "admin_regions",
          alias: "admin_regions2"
        },
        right: {
          type: "subquery",
          query: innerQuery,
          alias: "regions"
        },
        on: {
          type: "op",
          op: "=",
          exprs: [
            {
              type: "field",
              tableAlias: "regions",
              column: "id"
            }, {
              type: "field",
              tableAlias: "admin_regions2",
              column: "_id"
            }
          ]
        }
      },
      where: {
        type: "op",
        op: "and",
        exprs: [
          {
            type: "op",
            op: "=",
            exprs: [
              {
                type: "field",
                tableAlias: "admin_regions2",
                column: "level"
              }, design.detailLevel
            ]
          }
        ]
      }
    };
    if (design.scope) {
      query.where.exprs.push({
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "admin_regions2",
            column: "level" + (design.scopeLevel || 0)
          }, design.scope
        ]
      });
    }
    if (design.axes.color) {
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "regions",
          column: "color"
        },
        alias: "color"
      });
    }
    if (design.axes.label) {
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "regions",
          column: "label"
        },
        alias: "label"
      });
    }
    return query;
  };

  AdminChoroplethLayer.prototype.createCss = function(design, schema, filters) {
    var css, i, item, len, ref;
    css = '#layer0 {\n  line-color: #000;\n  line-width: 1.5;\n  line-opacity: 0.6;\n  polygon-opacity: ' + design.fillOpacity + ';\npolygon-fill: ' + (design.color || "transparent") + ';\nopacity: ' + design.fillOpacity + '; \n}\n';
    if (design.displayNames) {
      css += '#layer0::labels {\n  text-name: [name];\n  text-face-name: \'Arial Regular\';\n  text-halo-radius: 2;\n  text-halo-opacity: 0.5;\n  text-halo-fill: #FFF;\n}';
    }
    if (design.axes.color && design.axes.color.colorMap) {
      ref = design.axes.color.colorMap;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (_.includes(design.axes.color.excludedValues, item.value)) {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { line-color: transparent; polygon-opacity: 0; polygon-fill: transparent; }\n";
          if (design.displayNames) {
            css += "#layer0::labels [color=" + (JSON.stringify(item.value)) + "] { text-opacity: 0; text-halo-opacity: 0; }\n";
          }
        } else {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { polygon-fill: " + item.color + "; }\n";
        }
      }
    }
    return css;
  };

  AdminChoroplethLayer.prototype.onGridClick = function(ev, clickOptions) {
    var BlocksLayoutManager, WidgetFactory, compiledFilterExpr, exprCompiler, filter, filterExpr, results, table;
    if (ev.data && ev.data.id) {
      results = {};
      table = clickOptions.design.table;
      exprCompiler = new ExprCompiler(clickOptions.schema);
      filterExpr = {
        type: "op",
        op: "within",
        table: table,
        exprs: [
          clickOptions.design.adminRegionExpr, {
            type: "literal",
            idTable: "admin_regions",
            valueType: "id",
            value: ev.data.id
          }
        ]
      };
      compiledFilterExpr = exprCompiler.compileExpr({
        expr: filterExpr,
        tableAlias: "{alias}"
      });
      filter = {
        table: table,
        jsonql: compiledFilterExpr
      };
      if (ev.event.originalEvent.shiftKey) {
        if (clickOptions.scopeData === ev.data.id) {
          results.scope = null;
        } else {
          results.scope = {
            name: ev.data.name,
            filter: filter,
            data: ev.data.id
          };
        }
      } else if (clickOptions.design.popup) {
        BlocksLayoutManager = require('../layouts/blocks/BlocksLayoutManager');
        WidgetFactory = require('../widgets/WidgetFactory');
        results.popup = new BlocksLayoutManager().renderLayout({
          items: clickOptions.design.popup.items,
          style: "popup",
          renderWidget: (function(_this) {
            return function(options) {
              var filters, widget, widgetDataSource;
              widget = WidgetFactory.createWidget(options.type);
              filters = clickOptions.filters.concat([filter]);
              widgetDataSource = clickOptions.layerDataSource.getPopupWidgetDataSource(clickOptions.design, options.id);
              return widget.createViewElement({
                schema: clickOptions.schema,
                dataSource: clickOptions.dataSource,
                widgetDataSource: widgetDataSource,
                design: options.design,
                scope: null,
                filters: filters,
                onScopeChange: null,
                onDesignChange: null,
                width: options.width,
                height: options.height,
                standardWidth: options.standardWidth
              });
            };
          })(this)
        });
      }
      return results;
    } else {
      return null;
    }
  };

  AdminChoroplethLayer.prototype.getBounds = function(design, schema, dataSource, filters, callback) {
    if (!design.scope) {
      return callback(null);
    }
    filters = [
      {
        table: "admin_regions",
        jsonql: {
          type: "op",
          op: "=",
          exprs: [
            {
              type: "field",
              tableAlias: "{alias}",
              column: "_id"
            }, design.scope
          ]
        }
      }
    ];
    return this.getBoundsFromExpr(schema, dataSource, "admin_regions", {
      type: "field",
      table: "admin_regions",
      column: "shape"
    }, null, filters, callback);
  };

  AdminChoroplethLayer.prototype.getMinZoom = function(design) {
    return design.minZoom;
  };

  AdminChoroplethLayer.prototype.getMaxZoom = function(design) {
    return design.maxZoom;
  };

  AdminChoroplethLayer.prototype.getLegend = function(design, schema, name, dataSource) {
    var axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    return React.createElement(LayerLegendComponent, {
      schema: schema,
      name: name,
      axis: axisBuilder.cleanAxis({
        axis: design.axes.color,
        table: design.table,
        types: ['enum', 'text', 'boolean', 'date'],
        aggrNeed: "required"
      }),
      defaultColor: design.color
    });
  };

  AdminChoroplethLayer.prototype.getFilterableTables = function(design, schema) {
    if (design.table) {
      return [design.table];
    } else {
      return [];
    }
  };

  AdminChoroplethLayer.prototype.isEditable = function() {
    return true;
  };

  AdminChoroplethLayer.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.color = design.color || "#FFFFFF";
    design.adminRegionExpr = exprCleaner.cleanExpr(design.adminRegionExpr, {
      table: design.table,
      types: ["id"],
      idTable: "admin_regions"
    });
    design.axes = design.axes || {};
    design.fillOpacity = design.fillOpacity != null ? design.fillOpacity : 0.75;
    design.displayNames = design.displayNames != null ? design.displayNames : true;
    design.axes.color = axisBuilder.cleanAxis({
      axis: design.axes.color,
      table: design.table,
      types: ['enum', 'text', 'boolean', 'date'],
      aggrNeed: "required"
    });
    design.axes.label = axisBuilder.cleanAxis({
      axis: design.axes.label,
      table: design.table,
      types: ['text', 'number'],
      aggrNeed: "required"
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table
    });
    if (design.detailLevel == null) {
      design.detailLevel = 0;
    }
    return design;
  };

  AdminChoroplethLayer.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error, exprUtils;
    exprUtils = new ExprUtils(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing table";
    }
    if (design.detailLevel == null) {
      return "Missing detail level";
    }
    if (!design.adminRegionExpr || exprUtils.getExprType(design.adminRegionExpr) !== "id") {
      return "Missing admin region expr";
    }
    if (design.axes.color) {
      error = axisBuilder.validateAxis({
        axis: design.axes.color
      });
      if (error) {
        return error;
      }
    }
    if (design.axes.label) {
      error = axisBuilder.validateAxis({
        axis: design.axes.label
      });
      if (error) {
        return error;
      }
    }
    return null;
  };

  AdminChoroplethLayer.prototype.createDesignerElement = function(options) {
    var AdminChoroplethLayerDesigner;
    AdminChoroplethLayerDesigner = require('./AdminChoroplethLayerDesigner');
    return React.createElement(AdminChoroplethLayerDesigner, {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          return options.onDesignChange(_this.cleanDesign(design, options.schema));
        };
      })(this)
    });
  };

  AdminChoroplethLayer.prototype.createKMLExportJsonQL = function(design, schema, filters) {
    var adminGeometry, axisBuilder, colorExpr, compiledAdminRegionExpr, exprCompiler, filter, i, innerQuery, labelExpr, len, query, ref, ref1, relevantFilters, valueExpr, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);
    if ((design.scopeLevel != null) && ((ref = design.scopeLevel) !== 0 && ref !== 1 && ref !== 2 && ref !== 3 && ref !== 4 && ref !== 5)) {
      throw new Error("Invalid scope level");
    }
    if ((ref1 = design.detailLevel) !== 0 && ref1 !== 1 && ref1 !== 2 && ref1 !== 3 && ref1 !== 4 && ref1 !== 5) {
      throw new Error("Invalid detail level");
    }
    compiledAdminRegionExpr = exprCompiler.compileExpr({
      expr: design.adminRegionExpr,
      tableAlias: "innerquery"
    });
    innerQuery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions",
            column: "level" + design.detailLevel
          },
          alias: "id"
        }
      ],
      from: {
        type: "join",
        kind: "inner",
        left: {
          type: "table",
          table: "admin_regions",
          alias: "admin_regions"
        },
        right: exprCompiler.compileTable(design.table, "innerquery"),
        on: {
          type: "op",
          op: "=",
          exprs: [
            compiledAdminRegionExpr, {
              type: "field",
              tableAlias: "admin_regions",
              column: "_id"
            }
          ]
        }
      },
      groupBy: [1]
    };
    if (design.axes.color) {
      valueExpr = exprCompiler.compileExpr({
        expr: design.axes.color.expr,
        tableAlias: "innerquery"
      });
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "innerquery"
      });
      innerQuery.selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
      innerQuery.selects.push({
        type: "select",
        expr: valueExpr,
        alias: "value"
      });
    }
    if (design.axes.label) {
      labelExpr = axisBuilder.compileAxis({
        axis: design.axes.label,
        tableAlias: "innerquery"
      });
      innerQuery.selects.push({
        type: "select",
        expr: labelExpr,
        alias: "label"
      });
    }
    whereClauses = [];
    if (design.scope) {
      whereClauses.push({
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "admin_regions",
            column: "level" + (design.scopeLevel || 0)
          }, design.scope
        ]
      });
    }
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "innerquery"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (i = 0, len = relevantFilters.length; i < len; i++) {
      filter = relevantFilters[i];
      whereClauses.push(injectTableAlias(filter.jsonql, "innerquery"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 0) {
      innerQuery.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    }
    adminGeometry = {
      type: "op",
      op: "ST_AsGeoJson",
      exprs: [
        {
          type: "op",
          op: "ST_Transform",
          exprs: [
            {
              type: "field",
              tableAlias: "admin_regions2",
              column: "shape_simplified"
            }, 4326
          ]
        }
      ]
    };
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions2",
            column: "_id"
          },
          alias: "id"
        }, {
          type: "select",
          expr: adminGeometry,
          alias: "the_geom_webmercator"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "admin_regions2",
            column: "name"
          },
          alias: "name"
        }
      ],
      from: {
        type: "join",
        kind: "left",
        left: {
          type: "table",
          table: "admin_regions",
          alias: "admin_regions2"
        },
        right: {
          type: "subquery",
          query: innerQuery,
          alias: "regions"
        },
        on: {
          type: "op",
          op: "=",
          exprs: [
            {
              type: "field",
              tableAlias: "regions",
              column: "id"
            }, {
              type: "field",
              tableAlias: "admin_regions2",
              column: "_id"
            }
          ]
        }
      },
      where: {
        type: "op",
        op: "and",
        exprs: [
          {
            type: "op",
            op: "=",
            exprs: [
              {
                type: "field",
                tableAlias: "admin_regions2",
                column: "level"
              }, design.detailLevel
            ]
          }
        ]
      }
    };
    if (design.scope) {
      query.where.exprs.push({
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "admin_regions2",
            column: "level" + (design.scopeLevel || 0)
          }, design.scope
        ]
      });
    }
    if (design.axes.color) {
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "regions",
          column: "color"
        },
        alias: "color"
      });
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "regions",
          column: "value"
        },
        alias: "value"
      });
    }
    if (design.axes.label) {
      query.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "regions",
          column: "label"
        },
        alias: "label"
      });
    }
    return query;
  };

  AdminChoroplethLayer.prototype.getKMLExportJsonQL = function(design, schema, filters) {
    var layerDef, style;
    style = {
      color: design.color,
      opacity: design.fillOpacity
    };
    if (design.axes.color && design.axes.color.colorMap) {
      style.colorMap = design.axes.color.colorMap;
    }
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createKMLExportJsonQL(design, schema, filters),
          style: style
        }
      ]
    };
    return layerDef;
  };

  AdminChoroplethLayer.prototype.acceptKmlVisitorForRow = function(visitor, row) {
    var data, list, outer;
    if (!row.the_geom_webmercator) {
      return;
    }
    if (row.the_geom_webmercator.length === 0) {
      return;
    }
    data = JSON.parse(row.the_geom_webmercator);
    if (data.coordinates.length === 0) {
      return;
    }
    if (data.type === "MultiPolygon") {
      outer = data.coordinates[0][0];
    } else {
      outer = data.coordinates[0];
    }
    list = _.map(outer, function(coordinates) {
      return coordinates.join(",");
    });
    return visitor.addPolygon(list.join(" "), row.color, data.type === "MultiPolygon", row.name, visitor.buildDescription(row));
  };

  return AdminChoroplethLayer;

})(Layer);


},{"../axes/AxisBuilder":1029,"../layouts/blocks/BlocksLayoutManager":1060,"../widgets/WidgetFactory":1128,"./AdminChoroplethLayerDesigner":1073,"./Layer":1084,"./LayerLegendComponent":1086,"./LegendGroup":1089,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1073:[function(require,module,exports){
var AdminChoroplethLayerDesigner, AdminScopeAndDetailLevelComponent, AxisComponent, ColorComponent, EditPopupComponent, ExprComponent, ExprUtils, FilterExprComponent, H, R, Rcslider, React, TableSelectComponent, ZoomLevelsComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisComponent = require('./../axes/AxisComponent');

TableSelectComponent = require('../TableSelectComponent');

ColorComponent = require('../ColorComponent');

Rcslider = require('rc-slider');

EditPopupComponent = require('./EditPopupComponent');

ZoomLevelsComponent = require('./ZoomLevelsComponent');

AdminScopeAndDetailLevelComponent = require('./AdminScopeAndDetailLevelComponent');

module.exports = AdminChoroplethLayerDesigner = (function(superClass) {
  extend(AdminChoroplethLayerDesigner, superClass);

  function AdminChoroplethLayerDesigner() {
    this.handleColorAxisChange = bind(this.handleColorAxisChange, this);
    this.handleColorChange = bind(this.handleColorChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleScopeAndDetailLevelChange = bind(this.handleScopeAndDetailLevelChange, this);
    return AdminChoroplethLayerDesigner.__super__.constructor.apply(this, arguments);
  }

  AdminChoroplethLayerDesigner.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  AdminChoroplethLayerDesigner.prototype.update = function(updates) {
    return this.props.onDesignChange(_.extend({}, this.props.design, updates));
  };

  AdminChoroplethLayerDesigner.prototype.updateAxes = function(changes) {
    var axes;
    axes = _.extend({}, this.props.design.axes, changes);
    return this.update({
      axes: axes
    });
  };

  AdminChoroplethLayerDesigner.prototype.handleScopeAndDetailLevelChange = function(scope, scopeLevel, detailLevel) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      scope: scope,
      scopeLevel: scopeLevel,
      detailLevel: detailLevel
    }));
  };

  AdminChoroplethLayerDesigner.prototype.handleTableChange = function(table) {
    var adminRegionExpr, column, i, len, ref;
    adminRegionExpr = null;
    if (table) {
      ref = this.props.schema.getColumns(table);
      for (i = 0, len = ref.length; i < len; i++) {
        column = ref[i];
        if (column.type === "join" && column.join.type === "n-1" && column.join.toTable === "admin_regions") {
          adminRegionExpr = {
            type: "field",
            table: table,
            column: column.id
          };
          break;
        }
      }
    }
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      table: table,
      adminRegionExpr: adminRegionExpr
    }));
  };

  AdminChoroplethLayerDesigner.prototype.handleColorChange = function(color) {
    return this.update({
      color: color
    });
  };

  AdminChoroplethLayerDesigner.prototype.handleColorAxisChange = function(axis) {
    return this.updateAxes({
      color: axis
    });
  };

  AdminChoroplethLayerDesigner.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), H.div({
      style: {
        marginLeft: 10
      }
    }, R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    })));
  };

  AdminChoroplethLayerDesigner.prototype.renderAdminRegionExpr = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-map-marker"
    }), " Location"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: (function(_this) {
        return function(expr) {
          return _this.update({
            adminRegionExpr: expr
          });
        };
      })(this),
      table: this.props.design.table,
      types: ["id"],
      idTable: "admin_regions",
      value: this.props.design.adminRegionExpr
    })));
  };

  AdminChoroplethLayerDesigner.prototype.renderScopeAndDetailLevel = function() {
    return R(AdminScopeAndDetailLevelComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      scope: this.props.design.scope,
      scopeLevel: this.props.design.scopeLevel || 0,
      detailLevel: this.props.design.detailLevel,
      onScopeAndDetailLevelChange: this.handleScopeAndDetailLevelChange
    });
  };

  AdminChoroplethLayerDesigner.prototype.renderDisplayNames = function() {
    return H.div({
      className: "form-group"
    }, H.div({
      className: "checkbox"
    }, H.label(null, H.input({
      type: "checkbox",
      checked: this.props.design.displayNames,
      onChange: (function(_this) {
        return function(ev) {
          return _this.update({
            displayNames: ev.target.checked
          });
        };
      })(this)
    }), "Display Region Names")));
  };

  AdminChoroplethLayerDesigner.prototype.renderColor = function() {
    if (!this.props.design.table) {
      return;
    }
    return H.div(null, !this.props.design.axes.color ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Fill Color"), H.div(null, R(ColorComponent, {
      color: this.props.design.color,
      onChange: this.handleColorChange
    }))) : void 0, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Color By Data"), R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["text", "enum", "boolean", 'date'],
      aggrNeed: "required",
      value: this.props.design.axes.color,
      defaultColor: this.props.design.color,
      showColorMap: true,
      onChange: this.handleColorAxisChange,
      allowExcludedValues: true
    })));
  };

  AdminChoroplethLayerDesigner.prototype.renderFillOpacity = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Fill Opacity (%)"), ": ", R(Rcslider, {
      min: 0,
      max: 100,
      step: 1,
      tipTransitionName: "rc-slider-tooltip-zoom-down",
      value: this.props.design.fillOpacity * 100,
      onChange: (function(_this) {
        return function(val) {
          return _this.update({
            fillOpacity: val / 100
          });
        };
      })(this)
    }));
  };

  AdminChoroplethLayerDesigner.prototype.renderFilter = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: (function(_this) {
        return function(filter) {
          return _this.update({
            filter: filter
          });
        };
      })(this),
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  AdminChoroplethLayerDesigner.prototype.renderPopup = function() {
    if (!this.props.design.table) {
      return null;
    }
    return R(EditPopupComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table
    });
  };

  AdminChoroplethLayerDesigner.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderAdminRegionExpr(), this.renderScopeAndDetailLevel(), this.renderDisplayNames(), this.renderColor(), this.renderFillOpacity(), this.renderFilter(), this.renderPopup(), this.props.design.table ? R(ZoomLevelsComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }) : void 0);
  };

  return AdminChoroplethLayerDesigner;

})(React.Component);


},{"../ColorComponent":1016,"../TableSelectComponent":1025,"./../axes/AxisComponent":1031,"./AdminScopeAndDetailLevelComponent":1074,"./EditPopupComponent":1083,"./ZoomLevelsComponent":1108,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"rc-slider":416,"react":"react"}],1074:[function(require,module,exports){
var AdminScopeAndDetailLevelComponent, DetailLevelSelectComponent, H, R, React, ReactSelect, RegionSelectComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

RegionSelectComponent = require('./RegionSelectComponent');

DetailLevelSelectComponent = require('./DetailLevelSelectComponent');

ReactSelect = require('react-select');

module.exports = AdminScopeAndDetailLevelComponent = (function(superClass) {
  extend(AdminScopeAndDetailLevelComponent, superClass);

  function AdminScopeAndDetailLevelComponent() {
    this.handleDetailLevelChange = bind(this.handleDetailLevelChange, this);
    this.handleScopeChange = bind(this.handleScopeChange, this);
    return AdminScopeAndDetailLevelComponent.__super__.constructor.apply(this, arguments);
  }

  AdminScopeAndDetailLevelComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    scope: React.PropTypes.string,
    scopeLevel: React.PropTypes.number,
    detailLevel: React.PropTypes.number,
    onScopeAndDetailLevelChange: React.PropTypes.func.isRequired
  };

  AdminScopeAndDetailLevelComponent.prototype.handleScopeChange = function(scope, scopeLevel) {
    if (scope) {
      return this.props.onScopeAndDetailLevelChange(scope, scopeLevel, null);
    } else {
      return this.props.onScopeAndDetailLevelChange(null, null, 0);
    }
  };

  AdminScopeAndDetailLevelComponent.prototype.handleDetailLevelChange = function(detailLevel) {
    return this.props.onScopeAndDetailLevelChange(this.props.scope, this.props.scopeLevel, detailLevel);
  };

  AdminScopeAndDetailLevelComponent.prototype.render = function() {
    return H.div(null, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Region to Map"), R(RegionSelectComponent, {
      region: this.props.scope,
      onChange: this.handleScopeChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource
    })), (this.props.scope != null) && (this.props.detailLevel != null) ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Detail Level"), R(DetailLevelSelectComponent, {
      scope: this.props.scope,
      scopeLevel: this.props.scopeLevel,
      detailLevel: this.props.detailLevel,
      onChange: this.handleDetailLevelChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource
    })) : (this.props.scope == null) && (this.props.detailLevel != null) ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Detail Level"), R(ReactSelect, {
      value: this.props.detailLevel,
      options: [
        {
          value: 0,
          label: "Countries"
        }, {
          value: 1,
          label: "Level 1 (State/Province/District)"
        }
      ],
      clearable: false,
      onChange: (function(_this) {
        return function(value) {
          return _this.handleDetailLevelChange(parseInt(value));
        };
      })(this)
    })) : void 0);
  };

  return AdminScopeAndDetailLevelComponent;

})(React.Component);


},{"./DetailLevelSelectComponent":1081,"./RegionSelectComponent":1104,"lodash":"lodash","react":"react","react-select":818}],1075:[function(require,module,exports){
var BaseLayerDesignerComponent, H, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

module.exports = BaseLayerDesignerComponent = (function(superClass) {
  extend(BaseLayerDesignerComponent, superClass);

  function BaseLayerDesignerComponent() {
    this.handleBaseLayerChange = bind(this.handleBaseLayerChange, this);
    return BaseLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  BaseLayerDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  BaseLayerDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  BaseLayerDesignerComponent.prototype.handleBaseLayerChange = function(baseLayer) {
    return this.updateDesign({
      baseLayer: baseLayer
    });
  };

  BaseLayerDesignerComponent.prototype.renderBaseLayer = function(id, name) {
    var className;
    className = "mwater-visualization-layer";
    if (id === this.props.design.baseLayer) {
      className += " checked";
    }
    return H.div({
      key: id,
      className: className,
      style: {
        display: "inline-block"
      },
      onClick: this.handleBaseLayerChange.bind(null, id)
    }, name);
  };

  BaseLayerDesignerComponent.prototype.render = function() {
    return H.div({
      style: {
        marginLeft: 10
      }
    }, this.renderBaseLayer("cartodb_positron", "Light"), this.renderBaseLayer("cartodb_dark_matter", "Dark"), this.renderBaseLayer("bing_road", "Roads"), this.renderBaseLayer("bing_aerial", "Satellite"));
  };

  return BaseLayerDesignerComponent;

})(React.Component);


},{"lodash":"lodash","react":"react"}],1076:[function(require,module,exports){
/*
Copyright (c) 2011-2014, Pavel Shramov, Bruno Bergot
All rights reserved. 

Redistribution and use in source and binary forms, with or without modification, are 
permitted provided that the following conditions are met: 

   1. Redistributions of source code must retain the above copyright notice, this list of 
      conditions and the following disclaimer. 
	  
   2. Redistributions in binary form must reproduce the above copyright notice, this list 
      of conditions and the following disclaimer in the documentation and/or other materials
      provided with the distribution. 

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR 
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

var L = require('leaflet');

module.exports = L.TileLayer.extend({
	options: {
		subdomains: [0, 1, 2, 3],
		type: 'Aerial',
		attribution: 'Bing',
		culture: ''
	},

	initialize: function(key, options) {
		L.Util.setOptions(this, options);

		this._key = key;
		this._url = null;
		this.meta = {};
		this.loadMetadata();
	},

	tile2quad: function(x, y, z) {
		var quad = '';
		for (var i = z; i > 0; i--) {
			var digit = 0;
			var mask = 1 << (i - 1);
			if ((x & mask) !== 0) digit += 1;
			if ((y & mask) !== 0) digit += 2;
			quad = quad + digit;
		}
		return quad;
	},

	getTileUrl: function(p, z) {
		var zoom = this._getZoomForUrl();
		var subdomains = this.options.subdomains,
			s = this.options.subdomains[Math.abs((p.x + p.y) % subdomains.length)];
		return this._url.replace('{subdomain}', s)
				.replace('{quadkey}', this.tile2quad(p.x, p.y, zoom))
				.replace('{culture}', this.options.culture);
	},

	loadMetadata: function() {
		var _this = this;
		var cbid = '_bing_metadata_' + L.Util.stamp(this);
		window[cbid] = function (meta) {
			_this.meta = meta;
			window[cbid] = undefined;
			var e = document.getElementById(cbid);
			e.parentNode.removeChild(e);
			if (meta.errorDetails) {
				return;
			}
			_this.initMetadata();
		};
		var url = document.location.protocol + '//dev.virtualearth.net/REST/v1/Imagery/Metadata/' + this.options.type + '?include=ImageryProviders&jsonp=' + cbid +
		          '&key=' + this._key + '&UriScheme=' + document.location.protocol.slice(0, -1);
		var script = document.createElement('script');
		script.type = 'text/javascript';
		script.src = url;
		script.id = cbid;
		document.getElementsByTagName('head')[0].appendChild(script);
	},

	initMetadata: function() {
		var r = this.meta.resourceSets[0].resources[0];
		this.options.subdomains = r.imageUrlSubdomains;
		this._url = r.imageUrl;
		this._providers = [];
		if (r.imageryProviders) {
			for (var i = 0; i < r.imageryProviders.length; i++) {
				var p = r.imageryProviders[i];
				for (var j = 0; j < p.coverageAreas.length; j++) {
					var c = p.coverageAreas[j];
					var coverage = {zoomMin: c.zoomMin, zoomMax: c.zoomMax, active: false};
					var bounds = new L.LatLngBounds(
							new L.LatLng(c.bbox[0]+0.01, c.bbox[1]+0.01),
							new L.LatLng(c.bbox[2]-0.01, c.bbox[3]-0.01)
					);
					coverage.bounds = bounds;
					coverage.attrib = p.attribution;
					this._providers.push(coverage);
				}
			}
		}
		this._update();
	},

	_update: function() {
		if (this._url === null || !this._map) return;
		this._update_attribution();
		L.TileLayer.prototype._update.apply(this, []);
	},

	_update_attribution: function() {
		var bounds = this._map.getBounds();
		var zoom = this._map.getZoom();
		for (var i = 0; i < this._providers.length; i++) {
			var p = this._providers[i];
			if ((zoom <= p.zoomMax && zoom >= p.zoomMin) &&
					bounds.intersects(p.bounds)) {
				if (!p.active && this._map.attributionControl)
					this._map.attributionControl.addAttribution(p.attrib);
				p.active = true;
			} else {
				if (p.active && this._map.attributionControl)
					this._map.attributionControl.removeAttribution(p.attrib);
				p.active = false;
			}
		}
	},

	onRemove: function(map) {
		if (this._providers) {
			for (var i = 0; i < this._providers.length; i++) {
				var p = this._providers[i];
				if (p.active && this._map.attributionControl) {
					this._map.attributionControl.removeAttribution(p.attrib);
					p.active = false;
				}
			}
		}
    L.TileLayer.prototype.onRemove.apply(this, [map]);
	}
});

},{"leaflet":330}],1077:[function(require,module,exports){
var AxisBuilder, BufferLayer, ExprCleaner, ExprCompiler, ExprUtils, H, Layer, LayerLegendComponent, LegendGroup, React, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

H = React.DOM;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');

LayerLegendComponent = require('./LayerLegendComponent');


/*
Layer which draws a buffer around geometries (i.e. a radius circle around points)

Design is:
  table: table to get data from
  axes: axes (see below)
  filter: optional logical expression to filter by
  color: color of layer (e.g. #FF8800). Color axis overrides
  fillOpacity: Opacity to fill the circles (0-1)
  radius: radius to draw in meters
  minZoom: minimum zoom level
  maxZoom: maximum zoom level

  popup: contains items: which is BlocksLayoutManager items. Will be displayed when the circle is clicked

axes:
  geometry: where to draw buffers around
  color: color axis
 */

module.exports = BufferLayer = (function(superClass) {
  extend(BufferLayer, superClass);

  function BufferLayer() {
    return BufferLayer.__super__.constructor.apply(this, arguments);
  }

  BufferLayer.prototype.getJsonQLCss = function(design, schema, filters) {
    var layerDef;
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createJsonQL(design, schema, filters)
        }
      ],
      css: this.createCss(design, schema, filters),
      interactivity: {
        layer: "layer0",
        fields: ["id"]
      }
    };
    return layerDef;
  };

  BufferLayer.prototype.createJsonQL = function(design, schema, filters) {
    var axisBuilder, boundingBox, cases, categories, colorExpr, exprCompiler, filter, geometryExpr, j, len, order, query, radiusDeg, relevantFilters, selects, whereClauses, widthExpr;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);

    /*
    Query:
      select
      <primary key> as id,
      [<color axis> as color,
      st_transform(<geometry axis>, 3857) as the_geom_webmercator,
      radius * 2 / (!pixel_width! * cos(st_y(st_transform(geometryExpr, 4326)) * 0.017453293) as width
      from <table> as main
      where
        <geometry axis> is not null
         * Bounding box filter for speed
      and <geometry axis> &&
      ST_Transform(ST_Expand(
         * Prevent 3857 overflow (i.e. > 85 degrees lat)
        ST_Intersection(
          ST_Transform(!bbox!, 4326),
          ST_Expand(ST_MakeEnvelope(-180, -85, 180, 85, 4326), -<radius in degrees>))
        , <radius in degrees>})
      , 3857)
      and <other filters>
     */
    geometryExpr = axisBuilder.compileAxis({
      axis: design.axes.geometry,
      tableAlias: "main"
    });
    geometryExpr = {
      type: "op",
      op: "ST_Transform",
      exprs: [geometryExpr, 3857]
    };
    widthExpr = {
      type: "op",
      op: "+",
      exprs: [
        {
          type: "op",
          op: "/",
          exprs: [
            {
              type: "op",
              op: "*",
              exprs: [design.radius, 2]
            }, {
              type: "op",
              op: "*",
              exprs: [
                {
                  type: "token",
                  token: "!pixel_height!"
                }, {
                  type: "op",
                  op: "cos",
                  exprs: [
                    {
                      type: "op",
                      op: "*",
                      exprs: [
                        {
                          type: "op",
                          op: "ST_Y",
                          exprs: [
                            {
                              type: "op",
                              op: "ST_Transform",
                              exprs: [geometryExpr, 4326]
                            }
                          ]
                        }, 0.017453293
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }, 2
      ]
    };
    selects = [
      {
        type: "select",
        expr: {
          type: "field",
          tableAlias: "main",
          column: schema.getTable(design.table).primaryKey
        },
        alias: "id"
      }, {
        type: "select",
        expr: geometryExpr,
        alias: "the_geom_webmercator"
      }, {
        type: "select",
        expr: widthExpr,
        alias: "width"
      }
    ];
    if (design.axes.color) {
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "main"
      });
      selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
    }
    query = {
      type: "query",
      selects: selects,
      from: exprCompiler.compileTable(design.table, "main")
    };
    radiusDeg = design.radius / 100000;
    boundingBox = {
      type: "op",
      op: "ST_Transform",
      exprs: [
        {
          type: "op",
          op: "ST_Expand",
          exprs: [
            {
              type: "op",
              op: "ST_Intersection",
              exprs: [
                {
                  type: "op",
                  op: "ST_Transform",
                  exprs: [
                    {
                      type: "token",
                      token: "!bbox!"
                    }, 4326
                  ]
                }, {
                  type: "op",
                  op: "ST_Expand",
                  exprs: [
                    {
                      type: "op",
                      op: "ST_MakeEnvelope",
                      exprs: [-180, -85, 180, 85, 4326]
                    }, -radiusDeg
                  ]
                }
              ]
            }, radiusDeg
          ]
        }, 3857
      ]
    };
    whereClauses = [
      {
        type: "op",
        op: "is not null",
        exprs: [geometryExpr]
      }, {
        type: "op",
        op: "&&",
        exprs: [geometryExpr, boundingBox]
      }
    ];
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (j = 0, len = relevantFilters.length; j < len; j++) {
      filter = relevantFilters[j];
      whereClauses.push(injectTableAlias(filter.jsonql, "main"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    if (design.axes.color && design.axes.color.colorMap) {
      order = design.axes.color.drawOrder || _.pluck(design.axes.color.colorMap, "value");
      categories = axisBuilder.getCategories(design.axes.color, order);
      cases = _.map(categories, (function(_this) {
        return function(category, i) {
          return {
            when: category.value != null ? {
              type: "op",
              op: "=",
              exprs: [colorExpr, category.value]
            } : {
              type: "op",
              op: "is null",
              exprs: [colorExpr]
            },
            then: order.indexOf(category.value) || -1
          };
        };
      })(this));
      if (cases.length > 0) {
        query.orderBy = [
          {
            expr: {
              type: "case",
              cases: cases
            },
            direction: "desc"
          }
        ];
      }
    }
    return query;
  };

  BufferLayer.prototype.createCss = function(design, schema) {
    var css, item, j, len, ref, ref1;
    css = '#layer0 {\n  marker-fill-opacity: ' + design.fillOpacity + ';\nmarker-type: ellipse;\nmarker-width: [width];\nmarker-line-width: 0;\nmarker-allow-overlap: true;\nmarker-ignore-placement: true;\nmarker-fill: ' + (design.color || "transparent") + ';\n}';
    if ((ref = design.axes.color) != null ? ref.colorMap : void 0) {
      ref1 = design.axes.color.colorMap;
      for (j = 0, len = ref1.length; j < len; j++) {
        item = ref1[j];
        if (_.includes(design.axes.color.excludedValues, item.value)) {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { marker-fill-opacity: 0; }\n";
        } else {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { marker-fill: " + item.color + "; }\n";
        }
      }
    }
    return css;
  };

  BufferLayer.prototype.onGridClick = function(ev, clickOptions) {
    var BlocksLayoutManager, WidgetFactory, filter, ids, ref, results, table;
    if (ev.data && ev.data.id) {
      table = clickOptions.design.table;
      results = {};
      if (ev.event.originalEvent.shiftKey) {
        ids = clickOptions.scopeData || [];
        if (ref = ev.data.id, indexOf.call(ids, ref) >= 0) {
          ids = _.without(ids, ev.data.id);
        } else {
          ids = ids.concat([ev.data.id]);
        }
        filter = {
          table: table,
          jsonql: {
            type: "op",
            op: "=",
            modifier: "any",
            exprs: [
              {
                type: "field",
                tableAlias: "{alias}",
                column: clickOptions.schema.getTable(table).primaryKey
              }, {
                type: "literal",
                value: ids
              }
            ]
          }
        };
        if (ids.length > 0) {
          results.scope = {
            name: "Selected " + ids.length + " Circle(s)",
            filter: filter,
            data: ids
          };
        } else {
          results.scope = null;
        }
      }
      if (clickOptions.design.popup && !ev.event.originalEvent.shiftKey) {
        BlocksLayoutManager = require('../layouts/blocks/BlocksLayoutManager');
        WidgetFactory = require('../widgets/WidgetFactory');
        results.popup = new BlocksLayoutManager().renderLayout({
          items: clickOptions.design.popup.items,
          style: "popup",
          renderWidget: (function(_this) {
            return function(options) {
              var filters, widget, widgetDataSource;
              widget = WidgetFactory.createWidget(options.type);
              filter = {
                table: table,
                jsonql: {
                  type: "op",
                  op: "=",
                  exprs: [
                    {
                      type: "field",
                      tableAlias: "{alias}",
                      column: clickOptions.schema.getTable(table).primaryKey
                    }, {
                      type: "literal",
                      value: ev.data.id
                    }
                  ]
                }
              };
              filters = clickOptions.filters.concat([filter]);
              widgetDataSource = clickOptions.layerDataSource.getPopupWidgetDataSource(clickOptions.design, options.id);
              return widget.createViewElement({
                schema: clickOptions.schema,
                dataSource: clickOptions.dataSource,
                widgetDataSource: widgetDataSource,
                design: options.design,
                scope: null,
                filters: filters,
                onScopeChange: null,
                onDesignChange: null,
                width: options.width,
                height: options.height,
                standardWidth: options.standardWidth
              });
            };
          })(this)
        });
      } else if (!ev.event.originalEvent.shiftKey) {
        results.row = {
          tableId: table,
          primaryKey: ev.data.id
        };
      }
      return results;
    } else {
      return null;
    }
  };

  BufferLayer.prototype.getBounds = function(design, schema, dataSource, filters, callback) {
    return this.getBoundsFromExpr(schema, dataSource, design.table, design.axes.geometry.expr, design.filter, filters, callback);
  };

  BufferLayer.prototype.getMinZoom = function(design) {
    return design.minZoom;
  };

  BufferLayer.prototype.getMaxZoom = function(design) {
    return design.maxZoom;
  };

  BufferLayer.prototype.getLegend = function(design, schema, name) {
    var axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    return React.createElement(LayerLegendComponent, {
      schema: schema,
      name: name,
      axis: axisBuilder.cleanAxis({
        axis: design.axes.color,
        table: design.table,
        types: ['enum', 'text', 'boolean', 'date'],
        aggrNeed: "none"
      }),
      radiusLayer: true,
      defaultColor: design.color
    });
  };

  BufferLayer.prototype.getFilterableTables = function(design, schema) {
    if (design.table) {
      return [design.table];
    } else {
      return [];
    }
  };

  BufferLayer.prototype.isEditable = function() {
    return true;
  };

  BufferLayer.prototype.isIncomplete = function(design, schema) {
    return this.validateDesign(design, schema) != null;
  };

  BufferLayer.prototype.createDesignerElement = function(options) {
    var BufferLayerDesignerComponent;
    BufferLayerDesignerComponent = require('./BufferLayerDesignerComponent');
    return React.createElement(BufferLayerDesignerComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          return options.onDesignChange(_this.cleanDesign(design, options.schema));
        };
      })(this)
    });
  };

  BufferLayer.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.color = design.color || "#0088FF";
    design.axes = design.axes || {};
    design.radius = design.radius || 1000;
    design.fillOpacity = design.fillOpacity != null ? design.fillOpacity : 0.5;
    design.axes.geometry = axisBuilder.cleanAxis({
      axis: design.axes.geometry,
      table: design.table,
      types: ['geometry'],
      aggrNeed: "none"
    });
    design.axes.color = axisBuilder.cleanAxis({
      axis: design.axes.color,
      table: design.table,
      types: ['enum', 'text', 'boolean', 'date'],
      aggrNeed: "none"
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table
    });
    return design;
  };

  BufferLayer.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing table";
    }
    if (design.radius == null) {
      return "Missing radius";
    }
    if (!design.axes || !design.axes.geometry) {
      return "Missing axes";
    }
    error = axisBuilder.validateAxis({
      axis: design.axes.geometry
    });
    if (error) {
      return error;
    }
    error = axisBuilder.validateAxis({
      axis: design.axes.color
    });
    if (error) {
      return error;
    }
    return null;
  };

  BufferLayer.prototype.createKMLExportJsonQL = function(design, schema, filters) {
    var axisBuilder, bufferedGeometry, cases, categories, colorExpr, column, exprCompiler, extraFields, field, filter, geometryExpr, j, k, len, len1, order, query, radiusDeg, relevantFilters, selects, valueExpr, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);
    geometryExpr = axisBuilder.compileAxis({
      axis: design.axes.geometry,
      tableAlias: "main"
    });
    bufferedGeometry = {
      type: "op",
      op: "ST_AsGeoJson",
      exprs: [
        {
          type: "op",
          op: "::geometry",
          exprs: [
            {
              type: "op",
              op: "ST_Buffer",
              exprs: [
                {
                  type: "op",
                  op: "::geography",
                  exprs: [
                    {
                      type: "op",
                      op: "ST_Transform",
                      exprs: [geometryExpr, 4326]
                    }
                  ]
                }, design.radius
              ]
            }
          ]
        }
      ]
    };
    selects = [
      {
        type: "select",
        expr: {
          type: "field",
          tableAlias: "main",
          column: schema.getTable(design.table).primaryKey
        },
        alias: "id"
      }, {
        type: "select",
        expr: bufferedGeometry,
        alias: "the_geom_webmercator"
      }
    ];
    extraFields = ["code", "name", "desc", "type", "photos"];
    for (j = 0, len = extraFields.length; j < len; j++) {
      field = extraFields[j];
      column = schema.getColumn(design.table, field);
      if (column) {
        selects.push({
          type: "select",
          expr: {
            type: "field",
            tableAlias: "main",
            column: field
          },
          alias: field
        });
      }
    }
    if (design.axes.color) {
      valueExpr = exprCompiler.compileExpr({
        expr: design.axes.color.expr,
        tableAlias: "main"
      });
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "main"
      });
      selects.push({
        type: "select",
        expr: valueExpr,
        alias: "value"
      });
      selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
    }
    query = {
      type: "query",
      selects: selects,
      from: exprCompiler.compileTable(design.table, "main")
    };
    radiusDeg = design.radius / 100000;
    whereClauses = [
      {
        type: "op",
        op: "is not null",
        exprs: [geometryExpr]
      }
    ];
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (k = 0, len1 = relevantFilters.length; k < len1; k++) {
      filter = relevantFilters[k];
      whereClauses.push(injectTableAlias(filter.jsonql, "main"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    if (design.axes.color && design.axes.color.colorMap) {
      order = design.axes.color.drawOrder || _.pluck(design.axes.color.colorMap, "value");
      categories = axisBuilder.getCategories(design.axes.color, _.pluck(design.axes.color.colorMap, "value"));
      cases = _.map(categories, (function(_this) {
        return function(category, i) {
          return {
            when: category.value != null ? {
              type: "op",
              op: "=",
              exprs: [colorExpr, category.value]
            } : {
              type: "op",
              op: "is null",
              exprs: [colorExpr]
            },
            then: order.indexOf(category.value) || -1
          };
        };
      })(this));
      if (cases.length > 0) {
        query.orderBy = [
          {
            expr: {
              type: "case",
              cases: cases
            },
            direction: "desc"
          }
        ];
      }
    }
    return query;
  };

  BufferLayer.prototype.getKMLExportJsonQL = function(design, schema, filters) {
    var layerDef, style;
    style = {
      color: design.color,
      opacity: design.fillOpacity
    };
    if (design.axes.color && design.axes.color.colorMap) {
      style.colorMap = design.axes.color.colorMap;
    }
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createKMLExportJsonQL(design, schema, filters),
          style: style
        }
      ]
    };
    return layerDef;
  };

  BufferLayer.prototype.acceptKmlVisitorForRow = function(visitor, row) {
    var data, inner, list, outer;
    data = JSON.parse(row.the_geom_webmercator);
    outer = data.coordinates[0];
    inner = data.coordinates.slice(1);
    list = _.map(outer, function(coordinates) {
      return coordinates.join(",");
    });
    return visitor.addPolygon(list.join(" "), row.color, false, row.name, visitor.buildDescription(row));
  };

  return BufferLayer;

})(Layer);


},{"../axes/AxisBuilder":1029,"../layouts/blocks/BlocksLayoutManager":1060,"../widgets/WidgetFactory":1128,"./BufferLayerDesignerComponent":1078,"./Layer":1084,"./LayerLegendComponent":1086,"./LegendGroup":1089,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1078:[function(require,module,exports){
var AxisComponent, BufferLayerDesignerComponent, ColorComponent, EditPopupComponent, ExprUtils, FilterExprComponent, H, NumberInputComponent, R, Rcslider, React, TableSelectComponent, ZoomLevelsComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

NumberInputComponent = require('react-library/lib/NumberInputComponent');

AxisComponent = require('./../axes/AxisComponent');

ColorComponent = require('../ColorComponent');

TableSelectComponent = require('../TableSelectComponent');

Rcslider = require('rc-slider');

EditPopupComponent = require('./EditPopupComponent');

ZoomLevelsComponent = require('./ZoomLevelsComponent');

module.exports = BufferLayerDesignerComponent = (function(superClass) {
  extend(BufferLayerDesignerComponent, superClass);

  function BufferLayerDesignerComponent() {
    this.handleFillOpacityChange = bind(this.handleFillOpacityChange, this);
    this.handleColorAxisChange = bind(this.handleColorAxisChange, this);
    this.handleColorChange = bind(this.handleColorChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleGeometryAxisChange = bind(this.handleGeometryAxisChange, this);
    this.handleRadiusChange = bind(this.handleRadiusChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    return BufferLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  BufferLayerDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  BufferLayerDesignerComponent.prototype.update = function(updates) {
    return this.props.onDesignChange(_.extend({}, this.props.design, updates));
  };

  BufferLayerDesignerComponent.prototype.updateAxes = function(changes) {
    var axes;
    axes = _.extend({}, this.props.design.axes, changes);
    return this.update({
      axes: axes
    });
  };

  BufferLayerDesignerComponent.prototype.handleTableChange = function(table) {
    return this.update({
      table: table
    });
  };

  BufferLayerDesignerComponent.prototype.handleRadiusChange = function(radius) {
    return this.update({
      radius: radius
    });
  };

  BufferLayerDesignerComponent.prototype.handleGeometryAxisChange = function(axis) {
    return this.updateAxes({
      geometry: axis
    });
  };

  BufferLayerDesignerComponent.prototype.handleFilterChange = function(expr) {
    return this.update({
      filter: expr
    });
  };

  BufferLayerDesignerComponent.prototype.handleColorChange = function(color) {
    return this.update({
      color: color
    });
  };

  BufferLayerDesignerComponent.prototype.handleColorAxisChange = function(axis) {
    return this.updateAxes({
      color: axis
    });
  };

  BufferLayerDesignerComponent.prototype.handleFillOpacityChange = function(fillOpacity) {
    return this.update({
      fillOpacity: fillOpacity / 100
    });
  };

  BufferLayerDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), H.div({
      style: {
        marginLeft: 10
      }
    }, React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    })));
  };

  BufferLayerDesignerComponent.prototype.renderGeometryAxis = function() {
    var title;
    if (!this.props.design.table) {
      return;
    }
    title = H.span(null, H.span({
      className: "glyphicon glyphicon-map-marker"
    }), " Circle Centers");
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, title), H.div({
      style: {
        marginLeft: 10
      }
    }, React.createElement(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["geometry"],
      aggrNeed: "none",
      value: this.props.design.axes.geometry,
      onChange: this.handleGeometryAxisChange
    })));
  };

  BufferLayerDesignerComponent.prototype.renderRadius = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Radius (meters)"), ": ", React.createElement(NumberInputComponent, {
      value: this.props.design.radius,
      onChange: this.handleRadiusChange
    }));
  };

  BufferLayerDesignerComponent.prototype.renderColor = function() {
    if (!this.props.design.axes.geometry) {
      return;
    }
    return H.div(null, !this.props.design.axes.color ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Circle Color"), H.div(null, R(ColorComponent, {
      color: this.props.design.color,
      onChange: this.handleColorChange
    }))) : void 0, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Color By Data"), R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["text", "enum", "boolean", 'date'],
      aggrNeed: "none",
      value: this.props.design.axes.color,
      defaultColor: this.props.design.color,
      showColorMap: true,
      onChange: this.handleColorAxisChange,
      allowExcludedValues: true
    })));
  };

  BufferLayerDesignerComponent.prototype.renderFillOpacity = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Circle Opacity (%)"), ": ", React.createElement(Rcslider, {
      min: 0,
      max: 100,
      step: 1,
      tipTransitionName: "rc-slider-tooltip-zoom-down",
      value: this.props.design.fillOpacity * 100,
      onChange: this.handleFillOpacityChange
    }));
  };

  BufferLayerDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.axes.geometry) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  BufferLayerDesignerComponent.prototype.renderPopup = function() {
    if (!this.props.design.table) {
      return null;
    }
    return R(EditPopupComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table
    });
  };

  BufferLayerDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderGeometryAxis(), this.renderRadius(), this.renderColor(), this.renderFillOpacity(), this.renderFilter(), this.renderPopup(), this.props.design.table ? R(ZoomLevelsComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }) : void 0);
  };

  return BufferLayerDesignerComponent;

})(React.Component);


},{"../ColorComponent":1016,"../TableSelectComponent":1025,"./../axes/AxisComponent":1031,"./EditPopupComponent":1083,"./ZoomLevelsComponent":1108,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"rc-slider":416,"react":"react","react-library/lib/NumberInputComponent":789}],1079:[function(require,module,exports){
var AxisBuilder, ClusterLayer, ExprCleaner, ExprCompiler, ExprUtils, H, Layer, LayerLegendComponent, LegendGroup, React, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');

LayerLegendComponent = require('./LayerLegendComponent');


/*
Layer which clusters markers, counting them

Design is:
  table: table to get data from
  axes: axes (see below)
  filter: optional logical expression to filter by
  textColor: color of text. default #FFFFFF
  fillColor: color of markers that text is drawn on. default #337ab7
  minZoom: minimum zoom level
  maxZoom: maximum zoom level

axes:
  geometry: locations to cluster
 */

module.exports = ClusterLayer = (function(superClass) {
  extend(ClusterLayer, superClass);

  function ClusterLayer() {
    return ClusterLayer.__super__.constructor.apply(this, arguments);
  }

  ClusterLayer.prototype.getJsonQLCss = function(design, schema, filters) {
    var layerDef;
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createJsonQL(design, schema, filters)
        }
      ],
      css: this.createCss(design, schema, filters)
    };
    return layerDef;
  };

  ClusterLayer.prototype.createJsonQL = function(design, schema, filters) {
    var axisBuilder, centerExpr, clustExpr, cntExpr, exprCompiler, filter, geometryExpr, gridExpr, i, inner2Query, innerQuery, len, query, relevantFilters, sizeExpr, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);

    /*
    Query:
      Works by first snapping to grid and then clustering the clusters with slower DBSCAN method
    
      select 
        ST_Centroid(ST_Collect(center)) as the_geom_webmercator,
        sum(cnt) as cnt, 
        log(sum(cnt)) * 6 + 14 as size from 
          (
            select 
            ST_ClusterDBSCAN(center, (!pixel_width!*30 + !pixel_height!*30)/2, 1) over () as clust,
            sub1.center as center,
            cnt as cnt
            from
            (
              select 
              count(*) as cnt, 
              ST_Centroid(ST_Collect(<geometry axis>)) as center, 
              ST_Snaptogrid(<geometry axis>, !pixel_width!*40, !pixel_height!*40) as grid
              from <table> as main
              where <geometry axis> && !bbox! 
                and <geometry axis> is not null
                and <other filters>
              group by 3
            ) as sub1
          ) as sub2 
        group by sub2.clust
     */
    geometryExpr = axisBuilder.compileAxis({
      axis: design.axes.geometry,
      tableAlias: "main"
    });
    geometryExpr = {
      type: "op",
      op: "ST_Transform",
      exprs: [geometryExpr, 3857]
    };
    centerExpr = {
      type: "op",
      op: "ST_Centroid",
      exprs: [
        {
          type: "op",
          op: "ST_Collect",
          exprs: [geometryExpr]
        }
      ]
    };
    gridExpr = {
      type: "op",
      op: "ST_Snaptogrid",
      exprs: [
        geometryExpr, {
          type: "op",
          op: "*",
          exprs: [
            {
              type: "token",
              token: "!pixel_width!"
            }, 40
          ]
        }, {
          type: "op",
          op: "*",
          exprs: [
            {
              type: "token",
              token: "!pixel_width!"
            }, 40
          ]
        }
      ]
    };
    innerQuery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "op",
            op: "count",
            exprs: []
          },
          alias: "cnt"
        }, {
          type: "select",
          expr: centerExpr,
          alias: "center"
        }, {
          type: "select",
          expr: gridExpr,
          alias: "grid"
        }
      ],
      from: exprCompiler.compileTable(design.table, "main"),
      groupBy: [3]
    };
    whereClauses = [
      {
        type: "op",
        op: "&&",
        exprs: [
          geometryExpr, {
            type: "token",
            token: "!bbox!"
          }
        ]
      }
    ];
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (i = 0, len = relevantFilters.length; i < len; i++) {
      filter = relevantFilters[i];
      whereClauses.push(injectTableAlias(filter.jsonql, "main"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      innerQuery.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      innerQuery.where = whereClauses[0];
    }
    clustExpr = {
      type: "op",
      op: "ST_ClusterDBSCAN",
      exprs: [
        {
          type: "field",
          tableAlias: "innerquery",
          column: "center"
        }, {
          type: "op",
          op: "/",
          exprs: [
            {
              type: "op",
              op: "+",
              exprs: [
                {
                  type: "op",
                  op: "*",
                  exprs: [
                    {
                      type: "token",
                      token: "!pixel_width!"
                    }, 30
                  ]
                }, {
                  type: "op",
                  op: "*",
                  exprs: [
                    {
                      type: "token",
                      token: "!pixel_height!"
                    }, 30
                  ]
                }
              ]
            }, 2
          ]
        }, 1
      ]
    };
    inner2Query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: clustExpr,
          over: {},
          alias: "clust"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: "center"
          },
          alias: "center"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: "cnt"
          },
          alias: "cnt"
        }
      ],
      from: {
        type: "subquery",
        query: innerQuery,
        alias: "innerquery"
      }
    };
    centerExpr = {
      type: "op",
      op: "ST_Centroid",
      exprs: [
        {
          type: "op",
          op: "ST_Collect",
          exprs: [
            {
              type: "field",
              tableAlias: "inner2query",
              column: "center"
            }
          ]
        }
      ]
    };
    cntExpr = {
      type: "op",
      op: "sum",
      exprs: [
        {
          type: "field",
          tableAlias: "inner2query",
          column: "cnt"
        }
      ]
    };
    sizeExpr = {
      type: "op",
      op: "+",
      exprs: [
        {
          type: "op",
          op: "*",
          exprs: [
            {
              type: "op",
              op: "log",
              exprs: [cntExpr]
            }, 6
          ]
        }, 14
      ]
    };
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: centerExpr,
          alias: "the_geom_webmercator"
        }, {
          type: "select",
          expr: cntExpr,
          alias: "cnt"
        }, {
          type: "select",
          expr: sizeExpr,
          alias: "size"
        }
      ],
      from: {
        type: "subquery",
        query: inner2Query,
        alias: "inner2query"
      },
      groupBy: [
        {
          type: "field",
          tableAlias: "inner2query",
          column: "clust"
        }
      ]
    };
    return query;
  };

  ClusterLayer.prototype.createCss = function(design, schema) {
    var css;
    css = '#layer0 [cnt>1] {\n  marker-width: [size];\n  marker-line-color: white;\n  marker-line-width: 4;\n  marker-line-opacity: 0.6;\n  marker-placement: point;\n  marker-type: ellipse;\n  marker-allow-overlap: true;\n  marker-fill: ' + (design.fillColor || "#337ab7") + ';\n}\n\n#layer0::l1 [cnt>1] { \n  text-name: [cnt];\n  text-face-name: \'Arial Bold\';\n  text-allow-overlap: true;\n  text-fill: ' + (design.textColor || "white") + ';\n}\n\n#layer0 [cnt=1] {\n  marker-width: 10;\n  marker-line-color: white;\n  marker-line-width: 2;\n  marker-line-opacity: 0.6;\n  marker-placement: point;\n  marker-type: ellipse;\n  marker-allow-overlap: true;\n  marker-fill: ' + (design.fillColor || "#337ab7") + ';\n}';
    return css;
  };

  ClusterLayer.prototype.getBounds = function(design, schema, dataSource, filters, callback) {
    return this.getBoundsFromExpr(schema, dataSource, design.table, design.axes.geometry.expr, design.filter, filters, callback);
  };

  ClusterLayer.prototype.getMinZoom = function(design) {
    return design.minZoom;
  };

  ClusterLayer.prototype.getMaxZoom = function(design) {
    return design.maxZoom;
  };

  ClusterLayer.prototype.getLegend = function(design, schema, name) {
    var axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    return React.createElement(LayerLegendComponent, {
      schema: schema,
      defaultColor: design.fillColor || "#337ab7",
      symbol: 'font-awesome/circle',
      name: name
    });
  };

  ClusterLayer.prototype.getFilterableTables = function(design, schema) {
    if (design.table) {
      return [design.table];
    } else {
      return [];
    }
  };

  ClusterLayer.prototype.isEditable = function() {
    return true;
  };

  ClusterLayer.prototype.isIncomplete = function(design, schema) {
    return this.validateDesign(design, schema) != null;
  };

  ClusterLayer.prototype.createDesignerElement = function(options) {
    var ClusterLayerDesignerComponent;
    ClusterLayerDesignerComponent = require('./ClusterLayerDesignerComponent');
    return React.createElement(ClusterLayerDesignerComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          return options.onDesignChange(_this.cleanDesign(design, options.schema));
        };
      })(this)
    });
  };

  ClusterLayer.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.textColor = design.textColor || "white";
    design.fillColor = design.fillColor || "#337ab7";
    design.axes = design.axes || {};
    design.axes.geometry = axisBuilder.cleanAxis({
      axis: design.axes.geometry,
      table: design.table,
      types: ['geometry'],
      aggrNeed: "none"
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table
    });
    return design;
  };

  ClusterLayer.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing table";
    }
    if (!design.axes || !design.axes.geometry) {
      return "Missing axes";
    }
    error = axisBuilder.validateAxis({
      axis: design.axes.geometry
    });
    if (error) {
      return error;
    }
    return null;
  };

  return ClusterLayer;

})(Layer);


},{"../axes/AxisBuilder":1029,"./ClusterLayerDesignerComponent":1080,"./Layer":1084,"./LayerLegendComponent":1086,"./LegendGroup":1089,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1080:[function(require,module,exports){
var AxisComponent, ClusterLayerDesignerComponent, ColorComponent, ExprUtils, FilterExprComponent, H, R, React, TableSelectComponent, ZoomLevelsComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisComponent = require('./../axes/AxisComponent');

ColorComponent = require('../ColorComponent');

TableSelectComponent = require('../TableSelectComponent');

ZoomLevelsComponent = require('./ZoomLevelsComponent');

module.exports = ClusterLayerDesignerComponent = (function(superClass) {
  extend(ClusterLayerDesignerComponent, superClass);

  function ClusterLayerDesignerComponent() {
    this.handleFillColorChange = bind(this.handleFillColorChange, this);
    this.handleTextColorChange = bind(this.handleTextColorChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleGeometryAxisChange = bind(this.handleGeometryAxisChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    return ClusterLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  ClusterLayerDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  ClusterLayerDesignerComponent.prototype.update = function(updates) {
    return this.props.onDesignChange(_.extend({}, this.props.design, updates));
  };

  ClusterLayerDesignerComponent.prototype.updateAxes = function(changes) {
    var axes;
    axes = _.extend({}, this.props.design.axes, changes);
    return this.update({
      axes: axes
    });
  };

  ClusterLayerDesignerComponent.prototype.handleTableChange = function(table) {
    return this.update({
      table: table
    });
  };

  ClusterLayerDesignerComponent.prototype.handleGeometryAxisChange = function(axis) {
    return this.updateAxes({
      geometry: axis
    });
  };

  ClusterLayerDesignerComponent.prototype.handleFilterChange = function(expr) {
    return this.update({
      filter: expr
    });
  };

  ClusterLayerDesignerComponent.prototype.handleTextColorChange = function(color) {
    return this.update({
      textColor: color
    });
  };

  ClusterLayerDesignerComponent.prototype.handleFillColorChange = function(color) {
    return this.update({
      fillColor: color
    });
  };

  ClusterLayerDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), H.div({
      style: {
        marginLeft: 10
      }
    }, React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    })));
  };

  ClusterLayerDesignerComponent.prototype.renderGeometryAxis = function() {
    var title;
    if (!this.props.design.table) {
      return;
    }
    title = H.span(null, H.span({
      className: "glyphicon glyphicon-map-marker"
    }), " Locations to Cluster");
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, title), H.div({
      style: {
        marginLeft: 10
      }
    }, React.createElement(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["geometry"],
      aggrNeed: "none",
      value: this.props.design.axes.geometry,
      onChange: this.handleGeometryAxisChange
    })));
  };

  ClusterLayerDesignerComponent.prototype.renderTextColor = function() {
    if (!this.props.design.axes.geometry) {
      return;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Text Color"), H.div(null, R(ColorComponent, {
      color: this.props.design.textColor,
      onChange: this.handleTextColorChange
    })));
  };

  ClusterLayerDesignerComponent.prototype.renderFillColor = function() {
    if (!this.props.design.axes.geometry) {
      return;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Marker Color"), H.div(null, R(ColorComponent, {
      color: this.props.design.fillColor,
      onChange: this.handleFillColorChange
    })));
  };

  ClusterLayerDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.axes.geometry) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  ClusterLayerDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderGeometryAxis(), this.renderTextColor(), this.renderFillColor(), this.renderFilter(), this.props.design.table ? R(ZoomLevelsComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }) : void 0);
  };

  return ClusterLayerDesignerComponent;

})(React.Component);


},{"../ColorComponent":1016,"../TableSelectComponent":1025,"./../axes/AxisComponent":1031,"./ZoomLevelsComponent":1108,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1081:[function(require,module,exports){
var DetailLevelSelectComponent, H, R, React, ReactSelect, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ReactSelect = require('react-select');

module.exports = DetailLevelSelectComponent = (function(superClass) {
  extend(DetailLevelSelectComponent, superClass);

  DetailLevelSelectComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    scope: React.PropTypes.string.isRequired,
    scopeLevel: React.PropTypes.number.isRequired,
    detailLevel: React.PropTypes.number,
    onChange: React.PropTypes.func.isRequired
  };

  function DetailLevelSelectComponent() {
    DetailLevelSelectComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      options: null
    };
  }

  DetailLevelSelectComponent.prototype.componentWillMount = function() {
    return this.loadLevels(this.props);
  };

  DetailLevelSelectComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (nextProps.scope !== this.props.scope) {
      return this.loadLevels(nextProps);
    }
  };

  DetailLevelSelectComponent.prototype.loadLevels = function(props) {
    var query;
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "main",
            column: "level0"
          },
          alias: "level0"
        }
      ],
      from: {
        type: "table",
        table: "admin_regions",
        alias: "main"
      },
      where: {
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "main",
            column: "_id"
          }, props.scope
        ]
      }
    };
    return props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        var countryId;
        if (err) {
          alert("Error loading detail levels");
          return;
        }
        countryId = rows[0].level0;
        query = {
          type: "query",
          selects: [
            {
              type: "select",
              expr: {
                type: "field",
                tableAlias: "main",
                column: "level"
              },
              alias: "level"
            }, {
              type: "select",
              expr: {
                type: "field",
                tableAlias: "main",
                column: "name"
              },
              alias: "name"
            }
          ],
          from: {
            type: "table",
            table: "admin_region_levels",
            alias: "main"
          },
          where: {
            type: "op",
            op: "=",
            exprs: [
              {
                type: "field",
                tableAlias: "main",
                column: "country_id"
              }, countryId
            ]
          },
          orderBy: [
            {
              ordinal: 1,
              direction: "asc"
            }
          ]
        };
        return props.dataSource.performQuery(query, function(err, rows) {
          var options;
          if (err) {
            alert("Error loading detail levels");
            return;
          }
          rows = _.filter(rows, function(r) {
            return r.level > props.scopeLevel;
          });
          if (_this.props.detailLevel <= _this.props.scopeLevel && rows.length > 0) {
            _this.props.onChange(rows[0].level);
          }
          options = _.map(rows, function(r) {
            return {
              value: r.level,
              label: r.name
            };
          });
          return _this.setState({
            options: options
          });
        });
      };
    })(this));
  };

  DetailLevelSelectComponent.prototype.render = function() {
    if (this.state.options) {
      return R(ReactSelect, {
        value: this.props.detailLevel || "",
        options: this.state.options,
        clearable: false,
        onChange: (function(_this) {
          return function(value) {
            return _this.props.onChange(parseInt(value));
          };
        })(this)
      });
    } else {
      return H.div({
        className: "text-muted"
      }, H.i({
        className: "fa fa-spinner fa-spin"
      }), " Loading...");
    }
  };

  return DetailLevelSelectComponent;

})(React.Component);


},{"lodash":"lodash","react":"react","react-select":818}],1082:[function(require,module,exports){
var BlocksLayoutManager, DirectLayerDataSource, DirectMapDataSource, DirectWidgetDataSource, LayerFactory, MapBoundsCalculator, MapDataSource, WidgetFactory, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

LayerFactory = require('./LayerFactory');

injectTableAlias = require('mwater-expressions').injectTableAlias;

MapDataSource = require('./MapDataSource');

DirectWidgetDataSource = require('../widgets/DirectWidgetDataSource');

BlocksLayoutManager = require('../layouts/blocks/BlocksLayoutManager');

WidgetFactory = require('../widgets/WidgetFactory');

MapBoundsCalculator = require('./MapBoundsCalculator');

module.exports = DirectMapDataSource = (function(superClass) {
  extend(DirectMapDataSource, superClass);

  function DirectMapDataSource(options) {
    this.options = options;
  }

  DirectMapDataSource.prototype.getLayerDataSource = function(layerId) {
    var layerView;
    layerView = _.findWhere(this.options.design.layerViews, {
      id: layerId
    });
    if (!layerView) {
      return null;
    }
    return new DirectLayerDataSource(_.extend({}, this.options, {
      layerView: layerView
    }));
  };

  DirectMapDataSource.prototype.getBounds = function(design, filters, callback) {
    return new MapBoundsCalculator(this.options.schema, this.options.dataSource).getBounds(design, filters, callback);
  };

  return DirectMapDataSource;

})(MapDataSource);

DirectLayerDataSource = (function() {
  function DirectLayerDataSource(options) {
    this.options = options;
  }

  DirectLayerDataSource.prototype.getTileUrl = function(design, filters) {
    var jsonqlCss, layer;
    layer = LayerFactory.createLayer(this.options.layerView.type);
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(design, "png", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return design.tileUrl;
    }
    jsonqlCss = layer.getJsonQLCss(design, this.options.schema, filters);
    return this.createUrl("png", jsonqlCss);
  };

  DirectLayerDataSource.prototype.getUtfGridUrl = function(design, filters) {
    var jsonqlCss, layer;
    layer = LayerFactory.createLayer(this.options.layerView.type);
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(design, "grid.json", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return null;
    }
    jsonqlCss = layer.getJsonQLCss(design, this.options.schema, filters);
    return this.createUrl("grid.json", jsonqlCss);
  };

  DirectLayerDataSource.prototype.getPopupWidgetDataSource = function(design, widgetId) {
    var layer, ref, type, widget;
    layer = LayerFactory.createLayer(this.options.layerView.type);
    ref = new BlocksLayoutManager().getWidgetTypeAndDesign(design.popup.items, widgetId), type = ref.type, design = ref.design;
    widget = WidgetFactory.createWidget(type);
    return new DirectWidgetDataSource({
      widget: widget,
      schema: this.options.schema,
      dataSource: this.options.dataSource,
      apiUrl: this.options.apiUrl,
      client: this.options.client
    });
  };

  DirectLayerDataSource.prototype.createUrl = function(extension, jsonqlCss) {
    var query, url;
    query = "type=jsonql";
    if (this.options.client) {
      query += "&client=" + this.options.client;
    }
    query += "&design=" + encodeURIComponent(JSON.stringify(jsonqlCss));
    url = (this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?") + query;
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    return url;
  };

  DirectLayerDataSource.prototype.createLegacyUrl = function(design, extension, filters) {
    var relevantFilters, url, where, whereClauses;
    url = this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?type=" + design.type + "&radius=1000";
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    if (this.client) {
      url += "&client=" + this.options.client;
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    whereClauses = _.map(relevantFilters, (function(_this) {
      return function(f) {
        return injectTableAlias(f.jsonql, "main");
      };
    })(this));
    if (whereClauses.length > 1) {
      where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      where = whereClauses[0];
    }
    if (where) {
      url += "&where=" + encodeURIComponent(JSON.stringify(where));
    }
    return url;
  };

  return DirectLayerDataSource;

})();


},{"../layouts/blocks/BlocksLayoutManager":1060,"../widgets/DirectWidgetDataSource":1117,"../widgets/WidgetFactory":1128,"./LayerFactory":1085,"./MapBoundsCalculator":1091,"./MapDataSource":1094,"lodash":"lodash","mwater-expressions":14}],1083:[function(require,module,exports){
var BlocksLayoutManager, DirectWidgetDataSource, EditPopupComponent, H, ModalWindowComponent, R, React, WidgetFactory, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ModalWindowComponent = require('react-library/lib/ModalWindowComponent');

BlocksLayoutManager = require('../layouts/blocks/BlocksLayoutManager');

WidgetFactory = require('../widgets/WidgetFactory');

DirectWidgetDataSource = require('../widgets/DirectWidgetDataSource');

module.exports = EditPopupComponent = (function(superClass) {
  extend(EditPopupComponent, superClass);

  EditPopupComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired,
    table: React.PropTypes.string.isRequired
  };

  function EditPopupComponent() {
    this.handleRemovePopup = bind(this.handleRemovePopup, this);
    this.handleItemsChange = bind(this.handleItemsChange, this);
    EditPopupComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editing: false
    };
  }

  EditPopupComponent.prototype.handleItemsChange = function(items) {
    var design, popup;
    popup = this.props.design.popup || {};
    popup = _.extend({}, popup, {
      items: items
    });
    design = _.extend({}, this.props.design, {
      popup: popup
    });
    return this.props.onDesignChange(design);
  };

  EditPopupComponent.prototype.handleRemovePopup = function() {
    var design;
    design = _.omit(this.props.design, "popup");
    return this.props.onDesignChange(design);
  };

  EditPopupComponent.prototype.render = function() {
    var ref;
    return H.div(null, H.a({
      className: "btn btn-link",
      onClick: ((function(_this) {
        return function() {
          return _this.setState({
            editing: true
          });
        };
      })(this))
    }, H.i({
      className: "fa fa-pencil"
    }), " Customize Popup"), this.props.design.popup ? H.a({
      className: "btn btn-link",
      onClick: this.handleRemovePopup
    }, H.i({
      className: "fa fa-times"
    }), " Remove Popup") : void 0, this.state.editing ? R(ModalWindowComponent, {
      isOpen: true,
      onRequestClose: ((function(_this) {
        return function() {
          return _this.setState({
            editing: false
          });
        };
      })(this))
    }, new BlocksLayoutManager().renderLayout({
      items: (ref = this.props.design.popup) != null ? ref.items : void 0,
      style: "popup",
      onItemsChange: this.handleItemsChange,
      disableMaps: true,
      renderWidget: (function(_this) {
        return function(options) {
          var widget, widgetDataSource;
          widget = WidgetFactory.createWidget(options.type);
          widgetDataSource = new DirectWidgetDataSource({
            widget: widget,
            schema: _this.props.schema,
            dataSource: _this.props.dataSource
          });
          return widget.createViewElement({
            schema: _this.props.schema,
            dataSource: _this.props.dataSource,
            widgetDataSource: widgetDataSource,
            design: options.design,
            scope: null,
            filters: [],
            onScopeChange: null,
            onDesignChange: options.onDesignChange,
            width: options.width,
            height: options.height,
            standardWidth: options.standardWidth,
            singleRowTable: _this.props.table
          });
        };
      })(this)
    })) : void 0);
  };

  return EditPopupComponent;

})(React.Component);


},{"../layouts/blocks/BlocksLayoutManager":1060,"../widgets/DirectWidgetDataSource":1117,"../widgets/WidgetFactory":1128,"lodash":"lodash","react":"react","react-library/lib/ModalWindowComponent":787}],1084:[function(require,module,exports){
var AxisBuilder, ExprCompiler, Layer, _, injectTableAlias;

_ = require('lodash');

AxisBuilder = require('../axes/AxisBuilder');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

module.exports = Layer = (function() {
  function Layer() {}

  Layer.prototype.getJsonQLCss = function(design, schema, filters) {
    throw new Error("Not implemented");
  };

  Layer.prototype.onGridClick = function(ev, options) {
    return null;
  };

  Layer.prototype.getBounds = function(design, schema, dataSource, filters, callback) {
    return callback(null);
  };

  Layer.prototype.getMinZoom = function(design) {
    return null;
  };

  Layer.prototype.getMaxZoom = function(design) {
    return null;
  };

  Layer.prototype.getLegend = function(design, schema, name) {
    return null;
  };

  Layer.prototype.getFilterableTables = function(design, schema) {
    return [];
  };

  Layer.prototype.isEditable = function() {
    return false;
  };

  Layer.prototype.isIncomplete = function(design, schema) {
    return this.validateDesign(this.cleanDesign(design, schema), schema) != null;
  };

  Layer.prototype.createDesignerElement = function(options) {
    throw new Error("Not implemented");
  };

  Layer.prototype.cleanDesign = function(design, schema) {
    return design;
  };

  Layer.prototype.validateDesign = function(design, schema) {
    return null;
  };

  Layer.prototype.getKMLExportJsonQL = function(design, schema, filters) {
    throw new Error("Not implemented");
  };

  Layer.prototype.getBoundsFromExpr = function(schema, dataSource, table, geometryExpr, filterExpr, filters, callback) {
    var boundsQuery, compiledGeometryExpr, exprCompiler, where;
    exprCompiler = new ExprCompiler(schema);
    compiledGeometryExpr = exprCompiler.compileExpr({
      expr: geometryExpr,
      tableAlias: "main"
    });
    where = {
      type: "op",
      op: "and",
      exprs: _.pluck(_.where(filters, {
        table: table
      }), "jsonql")
    };
    if (filterExpr) {
      where.exprs.push(exprCompiler.compileExpr({
        expr: filterExpr,
        tableAlias: "main"
      }));
    }
    where.exprs = _.compact(where.exprs);
    where = injectTableAlias(where, "main");
    boundsQuery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "op",
            op: "::json",
            exprs: [
              {
                type: "op",
                op: "ST_AsGeoJSON",
                exprs: [
                  {
                    type: "op",
                    op: "ST_SetSRID",
                    exprs: [
                      {
                        type: "op",
                        op: "ST_Extent",
                        exprs: [
                          {
                            type: "op",
                            op: "ST_Transform",
                            exprs: [compiledGeometryExpr, 4326]
                          }
                        ]
                      }, 4326
                    ]
                  }
                ]
              }
            ]
          },
          alias: "bounds"
        }
      ],
      from: {
        type: "table",
        table: table,
        alias: "main"
      },
      where: where
    };
    return dataSource.performQuery(boundsQuery, (function(_this) {
      return function(err, results) {
        var bounds;
        if (err) {
          return callback(err);
        } else {
          if (results[0].bounds) {
            if (results[0].bounds.type === "Point") {
              bounds = {
                w: results[0].bounds.coordinates[0] - 0.1,
                s: results[0].bounds.coordinates[1] - 0.1,
                e: results[0].bounds.coordinates[0] + 0.1,
                n: results[0].bounds.coordinates[1] + 0.1
              };
            } else {
              bounds = {
                w: results[0].bounds.coordinates[0][0][0] - 0.001,
                s: results[0].bounds.coordinates[0][0][1] - 0.001,
                e: results[0].bounds.coordinates[0][2][0] + 0.001,
                n: results[0].bounds.coordinates[0][2][1] + 0.001
              };
            }
          } else {
            bounds = {
              w: -165.9375,
              n: 76.9206135182968,
              e: 38.67187499999999,
              s: -62.431074232920906
            };
          }
          return callback(null, bounds);
        }
      };
    })(this));
  };

  return Layer;

})();


},{"../axes/AxisBuilder":1029,"lodash":"lodash","mwater-expressions":14}],1085:[function(require,module,exports){
var AdminChoroplethLayer, BufferLayer, ClusterLayer, LayerFactory, MWaterServerLayer, MarkersLayer, TileUrlLayer;

MWaterServerLayer = require('./MWaterServerLayer');

MarkersLayer = require('./MarkersLayer');

BufferLayer = require('./BufferLayer');

AdminChoroplethLayer = require('./AdminChoroplethLayer');

ClusterLayer = require('./ClusterLayer');

TileUrlLayer = require('./TileUrlLayer');

module.exports = LayerFactory = (function() {
  function LayerFactory() {}

  LayerFactory.createLayer = function(type) {
    switch (type) {
      case "MWaterServer":
        return new MWaterServerLayer();
      case "Markers":
        return new MarkersLayer();
      case "Buffer":
        return new BufferLayer();
      case "AdminChoropleth":
        return new AdminChoroplethLayer();
      case "Cluster":
        return new ClusterLayer();
      case "TileUrl":
        return new TileUrlLayer();
    }
    throw new Error("Unknown type " + type);
  };

  return LayerFactory;

})();


},{"./AdminChoroplethLayer":1072,"./BufferLayer":1077,"./ClusterLayer":1079,"./MWaterServerLayer":1090,"./MarkersLayer":1102,"./TileUrlLayer":1106}],1086:[function(require,module,exports){
var AxisBuilder, ExprUtils, H, LayerLegendComponent, LegendGroup, R, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

_ = require('lodash');

R = React.createElement;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = LayerLegendComponent = (function(superClass) {
  extend(LayerLegendComponent, superClass);

  LayerLegendComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    name: React.PropTypes.string.isRequired,
    radiusLayer: React.PropTypes.bool,
    axis: React.PropTypes.object,
    symbol: React.PropTypes.string,
    defaultColor: React.PropTypes.string
  };

  LayerLegendComponent.defaultProps = {
    radiusLayer: false
  };

  function LayerLegendComponent() {
    LayerLegendComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      categories: []
    };
  }

  LayerLegendComponent.prototype.componentWillMount = function() {
    return this.loadCategories(this.props);
  };

  LayerLegendComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (!_.isEqual(nextProps.axis, this.props.axis)) {
      return this.loadCategories(nextProps);
    }
  };

  LayerLegendComponent.prototype.componentWillUnmount = function() {
    return this.unmounted = true;
  };

  LayerLegendComponent.prototype.loadCategories = function(props) {
    var axisBuilder, categories;
    axisBuilder = new AxisBuilder({
      schema: props.schema
    });
    if (!props.axis || !props.axis.colorMap) {
      return;
    }
    categories = axisBuilder.getCategories(props.axis, _.pluck(props.axis.colorMap, "value"));
    if (categories.length > 1) {
      this.setState({
        categories: categories
      });
    }
  };

  LayerLegendComponent.prototype.render = function() {
    var items;
    if (this.props.axis && this.props.axis.colorMap) {
      items = _.map(this.state.categories, (function(_this) {
        return function(category) {
          var color, label;
          if (_.includes(_this.props.axis.excludedValues, category.value)) {
            return null;
          }
          label = ExprUtils.localizeString(category.label);
          color = _.find(_this.props.axis.colorMap, {
            value: category.value
          });
          if (color) {
            return {
              color: color.color,
              name: label
            };
          } else {
            return {
              color: _this.props.defaultColor,
              name: label
            };
          }
        };
      })(this));
      items = _.compact(items);
    } else {
      items = [];
    }
    return React.createElement(LegendGroup, {
      symbol: this.props.symbol,
      items: items,
      defaultColor: this.props.defaultColor,
      name: this.props.name,
      radiusLayer: this.props.radiusLayer
    });
  };

  return LayerLegendComponent;

})(React.Component);


},{"../axes/AxisBuilder":1029,"./LegendGroup":1089,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1087:[function(require,module,exports){
var BingLayer, H, L, LeafletMapComponent, React, ReactDOM, UtfGridLayer,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

L = require('leaflet');

BingLayer = require('./BingLayer');

UtfGridLayer = require('./UtfGridLayer');

window.L = L;

require('leaflet-loading');

module.exports = LeafletMapComponent = (function(superClass) {
  extend(LeafletMapComponent, superClass);

  function LeafletMapComponent() {
    return LeafletMapComponent.__super__.constructor.apply(this, arguments);
  }

  LeafletMapComponent.propTypes = {
    baseLayerId: React.PropTypes.string.isRequired,
    initialBounds: React.PropTypes.shape({
      w: React.PropTypes.number.isRequired,
      n: React.PropTypes.number.isRequired,
      e: React.PropTypes.number.isRequired,
      s: React.PropTypes.number.isRequired
    }),
    width: React.PropTypes.any,
    height: React.PropTypes.any,
    onBoundsChange: React.PropTypes.func,
    layers: React.PropTypes.arrayOf(React.PropTypes.shape({
      tileUrl: React.PropTypes.string,
      utfGridUrl: React.PropTypes.string,
      visible: React.PropTypes.bool,
      opacity: React.PropTypes.number,
      onGridClick: React.PropTypes.func,
      minZoom: React.PropTypes.number,
      maxZoom: React.PropTypes.number
    })).isRequired,
    legend: React.PropTypes.node,
    dragging: React.PropTypes.bool,
    touchZoom: React.PropTypes.bool,
    scrollWheelZoom: React.PropTypes.bool,
    maxZoom: React.PropTypes.number,
    extraAttribution: React.PropTypes.string,
    loadingSpinner: React.PropTypes.bool
  };

  LeafletMapComponent.defaultProps = {
    dragging: true,
    touchZoom: true,
    scrollWheelZoom: true
  };

  LeafletMapComponent.prototype.reload = function() {
    var i, len, ref, results, tileLayer;
    ref = this.tileLayers;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      tileLayer = ref[i];
      results.push(tileLayer.redraw());
    }
    return results;
  };

  LeafletMapComponent.prototype.getBounds = function() {
    var curBounds;
    curBounds = this.map.getBounds();
    return {
      n: curBounds.getNorth(),
      e: curBounds.getEast(),
      s: curBounds.getSouth(),
      w: curBounds.getWest()
    };
  };

  LeafletMapComponent.prototype.setBounds = function(bounds, pad) {
    var curBounds, e, lBounds, n, s, w;
    if (bounds) {
      if (this.hasBounds) {
        curBounds = this.map.getBounds();
        if (curBounds && curBounds.getWest() === bounds.w && curBounds.getEast() === bounds.e && curBounds.getNorth() === bounds.n && curBounds.getSouth() === bounds.s) {
          return;
        }
      }
      n = bounds.n;
      w = bounds.w;
      s = bounds.s;
      e = bounds.e;
      if (n === s) {
        n += 0.001;
      }
      if (e === w) {
        e += 0.001;
      }
      lBounds = new L.LatLngBounds([[s, w], [n, e]]);
      if (pad) {
        lBounds = lBounds.pad(pad);
      }
      this.map.fitBounds(lBounds, {
        animate: true
      });
    } else {
      this.map.fitBounds([[-1, -180], [1, 180]]);
    }
    return this.hasBounds = true;
  };

  LeafletMapComponent.prototype.componentDidMount = function() {
    var loadingControl, mapElem, mapOptions;
    mapElem = ReactDOM.findDOMNode(this.refs.map);
    mapOptions = {
      fadeAnimation: false,
      dragging: this.props.dragging,
      touchZoom: this.props.touchZoom,
      scrollWheelZoom: this.props.scrollWheelZoom,
      minZoom: 1
    };
    if (this.props.maxZoom != null) {
      mapOptions.maxZoom = this.props.maxZoom;
    }
    this.map = L.map(mapElem, mapOptions);
    this.map.on("zoomend", (function(_this) {
      return function() {
        return _this.forceUpdate();
      };
    })(this));
    this.map.on("load", (function(_this) {
      return function() {
        _this.loaded = true;
        return _this.forceUpdate();
      };
    })(this));
    this.map.on("moveend", (function(_this) {
      return function() {
        var bounds;
        if (_this.props.onBoundsChange) {
          bounds = _this.map.getBounds();
          return _this.props.onBoundsChange({
            w: bounds.getWest(),
            n: bounds.getNorth(),
            e: bounds.getEast(),
            s: bounds.getSouth()
          });
        }
      };
    })(this));
    this.setBounds(this.props.initialBounds);
    if (this.props.loadingSpinner) {
      loadingControl = L.Control.loading({
        separate: true
      });
      this.map.addControl(loadingControl);
    }
    return this.updateMap();
  };

  LeafletMapComponent.prototype.componentDidUpdate = function(prevProps) {
    return this.updateMap(prevProps);
  };

  LeafletMapComponent.prototype.componentWillUnmount = function() {
    var ref;
    return (ref = this.map) != null ? ref.remove() : void 0;
  };

  LeafletMapComponent.prototype.openPopup = function(options) {
    var popupDiv;
    popupDiv = L.DomUtil.create('div', '');
    return ReactDOM.render(options.contents, popupDiv, (function(_this) {
      return function() {
        var popup;
        return popup = L.popup({
          minWidth: 100,
          offset: options.offset,
          autoPan: true
        }).setLatLng(options.location).setContent(popupDiv).openOn(_this.map);
      };
    })(this));
  };

  LeafletMapComponent.prototype.updateMap = function(prevProps) {
    var i, j, k, l, layer, len, len1, len2, len3, options, ref, ref1, ref2, ref3, results, tileLayer, utfGridLayer;
    if (prevProps && (prevProps.width !== this.props.width || prevProps.height !== this.props.height)) {
      this.map.invalidateSize();
    }
    if (prevProps && prevProps.maxZoom !== this.props.maxZoom) {
      this.map.options.maxZoom = this.props.maxZoom;
      if (this.map.getZoom() > this.props.maxZoom) {
        this.map.setZoom(this.props.maxZoom);
      }
    }
    if (!prevProps || this.props.extraAttribution !== prevProps.extraAttribution) {
      if (this.baseLayer) {
        this.baseLayer._map.attributionControl.removeAttribution(prevProps.extraAttribution);
        this.baseLayer._map.attributionControl.addAttribution(this.props.extraAttribution);
      }
    }
    if (!prevProps || this.props.baseLayerId !== prevProps.baseLayerId) {
      if (this.baseLayer) {
        this.map.removeLayer(this.baseLayer);
        this.baseLayer = null;
      }
      switch (this.props.baseLayerId) {
        case "bing_road":
          this.baseLayer = new BingLayer("Ao26dWY2IC8PjorsJKFaoR85EPXCnCohrJdisCWXIULAXFo0JAXquGauppTMQbyU", {
            type: "Road"
          });
          break;
        case "bing_aerial":
          this.baseLayer = new BingLayer("Ao26dWY2IC8PjorsJKFaoR85EPXCnCohrJdisCWXIULAXFo0JAXquGauppTMQbyU", {
            type: "AerialWithLabels"
          });
          break;
        case "cartodb_positron":
          this.baseLayer = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://cartodb.com/attributions">CartoDB</a>'
          });
          break;
        case "cartodb_dark_matter":
          this.baseLayer = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, &copy; <a href="https://cartodb.com/attributions">CartoDB</a>'
          });
      }
      this.map.addLayer(this.baseLayer);
      if (this.props.extraAttribution) {
        this.baseLayer._map.attributionControl.addAttribution(this.props.extraAttribution);
      }
      this.baseLayer.bringToBack();
    }
    if (!prevProps || JSON.stringify(_.omit(this.props.layers, "onGridClick")) !== JSON.stringify(_.omit(prevProps.layers, "onGridClick"))) {
      if (this.tileLayers) {
        ref = this.tileLayers;
        for (i = 0, len = ref.length; i < len; i++) {
          tileLayer = ref[i];
          this.map.removeLayer(tileLayer);
        }
        this.tileLayer = null;
      }
      if (this.utfGridLayers) {
        ref1 = this.utfGridLayers;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          utfGridLayer = ref1[j];
          this.map.removeLayer(utfGridLayer);
        }
        this.utfGridLayers = null;
      }
      if (this.props.layers) {
        this.tileLayers = [];
        ref2 = this.props.layers;
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          layer = ref2[k];
          if (!layer.visible || !layer.tileUrl) {
            continue;
          }
          options = {
            opacity: layer.opacity
          };
          if (layer.minZoom) {
            options.minZoom = layer.minZoom;
          }
          if (layer.maxZoom) {
            options.maxZoom = layer.maxZoom;
          }
          tileLayer = L.tileLayer(layer.tileUrl, options);
          this.tileLayers.push(tileLayer);
          this.map._zoomAnimated = false;
          this.map.addLayer(tileLayer);
          this.map._zoomAnimated = true;
          tileLayer._container.className += ' leaflet-zoom-hide';
        }
        this.utfGridLayers = [];
        ref3 = this.props.layers.slice().reverse();
        results = [];
        for (l = 0, len3 = ref3.length; l < len3; l++) {
          layer = ref3[l];
          if (!layer.visible) {
            continue;
          }
          if (layer.utfGridUrl) {
            utfGridLayer = new UtfGridLayer(layer.utfGridUrl, {
              useJsonP: false,
              minZoom: layer.minZoom || void 0,
              maxZoom: layer.maxZoom || void 0
            });
            this.map.addLayer(utfGridLayer);
            this.utfGridLayers.push(utfGridLayer);
            if (layer.onGridClick) {
              results.push((function(_this) {
                return function(layer) {
                  return utfGridLayer.on('click', function(ev) {
                    return layer.onGridClick(ev);
                  });
                };
              })(this)(layer));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        }
        return results;
      }
    }
  };

  LeafletMapComponent.prototype.render = function() {
    return H.div(null, this.props.legend && this.loaded ? React.cloneElement(this.props.legend, {
      zoom: this.map.getZoom()
    }) : void 0, H.div({
      ref: "map",
      style: {
        width: this.props.width,
        height: this.props.height
      }
    }));
  };

  return LeafletMapComponent;

})(React.Component);


},{"./BingLayer":1076,"./UtfGridLayer":1107,"leaflet":330,"leaflet-loading":329,"react":"react","react-dom":"react-dom"}],1088:[function(require,module,exports){
var H, LayerFactory, LegendComponent, R, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

LayerFactory = require('./LayerFactory');

module.exports = LegendComponent = (function(superClass) {
  extend(LegendComponent, superClass);

  function LegendComponent() {
    return LegendComponent.__super__.constructor.apply(this, arguments);
  }

  LegendComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    layerViews: React.PropTypes.array.isRequired,
    zoom: React.PropTypes.number
  };

  LegendComponent.prototype.render = function() {
    var legendItems, style;
    legendItems = _.compact(_.map(this.props.layerViews, (function(_this) {
      return function(layerView) {
        var design, layer, maxZoom, minZoom;
        layer = LayerFactory.createLayer(layerView.type);
        design = layer.cleanDesign(layerView.design, _this.props.schema);
        if (layer.validateDesign(design, _this.props.schema)) {
          return null;
        }
        if (!layerView.visible) {
          return null;
        }
        minZoom = layer.getMinZoom(design);
        maxZoom = layer.getMaxZoom(design);
        if ((minZoom != null) && (_this.props.zoom != null) && _this.props.zoom < minZoom) {
          return null;
        }
        if ((maxZoom != null) && (_this.props.zoom != null) && _this.props.zoom > maxZoom) {
          return null;
        }
        return {
          key: layerView.id,
          legend: layer.getLegend(design, _this.props.schema, layerView.name)
        };
      };
    })(this)));
    if (legendItems.length === 0) {
      return null;
    }
    style = {
      padding: 7,
      background: "rgba(255,255,255,0.8)",
      boxShadow: "0 0 15px rgba(0,0,0,0.2)",
      borderRadius: 5,
      position: 'absolute',
      right: 10,
      bottom: 35,
      maxHeight: '85%',
      overflowY: 'auto',
      zIndex: 1000,
      fontSize: 12
    };
    return H.div({
      style: style,
      className: "mwater-visualization-legend"
    }, _.map(legendItems, (function(_this) {
      return function(item, i) {
        return [
          H.div({
            key: item.key
          }, item.legend)
        ];
      };
    })(this)));
  };

  return LegendComponent;

})(React.Component);


},{"./LayerFactory":1085,"lodash":"lodash","react":"react"}],1089:[function(require,module,exports){
var H, LegendGroup, LegendItem, React, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

_ = require('lodash');

module.exports = LegendGroup = (function(superClass) {
  extend(LegendGroup, superClass);

  function LegendGroup() {
    return LegendGroup.__super__.constructor.apply(this, arguments);
  }

  LegendGroup.propTypes = {
    items: React.PropTypes.array,
    radiusLayer: React.PropTypes.bool,
    defaultColor: React.PropTypes.string,
    name: React.PropTypes.string,
    symbol: React.PropTypes.string
  };

  LegendGroup.defaultProps = {
    items: [],
    radiusLayer: false,
    symbol: null
  };

  LegendGroup.prototype.render = function() {
    return H.div({
      style: {
        marginBottom: 5
      }
    }, React.createElement(LegendItem, {
      hasChildren: this.props.items.length > 0,
      symbol: this.props.symbol,
      color: this.props.defaultColor,
      name: this.props.name,
      key: this.props.name,
      radiusLayer: this.props.radiusLayer
    }), _.map(this.props.items, (function(_this) {
      return function(item) {
        return React.createElement(LegendItem, {
          isChild: true,
          symbol: _this.props.symbol,
          color: item.color,
          name: item.name,
          key: item.name,
          radiusLayer: _this.props.radiusLayer
        });
      };
    })(this)));
  };

  return LegendGroup;

})(React.Component);

LegendItem = (function(superClass) {
  extend(LegendItem, superClass);

  function LegendItem() {
    return LegendItem.__super__.constructor.apply(this, arguments);
  }

  LegendItem.propTypes = {
    color: React.PropTypes.string,
    name: React.PropTypes.string,
    radiusLayer: React.PropTypes.bool,
    symbol: React.PropTypes.string,
    hasChildren: React.PropTypes.bool,
    isChild: React.PropTypes.bool
  };

  LegendItem.defaultProps = {
    radiusLayer: false,
    hasChildren: false,
    isChild: false
  };

  LegendItem.prototype.renderSymbol = function() {
    var className, symbolStyle;
    symbolStyle = {
      color: this.props.color,
      display: 'inline-block',
      marginRight: 4
    };
    className = this.props.symbol.replace('font-awesome/', 'fa fa-');
    return H.span({
      className: className,
      style: symbolStyle
    }, "");
  };

  LegendItem.prototype.renderColorIndicator = function() {
    var indicatorStyle;
    indicatorStyle = {
      height: 10,
      width: 10,
      backgroundColor: this.props.color,
      display: 'inline-block',
      marginRight: 4
    };
    if (this.props.radiusLayer) {
      indicatorStyle['borderRadius'] = 5;
    }
    return H.span({
      style: indicatorStyle
    }, "");
  };

  LegendItem.prototype.renderIndicator = function() {
    if (this.props.symbol) {
      return this.renderSymbol();
    } else {
      return this.renderColorIndicator();
    }
  };

  LegendItem.prototype.render = function() {
    var containerStyle, titleStyle;
    titleStyle = {};
    if (!this.props.isChild) {
      titleStyle = {
        margin: 2,
        fontWeight: 'bold'
      };
    }
    containerStyle = {
      paddingLeft: this.props.isChild ? 5 : 0
    };
    return H.div({
      style: containerStyle
    }, !this.props.hasChildren ? this.renderIndicator() : void 0, H.span({
      style: titleStyle
    }, this.props.name));
  };

  return LegendItem;

})(React.Component);


},{"lodash":"lodash","react":"react"}],1090:[function(require,module,exports){
var ExprCompiler, H, Layer, LoadingLegend, MWaterServerLayer, React, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

React = require('react');

H = React.DOM;

module.exports = MWaterServerLayer = (function(superClass) {
  extend(MWaterServerLayer, superClass);

  function MWaterServerLayer() {
    return MWaterServerLayer.__super__.constructor.apply(this, arguments);
  }

  MWaterServerLayer.prototype.onGridClick = function(ev, options) {
    if (ev.data && ev.data.id) {
      return {
        row: {
          tableId: options.design.table,
          primaryKey: ev.data.id
        }
      };
    }
    return null;
  };

  MWaterServerLayer.prototype.getMinZoom = function(design) {
    return design.minZoom;
  };

  MWaterServerLayer.prototype.getMaxZoom = function(design) {
    return design.maxZoom;
  };

  MWaterServerLayer.prototype.getLegend = function(design, schema) {
    var apiUrl;
    apiUrl = "https://api.mwater.co/v3/";
    return React.createElement(LoadingLegend, {
      url: apiUrl + "maps/legend?type=" + design.type
    });
  };

  MWaterServerLayer.prototype.getFilterableTables = function(design, schema) {
    if (design.table) {
      return [design.table];
    } else {
      return [];
    }
  };

  MWaterServerLayer.prototype.isEditable = function() {
    return false;
  };

  MWaterServerLayer.prototype.cleanDesign = function(design, schema) {
    return design;
  };

  MWaterServerLayer.prototype.validateDesign = function(design, schema) {
    return null;
  };

  return MWaterServerLayer;

})(Layer);

LoadingLegend = (function(superClass) {
  extend(LoadingLegend, superClass);

  LoadingLegend.propTypes = {
    url: React.PropTypes.string
  };

  function LoadingLegend() {
    LoadingLegend.__super__.constructor.apply(this, arguments);
    this.state = {
      html: "Loading..."
    };
  }

  LoadingLegend.prototype.componentDidMount = function() {
    return $.get(this.props.url).success((function(_this) {
      return function(data) {
        return _this.setState({
          html: data
        });
      };
    })(this));
  };

  LoadingLegend.prototype.componentWillReceiveProps = function(nextProps) {
    if (nextProps.url !== this.props.url) {
      return $.get(nextProps.url).success((function(_this) {
        return function(data) {
          return _this.setState({
            html: data
          });
        };
      })(this));
    }
  };

  LoadingLegend.prototype.render = function() {
    return H.div({
      style: {
        font: "14px/16px Arial, Helvetica, sans-serif",
        color: "#555"
      },
      dangerouslySetInnerHTML: {
        __html: this.state.html
      }
    });
  };

  return LoadingLegend;

})(React.Component);


},{"./Layer":1084,"mwater-expressions":14,"react":"react"}],1091:[function(require,module,exports){
var ExprCompiler, LayerFactory, MapBoundsCalculator, _, async;

_ = require('lodash');

async = require('async');

LayerFactory = require('./LayerFactory');

ExprCompiler = require('mwater-expressions').ExprCompiler;

module.exports = MapBoundsCalculator = (function() {
  function MapBoundsCalculator(schema, dataSource) {
    this.schema = schema;
    this.dataSource = dataSource;
  }

  MapBoundsCalculator.prototype.getBounds = function(design, filters, callback) {
    var allBounds, exprCompiler;
    exprCompiler = new ExprCompiler(this.schema);
    allBounds = [];
    return async.each(design.layerViews, (function(_this) {
      return function(layerView, cb) {
        var allFilters, expr, jsonql, layer, layerDesign, ref, table;
        if (!layerView.visible) {
          return cb(null);
        }
        layer = LayerFactory.createLayer(layerView.type);
        layerDesign = layer.cleanDesign(layerView.design, _this.schema);
        if (layer.validateDesign(layerDesign, _this.schema)) {
          return cb(null);
        }
        allFilters = (filters || []).slice();
        ref = design.filters || {};
        for (table in ref) {
          expr = ref[table];
          jsonql = exprCompiler.compileExpr({
            expr: expr,
            tableAlias: "{alias}"
          });
          allFilters.push({
            table: table,
            jsonql: jsonql
          });
        }
        return layer.getBounds(layerDesign, _this.schema, _this.dataSource, allFilters, function(error, bounds) {
          if (error) {
            return cb(error);
          }
          if (bounds) {
            allBounds.push(bounds);
          }
          return cb(null);
        });
      };
    })(this), (function(_this) {
      return function(error) {
        if (error) {
          return callback(error);
        }
        if (allBounds.length === 0) {
          return callback(null);
        }
        return callback(null, {
          n: _.max(allBounds, "n").n,
          e: _.max(allBounds, "e").e,
          s: _.min(allBounds, "s").s,
          w: _.min(allBounds, "w").w
        });
      };
    })(this));
  };

  return MapBoundsCalculator;

})();


},{"./LayerFactory":1085,"async":29,"lodash":"lodash","mwater-expressions":14}],1092:[function(require,module,exports){
var AutoSizeComponent, H, MapComponent, MapControlComponent, MapDesignerComponent, MapViewComponent, React, UndoStack, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

MapViewComponent = require('./MapViewComponent');

MapDesignerComponent = require('./MapDesignerComponent');

MapControlComponent = require('./MapControlComponent');

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

UndoStack = require('../UndoStack');

module.exports = MapComponent = (function(superClass) {
  extend(MapComponent, superClass);

  MapComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    mapDataSource: React.PropTypes.shape({
      getLayerDataSource: React.PropTypes.func.isRequired
    }).isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    onRowClick: React.PropTypes.func,
    titleElem: React.PropTypes.node,
    extraTitleButtonsElem: React.PropTypes.node
  };

  function MapComponent(props) {
    this.refMapView = bind(this.refMapView, this);
    this.handleDesignChange = bind(this.handleDesignChange, this);
    this.handleRedo = bind(this.handleRedo, this);
    this.handleUndo = bind(this.handleUndo, this);
    this.handlePrint = bind(this.handlePrint, this);
    MapComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      undoStack: new UndoStack().push(props.design),
      transientDesign: props.design
    };
  }

  MapComponent.prototype.componentWillReceiveProps = function(nextProps) {
    this.setState({
      undoStack: this.state.undoStack.push(nextProps.design)
    });
    if (!_.isEqual(nextProps.design, this.props.design)) {
      return this.setState({
        transientDesign: nextProps.design
      });
    }
  };

  MapComponent.prototype.handlePrint = function(scale) {
    return this.mapView.print(scale);
  };

  MapComponent.prototype.handleUndo = function() {
    var undoStack;
    undoStack = this.state.undoStack.undo();
    return this.setState({
      undoStack: undoStack
    }, (function(_this) {
      return function() {
        return _this.props.onDesignChange(undoStack.getValue());
      };
    })(this));
  };

  MapComponent.prototype.handleRedo = function() {
    var undoStack;
    undoStack = this.state.undoStack.redo();
    return this.setState({
      undoStack: undoStack
    }, (function(_this) {
      return function() {
        return _this.props.onDesignChange(undoStack.getValue());
      };
    })(this));
  };

  MapComponent.prototype.renderPrint = function() {
    return H.div({
      key: "print",
      className: "btn-group"
    }, H.button({
      type: "button",
      "data-toggle": "dropdown",
      className: "btn btn-link btn-sm dropdown-toggle"
    }, H.span({
      className: "glyphicon glyphicon-print"
    }), " Print ", H.span({
      className: "caret"
    })), H.ul({
      className: "dropdown-menu"
    }, H.li({
      key: "scale2"
    }, H.a({
      onClick: this.handlePrint.bind(null, 2)
    }, "Normal")), H.li({
      key: "scale3"
    }, H.a({
      onClick: this.handlePrint.bind(null, 3)
    }, "High-Resolution"))));
  };

  MapComponent.prototype.renderActionLinks = function() {
    return H.div(null, this.props.onDesignChange != null ? [
      H.a({
        key: "undo",
        className: "btn btn-link btn-sm " + (!this.state.undoStack.canUndo() ? "disabled" : ""),
        onClick: this.handleUndo
      }, H.span({
        className: "glyphicon glyphicon-triangle-left"
      }), " Undo"), " ", H.a({
        key: "redo",
        className: "btn btn-link btn-sm " + (!this.state.undoStack.canRedo() ? "disabled" : ""),
        onClick: this.handleRedo
      }, H.span({
        className: "glyphicon glyphicon-triangle-right"
      }), " Redo")
    ] : void 0, this.renderPrint(), this.props.extraTitleButtonsElem);
  };

  MapComponent.prototype.renderHeader = function() {
    return H.div({
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        height: 40,
        padding: 4,
        borderBottom: "solid 2px #AAA"
      }
    }, H.div({
      style: {
        float: "right"
      }
    }, this.renderActionLinks()), this.props.titleElem);
  };

  MapComponent.prototype.handleDesignChange = function(design) {
    if (this.props.onDesignChange) {
      return this.props.onDesignChange(design);
    } else {
      return this.setState({
        transientDesign: design
      });
    }
  };

  MapComponent.prototype.getDesign = function() {
    if (this.props.onDesignChange) {
      return this.props.design;
    } else {
      return this.state.transientDesign;
    }
  };

  MapComponent.prototype.refMapView = function(el) {
    return this.mapView = el;
  };

  MapComponent.prototype.renderView = function() {
    return React.createElement(AutoSizeComponent, {
      injectWidth: true,
      injectHeight: true
    }, React.createElement(MapViewComponent, {
      ref: this.refMapView,
      mapDataSource: this.props.mapDataSource,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.getDesign(),
      onDesignChange: this.handleDesignChange,
      onRowClick: this.props.onRowClick
    }));
  };

  MapComponent.prototype.renderDesigner = function() {
    if (this.props.onDesignChange) {
      return React.createElement(MapDesignerComponent, {
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        design: this.getDesign(),
        onDesignChange: this.handleDesignChange
      });
    } else {
      return React.createElement(MapControlComponent, {
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        design: this.getDesign(),
        onDesignChange: this.handleDesignChange
      });
    }
  };

  MapComponent.prototype.render = function() {
    return H.div({
      style: {
        width: "100%",
        height: "100%",
        position: "relative"
      }
    }, H.div({
      style: {
        position: "absolute",
        width: "70%",
        height: "100%",
        paddingTop: 40
      }
    }, this.renderHeader(), H.div({
      style: {
        width: "100%",
        height: "100%"
      }
    }, this.renderView())), H.div({
      style: {
        position: "absolute",
        left: "70%",
        width: "30%",
        height: "100%",
        borderLeft: "solid 3px #AAA",
        overflowY: "auto"
      }
    }, this.renderDesigner()));
  };

  return MapComponent;

})(React.Component);


},{"../UndoStack":1027,"./MapControlComponent":1093,"./MapDesignerComponent":1095,"./MapViewComponent":1100,"lodash":"lodash","react":"react","react-library/lib/AutoSizeComponent":783}],1093:[function(require,module,exports){
var BaseLayerDesignerComponent, H, MapControlComponent, MapLayersDesignerComponent, R, React,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

MapLayersDesignerComponent = require('./MapLayersDesignerComponent');

BaseLayerDesignerComponent = require('./BaseLayerDesignerComponent');

module.exports = MapControlComponent = (function(superClass) {
  extend(MapControlComponent, superClass);

  function MapControlComponent() {
    return MapControlComponent.__super__.constructor.apply(this, arguments);
  }

  MapControlComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  MapControlComponent.prototype.render = function() {
    return H.div({
      style: {
        padding: 5
      }
    }, R(MapLayersDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      allowEditingLayers: false
    }), H.br(), H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Map Style"), R(BaseLayerDesignerComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    })));
  };

  return MapControlComponent;

})(React.Component);


},{"./BaseLayerDesignerComponent":1075,"./MapLayersDesignerComponent":1098,"react":"react"}],1094:[function(require,module,exports){
var MapDataSource;

module.exports = MapDataSource = (function() {
  function MapDataSource() {}

  MapDataSource.prototype.getLayerDataSource = function(layerId) {
    throw new Error("Not implemented");
  };

  MapDataSource.prototype.getBounds = function(design, filters, callback) {
    return callback(null);
  };

  return MapDataSource;

})();


},{}],1095:[function(require,module,exports){
var AdvancedOptionsComponent, AttributionComponent, BaseLayerDesignerComponent, CheckboxComponent, ClickOutHandler, H, MapDesignerComponent, MapFiltersDesignerComponent, MapLayersDesignerComponent, MapUtils, NumberInputComponent, PopoverHelpComponent, R, React, TabbedComponent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

TabbedComponent = require('react-library/lib/TabbedComponent');

NumberInputComponent = require('react-library/lib/NumberInputComponent');

CheckboxComponent = require('../CheckboxComponent');

ClickOutHandler = require('react-onclickout');

MapLayersDesignerComponent = require('./MapLayersDesignerComponent');

MapFiltersDesignerComponent = require('./MapFiltersDesignerComponent');

BaseLayerDesignerComponent = require('./BaseLayerDesignerComponent');

PopoverHelpComponent = require('react-library/lib/PopoverHelpComponent');

MapUtils = require('./MapUtils');

module.exports = MapDesignerComponent = (function(superClass) {
  extend(MapDesignerComponent, superClass);

  function MapDesignerComponent() {
    this.handleConvertToClusterMap = bind(this.handleConvertToClusterMap, this);
    this.handleAutoBoundsChange = bind(this.handleAutoBoundsChange, this);
    this.handleAttributionChange = bind(this.handleAttributionChange, this);
    return MapDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  MapDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  MapDesignerComponent.prototype.handleAttributionChange = function(text) {
    var design;
    design = _.extend({}, this.props.design, {
      attribution: text
    });
    return this.props.onDesignChange(design);
  };

  MapDesignerComponent.prototype.handleAutoBoundsChange = function(value) {
    var design;
    design = _.extend({}, this.props.design, {
      autoBounds: value
    });
    return this.props.onDesignChange(design);
  };

  MapDesignerComponent.prototype.handleConvertToClusterMap = function() {
    return this.props.onDesignChange(MapUtils.convertToClusterMap(this.props.design));
  };

  MapDesignerComponent.prototype.renderOptionsTab = function() {
    return H.div(null, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Map Style"), R(BaseLayerDesignerComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    })), R(CheckboxComponent, {
      checked: this.props.design.autoBounds,
      onChange: this.handleAutoBoundsChange
    }, H.span({
      className: "text-muted"
    }, "Automatic zoom ", R(PopoverHelpComponent, {
      placement: "left"
    }, 'Automatically zoom to the complete data whenever the map is loaded or the filters change'))), MapUtils.canConvertToClusterMap(this.props.design) ? H.div({
      key: "tocluster"
    }, H.a({
      onClick: this.handleConvertToClusterMap,
      className: "btn btn-link btn-sm"
    }, "Convert to cluster map")) : void 0, R(AttributionComponent, {
      text: this.props.design.attribution,
      onTextChange: this.handleAttributionChange
    }), H.br(), R(AdvancedOptionsComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }));
  };

  MapDesignerComponent.prototype.render = function() {
    return H.div({
      style: {
        padding: 5
      }
    }, R(TabbedComponent, {
      initialTabId: "layers",
      tabs: [
        {
          id: "layers",
          label: [
            H.i({
              className: "fa fa-bars"
            }), " Layers"
          ],
          elem: R(MapLayersDesignerComponent, {
            schema: this.props.schema,
            dataSource: this.props.dataSource,
            design: this.props.design,
            onDesignChange: this.props.onDesignChange,
            allowEditingLayers: true
          })
        }, {
          id: "filters",
          label: [
            H.i({
              className: "fa fa-filter"
            }), " Filters"
          ],
          elem: R(MapFiltersDesignerComponent, {
            schema: this.props.schema,
            dataSource: this.props.dataSource,
            design: this.props.design,
            onDesignChange: this.props.onDesignChange
          })
        }, {
          id: "options",
          label: [
            H.i({
              className: "fa fa-cog"
            }), " Options"
          ],
          elem: this.renderOptionsTab()
        }
      ]
    }));
  };

  return MapDesignerComponent;

})(React.Component);

AttributionComponent = (function(superClass) {
  extend(AttributionComponent, superClass);

  AttributionComponent.propTypes = {
    text: React.PropTypes.string,
    onTextChange: React.PropTypes.func.isRequired
  };

  AttributionComponent.defaultProps = {
    text: null
  };

  function AttributionComponent() {
    this.handleTextClick = bind(this.handleTextClick, this);
    this.handleClickOut = bind(this.handleClickOut, this);
    this.handleTextChange = bind(this.handleTextChange, this);
    AttributionComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editing: false
    };
  }

  AttributionComponent.prototype.handleTextChange = function(e) {
    return this.props.onTextChange(e.target.value);
  };

  AttributionComponent.prototype.handleClickOut = function() {
    return this.setState({
      editing: false
    });
  };

  AttributionComponent.prototype.renderEditor = function() {
    return R(ClickOutHandler, {
      onClickOut: this.handleClickOut
    }, H.input({
      ref: "attributionInput",
      onChange: this.handleTextChange,
      value: this.props.text,
      className: 'form-control'
    }));
  };

  AttributionComponent.prototype.handleTextClick = function() {
    return this.setState({
      editing: true
    });
  };

  AttributionComponent.prototype.render = function() {
    var elem;
    elem = H.div({
      style: {
        marginLeft: 5
      }
    }, this.state.editing ? this.renderEditor() : this.props.text ? H.span({
      onClick: this.handleTextClick,
      style: {
        cursor: "pointer"
      }
    }, this.props.text) : H.a({
      onClick: this.handleTextClick,
      className: "btn btn-link btn-sm"
    }, "+ Add attribution"));
    if (this.props.text || this.state.editing) {
      elem = H.div({
        className: "form-group"
      }, H.label({
        className: "text-muted"
      }, "Attribution"), elem);
    }
    return elem;
  };

  return AttributionComponent;

})(React.Component);

AdvancedOptionsComponent = (function(superClass) {
  extend(AdvancedOptionsComponent, superClass);

  AdvancedOptionsComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  function AdvancedOptionsComponent(props) {
    AdvancedOptionsComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      expanded: false
    };
  }

  AdvancedOptionsComponent.prototype.render = function() {
    if (!this.state.expanded) {
      return H.div(null, H.a({
        className: "btn btn-link btn-xs",
        onClick: ((function(_this) {
          return function() {
            return _this.setState({
              expanded: true
            });
          };
        })(this))
      }, "Advanced options..."));
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Advanced"), H.div(null, H.span({
      className: "text-muted"
    }, "Maximum Zoom Level: "), " ", R(NumberInputComponent, {
      small: true,
      style: {
        display: "inline-block"
      },
      placeholder: "None",
      value: this.props.design.maxZoom,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onDesignChange(_.extend({}, _this.props.design, {
            maxZoom: v
          }));
        };
      })(this)
    })));
  };

  return AdvancedOptionsComponent;

})(React.Component);


},{"../CheckboxComponent":1015,"./BaseLayerDesignerComponent":1075,"./MapFiltersDesignerComponent":1096,"./MapLayersDesignerComponent":1098,"./MapUtils":1099,"react":"react","react-library/lib/NumberInputComponent":789,"react-library/lib/PopoverHelpComponent":790,"react-library/lib/TabbedComponent":792,"react-onclickout":812}],1096:[function(require,module,exports){
var ExprCleaner, ExprUtils, FilterExprComponent, FiltersDesignerComponent, H, LayerFactory, MapFiltersDesignerComponent, PopoverHelpComponent, R, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

PopoverHelpComponent = require('react-library/lib/PopoverHelpComponent');

FiltersDesignerComponent = require('../FiltersDesignerComponent');

LayerFactory = require('./LayerFactory');

module.exports = MapFiltersDesignerComponent = (function(superClass) {
  extend(MapFiltersDesignerComponent, superClass);

  function MapFiltersDesignerComponent() {
    this.handleFiltersChange = bind(this.handleFiltersChange, this);
    return MapFiltersDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  MapFiltersDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  MapFiltersDesignerComponent.prototype.handleFiltersChange = function(filters) {
    var design;
    design = _.extend({}, this.props.design, {
      filters: filters
    });
    return this.props.onDesignChange(design);
  };

  MapFiltersDesignerComponent.prototype.render = function() {
    var filterableTables, i, layer, layerView, len, ref;
    filterableTables = [];
    ref = this.props.design.layerViews;
    for (i = 0, len = ref.length; i < len; i++) {
      layerView = ref[i];
      layer = LayerFactory.createLayer(layerView.type);
      filterableTables = _.uniq(filterableTables.concat(layer.getFilterableTables(layerView.design, this.props.schema)));
    }
    filterableTables = _.filter(filterableTables, (function(_this) {
      return function(table) {
        return _this.props.schema.getTable(table);
      };
    })(this));
    if (filterableTables.length === 0) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Filters ", R(PopoverHelpComponent, {
      placement: "left"
    }, 'Filters all layers in the map. Individual layers can be filtered by clicking on Customize...')), H.div({
      style: {
        margin: 5
      }
    }, R(FiltersDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      filters: this.props.design.filters,
      onFiltersChange: this.handleFiltersChange,
      filterableTables: filterableTables
    })));
  };

  return MapFiltersDesignerComponent;

})(React.Component);


},{"../FiltersDesignerComponent":1019,"./LayerFactory":1085,"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/PopoverHelpComponent":790}],1097:[function(require,module,exports){
var ActionCancelModalComponent, H, LayerFactory, MapLayerViewDesignerComponent, Rcslider, React,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

Rcslider = require('rc-slider');

LayerFactory = require('./LayerFactory');

module.exports = MapLayerViewDesignerComponent = (function(superClass) {
  extend(MapLayerViewDesignerComponent, superClass);

  MapLayerViewDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    layerView: React.PropTypes.object.isRequired,
    onLayerViewChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired,
    connectDragSource: React.PropTypes.func,
    connectDragPreview: React.PropTypes.func,
    connectDropTarget: React.PropTypes.func,
    allowEditingLayer: React.PropTypes.bool.isRequired
  };

  function MapLayerViewDesignerComponent(props) {
    this.handleRemove = bind(this.handleRemove, this);
    this.handleOpacityChange = bind(this.handleOpacityChange, this);
    this.handleRename = bind(this.handleRename, this);
    this.handleSaveEditing = bind(this.handleSaveEditing, this);
    this.handleToggleEditing = bind(this.handleToggleEditing, this);
    this.handleVisibleClick = bind(this.handleVisibleClick, this);
    var layer;
    MapLayerViewDesignerComponent.__super__.constructor.call(this, props);
    layer = LayerFactory.createLayer(this.props.layerView.type);
    this.state = {
      editing: props.allowEditingLayer && layer.isIncomplete(this.props.layerView.design, this.props.schema)
    };
  }

  MapLayerViewDesignerComponent.prototype.update = function(updates) {
    return this.props.onLayerViewChange(_.extend({}, this.props.layerView, updates));
  };

  MapLayerViewDesignerComponent.prototype.handleVisibleClick = function(index) {
    return this.update({
      visible: !this.props.layerView.visible
    });
  };

  MapLayerViewDesignerComponent.prototype.handleToggleEditing = function() {
    return this.setState({
      editing: !this.state.editing
    });
  };

  MapLayerViewDesignerComponent.prototype.handleSaveEditing = function(design) {
    return this.update({
      design: design
    });
  };

  MapLayerViewDesignerComponent.prototype.handleRename = function() {
    var name;
    if (this.props.allowEditingLayer) {
      name = prompt("Enter new name", this.props.layerView.name);
      if (name) {
        return this.update({
          name: name
        });
      }
    }
  };

  MapLayerViewDesignerComponent.prototype.renderVisible = function() {
    if (this.props.layerView.visible) {
      return H.i({
        className: "fa fa-fw fa-check-square",
        style: {
          color: "#2E6DA4"
        },
        onClick: this.handleVisibleClick
      });
    } else {
      return H.i({
        className: "fa fa-fw fa-square",
        style: {
          color: "#DDDDDD"
        },
        onClick: this.handleVisibleClick
      });
    }
  };

  MapLayerViewDesignerComponent.prototype.renderName = function() {
    return H.span({
      className: "hover-display-parent",
      onClick: this.handleRename,
      style: {
        cursor: "pointer"
      }
    }, this.props.layerView.name, " ", H.span({
      className: "hover-display-child glyphicon glyphicon-pencil text-muted"
    }));
  };

  MapLayerViewDesignerComponent.prototype.renderEditor = function() {
    var layer;
    layer = LayerFactory.createLayer(this.props.layerView.type);
    return H.div(null, layer.isEditable() ? layer.createDesignerElement({
      design: this.props.layerView.design,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onDesignChange: this.handleSaveEditing
    }) : void 0, this.renderOpacityControl());
  };

  MapLayerViewDesignerComponent.prototype.renderLayerEditToggle = function() {
    return H.div({
      key: "edit",
      style: {
        marginBottom: (this.state.editing ? 10 : void 0)
      }
    }, H.a({
      onClick: this.handleToggleEditing,
      style: {
        fontSize: 12,
        cursor: "pointer"
      }
    }, this.state.editing ? [
      H.i({
        className: "fa fa-caret-up"
      }), " Close"
    ] : [
      H.i({
        className: "fa fa-cog"
      }), " Customize..."
    ]));
  };

  MapLayerViewDesignerComponent.prototype.handleOpacityChange = function(newValue) {
    return this.update({
      opacity: newValue / 100
    });
  };

  MapLayerViewDesignerComponent.prototype.handleRemove = function() {
    if (confirm("Delete layer?")) {
      return this.props.onRemove();
    }
  };

  MapLayerViewDesignerComponent.prototype.renderOpacityControl = function() {
    return H.div({
      className: 'form-group',
      style: {
        paddingTop: 10
      }
    }, H.label({
      className: 'text-muted'
    }, H.span(null, "Opacity: " + (Math.round(this.props.layerView.opacity * 100)) + "%")), H.div({
      style: {
        padding: '10px'
      }
    }, React.createElement(Rcslider, {
      min: 0,
      max: 100,
      step: 1,
      tipTransitionName: "rc-slider-tooltip-zoom-down",
      value: this.props.layerView.opacity * 100,
      onChange: this.handleOpacityChange
    })));
  };

  MapLayerViewDesignerComponent.prototype.renderDeleteLayer = function() {
    return H.div({
      style: {
        float: "right",
        cursor: "pointer",
        marginLeft: 10
      },
      key: "delete"
    }, H.a({
      onClick: this.handleRemove
    }, H.i({
      className: "fa fa-remove"
    })));
  };

  MapLayerViewDesignerComponent.prototype.render = function() {
    var layer, style;
    layer = LayerFactory.createLayer(this.props.layerView.type);
    style = {
      cursor: "move",
      marginRight: 8,
      opacity: 0.5
    };
    return this.props.connectDragPreview(this.props.connectDropTarget(H.div(null, H.div({
      style: {
        fontSize: 16
      },
      key: "layerView"
    }, this.props.connectDragSource ? this.props.connectDragSource(H.i({
      className: "fa fa-bars",
      style: style
    })) : void 0, this.props.allowEditingLayer ? this.renderDeleteLayer() : void 0, this.renderVisible(), "\u00A0", this.renderName()), this.props.allowEditingLayer ? this.renderLayerEditToggle() : void 0, this.state.editing ? this.renderEditor() : void 0)));
  };

  return MapLayerViewDesignerComponent;

})(React.Component);


},{"./LayerFactory":1085,"rc-slider":416,"react":"react","react-library/lib/ActionCancelModalComponent":781}],1098:[function(require,module,exports){
var AddLayerComponent, H, LayerFactory, MapLayerViewDesignerComponent, MapLayersDesignerComponent, R, React, ReorderableListComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

LayerFactory = require('./LayerFactory');

AddLayerComponent = require('./AddLayerComponent');

MapLayerViewDesignerComponent = require('./MapLayerViewDesignerComponent');

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

module.exports = MapLayersDesignerComponent = (function(superClass) {
  extend(MapLayersDesignerComponent, superClass);

  function MapLayersDesignerComponent() {
    this.renderLayerView = bind(this.renderLayerView, this);
    this.handleReorder = bind(this.handleReorder, this);
    this.handleRemoveLayerView = bind(this.handleRemoveLayerView, this);
    this.handleLayerViewChange = bind(this.handleLayerViewChange, this);
    return MapLayersDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  MapLayersDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired,
    allowEditingLayers: React.PropTypes.bool.isRequired
  };

  MapLayersDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  MapLayersDesignerComponent.prototype.handleLayerViewChange = function(index, layerView) {
    var layerViews;
    layerViews = this.props.design.layerViews.slice();
    layerViews[index] = layerView;
    if (layerView.group && layerView.visible) {
      _.each(this.props.design.layerViews, (function(_this) {
        return function(lv, i) {
          if (lv.visible && i !== index && lv.group === layerView.group) {
            return layerViews[i] = _.extend({}, lv, {
              visible: false
            });
          }
        };
      })(this));
    }
    return this.updateDesign({
      layerViews: layerViews
    });
  };

  MapLayersDesignerComponent.prototype.handleRemoveLayerView = function(index) {
    var layerViews;
    layerViews = this.props.design.layerViews.slice();
    layerViews.splice(index, 1);
    return this.updateDesign({
      layerViews: layerViews
    });
  };

  MapLayersDesignerComponent.prototype.handleReorder = function(layerList) {
    return this.updateDesign({
      layerViews: layerList
    });
  };

  MapLayersDesignerComponent.prototype.renderLayerView = function(layerView, index, connectDragSource, connectDragPreview, connectDropTarget) {
    var style;
    style = {
      padding: "10px 15px",
      border: "1px solid #ddd",
      marginBottom: -1,
      backgroundColor: "#fff"
    };
    return H.div({
      style: style
    }, React.createElement(MapLayerViewDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      layerView: layerView,
      onLayerViewChange: (function(_this) {
        return function(lv) {
          return _this.handleLayerViewChange(index, lv);
        };
      })(this),
      onRemove: (function(_this) {
        return function() {
          return _this.handleRemoveLayerView(index);
        };
      })(this),
      connectDragSource: connectDragSource,
      connectDragPreview: connectDragPreview,
      connectDropTarget: connectDropTarget,
      allowEditingLayer: this.props.allowEditingLayers
    }));
  };

  MapLayersDesignerComponent.prototype.render = function() {
    return H.div({
      className: "form-group"
    }, this.props.design.layerViews.length > 0 ? H.div({
      style: {
        padding: 5
      },
      key: "layers"
    }, H.div({
      className: "list-group",
      key: "layers",
      style: {
        marginBottom: 10
      }
    }, React.createElement(ReorderableListComponent, {
      items: this.props.design.layerViews,
      onReorder: this.handleReorder,
      renderItem: this.renderLayerView,
      getItemId: (function(_this) {
        return function(layerView) {
          return layerView.id;
        };
      })(this)
    }))) : void 0, this.props.allowEditingLayers ? R(AddLayerComponent, {
      key: "addlayer",
      layerNumber: this.props.design.layerViews.length,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }) : void 0);
  };

  return MapLayersDesignerComponent;

})(React.Component);


},{"./AddLayerComponent":1071,"./LayerFactory":1085,"./MapLayerViewDesignerComponent":1097,"lodash":"lodash","react":"react","react-library/lib/reorderable/ReorderableListComponent":795}],1099:[function(require,module,exports){
var _;

_ = require('lodash');

exports.canConvertToClusterMap = function(design) {
  return _.any(design.layerViews, function(lv) {
    return lv.type === "Markers";
  });
};

exports.convertToClusterMap = function(design) {
  var layerViews;
  layerViews = _.map(design.layerViews, (function(_this) {
    return function(lv) {
      var ref;
      if (lv.type !== "Markers") {
        return lv;
      }
      lv = _.cloneDeep(lv);
      lv.type = "Cluster";
      lv.design = {
        table: lv.design.table,
        axes: {
          geometry: (ref = lv.design.axes) != null ? ref.geometry : void 0
        },
        filter: lv.design.filter,
        fillColor: lv.design.color,
        minZoom: lv.design.minZoom,
        maxZoom: lv.design.maxZoom
      };
      return lv;
    };
  })(this));
  return _.extend({}, design, {
    layerViews: layerViews
  });
};


},{"lodash":"lodash"}],1100:[function(require,module,exports){
var ExprCompiler, ExprUtils, H, LayerFactory, LeafletMapComponent, LegendComponent, MapViewComponent, ModalPopupComponent, R, React, ReactElementPrinter, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

LeafletMapComponent = require('./LeafletMapComponent');

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCompiler = require('mwater-expressions').ExprCompiler;

LayerFactory = require('./LayerFactory');

ModalPopupComponent = require('react-library/lib/ModalPopupComponent');

ReactElementPrinter = require('react-library/lib/ReactElementPrinter');

LegendComponent = require('./LegendComponent');

module.exports = MapViewComponent = (function(superClass) {
  extend(MapViewComponent, superClass);

  MapViewComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    mapDataSource: React.PropTypes.shape({
      getLayerDataSource: React.PropTypes.func.isRequired,
      getBounds: React.PropTypes.func.isRequired
    }).isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    onRowClick: React.PropTypes.func,
    extraFilters: React.PropTypes.arrayOf(React.PropTypes.shape({
      table: React.PropTypes.string.isRequired,
      jsonql: React.PropTypes.object.isRequired
    })),
    scope: React.PropTypes.shape({
      name: React.PropTypes.string.isRequired,
      filter: React.PropTypes.shape({
        table: React.PropTypes.string.isRequired,
        jsonql: React.PropTypes.object.isRequired
      }),
      data: React.PropTypes.shape({
        layerViewId: React.PropTypes.string.isRequired,
        data: React.PropTypes.any
      }).isRequired
    }),
    onScopeChange: React.PropTypes.func,
    dragging: React.PropTypes.bool,
    touchZoom: React.PropTypes.bool,
    scrollWheelZoom: React.PropTypes.bool
  };

  function MapViewComponent(props) {
    this.handleGridClick = bind(this.handleGridClick, this);
    this.handleBoundsChange = bind(this.handleBoundsChange, this);
    this.print = bind(this.print, this);
    MapViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      popupContents: null
    };
  }

  MapViewComponent.prototype.print = function(scale) {
    var design, elem, printer;
    design = _.extend({}, this.props.design, {
      bounds: this.refs.leafletMap.getBounds()
    });
    elem = H.div({
      style: {
        transform: "rotate(90deg) translateY(-720px)",
        width: 0,
        height: 0
      }
    }, H.div({
      style: {
        transform: "scale(" + (1 / scale) + ")",
        transformOrigin: "top left"
      }
    }, H.style(null, '.leaflet-control-zoom { display: none; }\n@media print {\n  body { -webkit-print-color-adjust: exact; }\n}      '), R(MapViewComponent, _.extend({}, this.props, {
      width: 960 * scale,
      height: 720 * scale,
      design: design,
      onDesignChange: null
    }))));
    printer = new ReactElementPrinter();
    return printer.print(elem, {
      delay: 8000
    });
  };

  MapViewComponent.prototype.componentDidMount = function() {
    if (this.props.design.autoBounds) {
      return this.performAutoZoom();
    }
  };

  MapViewComponent.prototype.componentDidUpdate = function(prevProps) {
    var ref;
    if (this.props.design.autoBounds) {
      if (!_.isEqual(this.props.design.filters, prevProps.design.filters) || !_.isEqual(this.props.extraFilters, prevProps.extraFilters) || !prevProps.design.autoBounds) {
        return this.performAutoZoom();
      }
    } else {
      if (!_.isEqual(this.props.design.bounds, prevProps.design.bounds)) {
        return (ref = this.refs.leafletMap) != null ? ref.setBounds(this.props.design.bounds) : void 0;
      }
    }
  };

  MapViewComponent.prototype.performAutoZoom = function() {
    return this.props.mapDataSource.getBounds(this.props.design, this.getCompiledFilters(), (function(_this) {
      return function(error, bounds) {
        var ref;
        if (bounds) {
          if ((ref = _this.refs.leafletMap) != null) {
            ref.setBounds(bounds, 0.2);
          }
          if (_this.props.onDesignChange != null) {
            return _this.props.onDesignChange(_.extend({}, _this.props.design, {
              bounds: bounds
            }));
          }
        }
      };
    })(this));
  };

  MapViewComponent.prototype.handleBoundsChange = function(bounds) {
    var design;
    if (this.props.onDesignChange == null) {
      return;
    }
    if (this.props.design.autoBounds) {
      return;
    }
    design = _.extend({}, this.props.design, {
      bounds: bounds
    });
    return this.props.onDesignChange(design);
  };

  MapViewComponent.prototype.handleGridClick = function(layerViewId, ev) {
    var design, layer, layerView, ref, ref1, results, scope;
    layerView = _.findWhere(this.props.design.layerViews, {
      id: layerViewId
    });
    layer = LayerFactory.createLayer(layerView.type);
    design = layer.cleanDesign(layerView.design, this.props.schema);
    results = layer.onGridClick(ev, {
      design: design,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      layerDataSource: this.props.mapDataSource.getLayerDataSource(layerViewId),
      scopeData: ((ref = this.props.scope) != null ? (ref1 = ref.data) != null ? ref1.layerViewId : void 0 : void 0) === layerViewId ? this.props.scope.data.data : void 0,
      filters: this.getCompiledFilters()
    });
    if (!results) {
      return;
    }
    if (results.popup) {
      this.setState({
        popupContents: results.popup
      });
    }
    if (results.row && this.props.onRowClick) {
      this.props.onRowClick(results.row.tableId, results.row.primaryKey);
    }
    if (this.props.onScopeChange && _.has(results, "scope")) {
      if (results.scope) {
        scope = {
          name: results.scope.name,
          filter: results.scope.filter,
          data: {
            layerViewId: layerViewId,
            data: results.scope.data
          }
        };
      } else {
        scope = null;
      }
      return this.props.onScopeChange(scope);
    }
  };

  MapViewComponent.prototype.getCompiledFilters = function() {
    var compiledFilters, expr, exprCompiler, jsonql, ref, table;
    exprCompiler = new ExprCompiler(this.props.schema);
    compiledFilters = [];
    ref = this.props.design.filters || {};
    for (table in ref) {
      expr = ref[table];
      jsonql = exprCompiler.compileExpr({
        expr: expr,
        tableAlias: "{alias}"
      });
      compiledFilters.push({
        table: table,
        jsonql: jsonql
      });
    }
    if (this.props.extraFilters) {
      compiledFilters = compiledFilters.concat(this.props.extraFilters);
    }
    return compiledFilters;
  };

  MapViewComponent.prototype.renderLegend = function() {
    return R(LegendComponent, {
      schema: this.props.schema,
      layerViews: this.props.design.layerViews
    });
  };

  MapViewComponent.prototype.renderPopup = function() {
    if (!this.state.popupContents) {
      return null;
    }
    return R(ModalPopupComponent, {
      onClose: (function(_this) {
        return function() {
          return _this.setState({
            popupContents: null
          });
        };
      })(this),
      showCloseX: true,
      size: "large"
    }, this.state.popupContents, H.div({
      style: {
        textAlign: "right",
        marginTop: 10
      }
    }, H.button({
      className: "btn btn-default",
      onClick: ((function(_this) {
        return function() {
          return _this.setState({
            popupContents: null
          });
        };
      })(this))
    }, "Close")));
  };

  MapViewComponent.prototype.render = function() {
    var compiledFilters, design, i, index, isScoping, layer, layerDataSource, layerView, leafletLayer, leafletLayers, len, ref, scopedCompiledFilters;
    compiledFilters = this.getCompiledFilters();
    if (this.props.scope) {
      scopedCompiledFilters = compiledFilters.concat([this.props.scope.filter]);
    } else {
      scopedCompiledFilters = compiledFilters;
    }
    leafletLayers = [];
    ref = this.props.design.layerViews;
    for (index = i = 0, len = ref.length; i < len; index = ++i) {
      layerView = ref[index];
      layer = LayerFactory.createLayer(layerView.type);
      design = layer.cleanDesign(layerView.design, this.props.schema);
      if (layer.validateDesign(design, this.props.schema)) {
        continue;
      }
      layerDataSource = this.props.mapDataSource.getLayerDataSource(layerView.id);
      isScoping = this.props.scope && this.props.scope.data.layerViewId === layerView.id;
      leafletLayer = {
        tileUrl: layerDataSource.getTileUrl(design, isScoping ? compiledFilters : scopedCompiledFilters),
        utfGridUrl: layerDataSource.getUtfGridUrl(design, isScoping ? compiledFilters : scopedCompiledFilters),
        visible: layerView.visible,
        opacity: isScoping ? layerView.opacity * 0.3 : layerView.opacity,
        minZoom: layer.getMinZoom(design),
        maxZoom: layer.getMaxZoom(design),
        onGridClick: this.handleGridClick.bind(null, layerView.id)
      };
      leafletLayers.push(leafletLayer);
      if (isScoping) {
        leafletLayer = {
          tileUrl: layerDataSource.getTileUrl(design, scopedCompiledFilters),
          utfGridUrl: layerDataSource.getUtfGridUrl(design, scopedCompiledFilters),
          visible: layerView.visible,
          opacity: layerView.opacity,
          minZoom: layer.getMinZoom(design),
          maxZoom: layer.getMaxZoom(design),
          onGridClick: this.handleGridClick.bind(null, layerView.id)
        };
        leafletLayers.push(leafletLayer);
      }
    }
    return H.div({
      style: {
        width: this.props.width,
        height: this.props.height,
        position: 'relative'
      }
    }, this.renderPopup(), R(LeafletMapComponent, {
      ref: "leafletMap",
      initialBounds: this.props.design.bounds,
      baseLayerId: this.props.design.baseLayer,
      layers: leafletLayers,
      width: this.props.width,
      height: this.props.height,
      legend: this.renderLegend(),
      dragging: this.props.dragging,
      touchZoom: this.props.touchZoom,
      scrollWheelZoom: this.props.scrollWheelZoom,
      onBoundsChange: this.handleBoundsChange,
      extraAttribution: this.props.design.attribution,
      loadingSpinner: true,
      maxZoom: this.props.design.maxZoom
    }));
  };

  return MapViewComponent;

})(React.Component);


},{"./LayerFactory":1085,"./LeafletMapComponent":1087,"./LegendComponent":1088,"lodash":"lodash","mwater-expressions":14,"react":"react","react-library/lib/ModalPopupComponent":786,"react-library/lib/ReactElementPrinter":791}],1101:[function(require,module,exports){
var H, MarkerSymbolSelectComponent, R, React, ReactSelect, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ReactSelect = require('react-select');

module.exports = MarkerSymbolSelectComponent = (function(superClass) {
  extend(MarkerSymbolSelectComponent, superClass);

  function MarkerSymbolSelectComponent() {
    return MarkerSymbolSelectComponent.__super__.constructor.apply(this, arguments);
  }

  MarkerSymbolSelectComponent.propTypes = {
    symbol: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired
  };

  MarkerSymbolSelectComponent.prototype.render = function() {
    var optionRenderer, options;
    options = [
      {
        value: "font-awesome/dot-circle-o",
        label: "Dot circle"
      }, {
        value: "font-awesome/bullseye",
        label: "Bullseye"
      }, {
        value: "font-awesome/star",
        label: "Star"
      }, {
        value: "font-awesome/square",
        label: "Square"
      }, {
        value: "font-awesome/home",
        label: "Home"
      }, {
        value: "font-awesome/plus",
        label: "Plus"
      }, {
        value: "font-awesome/plus-circle",
        label: "Plus Circle"
      }, {
        value: "font-awesome/plus-square",
        label: "Plus Square"
      }, {
        value: "font-awesome/asterisk",
        label: "Asterisk"
      }, {
        value: "font-awesome/mobile",
        label: "Mobile"
      }, {
        value: "font-awesome/check",
        label: "Check"
      }, {
        value: "font-awesome/university",
        label: "Institution"
      }, {
        value: "font-awesome/check-circle",
        label: "Check Circle"
      }, {
        value: "font-awesome/times",
        label: "Removed"
      }, {
        value: "font-awesome/ban",
        label: "Ban"
      }, {
        value: "font-awesome/crosshairs",
        label: "Crosshairs"
      }, {
        value: "font-awesome/flask",
        label: "Flask"
      }, {
        value: "font-awesome/flag",
        label: "Flag"
      }, {
        value: "font-awesome/info-circle",
        label: "Info Circle"
      }, {
        value: "font-awesome/exclamation-circle",
        label: "Exclamation Circle"
      }, {
        value: "font-awesome/exclamation-triangle",
        label: "Exclamation Triangle"
      }, {
        value: "font-awesome/bell",
        label: "Bell"
      }, {
        value: "font-awesome/bolt",
        label: "Bolt"
      }, {
        value: "font-awesome/building",
        label: "Building"
      }, {
        value: "font-awesome/bus",
        label: "Bus"
      }, {
        value: "font-awesome/certificate",
        label: "Certificate"
      }, {
        value: "font-awesome/comment",
        label: "Comment"
      }, {
        value: "font-awesome/male",
        label: "Male"
      }, {
        value: "font-awesome/female",
        label: "Female"
      }, {
        value: "font-awesome/user",
        label: "Person"
      }, {
        value: "font-awesome/users",
        label: "Group"
      }, {
        value: "font-awesome/wheelchair",
        label: "Wheelchair"
      }, {
        value: "font-awesome/h-square",
        label: "Hospital Symbol"
      }, {
        value: "font-awesome/thumbs-up",
        label: "Thumbs Up"
      }, {
        value: "font-awesome/thumbs-down",
        label: "Thumbs Down"
      }, {
        value: "font-awesome/ticket",
        label: "Ticket"
      }, {
        value: "font-awesome/tint",
        label: "Tint"
      }, {
        value: "font-awesome/times-circle",
        label: "Times Circle"
      }, {
        value: "font-awesome/tree",
        label: "Tree"
      }, {
        value: "font-awesome/file",
        label: "File"
      }, {
        value: "font-awesome/usd",
        label: "USD"
      }, {
        value: "font-awesome/caret-up",
        label: "Caret Up"
      }, {
        value: "font-awesome/chevron-circle-up",
        label: "Chevron Up"
      }, {
        value: "font-awesome/chevron-circle-down",
        label: "Chevron Down"
      }, {
        value: "font-awesome/medkit",
        label: "Medkit"
      }, {
        value: "font-awesome/cloud",
        label: "Cloud"
      }, {
        value: "font-awesome/beer",
        label: "Cup"
      }
    ];
    optionRenderer = function(option) {
      return H.span(null, H.i({
        className: "fa fa-" + (option.value.substr(13))
      }), " " + option.label);
    };
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "fa fa-star"
    }), " ", "Symbol"), R(ReactSelect, {
      placeholder: "Circle",
      value: this.props.symbol,
      options: options,
      optionRenderer: optionRenderer,
      valueRenderer: optionRenderer,
      onChange: this.props.onChange
    }));
  };

  return MarkerSymbolSelectComponent;

})(React.Component);


},{"lodash":"lodash","react":"react","react-select":818}],1102:[function(require,module,exports){
var AxisBuilder, ExprCleaner, ExprCompiler, ExprUtils, H, Layer, LayerLegendComponent, LegendGroup, MarkersLayer, React, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

React = require('react');

H = React.DOM;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');

LayerLegendComponent = require('./LayerLegendComponent');


/*
Layer that is composed of markers
Design is:
  table: table to get data from
  axes: axes (see below)
  filter: optional logical expression to filter by
  color: color of layer (e.g. #FF8800). Color axis overrides
  symbol: symbol to use for layer. e.g. "font-awesome/bell". Will be converted on server to proper uri.
  popup: contains items: which is BlocksLayoutManager items. Will be displayed when the marker is clicked
  minZoom: minimum zoom level
  maxZoom: maximum zoom level

LEGACY: sublayers array that contains above design

axes:
  geometry: where to place markers
  color: color axis (to split into series based on a color)
 */

module.exports = MarkersLayer = (function(superClass) {
  extend(MarkersLayer, superClass);

  function MarkersLayer() {
    return MarkersLayer.__super__.constructor.apply(this, arguments);
  }

  MarkersLayer.prototype.getJsonQLCss = function(design, schema, filters) {
    var layerDef;
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createJsonQL(design, schema, filters)
        }
      ],
      css: this.createCss(design, schema),
      interactivity: {
        layer: "layer0",
        fields: ["id"]
      }
    };
    return layerDef;
  };

  MarkersLayer.prototype.createJsonQL = function(design, schema, filters) {
    var axisBuilder, cluster, colorExpr, exprCompiler, filter, geometryExpr, i, innerquery, len, outerquery, relevantFilters, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);
    geometryExpr = axisBuilder.compileAxis({
      axis: design.axes.geometry,
      tableAlias: "innerquery"
    });
    geometryExpr = {
      type: "op",
      op: "ST_Transform",
      exprs: [geometryExpr, 3857]
    };
    cluster = {
      type: "select",
      expr: {
        type: "op",
        op: "row_number",
        exprs: []
      },
      over: {
        partitionBy: [
          {
            type: "op",
            op: "ST_SnapToGrid",
            exprs: [
              geometryExpr, {
                type: "op",
                op: "*",
                exprs: [
                  {
                    type: "token",
                    token: "!pixel_width!"
                  }, 5
                ]
              }, {
                type: "op",
                op: "*",
                exprs: [
                  {
                    type: "token",
                    token: "!pixel_height!"
                  }, 5
                ]
              }
            ]
          }
        ]
      },
      alias: "r"
    };
    innerquery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: schema.getTable(design.table).primaryKey
          },
          alias: "id"
        }, {
          type: "select",
          expr: geometryExpr,
          alias: "the_geom_webmercator"
        }, cluster
      ],
      from: exprCompiler.compileTable(design.table, "innerquery")
    };
    if (design.axes.color) {
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "innerquery"
      });
      innerquery.selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
    }
    whereClauses = [
      {
        type: "op",
        op: "&&",
        exprs: [
          geometryExpr, {
            type: "token",
            token: "!bbox!"
          }
        ]
      }
    ];
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "innerquery"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (i = 0, len = relevantFilters.length; i < len; i++) {
      filter = relevantFilters[i];
      whereClauses.push(injectTableAlias(filter.jsonql, "innerquery"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      innerquery.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      innerquery.where = whereClauses[0];
    }
    outerquery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "op",
            op: "::text",
            exprs: [
              {
                type: "field",
                tableAlias: "innerquery",
                column: "id"
              }
            ]
          },
          alias: "id"
        }, {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: "the_geom_webmercator"
          },
          alias: "the_geom_webmercator"
        }
      ],
      from: {
        type: "subquery",
        query: innerquery,
        alias: "innerquery"
      },
      where: {
        type: "op",
        op: "<=",
        exprs: [
          {
            type: "field",
            tableAlias: "innerquery",
            column: "r"
          }, 3
        ]
      }
    };
    if (design.axes.color) {
      outerquery.selects.push({
        type: "select",
        expr: {
          type: "field",
          tableAlias: "innerquery",
          column: "color"
        },
        alias: "color"
      });
    }
    return outerquery;
  };

  MarkersLayer.prototype.createCss = function(design, schema) {
    var css, i, item, len, ref, stroke, symbol;
    css = "";
    if (design.symbol) {
      symbol = "marker-file: url(" + design.symbol + ");";
      stroke = "marker-line-width: 60;";
    } else {
      symbol = "marker-type: ellipse;";
      stroke = "marker-line-width: 1;";
    }
    css += '#layer0 {\n  marker-fill: ' + (design.color || "#666666") + ';\nmarker-width: 10;\nmarker-line-color: white;' + stroke + 'marker-line-opacity: 0.6;\nmarker-placement: point;' + symbol + '  marker-allow-overlap: true;\n}\n';
    if (design.axes.color && design.axes.color.colorMap) {
      ref = design.axes.color.colorMap;
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (_.includes(design.axes.color.excludedValues, item.value)) {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { marker-line-opacity: 0; marker-fill-opacity: 0; }\n";
        } else {
          css += "#layer0 [color=" + (JSON.stringify(item.value)) + "] { marker-fill: " + item.color + " }\n";
        }
      }
    }
    return css;
  };

  MarkersLayer.prototype.onGridClick = function(ev, clickOptions) {
    var BlocksLayoutManager, WidgetFactory, filter, ids, ref, results, table;
    if (ev.data && ev.data.id) {
      table = clickOptions.design.table;
      results = {};
      if (ev.event.originalEvent.shiftKey) {
        ids = clickOptions.scopeData || [];
        if (ref = ev.data.id, indexOf.call(ids, ref) >= 0) {
          ids = _.without(ids, ev.data.id);
        } else {
          ids = ids.concat([ev.data.id]);
        }
        filter = {
          table: table,
          jsonql: {
            type: "op",
            op: "=",
            modifier: "any",
            exprs: [
              {
                type: "field",
                tableAlias: "{alias}",
                column: clickOptions.schema.getTable(table).primaryKey
              }, {
                type: "literal",
                value: ids
              }
            ]
          }
        };
        if (ids.length > 0) {
          results.scope = {
            name: "Selected " + ids.length + " Markers(s)",
            filter: filter,
            data: ids
          };
        } else {
          results.scope = null;
        }
      }
      if (clickOptions.design.popup && !ev.event.originalEvent.shiftKey) {
        BlocksLayoutManager = require('../layouts/blocks/BlocksLayoutManager');
        WidgetFactory = require('../widgets/WidgetFactory');
        results.popup = new BlocksLayoutManager().renderLayout({
          items: clickOptions.design.popup.items,
          style: "popup",
          renderWidget: (function(_this) {
            return function(options) {
              var filters, widget, widgetDataSource;
              widget = WidgetFactory.createWidget(options.type);
              filter = {
                table: table,
                jsonql: {
                  type: "op",
                  op: "=",
                  exprs: [
                    {
                      type: "field",
                      tableAlias: "{alias}",
                      column: clickOptions.schema.getTable(table).primaryKey
                    }, {
                      type: "literal",
                      value: ev.data.id
                    }
                  ]
                }
              };
              filters = clickOptions.filters.concat([filter]);
              widgetDataSource = clickOptions.layerDataSource.getPopupWidgetDataSource(clickOptions.design, options.id);
              return widget.createViewElement({
                schema: clickOptions.schema,
                dataSource: clickOptions.dataSource,
                widgetDataSource: widgetDataSource,
                design: options.design,
                scope: null,
                filters: filters,
                onScopeChange: null,
                onDesignChange: null,
                width: options.width,
                height: options.height,
                standardWidth: options.standardWidth
              });
            };
          })(this)
        });
      } else if (!ev.event.originalEvent.shiftKey) {
        results.row = {
          tableId: table,
          primaryKey: ev.data.id
        };
      }
      return results;
    } else {
      return null;
    }
  };

  MarkersLayer.prototype.getBounds = function(design, schema, dataSource, filters, callback) {
    return this.getBoundsFromExpr(schema, dataSource, design.table, design.axes.geometry.expr, design.filter, filters, callback);
  };

  MarkersLayer.prototype.getMinZoom = function(design) {
    return design.minZoom;
  };

  MarkersLayer.prototype.getMaxZoom = function(design) {
    return design.maxZoom;
  };

  MarkersLayer.prototype.getLegend = function(design, schema, name) {
    var axisBuilder;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    return React.createElement(LayerLegendComponent, {
      schema: schema,
      defaultColor: design.color,
      symbol: design.symbol || 'font-awesome/circle',
      name: name,
      axis: axisBuilder.cleanAxis({
        axis: design.axes.color,
        table: design.table,
        types: ['enum', 'text', 'boolean', 'date'],
        aggrNeed: "none"
      })
    });
  };

  MarkersLayer.prototype.getFilterableTables = function(design, schema) {
    if (design.table) {
      return [design.table];
    } else {
      return [];
    }
  };

  MarkersLayer.prototype.isEditable = function() {
    return true;
  };

  MarkersLayer.prototype.createDesignerElement = function(options) {
    var MarkersLayerDesignerComponent;
    MarkersLayerDesignerComponent = require('./MarkersLayerDesignerComponent');
    return React.createElement(MarkersLayerDesignerComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          return options.onDesignChange(_this.cleanDesign(design, options.schema));
        };
      })(this)
    });
  };

  MarkersLayer.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner, ref;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    if ((ref = design.sublayers) != null ? ref[0] : void 0) {
      design = _.extend({}, design, design.sublayers[0]);
    }
    delete design.sublayers;
    design.axes = design.axes || {};
    design.color = design.color || "#0088FF";
    design.axes.geometry = axisBuilder.cleanAxis({
      axis: design.axes.geometry,
      table: design.table,
      types: ['geometry'],
      aggrNeed: "none"
    });
    design.axes.color = axisBuilder.cleanAxis({
      axis: design.axes.color,
      table: design.table,
      types: ['enum', 'text', 'boolean', 'date'],
      aggrNeed: "none"
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table
    });
    return design;
  };

  MarkersLayer.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing table";
    }
    if (!design.axes || !design.axes.geometry) {
      return "Missing axes";
    }
    error = axisBuilder.validateAxis({
      axis: design.axes.geometry
    });
    if (error) {
      return error;
    }
    return null;
  };

  MarkersLayer.prototype.createKMLExportJsonQL = function(design, schema, filters) {
    var axisBuilder, colorExpr, column, exprCompiler, extraFields, field, filter, geometryExpr, i, innerquery, j, len, len1, relevantFilters, valueExpr, whereClauses;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    exprCompiler = new ExprCompiler(schema);
    geometryExpr = axisBuilder.compileAxis({
      axis: design.axes.geometry,
      tableAlias: "innerquery"
    });
    geometryExpr = {
      type: "op",
      op: "ST_Transform",
      exprs: [geometryExpr, 4326]
    };
    innerquery = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: schema.getTable(design.table).primaryKey
          },
          alias: "id"
        }, {
          type: "select",
          expr: {
            type: "op",
            op: "ST_X",
            exprs: [geometryExpr]
          },
          alias: "longitude"
        }, {
          type: "select",
          expr: {
            type: "op",
            op: "ST_Y",
            exprs: [geometryExpr]
          },
          alias: "latitude"
        }
      ],
      from: exprCompiler.compileTable(design.table, "innerquery")
    };
    extraFields = ["code", "name", "desc", "type", "photos"];
    for (i = 0, len = extraFields.length; i < len; i++) {
      field = extraFields[i];
      column = schema.getColumn(design.table, field);
      if (column) {
        innerquery.selects.push({
          type: "select",
          expr: {
            type: "field",
            tableAlias: "innerquery",
            column: field
          },
          alias: field
        });
      }
    }
    if (design.axes.color) {
      colorExpr = axisBuilder.compileAxis({
        axis: design.axes.color,
        tableAlias: "innerquery"
      });
      valueExpr = exprCompiler.compileExpr({
        expr: design.axes.color.expr,
        tableAlias: "innerquery"
      });
      innerquery.selects.push({
        type: "select",
        expr: colorExpr,
        alias: "color"
      });
      innerquery.selects.push({
        type: "select",
        expr: valueExpr,
        alias: "value"
      });
    }
    whereClauses = [];
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "innerquery"
      }));
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    for (j = 0, len1 = relevantFilters.length; j < len1; j++) {
      filter = relevantFilters[j];
      whereClauses.push(injectTableAlias(filter.jsonql, "innerquery"));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      innerquery.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      innerquery.where = whereClauses[0];
    }
    return innerquery;
  };

  MarkersLayer.prototype.createKMLExportStyleInfo = function(design, schema, filters) {
    var style, symbol;
    if (design.symbol) {
      symbol = design.symbol;
    } else {
      symbol = "font-awesome/circle";
    }
    style = {
      color: design.color,
      symbol: symbol
    };
    if (design.axes.color && design.axes.color.colorMap) {
      style.colorMap = design.axes.color.colorMap;
    }
    return style;
  };

  MarkersLayer.prototype.getKMLExportJsonQL = function(design, schema, filters) {
    var layerDef;
    layerDef = {
      layers: [
        {
          id: "layer0",
          jsonql: this.createKMLExportJsonQL(design, schema, filters),
          style: this.createKMLExportStyleInfo(design, schema, filters)
        }
      ]
    };
    return layerDef;
  };

  MarkersLayer.prototype.acceptKmlVisitorForRow = function(visitor, row) {
    return visitor.addPoint(row.latitude, row.longitude, row.name, visitor.buildDescription(row), row.color);
  };

  return MarkersLayer;

})(Layer);


},{"../axes/AxisBuilder":1029,"../layouts/blocks/BlocksLayoutManager":1060,"../widgets/WidgetFactory":1128,"./Layer":1084,"./LayerLegendComponent":1086,"./LegendGroup":1089,"./MarkersLayerDesignerComponent":1103,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1103:[function(require,module,exports){
var AxisComponent, ColorComponent, EditPopupComponent, ExprUtils, FilterExprComponent, H, MarkerSymbolSelectComponent, MarkersLayerDesignerComponent, R, React, ReactSelect, TableSelectComponent, ZoomLevelsComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisComponent = require('./../axes/AxisComponent');

ColorComponent = require('../ColorComponent');

TableSelectComponent = require('../TableSelectComponent');

ReactSelect = require('react-select');

EditPopupComponent = require('./EditPopupComponent');

ZoomLevelsComponent = require('./ZoomLevelsComponent');

MarkerSymbolSelectComponent = require('./MarkerSymbolSelectComponent');

module.exports = MarkersLayerDesignerComponent = (function(superClass) {
  extend(MarkersLayerDesignerComponent, superClass);

  function MarkersLayerDesignerComponent() {
    this.handleNameChange = bind(this.handleNameChange, this);
    this.handleSymbolChange = bind(this.handleSymbolChange, this);
    this.handleColorChange = bind(this.handleColorChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleColorAxisChange = bind(this.handleColorAxisChange, this);
    this.handleGeometryAxisChange = bind(this.handleGeometryAxisChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    return MarkersLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  MarkersLayerDesignerComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  MarkersLayerDesignerComponent.prototype.update = function(updates) {
    return this.props.onDesignChange(_.extend({}, this.props.design, updates));
  };

  MarkersLayerDesignerComponent.prototype.updateAxes = function(changes) {
    var axes;
    axes = _.extend({}, this.props.design.axes, changes);
    return this.update({
      axes: axes
    });
  };

  MarkersLayerDesignerComponent.prototype.handleTableChange = function(table) {
    return this.update({
      table: table
    });
  };

  MarkersLayerDesignerComponent.prototype.handleGeometryAxisChange = function(axis) {
    return this.updateAxes({
      geometry: axis
    });
  };

  MarkersLayerDesignerComponent.prototype.handleColorAxisChange = function(axis) {
    return this.updateAxes({
      color: axis
    });
  };

  MarkersLayerDesignerComponent.prototype.handleFilterChange = function(expr) {
    return this.update({
      filter: expr
    });
  };

  MarkersLayerDesignerComponent.prototype.handleColorChange = function(color) {
    return this.update({
      color: color
    });
  };

  MarkersLayerDesignerComponent.prototype.handleSymbolChange = function(symbol) {
    return this.update({
      symbol: symbol
    });
  };

  MarkersLayerDesignerComponent.prototype.handleNameChange = function(e) {
    return this.update({
      name: e.target.value
    });
  };

  MarkersLayerDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), H.div({
      style: {
        marginLeft: 10
      }
    }, R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    })));
  };

  MarkersLayerDesignerComponent.prototype.renderGeometryAxis = function() {
    var title;
    if (!this.props.design.table) {
      return;
    }
    title = H.span(null, H.span({
      className: "glyphicon glyphicon-map-marker"
    }), " Marker Position");
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, title), H.div({
      style: {
        marginLeft: 10
      }
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["geometry"],
      aggrNeed: "none",
      value: this.props.design.axes.geometry,
      onChange: this.handleGeometryAxisChange
    })));
  };

  MarkersLayerDesignerComponent.prototype.renderColor = function() {
    if (!this.props.design.axes.geometry) {
      return;
    }
    return H.div(null, !this.props.design.axes.color ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Marker Color"), H.div(null, R(ColorComponent, {
      color: this.props.design.color,
      onChange: this.handleColorChange
    }))) : void 0, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon glyphicon-tint"
    }), "Color By Data"), R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["text", "enum", "boolean", 'date'],
      aggrNeed: "none",
      value: this.props.design.axes.color,
      defaultColor: this.props.design.color,
      showColorMap: true,
      onChange: this.handleColorAxisChange,
      allowExcludedValues: true
    })));
  };

  MarkersLayerDesignerComponent.prototype.renderSymbol = function() {
    if (!this.props.design.axes.geometry) {
      return;
    }
    return R(MarkerSymbolSelectComponent, {
      symbol: this.props.design.symbol,
      onChange: this.handleSymbolChange
    });
  };

  MarkersLayerDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.axes.geometry) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  MarkersLayerDesignerComponent.prototype.renderPopup = function() {
    if (!this.props.design.table) {
      return null;
    }
    return R(EditPopupComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table
    });
  };

  MarkersLayerDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderGeometryAxis(), this.renderColor(), this.renderSymbol(), this.renderFilter(), this.renderPopup(), this.props.design.table ? R(ZoomLevelsComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange
    }) : void 0);
  };

  return MarkersLayerDesignerComponent;

})(React.Component);


},{"../ColorComponent":1016,"../TableSelectComponent":1025,"./../axes/AxisComponent":1031,"./EditPopupComponent":1083,"./MarkerSymbolSelectComponent":1101,"./ZoomLevelsComponent":1108,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-select":818}],1104:[function(require,module,exports){
var H, IdLiteralComponent, R, React, RegionSelectComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

IdLiteralComponent = require('mwater-expressions-ui').IdLiteralComponent;

module.exports = RegionSelectComponent = (function(superClass) {
  extend(RegionSelectComponent, superClass);

  function RegionSelectComponent() {
    this.handleChange = bind(this.handleChange, this);
    return RegionSelectComponent.__super__.constructor.apply(this, arguments);
  }

  RegionSelectComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    region: React.PropTypes.string,
    onChange: React.PropTypes.func.isRequired,
    placeholder: React.PropTypes.string
  };

  RegionSelectComponent.defaultProps = {
    placeholder: "All Countries"
  };

  RegionSelectComponent.prototype.handleChange = function(id) {
    var query;
    if (!id) {
      this.props.onChange(null, null);
      return;
    }
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: {
            type: "field",
            tableAlias: "main",
            column: "level"
          },
          alias: "level"
        }
      ],
      from: {
        type: "table",
        table: "admin_regions",
        alias: "main"
      },
      where: {
        type: "op",
        op: "=",
        exprs: [
          {
            type: "field",
            tableAlias: "main",
            column: "_id"
          }, id
        ]
      }
    };
    return this.props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err) {
          console.log("Error getting regions: " + (err != null ? err.message : void 0));
          return;
        }
        return _this.props.onChange(id, rows[0].level);
      };
    })(this));
  };

  RegionSelectComponent.prototype.render = function() {
    return R(IdLiteralComponent, {
      value: this.props.region,
      onChange: this.handleChange,
      idTable: "admin_regions",
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      placeholder: this.props.placeholder,
      orderBy: [
        {
          expr: {
            type: "field",
            tableAlias: "main",
            column: "level"
          },
          direction: "asc"
        }
      ]
    });
  };

  return RegionSelectComponent;

})(React.Component);


},{"lodash":"lodash","mwater-expressions-ui":362,"react":"react"}],1105:[function(require,module,exports){
var LayerFactory, MapDataSource, ServerLayerDataSource, ServerMapDataSource, ServerMapLayerPopupWidgetDataSource, _, injectTableAlias, querystring,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

querystring = require('querystring');

MapDataSource = require('./MapDataSource');

LayerFactory = require('./LayerFactory');

injectTableAlias = require('mwater-expressions').injectTableAlias;

module.exports = ServerMapDataSource = (function(superClass) {
  extend(ServerMapDataSource, superClass);

  function ServerMapDataSource(options) {
    this.options = options;
  }

  ServerMapDataSource.prototype.getLayerDataSource = function(layerId) {
    var layerView;
    layerView = _.findWhere(this.options.design.layerViews, {
      id: layerId
    });
    if (!layerView) {
      return null;
    }
    return new ServerLayerDataSource(_.extend({}, this.options, {
      layerView: layerView
    }));
  };

  ServerMapDataSource.prototype.getBounds = function(design, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev
    };
    url = this.options.apiUrl + ("maps/" + this.options.mapId + "/bounds?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  return ServerMapDataSource;

})(MapDataSource);

ServerLayerDataSource = (function() {
  function ServerLayerDataSource(options) {
    this.options = options;
  }

  ServerLayerDataSource.prototype.getTileUrl = function(design, filters) {
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(design, "png", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return design.tileUrl;
    }
    return this.createUrl(filters, "png");
  };

  ServerLayerDataSource.prototype.getUtfGridUrl = function(design, filters) {
    if (this.options.layerView.type === "MWaterServer") {
      return this.createLegacyUrl(design, "grid.json", filters);
    }
    if (this.options.layerView.type === "TileUrl") {
      return null;
    }
    return this.createUrl(filters, "grid.json");
  };

  ServerLayerDataSource.prototype.getPopupWidgetDataSource = function(design, widgetId) {
    return new ServerMapLayerPopupWidgetDataSource({
      apiUrl: this.options.apiUrl,
      client: this.options.client,
      share: this.options.share,
      mapId: this.options.mapId,
      rev: this.options.rev,
      layerId: this.options.layerView.id,
      popupWidgetId: widgetId
    });
  };

  ServerLayerDataSource.prototype.createUrl = function(filters, extension) {
    var query, url;
    query = {
      type: "maps",
      client: this.options.client,
      share: this.options.share,
      map: this.options.mapId,
      layer: this.options.layerView.id,
      filters: JSON.stringify(filters || []),
      rev: this.options.rev
    };
    url = (this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?") + querystring.stringify(query);
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    return url;
  };

  ServerLayerDataSource.prototype.createLegacyUrl = function(design, extension, filters) {
    var relevantFilters, url, where, whereClauses;
    url = this.options.apiUrl + "maps/tiles/{z}/{x}/{y}." + extension + "?type=" + design.type + "&radius=1000";
    if (url.match(/^https:\/\/api\.mwater\.co\//)) {
      url = url.replace(/^https:\/\/api\.mwater\.co\//, "https://{s}-api.mwater.co/");
    }
    if (this.options.client) {
      url += "&client=" + this.options.client;
    }
    if (this.options.share) {
      url += "&share=" + this.options.share;
    }
    relevantFilters = _.where(filters, {
      table: design.table
    });
    whereClauses = _.map(relevantFilters, (function(_this) {
      return function(f) {
        return injectTableAlias(f.jsonql, "main");
      };
    })(this));
    if (whereClauses.length > 1) {
      where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      where = whereClauses[0];
    }
    if (where) {
      url += "&where=" + encodeURIComponent(JSON.stringify(where));
    }
    return url;
  };

  return ServerLayerDataSource;

})();

ServerMapLayerPopupWidgetDataSource = (function() {
  function ServerMapLayerPopupWidgetDataSource(options) {
    this.options = options;
  }

  ServerMapLayerPopupWidgetDataSource.prototype.getData = function(design, filters, callback) {
    var query, url;
    query = {
      client: this.options.client,
      share: this.options.share,
      filters: JSON.stringify(filters),
      rev: this.options.rev
    };
    url = this.options.apiUrl + ("maps/" + this.options.mapId + "/layers/" + this.options.layerId + "/widgets/" + this.options.popupWidgetId + "/data?") + querystring.stringify(query);
    return $.getJSON(url, (function(_this) {
      return function(data) {
        return callback(null, data);
      };
    })(this)).fail((function(_this) {
      return function(xhr) {
        console.log(xhr.responseText);
        return callback(new Error(xhr.responseText));
      };
    })(this));
  };

  ServerMapLayerPopupWidgetDataSource.prototype.getImageUrl = function(imageId, height) {
    var url;
    url = this.options.apiUrl + ("images/" + imageId);
    if (height) {
      url += "?h=" + height;
    }
    return url;
  };

  return ServerMapLayerPopupWidgetDataSource;

})();


},{"./LayerFactory":1085,"./MapDataSource":1094,"lodash":"lodash","mwater-expressions":14,"querystring":400}],1106:[function(require,module,exports){
var AxisBuilder, ExprCleaner, ExprCompiler, ExprUtils, H, Layer, LegendGroup, R, React, TileUrlLayer, TileUrlLayerDesignerComponent, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

Layer = require('./Layer');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprUtils = require('mwater-expressions').ExprUtils;

injectTableAlias = require('mwater-expressions').injectTableAlias;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../axes/AxisBuilder');

LegendGroup = require('./LegendGroup');


/*
Layer that is a custom Leaflet-style url tile layer
Design is:
  tileUrl: Url with {s}, {z}, {x}, {y}
 */

module.exports = TileUrlLayer = (function(superClass) {
  extend(TileUrlLayer, superClass);

  function TileUrlLayer() {
    return TileUrlLayer.__super__.constructor.apply(this, arguments);
  }

  TileUrlLayer.prototype.getMinZoom = function(design) {
    return null;
  };

  TileUrlLayer.prototype.getMaxZoom = function(design) {
    return null;
  };

  TileUrlLayer.prototype.isEditable = function() {
    return true;
  };

  TileUrlLayer.prototype.isIncomplete = function(design, schema) {
    return this.validateDesign(this.cleanDesign(design, schema), schema) != null;
  };

  TileUrlLayer.prototype.createDesignerElement = function(options) {
    return R(TileUrlLayerDesignerComponent, {
      design: options.design,
      onDesignChange: options.onDesignChange
    });
  };

  TileUrlLayer.prototype.cleanDesign = function(design, schema) {
    return design;
  };

  TileUrlLayer.prototype.validateDesign = function(design, schema) {
    if (!design.tileUrl) {
      return "Missing Url";
    }
    return null;
  };

  return TileUrlLayer;

})(Layer);

TileUrlLayerDesignerComponent = (function(superClass) {
  extend(TileUrlLayerDesignerComponent, superClass);

  function TileUrlLayerDesignerComponent() {
    this.handleTileUrlChange = bind(this.handleTileUrlChange, this);
    return TileUrlLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  TileUrlLayerDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  TileUrlLayerDesignerComponent.prototype.handleTileUrlChange = function(ev) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      tileUrl: ev.target.value
    }));
  };

  TileUrlLayerDesignerComponent.prototype.render = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Url (containing {z}, {x} and {y})"), H.input({
      type: "text",
      className: "form-control",
      value: this.props.design.tileUrl || "",
      onChange: this.handleTileUrlChange
    }));
  };

  return TileUrlLayerDesignerComponent;

})(React.Component);


},{"../axes/AxisBuilder":1029,"./Layer":1084,"./LegendGroup":1089,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1107:[function(require,module,exports){
/*
 Copyright (c) 2012, Smartrak, David Leaver
 Leaflet.utfgrid is an open-source JavaScript library that provides utfgrid interaction on leaflet powered maps.
 https://github.com/danzel/Leaflet.utfgrid

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
*/
var L = require("leaflet");

// Store last absorbed (data != null) event to prevent multiple layers from triggering click event
var absorbedEvent = null;

function ajax(url, cb) {
	// the following is from JavaScript: The Definitive Guide
	// and https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest_in_IE6
	if (window.XMLHttpRequest === undefined) {
		window.XMLHttpRequest = function () {
			/*global ActiveXObject:true */
			try {
				return new ActiveXObject("Microsoft.XMLHTTP");
			}
			catch  (e) {
				throw new Error("XMLHttpRequest is not supported");
			}
		};
	}
	var response, request = new XMLHttpRequest();
	request.open("GET", url);
	request.onreadystatechange = function () {
		/*jshint evil: true */
		if (request.readyState === 4 && request.status === 200) {
			if (window.JSON) {
				response = JSON.parse(request.responseText);
			} else {
				response = eval("(" + request.responseText + ")");
			}
			cb(response);
		}
	};
	request.send();
};

module.exports = L.Layer.extend({
	options: {
		subdomains: 'abc',

		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,

		resolution: 4,

		useJsonP: true,
		pointerCursor: true
	},

	//The thing the mouse is currently on
	_mouseOn: null,

	initialize: function (url, options) {
		L.Util.setOptions(this, options);

		this._url = url;
		this._cache = {};

		//Find a unique id in window we can use for our callbacks
		//Required for jsonP
		var i = 0;
		while (window['lu' + i]) {
			i++;
		}
		this._windowKey = 'lu' + i;
		window[this._windowKey] = {};

		var subdomains = this.options.subdomains;
		if (typeof this.options.subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._container = this._map._container;

		this._update();

		map.on('click', this._click, this);
		map.on('mousemove', this._move, this);
		map.on('moveend', this._update, this);
	},

	onRemove: function () {
		var map = this._map;
		map.off('click', this._click, this);
		map.off('mousemove', this._move, this);
		map.off('moveend', this._update, this);
		if (this.options.pointerCursor) {
			this._container.style.cursor = '';
		}
	},

	_click: function (e) {
		var zoom = this._map.getZoom();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		// Get object for event
		obj = this._objectForEvent(e);

		// Ignore if event has been dealt with
		if (e === absorbedEvent)
			return;

		// Store event if absorbed
		if (obj.data !== null)
			absorbedEvent = e;

		this.fire('click', obj);
	},
	_move: function (e) {
		var zoom = this._map.getZoom();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var on = this._objectForEvent(e);

		if (on.data !== this._mouseOn) {
			if (this._mouseOn) {
				this.fire('mouseout', { latlng: e.latlng, data: this._mouseOn });
				if (this.options.pointerCursor) {
					this._container.style.cursor = '';
				}
			}
			if (on.data) {
				this.fire('mouseover', on);
				if (this.options.pointerCursor) {
					this._container.style.cursor = 'pointer';
				}
			}

			this._mouseOn = on.data;
		} else if (on.data) {
			this.fire('mousemove', on);
		}
	},

	_objectForEvent: function (e) {
		var map = this._map,
		    point = map.project(e.latlng),
		    tileSize = this.options.tileSize,
		    resolution = this.options.resolution,
		    x = Math.floor(point.x / tileSize),
		    y = Math.floor(point.y / tileSize),
		    gridX = Math.floor((point.x - (x * tileSize)) / resolution),
		    gridY = Math.floor((point.y - (y * tileSize)) / resolution),
			max = map.options.crs.scale(map.getZoom()) / tileSize;

		x = (x + max) % max;
		y = (y + max) % max;

		var data = this._cache[map.getZoom() + '_' + x + '_' + y];
		if (!data) {
			return { latlng: e.latlng, data: null, event: e };
		}

		var idx = this._utfDecode(data.grid[gridY].charCodeAt(gridX)),
		    key = data.keys[idx],
		    result = data.data[key];

		if (!data.data.hasOwnProperty(key)) {
			result = null;
		}

		return { latlng: e.latlng, data: result, event: e };
	},

	//Load up all required json grid files
	//TODO: Load from center etc
	_update: function () {

		var bounds = this._map.getPixelBounds(),
		    zoom = this._map.getZoom(),
		    tileSize = this.options.tileSize;

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		// Round down for fractional zooms
		zoom = Math.floor(zoom);

		var nwTilePoint = new L.Point(
				Math.floor(bounds.min.x / tileSize),
				Math.floor(bounds.min.y / tileSize)),
			seTilePoint = new L.Point(
				Math.floor(bounds.max.x / tileSize),
				Math.floor(bounds.max.y / tileSize)),
				max = this._map.options.crs.scale(zoom) / tileSize;

		//Load all required ones
		for (var x = nwTilePoint.x; x <= seTilePoint.x; x++) {
			for (var y = nwTilePoint.y; y <= seTilePoint.y; y++) {

				var xw = (x + max) % max, yw = (y + max) % max;
				var key = zoom + '_' + xw + '_' + yw;

				if (!this._cache.hasOwnProperty(key)) {
					this._cache[key] = null;

					if (this.options.useJsonP) {
						this._loadTileP(zoom, xw, yw);
					} else {
						this._loadTile(zoom, xw, yw);
					}
				}
			}
		}
	},

	_getSubdomain: function (x, y) {
		var index = Math.abs(x + y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},


	_loadTileP: function (zoom, x, y) {
		var head = document.getElementsByTagName('head')[0],
		    key = zoom + '_' + x + '_' + y,
		    functionName = 'lu_' + key,
		    wk = this._windowKey,
		    self = this;

		var url = L.Util.template(this._url, L.Util.extend({
			s: this._getSubdomain(x, y),
			z: zoom,
			x: x,
			y: y,
			cb: wk + '.' + functionName
		}, this.options));

		var script = document.createElement('script');
		script.setAttribute("type", "text/javascript");
		script.setAttribute("src", url);

		window[wk][functionName] = function (data) {
			self._cache[key] = data;
			delete window[wk][functionName];
			head.removeChild(script);
		};

		head.appendChild(script);
	},

	_loadTile: function (zoom, x, y) {
		var url = L.Util.template(this._url, L.Util.extend({
	  	s: this._getSubdomain(x, y),
			z: zoom,
			x: x,
			y: y
		}, this.options));

		var key = zoom + '_' + x + '_' + y;
		var self = this;
		ajax(url, function (data) {
			self._cache[key] = data;
		});
	},

	_utfDecode: function (c) {
		if (c >= 93) {
			c--;
		}
		if (c >= 35) {
			c--;
		}
		return c - 32;
	}
});
},{"leaflet":330}],1108:[function(require,module,exports){
var H, NumberInputComponent, R, React, ZoomLevelsComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

NumberInputComponent = require('react-library/lib/NumberInputComponent');

module.exports = ZoomLevelsComponent = (function(superClass) {
  extend(ZoomLevelsComponent, superClass);

  ZoomLevelsComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  function ZoomLevelsComponent(props) {
    ZoomLevelsComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      expanded: false
    };
  }

  ZoomLevelsComponent.prototype.render = function() {
    if (!this.state.expanded) {
      return H.div(null, H.a({
        className: "btn btn-link btn-xs",
        onClick: ((function(_this) {
          return function() {
            return _this.setState({
              expanded: true
            });
          };
        })(this))
      }, "Advanced options..."));
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Advanced"), H.div({
      key: "min"
    }, H.span({
      className: "text-muted"
    }, "Minimum Zoom Level:"), " ", R(NumberInputComponent, {
      small: true,
      style: {
        display: "inline-block"
      },
      placeholder: "None",
      value: this.props.design.minZoom,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onDesignChange(_.extend({}, _this.props.design, {
            minZoom: v
          }));
        };
      })(this)
    })), H.div({
      key: "max"
    }, H.span({
      className: "text-muted"
    }, "Maximum Zoom Level: "), " ", R(NumberInputComponent, {
      small: true,
      style: {
        display: "inline-block"
      },
      placeholder: "None",
      value: this.props.design.maxZoom,
      onChange: (function(_this) {
        return function(v) {
          return _this.props.onDesignChange(_.extend({}, _this.props.design, {
            maxZoom: v
          }));
        };
      })(this)
    })));
  };

  return ZoomLevelsComponent;

})(React.Component);


},{"lodash":"lodash","react":"react","react-library/lib/NumberInputComponent":789}],1109:[function(require,module,exports){
// SVGPathSeg API polyfill
// https://github.com/progers/pathseg
//
// This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from
// SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec
// changes which were implemented in Firefox 43 and Chrome 46.

(function() { "use strict";
    if (!("SVGPathSeg" in window)) {
        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg
        window.SVGPathSeg = function(type, typeAsLetter, owningPathSegList) {
            this.pathSegType = type;
            this.pathSegTypeAsLetter = typeAsLetter;
            this._owningPathSegList = owningPathSegList;
        }

        SVGPathSeg.PATHSEG_UNKNOWN = 0;
        SVGPathSeg.PATHSEG_CLOSEPATH = 1;
        SVGPathSeg.PATHSEG_MOVETO_ABS = 2;
        SVGPathSeg.PATHSEG_MOVETO_REL = 3;
        SVGPathSeg.PATHSEG_LINETO_ABS = 4;
        SVGPathSeg.PATHSEG_LINETO_REL = 5;
        SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;
        SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;
        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;
        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;
        SVGPathSeg.PATHSEG_ARC_ABS = 10;
        SVGPathSeg.PATHSEG_ARC_REL = 11;
        SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;
        SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;
        SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;
        SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;
        SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;
        SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;
        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;
        SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

        // Notify owning PathSegList on any changes so they can be synchronized back to the path element.
        SVGPathSeg.prototype._segmentChanged = function() {
            if (this._owningPathSegList)
                this._owningPathSegList.segmentChanged(this);
        }

        window.SVGPathSegClosePath = function(owningPathSegList) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CLOSEPATH, "z", owningPathSegList);
        }
        SVGPathSegClosePath.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegClosePath.prototype.toString = function() { return "[object SVGPathSegClosePath]"; }
        SVGPathSegClosePath.prototype._asPathString = function() { return this.pathSegTypeAsLetter; }
        SVGPathSegClosePath.prototype.clone = function() { return new SVGPathSegClosePath(undefined); }

        window.SVGPathSegMovetoAbs = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_ABS, "M", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegMovetoAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegMovetoAbs.prototype.toString = function() { return "[object SVGPathSegMovetoAbs]"; }
        SVGPathSegMovetoAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegMovetoAbs.prototype.clone = function() { return new SVGPathSegMovetoAbs(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegMovetoAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegMovetoAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegMovetoRel = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_MOVETO_REL, "m", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegMovetoRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegMovetoRel.prototype.toString = function() { return "[object SVGPathSegMovetoRel]"; }
        SVGPathSegMovetoRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegMovetoRel.prototype.clone = function() { return new SVGPathSegMovetoRel(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegMovetoRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegMovetoRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoAbs = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_ABS, "L", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegLinetoAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoAbs.prototype.toString = function() { return "[object SVGPathSegLinetoAbs]"; }
        SVGPathSegLinetoAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegLinetoAbs.prototype.clone = function() { return new SVGPathSegLinetoAbs(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegLinetoAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegLinetoAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoRel = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_REL, "l", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegLinetoRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoRel.prototype.toString = function() { return "[object SVGPathSegLinetoRel]"; }
        SVGPathSegLinetoRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegLinetoRel.prototype.clone = function() { return new SVGPathSegLinetoRel(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegLinetoRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegLinetoRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoCubicAbs = function(owningPathSegList, x, y, x1, y1, x2, y2) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, "C", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x1 = x1;
            this._y1 = y1;
            this._x2 = x2;
            this._y2 = y2;
        }
        SVGPathSegCurvetoCubicAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoCubicAbs.prototype.toString = function() { return "[object SVGPathSegCurvetoCubicAbs]"; }
        SVGPathSegCurvetoCubicAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoCubicAbs.prototype.clone = function() { return new SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2); }
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x1", { get: function() { return this._x1; }, set: function(x1) { this._x1 = x1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y1", { get: function() { return this._y1; }, set: function(y1) { this._y1 = y1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "x2", { get: function() { return this._x2; }, set: function(x2) { this._x2 = x2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicAbs.prototype, "y2", { get: function() { return this._y2; }, set: function(y2) { this._y2 = y2; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoCubicRel = function(owningPathSegList, x, y, x1, y1, x2, y2) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, "c", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x1 = x1;
            this._y1 = y1;
            this._x2 = x2;
            this._y2 = y2;
        }
        SVGPathSegCurvetoCubicRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoCubicRel.prototype.toString = function() { return "[object SVGPathSegCurvetoCubicRel]"; }
        SVGPathSegCurvetoCubicRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoCubicRel.prototype.clone = function() { return new SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2); }
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x1", { get: function() { return this._x1; }, set: function(x1) { this._x1 = x1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y1", { get: function() { return this._y1; }, set: function(y1) { this._y1 = y1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "x2", { get: function() { return this._x2; }, set: function(x2) { this._x2 = x2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicRel.prototype, "y2", { get: function() { return this._y2; }, set: function(y2) { this._y2 = y2; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoQuadraticAbs = function(owningPathSegList, x, y, x1, y1) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, "Q", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x1 = x1;
            this._y1 = y1;
        }
        SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoQuadraticAbs.prototype.toString = function() { return "[object SVGPathSegCurvetoQuadraticAbs]"; }
        SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoQuadraticAbs.prototype.clone = function() { return new SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1); }
        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "x1", { get: function() { return this._x1; }, set: function(x1) { this._x1 = x1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticAbs.prototype, "y1", { get: function() { return this._y1; }, set: function(y1) { this._y1 = y1; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoQuadraticRel = function(owningPathSegList, x, y, x1, y1) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, "q", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x1 = x1;
            this._y1 = y1;
        }
        SVGPathSegCurvetoQuadraticRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoQuadraticRel.prototype.toString = function() { return "[object SVGPathSegCurvetoQuadraticRel]"; }
        SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x1 + " " + this._y1 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoQuadraticRel.prototype.clone = function() { return new SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1); }
        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "x1", { get: function() { return this._x1; }, set: function(x1) { this._x1 = x1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticRel.prototype, "y1", { get: function() { return this._y1; }, set: function(y1) { this._y1 = y1; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegArcAbs = function(owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_ABS, "A", owningPathSegList);
            this._x = x;
            this._y = y;
            this._r1 = r1;
            this._r2 = r2;
            this._angle = angle;
            this._largeArcFlag = largeArcFlag;
            this._sweepFlag = sweepFlag;
        }
        SVGPathSegArcAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegArcAbs.prototype.toString = function() { return "[object SVGPathSegArcAbs]"; }
        SVGPathSegArcAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y; }
        SVGPathSegArcAbs.prototype.clone = function() { return new SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag); }
        Object.defineProperty(SVGPathSegArcAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "r1", { get: function() { return this._r1; }, set: function(r1) { this._r1 = r1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "r2", { get: function() { return this._r2; }, set: function(r2) { this._r2 = r2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "angle", { get: function() { return this._angle; }, set: function(angle) { this._angle = angle; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "largeArcFlag", { get: function() { return this._largeArcFlag; }, set: function(largeArcFlag) { this._largeArcFlag = largeArcFlag; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcAbs.prototype, "sweepFlag", { get: function() { return this._sweepFlag; }, set: function(sweepFlag) { this._sweepFlag = sweepFlag; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegArcRel = function(owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_ARC_REL, "a", owningPathSegList);
            this._x = x;
            this._y = y;
            this._r1 = r1;
            this._r2 = r2;
            this._angle = angle;
            this._largeArcFlag = largeArcFlag;
            this._sweepFlag = sweepFlag;
        }
        SVGPathSegArcRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegArcRel.prototype.toString = function() { return "[object SVGPathSegArcRel]"; }
        SVGPathSegArcRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._r1 + " " + this._r2 + " " + this._angle + " " + (this._largeArcFlag ? "1" : "0") + " " + (this._sweepFlag ? "1" : "0") + " " + this._x + " " + this._y; }
        SVGPathSegArcRel.prototype.clone = function() { return new SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag); }
        Object.defineProperty(SVGPathSegArcRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "r1", { get: function() { return this._r1; }, set: function(r1) { this._r1 = r1; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "r2", { get: function() { return this._r2; }, set: function(r2) { this._r2 = r2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "angle", { get: function() { return this._angle; }, set: function(angle) { this._angle = angle; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "largeArcFlag", { get: function() { return this._largeArcFlag; }, set: function(largeArcFlag) { this._largeArcFlag = largeArcFlag; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegArcRel.prototype, "sweepFlag", { get: function() { return this._sweepFlag; }, set: function(sweepFlag) { this._sweepFlag = sweepFlag; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoHorizontalAbs = function(owningPathSegList, x) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, "H", owningPathSegList);
            this._x = x;
        }
        SVGPathSegLinetoHorizontalAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoHorizontalAbs.prototype.toString = function() { return "[object SVGPathSegLinetoHorizontalAbs]"; }
        SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x; }
        SVGPathSegLinetoHorizontalAbs.prototype.clone = function() { return new SVGPathSegLinetoHorizontalAbs(undefined, this._x); }
        Object.defineProperty(SVGPathSegLinetoHorizontalAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoHorizontalRel = function(owningPathSegList, x) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, "h", owningPathSegList);
            this._x = x;
        }
        SVGPathSegLinetoHorizontalRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoHorizontalRel.prototype.toString = function() { return "[object SVGPathSegLinetoHorizontalRel]"; }
        SVGPathSegLinetoHorizontalRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x; }
        SVGPathSegLinetoHorizontalRel.prototype.clone = function() { return new SVGPathSegLinetoHorizontalRel(undefined, this._x); }
        Object.defineProperty(SVGPathSegLinetoHorizontalRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoVerticalAbs = function(owningPathSegList, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, "V", owningPathSegList);
            this._y = y;
        }
        SVGPathSegLinetoVerticalAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoVerticalAbs.prototype.toString = function() { return "[object SVGPathSegLinetoVerticalAbs]"; }
        SVGPathSegLinetoVerticalAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._y; }
        SVGPathSegLinetoVerticalAbs.prototype.clone = function() { return new SVGPathSegLinetoVerticalAbs(undefined, this._y); }
        Object.defineProperty(SVGPathSegLinetoVerticalAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegLinetoVerticalRel = function(owningPathSegList, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, "v", owningPathSegList);
            this._y = y;
        }
        SVGPathSegLinetoVerticalRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegLinetoVerticalRel.prototype.toString = function() { return "[object SVGPathSegLinetoVerticalRel]"; }
        SVGPathSegLinetoVerticalRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._y; }
        SVGPathSegLinetoVerticalRel.prototype.clone = function() { return new SVGPathSegLinetoVerticalRel(undefined, this._y); }
        Object.defineProperty(SVGPathSegLinetoVerticalRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoCubicSmoothAbs = function(owningPathSegList, x, y, x2, y2) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, "S", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x2 = x2;
            this._y2 = y2;
        }
        SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function() { return "[object SVGPathSegCurvetoCubicSmoothAbs]"; }
        SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function() { return new SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2); }
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "x2", { get: function() { return this._x2; }, set: function(x2) { this._x2 = x2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothAbs.prototype, "y2", { get: function() { return this._y2; }, set: function(y2) { this._y2 = y2; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoCubicSmoothRel = function(owningPathSegList, x, y, x2, y2) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, "s", owningPathSegList);
            this._x = x;
            this._y = y;
            this._x2 = x2;
            this._y2 = y2;
        }
        SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function() { return "[object SVGPathSegCurvetoCubicSmoothRel]"; }
        SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x2 + " " + this._y2 + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function() { return new SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2); }
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "x2", { get: function() { return this._x2; }, set: function(x2) { this._x2 = x2; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoCubicSmoothRel.prototype, "y2", { get: function() { return this._y2; }, set: function(y2) { this._y2 = y2; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoQuadraticSmoothAbs = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, "T", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function() { return "[object SVGPathSegCurvetoQuadraticSmoothAbs]"; }
        SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function() { return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothAbs.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        window.SVGPathSegCurvetoQuadraticSmoothRel = function(owningPathSegList, x, y) {
            SVGPathSeg.call(this, SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, "t", owningPathSegList);
            this._x = x;
            this._y = y;
        }
        SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(SVGPathSeg.prototype);
        SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function() { return "[object SVGPathSegCurvetoQuadraticSmoothRel]"; }
        SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function() { return this.pathSegTypeAsLetter + " " + this._x + " " + this._y; }
        SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function() { return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y); }
        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "x", { get: function() { return this._x; }, set: function(x) { this._x = x; this._segmentChanged(); }, enumerable: true });
        Object.defineProperty(SVGPathSegCurvetoQuadraticSmoothRel.prototype, "y", { get: function() { return this._y; }, set: function(y) { this._y = y; this._segmentChanged(); }, enumerable: true });

        // Add createSVGPathSeg* functions to SVGPathElement.
        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathElement.
        SVGPathElement.prototype.createSVGPathSegClosePath = function() { return new SVGPathSegClosePath(undefined); }
        SVGPathElement.prototype.createSVGPathSegMovetoAbs = function(x, y) { return new SVGPathSegMovetoAbs(undefined, x, y); }
        SVGPathElement.prototype.createSVGPathSegMovetoRel = function(x, y) { return new SVGPathSegMovetoRel(undefined, x, y); }
        SVGPathElement.prototype.createSVGPathSegLinetoAbs = function(x, y) { return new SVGPathSegLinetoAbs(undefined, x, y); }
        SVGPathElement.prototype.createSVGPathSegLinetoRel = function(x, y) { return new SVGPathSegLinetoRel(undefined, x, y); }
        SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function(x, y, x1, y1, x2, y2) { return new SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2); }
        SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function(x, y, x1, y1, x2, y2) { return new SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2); }
        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function(x, y, x1, y1) { return new SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1); }
        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function(x, y, x1, y1) { return new SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1); }
        SVGPathElement.prototype.createSVGPathSegArcAbs = function(x, y, r1, r2, angle, largeArcFlag, sweepFlag) { return new SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag); }
        SVGPathElement.prototype.createSVGPathSegArcRel = function(x, y, r1, r2, angle, largeArcFlag, sweepFlag) { return new SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag); }
        SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function(x) { return new SVGPathSegLinetoHorizontalAbs(undefined, x); }
        SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function(x) { return new SVGPathSegLinetoHorizontalRel(undefined, x); }
        SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function(y) { return new SVGPathSegLinetoVerticalAbs(undefined, y); }
        SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function(y) { return new SVGPathSegLinetoVerticalRel(undefined, y); }
        SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function(x, y, x2, y2) { return new SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2); }
        SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function(x, y, x2, y2) { return new SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2); }
        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function(x, y) { return new SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y); }
        SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function(x, y) { return new SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y); }
    }

    if (!("SVGPathSegList" in window)) {
        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList
        window.SVGPathSegList = function(pathElement) {
            this._pathElement = pathElement;
            this._list = this._parsePath(this._pathElement.getAttribute("d"));

            // Use a MutationObserver to catch changes to the path's "d" attribute.
            this._mutationObserverConfig = { "attributes": true, "attributeFilter": ["d"] };
            this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));
            this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
        }

        Object.defineProperty(SVGPathSegList.prototype, "numberOfItems", {
            get: function() {
                this._checkPathSynchronizedToList();
                return this._list.length;
            },
            enumerable: true
        });

        // Add the pathSegList accessors to SVGPathElement.
        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData
        Object.defineProperty(SVGPathElement.prototype, "pathSegList", {
            get: function() {
                if (!this._pathSegList)
                    this._pathSegList = new SVGPathSegList(this);
                return this._pathSegList;
            },
            enumerable: true
        });
        // FIXME: The following are not implemented and simply return SVGPathElement.pathSegList.
        Object.defineProperty(SVGPathElement.prototype, "normalizedPathSegList", { get: function() { return this.pathSegList; }, enumerable: true });
        Object.defineProperty(SVGPathElement.prototype, "animatedPathSegList", { get: function() { return this.pathSegList; }, enumerable: true });
        Object.defineProperty(SVGPathElement.prototype, "animatedNormalizedPathSegList", { get: function() { return this.pathSegList; }, enumerable: true });

        // Process any pending mutations to the path element and update the list as needed.
        // This should be the first call of all public functions and is needed because
        // MutationObservers are not synchronous so we can have pending asynchronous mutations.
        SVGPathSegList.prototype._checkPathSynchronizedToList = function() {
            this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());
        }

        SVGPathSegList.prototype._updateListFromPathMutations = function(mutationRecords) {
            if (!this._pathElement)
                return;
            var hasPathMutations = false;
            mutationRecords.forEach(function(record) {
                if (record.attributeName == "d")
                    hasPathMutations = true;
            });
            if (hasPathMutations)
                this._list = this._parsePath(this._pathElement.getAttribute("d"));
        }

        // Serialize the list and update the path's 'd' attribute.
        SVGPathSegList.prototype._writeListToPath = function() {
            this._pathElementMutationObserver.disconnect();
            this._pathElement.setAttribute("d", SVGPathSegList._pathSegArrayAsString(this._list));
            this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);
        }

        // When a path segment changes the list needs to be synchronized back to the path element.
        SVGPathSegList.prototype.segmentChanged = function(pathSeg) {
            this._writeListToPath();
        }

        SVGPathSegList.prototype.clear = function() {
            this._checkPathSynchronizedToList();

            this._list.forEach(function(pathSeg) {
                pathSeg._owningPathSegList = null;
            });
            this._list = [];
            this._writeListToPath();
        }

        SVGPathSegList.prototype.initialize = function(newItem) {
            this._checkPathSynchronizedToList();

            this._list = [newItem];
            newItem._owningPathSegList = this;
            this._writeListToPath();
            return newItem;
        }

        SVGPathSegList.prototype._checkValidIndex = function(index) {
            if (isNaN(index) || index < 0 || index >= this.numberOfItems)
                throw "INDEX_SIZE_ERR";
        }

        SVGPathSegList.prototype.getItem = function(index) {
            this._checkPathSynchronizedToList();

            this._checkValidIndex(index);
            return this._list[index];
        }

        SVGPathSegList.prototype.insertItemBefore = function(newItem, index) {
            this._checkPathSynchronizedToList();

            // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.
            if (index > this.numberOfItems)
                index = this.numberOfItems;
            if (newItem._owningPathSegList) {
                // SVG2 spec says to make a copy.
                newItem = newItem.clone();
            }
            this._list.splice(index, 0, newItem);
            newItem._owningPathSegList = this;
            this._writeListToPath();
            return newItem;
        }

        SVGPathSegList.prototype.replaceItem = function(newItem, index) {
            this._checkPathSynchronizedToList();

            if (newItem._owningPathSegList) {
                // SVG2 spec says to make a copy.
                newItem = newItem.clone();
            }
            this._checkValidIndex(index);
            this._list[index] = newItem;
            newItem._owningPathSegList = this;
            this._writeListToPath();
            return newItem;
        }

        SVGPathSegList.prototype.removeItem = function(index) {
            this._checkPathSynchronizedToList();

            this._checkValidIndex(index);
            var item = this._list[index];
            this._list.splice(index, 1);
            this._writeListToPath();
            return item;
        }

        SVGPathSegList.prototype.appendItem = function(newItem) {
            this._checkPathSynchronizedToList();

            if (newItem._owningPathSegList) {
                // SVG2 spec says to make a copy.
                newItem = newItem.clone();
            }
            this._list.push(newItem);
            newItem._owningPathSegList = this;
            // TODO: Optimize this to just append to the existing attribute.
            this._writeListToPath();
            return newItem;
        }

        SVGPathSegList._pathSegArrayAsString = function(pathSegArray) {
            var string = "";
            var first = true;
            pathSegArray.forEach(function(pathSeg) {
                if (first) {
                    first = false;
                    string += pathSeg._asPathString();
                } else {
                    string += " " + pathSeg._asPathString();
                }
            });
            return string;
        }

        // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.
        SVGPathSegList.prototype._parsePath = function(string) {
            if (!string || string.length == 0)
                return [];

            var owningPathSegList = this;

            var Builder = function() {
                this.pathSegList = [];
            }

            Builder.prototype.appendSegment = function(pathSeg) {
                this.pathSegList.push(pathSeg);
            }

            var Source = function(string) {
                this._string = string;
                this._currentIndex = 0;
                this._endIndex = this._string.length;
                this._previousCommand = SVGPathSeg.PATHSEG_UNKNOWN;

                this._skipOptionalSpaces();
            }

            Source.prototype._isCurrentSpace = function() {
                var character = this._string[this._currentIndex];
                return character <= " " && (character == " " || character == "\n" || character == "\t" || character == "\r" || character == "\f");
            }

            Source.prototype._skipOptionalSpaces = function() {
                while (this._currentIndex < this._endIndex && this._isCurrentSpace())
                    this._currentIndex++;
                return this._currentIndex < this._endIndex;
            }

            Source.prototype._skipOptionalSpacesOrDelimiter = function() {
                if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != ",")
                    return false;
                if (this._skipOptionalSpaces()) {
                    if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ",") {
                        this._currentIndex++;
                        this._skipOptionalSpaces();
                    }
                }
                return this._currentIndex < this._endIndex;
            }

            Source.prototype.hasMoreData = function() {
                return this._currentIndex < this._endIndex;
            }

            Source.prototype.peekSegmentType = function() {
                var lookahead = this._string[this._currentIndex];
                return this._pathSegTypeFromChar(lookahead);
            }

            Source.prototype._pathSegTypeFromChar = function(lookahead) {
                switch (lookahead) {
                case "Z":
                case "z":
                    return SVGPathSeg.PATHSEG_CLOSEPATH;
                case "M":
                    return SVGPathSeg.PATHSEG_MOVETO_ABS;
                case "m":
                    return SVGPathSeg.PATHSEG_MOVETO_REL;
                case "L":
                    return SVGPathSeg.PATHSEG_LINETO_ABS;
                case "l":
                    return SVGPathSeg.PATHSEG_LINETO_REL;
                case "C":
                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;
                case "c":
                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;
                case "Q":
                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;
                case "q":
                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;
                case "A":
                    return SVGPathSeg.PATHSEG_ARC_ABS;
                case "a":
                    return SVGPathSeg.PATHSEG_ARC_REL;
                case "H":
                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;
                case "h":
                    return SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;
                case "V":
                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;
                case "v":
                    return SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;
                case "S":
                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;
                case "s":
                    return SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;
                case "T":
                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;
                case "t":
                    return SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;
                default:
                    return SVGPathSeg.PATHSEG_UNKNOWN;
                }
            }

            Source.prototype._nextCommandHelper = function(lookahead, previousCommand) {
                // Check for remaining coordinates in the current command.
                if ((lookahead == "+" || lookahead == "-" || lookahead == "." || (lookahead >= "0" && lookahead <= "9")) && previousCommand != SVGPathSeg.PATHSEG_CLOSEPATH) {
                    if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_ABS)
                        return SVGPathSeg.PATHSEG_LINETO_ABS;
                    if (previousCommand == SVGPathSeg.PATHSEG_MOVETO_REL)
                        return SVGPathSeg.PATHSEG_LINETO_REL;
                    return previousCommand;
                }
                return SVGPathSeg.PATHSEG_UNKNOWN;
            }

            Source.prototype.initialCommandIsMoveTo = function() {
                // If the path is empty it is still valid, so return true.
                if (!this.hasMoreData())
                    return true;
                var command = this.peekSegmentType();
                // Path must start with moveTo.
                return command == SVGPathSeg.PATHSEG_MOVETO_ABS || command == SVGPathSeg.PATHSEG_MOVETO_REL;
            }

            // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.
            // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF
            Source.prototype._parseNumber = function() {
                var exponent = 0;
                var integer = 0;
                var frac = 1;
                var decimal = 0;
                var sign = 1;
                var expsign = 1;

                var startIndex = this._currentIndex;

                this._skipOptionalSpaces();

                // Read the sign.
                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "+")
                    this._currentIndex++;
                else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == "-") {
                    this._currentIndex++;
                    sign = -1;
                }

                if (this._currentIndex == this._endIndex || ((this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9") && this._string.charAt(this._currentIndex) != "."))
                    // The first character of a number must be one of [0-9+-.].
                    return undefined;

                // Read the integer part, build right-to-left.
                var startIntPartIndex = this._currentIndex;
                while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9")
                    this._currentIndex++; // Advance to first non-digit.

                if (this._currentIndex != startIntPartIndex) {
                    var scanIntPartIndex = this._currentIndex - 1;
                    var multiplier = 1;
                    while (scanIntPartIndex >= startIntPartIndex) {
                        integer += multiplier * (this._string.charAt(scanIntPartIndex--) - "0");
                        multiplier *= 10;
                    }
                }

                // Read the decimals.
                if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == ".") {
                    this._currentIndex++;

                    // There must be a least one digit following the .
                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9")
                        return undefined;
                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9")
                        decimal += (this._string.charAt(this._currentIndex++) - "0") * (frac *= 0.1);
                }

                // Read the exponent part.
                if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == "e" || this._string.charAt(this._currentIndex) == "E") && (this._string.charAt(this._currentIndex + 1) != "x" && this._string.charAt(this._currentIndex + 1) != "m")) {
                    this._currentIndex++;

                    // Read the sign of the exponent.
                    if (this._string.charAt(this._currentIndex) == "+") {
                        this._currentIndex++;
                    } else if (this._string.charAt(this._currentIndex) == "-") {
                        this._currentIndex++;
                        expsign = -1;
                    }

                    // There must be an exponent.
                    if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < "0" || this._string.charAt(this._currentIndex) > "9")
                        return undefined;

                    while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= "0" && this._string.charAt(this._currentIndex) <= "9") {
                        exponent *= 10;
                        exponent += (this._string.charAt(this._currentIndex) - "0");
                        this._currentIndex++;
                    }
                }

                var number = integer + decimal;
                number *= sign;

                if (exponent)
                    number *= Math.pow(10, expsign * exponent);

                if (startIndex == this._currentIndex)
                    return undefined;

                this._skipOptionalSpacesOrDelimiter();

                return number;
            }

            Source.prototype._parseArcFlag = function() {
                if (this._currentIndex >= this._endIndex)
                    return undefined;
                var flag = false;
                var flagChar = this._string.charAt(this._currentIndex++);
                if (flagChar == "0")
                    flag = false;
                else if (flagChar == "1")
                    flag = true;
                else
                    return undefined;

                this._skipOptionalSpacesOrDelimiter();
                return flag;
            }

            Source.prototype.parseSegment = function() {
                var lookahead = this._string[this._currentIndex];
                var command = this._pathSegTypeFromChar(lookahead);
                if (command == SVGPathSeg.PATHSEG_UNKNOWN) {
                    // Possibly an implicit command. Not allowed if this is the first command.
                    if (this._previousCommand == SVGPathSeg.PATHSEG_UNKNOWN)
                        return null;
                    command = this._nextCommandHelper(lookahead, this._previousCommand);
                    if (command == SVGPathSeg.PATHSEG_UNKNOWN)
                        return null;
                } else {
                    this._currentIndex++;
                }

                this._previousCommand = command;

                switch (command) {
                case SVGPathSeg.PATHSEG_MOVETO_REL:
                    return new SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_MOVETO_ABS:
                    return new SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_REL:
                    return new SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_ABS:
                    return new SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:
                    return new SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:
                    return new SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:
                    return new SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());
                case SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:
                    return new SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());
                case SVGPathSeg.PATHSEG_CLOSEPATH:
                    this._skipOptionalSpaces();
                    return new SVGPathSegClosePath(owningPathSegList);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:
                    var points = {x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);
                case SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:
                    var points = {x2: this._parseNumber(), y2: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:
                    return new SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:
                    return new SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());
                case SVGPathSeg.PATHSEG_ARC_REL:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                case SVGPathSeg.PATHSEG_ARC_ABS:
                    var points = {x1: this._parseNumber(), y1: this._parseNumber(), arcAngle: this._parseNumber(), arcLarge: this._parseArcFlag(), arcSweep: this._parseArcFlag(), x: this._parseNumber(), y: this._parseNumber()};
                    return new SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);
                default:
                    throw "Unknown path seg type."
                }
            }

            var builder = new Builder();
            var source = new Source(string);

            if (!source.initialCommandIsMoveTo())
                return [];
            while (source.hasMoreData()) {
                var pathSeg = source.parseSegment();
                if (!pathSeg)
                    return [];
                builder.appendSegment(pathSeg);
            }

            return builder.pathSegList;
        }
    }
}());
},{}],1110:[function(require,module,exports){
var ExprCleaner, ExprCompiler, ExprUtils, QuickfilterCompiler, _;

_ = require('lodash');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = QuickfilterCompiler = (function() {
  function QuickfilterCompiler(schema) {
    this.schema = schema;
  }

  QuickfilterCompiler.prototype.compile = function(design, values, locks) {
    var expr, filterExpr, filters, i, index, item, jsonql, len, lock, value;
    if (!design) {
      return [];
    }
    filters = [];
    for (index = i = 0, len = design.length; i < len; index = ++i) {
      item = design[index];
      lock = _.find(locks, function(lock) {
        return _.isEqual(lock.expr, item.expr);
      });
      if (lock) {
        value = lock.value;
      } else {
        value = values != null ? values[index] : void 0;
      }
      if (!value) {
        continue;
      }
      expr = new ExprCleaner(this.schema).cleanExpr(item.expr);
      if (!expr) {
        continue;
      }
      filterExpr = this.compileToFilterExpr(expr, value);
      jsonql = new ExprCompiler(this.schema).compileExpr({
        expr: filterExpr,
        tableAlias: "{alias}"
      });
      if (jsonql == null) {
        continue;
      }
      filters.push({
        table: expr.table,
        jsonql: jsonql
      });
    }
    return filters;
  };

  QuickfilterCompiler.prototype.compileToFilterExpr = function(expr, value) {
    var type;
    type = new ExprUtils(this.schema).getExprType(expr);
    if (type === 'enum' || type === 'text') {
      return {
        type: "op",
        op: "=",
        table: expr.table,
        exprs: [
          expr, {
            type: "literal",
            valueType: "enum",
            value: value
          }
        ]
      };
    } else if (type === 'date' || type === 'datetime') {
      return {
        type: "op",
        op: value.op,
        table: expr.table,
        exprs: [expr].concat(value.exprs)
      };
    }
  };

  return QuickfilterCompiler;

})();


},{"lodash":"lodash","mwater-expressions":14}],1111:[function(require,module,exports){
var DateExprComponent, DateQuickfilterComponent, EnumQuickfilterComponent, ExprCleaner, ExprUtils, H, QuickfiltersComponent, React, ReactSelect, TextLiteralComponent, TextQuickfilterComponent, moment,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

H = React.DOM;

ReactSelect = require('react-select');

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCleaner = require('mwater-expressions').ExprCleaner;

TextLiteralComponent = require('./TextLiteralComponent');

moment = require('moment');

module.exports = QuickfiltersComponent = (function(superClass) {
  extend(QuickfiltersComponent, superClass);

  function QuickfiltersComponent() {
    return QuickfiltersComponent.__super__.constructor.apply(this, arguments);
  }

  QuickfiltersComponent.propTypes = {
    design: React.PropTypes.arrayOf(React.PropTypes.shape({
      expr: React.PropTypes.object.isRequired,
      label: React.PropTypes.string
    })),
    values: React.PropTypes.array,
    onValuesChange: React.PropTypes.func.isRequired,
    locks: React.PropTypes.arrayOf(React.PropTypes.shape({
      expr: React.PropTypes.object.isRequired,
      value: React.PropTypes.any
    })),
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  QuickfiltersComponent.prototype.renderQuickfilter = function(item, index) {
    var expr, itemValue, lock, onValueChange, type, values;
    values = this.props.values || [];
    itemValue = values[index];
    expr = new ExprCleaner(this.props.schema).cleanExpr(item.expr);
    if (!expr) {
      return null;
    }
    type = new ExprUtils(this.props.schema).getExprType(expr);
    lock = _.find(this.props.locks, function(lock) {
      return _.isEqual(lock.expr, expr);
    });
    if (lock) {
      itemValue = lock.value;
      onValueChange = null;
    } else {
      onValueChange = (function(_this) {
        return function(v) {
          values = (_this.props.values || []).slice();
          values[index] = v;
          return _this.props.onValuesChange(values);
        };
      })(this);
    }
    if (type === "enum") {
      return React.createElement(EnumQuickfilterComponent, {
        key: index,
        label: item.label,
        expr: expr,
        schema: this.props.schema,
        options: new ExprUtils(this.props.schema).getExprEnumValues(expr),
        value: itemValue,
        onValueChange: onValueChange
      });
    }
    if (type === "text") {
      return React.createElement(TextQuickfilterComponent, {
        key: index,
        label: item.label,
        expr: expr,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        value: itemValue,
        onValueChange: onValueChange
      });
    }
    if (type === "date" || type === "datetime") {
      return React.createElement(DateQuickfilterComponent, {
        key: index,
        label: item.label,
        expr: expr,
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        value: itemValue,
        onValueChange: onValueChange
      });
    }
  };

  QuickfiltersComponent.prototype.render = function() {
    if (!this.props.design || this.props.design.length === 0) {
      return null;
    }
    return H.div({
      style: {
        borderTop: "solid 1px #E8E8E8",
        borderBottom: "solid 1px #E8E8E8",
        padding: 5
      }
    }, _.map(this.props.design, (function(_this) {
      return function(item, i) {
        return _this.renderQuickfilter(item, i);
      };
    })(this)));
  };

  return QuickfiltersComponent;

})(React.Component);

EnumQuickfilterComponent = (function(superClass) {
  extend(EnumQuickfilterComponent, superClass);

  function EnumQuickfilterComponent() {
    this.handleChange = bind(this.handleChange, this);
    return EnumQuickfilterComponent.__super__.constructor.apply(this, arguments);
  }

  EnumQuickfilterComponent.propTypes = {
    label: React.PropTypes.string,
    schema: React.PropTypes.object.isRequired,
    options: React.PropTypes.arrayOf(React.PropTypes.shape({
      id: React.PropTypes.string.isRequired,
      name: React.PropTypes.object.isRequired
    })).isRequired,
    value: React.PropTypes.any,
    onValueChange: React.PropTypes.func
  };

  EnumQuickfilterComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  EnumQuickfilterComponent.prototype.handleChange = function(val) {
    if (val) {
      return this.props.onValueChange(val);
    } else {
      return this.props.onValueChange(null);
    }
  };

  EnumQuickfilterComponent.prototype.render = function() {
    return H.div({
      style: {
        display: "inline-block",
        paddingRight: 10
      }
    }, this.props.label ? H.span({
      style: {
        color: "gray"
      }
    }, this.props.label + ":\u00a0") : void 0, H.div({
      style: {
        display: "inline-block",
        minWidth: "20em",
        verticalAlign: "middle"
      }
    }, React.createElement(ReactSelect, {
      placeholder: "All",
      value: this.props.value,
      multi: false,
      options: _.map(this.props.options, (function(_this) {
        return function(opt) {
          return {
            value: opt.id,
            label: ExprUtils.localizeString(opt.name, _this.context.locale)
          };
        };
      })(this)),
      onChange: this.props.onValueChange ? this.handleChange : void 0,
      disabled: this.props.onValueChange == null
    })), !this.props.onValueChange ? H.i({
      className: "text-warning fa fa-fw fa-lock"
    }) : void 0);
  };

  return EnumQuickfilterComponent;

})(React.Component);

TextQuickfilterComponent = (function(superClass) {
  extend(TextQuickfilterComponent, superClass);

  function TextQuickfilterComponent() {
    return TextQuickfilterComponent.__super__.constructor.apply(this, arguments);
  }

  TextQuickfilterComponent.propTypes = {
    label: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    expr: React.PropTypes.object.isRequired,
    value: React.PropTypes.any,
    onValueChange: React.PropTypes.func
  };

  TextQuickfilterComponent.prototype.render = function() {
    return H.div({
      style: {
        display: "inline-block",
        paddingRight: 10
      }
    }, this.props.label ? H.span({
      style: {
        color: "gray"
      }
    }, this.props.label + ":\u00a0") : void 0, H.div({
      style: {
        display: "inline-block",
        minWidth: "20em",
        verticalAlign: "middle"
      }
    }, React.createElement(TextLiteralComponent, {
      value: this.props.value,
      onChange: this.props.onValueChange,
      refExpr: this.props.expr,
      schema: this.props.schema,
      dataSource: this.props.dataSource
    })), !this.props.onValueChange ? H.i({
      className: "text-warning fa fa-fw fa-lock"
    }) : void 0);
  };

  return TextQuickfilterComponent;

})(React.Component);

DateQuickfilterComponent = (function(superClass) {
  extend(DateQuickfilterComponent, superClass);

  function DateQuickfilterComponent() {
    return DateQuickfilterComponent.__super__.constructor.apply(this, arguments);
  }

  DateQuickfilterComponent.propTypes = {
    label: React.PropTypes.string,
    schema: React.PropTypes.object.isRequired,
    expr: React.PropTypes.object.isRequired,
    value: React.PropTypes.any,
    onValueChange: React.PropTypes.func.isRequired
  };

  DateQuickfilterComponent.prototype.render = function() {
    return H.div({
      style: {
        display: "inline-block",
        paddingRight: 10
      }
    }, this.props.label ? H.span({
      style: {
        color: "gray"
      }
    }, this.props.label + ":\u00a0") : void 0, H.div({
      style: {
        display: "inline-block",
        minWidth: "20em",
        verticalAlign: "middle"
      }
    }, React.createElement(DateExprComponent, {
      type: new ExprUtils(this.props.schema).getExprType(this.props.expr),
      value: this.props.value,
      onValueChange: this.props.onValueChange
    })), !this.props.onValueChange ? H.i({
      className: "text-warning fa fa-fw fa-lock"
    }) : void 0);
  };

  return DateQuickfilterComponent;

})(React.Component);

DateExprComponent = (function(superClass) {
  extend(DateExprComponent, superClass);

  function DateExprComponent() {
    this.handleChange = bind(this.handleChange, this);
    return DateExprComponent.__super__.constructor.apply(this, arguments);
  }

  DateExprComponent.propTypes = {
    type: React.PropTypes.string.isRequired,
    value: React.PropTypes.any,
    onValueChange: React.PropTypes.func
  };

  DateExprComponent.prototype.handleChange = function(val) {
    if (val) {
      return this.props.onValueChange(JSON.parse(val));
    } else {
      return this.props.onValueChange(null);
    }
  };

  DateExprComponent.prototype.render = function() {
    var i, j, options;
    options = [
      {
        value: JSON.stringify({
          op: "thisyear",
          exprs: []
        }),
        label: 'This Year'
      }, {
        value: JSON.stringify({
          op: "lastyear",
          exprs: []
        }),
        label: 'Last Year'
      }, {
        value: JSON.stringify({
          op: "thismonth",
          exprs: []
        }),
        label: 'This Month'
      }, {
        value: JSON.stringify({
          op: "lastmonth",
          exprs: []
        }),
        label: 'Last Month'
      }, {
        value: JSON.stringify({
          op: "today",
          exprs: []
        }),
        label: 'Today'
      }, {
        value: JSON.stringify({
          op: "yesterday",
          exprs: []
        }),
        label: 'Yesterday'
      }, {
        value: JSON.stringify({
          op: "last24hours",
          exprs: []
        }),
        label: 'In Last 24 Hours'
      }, {
        value: JSON.stringify({
          op: "last7days",
          exprs: []
        }),
        label: 'In Last 7 Days'
      }, {
        value: JSON.stringify({
          op: "last30days",
          exprs: []
        }),
        label: 'In Last 30 Days'
      }, {
        value: JSON.stringify({
          op: "last365days",
          exprs: []
        }),
        label: 'In Last 365 Days'
      }
    ];
    for (i = j = 1; j <= 24; i = ++j) {
      if (this.props.type === "date") {
        options.push({
          value: JSON.stringify({
            op: "between",
            exprs: [
              {
                type: "literal",
                valueType: this.props.type,
                value: moment().startOf("month").subtract(i, 'months').format("YYYY-MM-DD")
              }, {
                type: "literal",
                valueType: this.props.type,
                value: moment().startOf("month").subtract(i - 1, 'months').subtract(1, "days").format("YYYY-MM-DD")
              }
            ]
          }),
          label: moment().startOf("month").subtract(i, 'months').format("MMM YYYY")
        });
      } else if (this.props.type === "datetime") {
        options.push({
          value: JSON.stringify({
            op: "between",
            exprs: [
              {
                type: "literal",
                valueType: this.props.type,
                value: moment().startOf("month").subtract(i, 'months').toISOString()
              }, {
                type: "literal",
                valueType: this.props.type,
                value: moment().startOf("month").subtract(i - 1, 'months').subtract(1, "milliseconds").toISOString()
              }
            ]
          }),
          label: moment().startOf("month").subtract(i, 'months').format("MMM YYYY")
        });
      }
    }
    return H.div({
      style: {
        display: "inline-block",
        minWidth: "20em",
        verticalAlign: "middle"
      }
    }, React.createElement(ReactSelect, {
      placeholder: "All",
      value: this.props.value ? JSON.stringify(this.props.value) : "",
      multi: false,
      options: options,
      onChange: this.props.onValueChange ? this.handleChange : void 0,
      disabled: this.props.onValueChange == null
    }));
  };

  return DateExprComponent;

})(React.Component);


},{"./TextLiteralComponent":1113,"moment":337,"mwater-expressions":14,"react":"react","react-select":818}],1112:[function(require,module,exports){
var ExprComponent, H, QuickfilterDesignComponent, QuickfiltersDesignComponent, R, React, RemovableComponent, TableSelectComponent, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

update = require('update-object');

TableSelectComponent = require('../TableSelectComponent');

ExprComponent = require('mwater-expressions-ui').ExprComponent;

module.exports = QuickfiltersDesignComponent = (function(superClass) {
  extend(QuickfiltersDesignComponent, superClass);

  function QuickfiltersDesignComponent() {
    this.handleRemove = bind(this.handleRemove, this);
    this.handleAdd = bind(this.handleAdd, this);
    return QuickfiltersDesignComponent.__super__.constructor.apply(this, arguments);
  }

  QuickfiltersDesignComponent.propTypes = {
    design: React.PropTypes.array.isRequired,
    onDesignChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string
  };

  QuickfiltersDesignComponent.defaultProps = {
    design: []
  };

  QuickfiltersDesignComponent.prototype.renderQuickfilter = function(item, index) {
    return R(QuickfilterDesignComponent, {
      key: index,
      design: item,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      onChange: (function(_this) {
        return function(newItem) {
          var design;
          design = _this.props.design.slice();
          design[index] = newItem;
          return _this.props.onDesignChange(design);
        };
      })(this),
      onRemove: this.handleRemove.bind(null, index)
    });
  };

  QuickfiltersDesignComponent.prototype.handleAdd = function() {
    var design;
    design = this.props.design.concat([{}]);
    return this.props.onDesignChange(design);
  };

  QuickfiltersDesignComponent.prototype.handleRemove = function(index) {
    var design;
    design = this.props.design.slice();
    design.splice(index, 1);
    return this.props.onDesignChange(design);
  };

  QuickfiltersDesignComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.design, (function(_this) {
      return function(item, index) {
        return _this.renderQuickfilter(item, index);
      };
    })(this)), H.button({
      type: "button",
      className: "btn btn-sm btn-default",
      onClick: this.handleAdd
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Quick Filter"));
  };

  return QuickfiltersDesignComponent;

})(React.Component);

QuickfilterDesignComponent = (function(superClass) {
  extend(QuickfilterDesignComponent, superClass);

  QuickfilterDesignComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string
  };

  function QuickfilterDesignComponent(props) {
    this.handleLabelChange = bind(this.handleLabelChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    var ref;
    QuickfilterDesignComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      table: props.table || ((ref = props.design.expr) != null ? ref.table : void 0)
    };
  }

  QuickfilterDesignComponent.prototype.componentWillReceiveProps = function(nextProps) {
    var ref, table;
    table = nextProps.table || ((ref = nextProps.design.expr) != null ? ref.table : void 0);
    if (table && table !== this.state.table) {
      return this.setState({
        table: table
      });
    }
  };

  QuickfilterDesignComponent.prototype.handleTableChange = function(table) {
    var design;
    this.setState({
      table: table
    });
    design = {
      expr: null,
      label: null
    };
    return this.props.onChange(design);
  };

  QuickfilterDesignComponent.prototype.handleExprChange = function(expr) {
    return this.props.onChange(update(this.props.design, {
      expr: {
        $set: expr
      }
    }));
  };

  QuickfilterDesignComponent.prototype.handleLabelChange = function(ev) {
    return this.props.onChange(update(this.props.design, {
      label: {
        $set: ev.target.value
      }
    }));
  };

  QuickfilterDesignComponent.prototype.render = function() {
    return R(RemovableComponent, {
      onRemove: this.props.onRemove
    }, H.div({
      className: "panel panel-default"
    }, H.div({
      className: "panel-body"
    }, !this.props.table ? H.div({
      className: "form-group",
      key: "table"
    }, H.label({
      className: "text-muted"
    }, "Data Source"), R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.state.table,
      onChange: this.handleTableChange
    })) : void 0, this.state.table ? H.div({
      className: "form-group",
      key: "expr"
    }, H.label({
      className: "text-muted"
    }, "Filter By"), H.div(null, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.state.table,
      value: this.props.design.expr,
      onChange: this.handleExprChange,
      types: ['enum', 'text', 'date', 'datetime']
    }))) : void 0, this.props.design.expr ? H.div({
      className: "form-group",
      key: "label"
    }, H.label({
      className: "text-muted"
    }, "Label"), H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.label || "",
      onChange: this.handleLabelChange,
      placeholder: "Optional Label"
    })) : void 0)));
  };

  return QuickfilterDesignComponent;

})(React.Component);

RemovableComponent = (function(superClass) {
  extend(RemovableComponent, superClass);

  function RemovableComponent() {
    return RemovableComponent.__super__.constructor.apply(this, arguments);
  }

  RemovableComponent.propTypes = {
    onRemove: React.PropTypes.func.isRequired
  };

  RemovableComponent.prototype.render = function() {
    return H.div({
      style: {
        display: "flex"
      },
      className: "hover-display-parent"
    }, H.div({
      style: {
        flex: "1 1 auto"
      },
      key: "main"
    }, this.props.children), H.div({
      style: {
        flex: "0 0 auto",
        alignSelf: "center"
      },
      className: "hover-display-child",
      key: "remove"
    }, H.a({
      onClick: this.props.onRemove,
      style: {
        fontSize: "80%",
        cursor: "pointer",
        marginLeft: 5
      }
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))));
  };

  return RemovableComponent;

})(React.Component);


},{"../TableSelectComponent":1025,"mwater-expressions-ui":362,"react":"react","update-object":1003}],1113:[function(require,module,exports){
var ExprCompiler, H, React, ReactSelect, TextLiteralComponent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

ReactSelect = require('react-select');

ExprCompiler = require("mwater-expressions").ExprCompiler;

module.exports = TextLiteralComponent = (function(superClass) {
  extend(TextLiteralComponent, superClass);

  function TextLiteralComponent() {
    this.getOptions = bind(this.getOptions, this);
    this.handleChange = bind(this.handleChange, this);
    return TextLiteralComponent.__super__.constructor.apply(this, arguments);
  }

  TextLiteralComponent.propTypes = {
    value: React.PropTypes.string,
    onChange: React.PropTypes.func,
    refExpr: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  TextLiteralComponent.prototype.handleChange = function(val) {
    var value;
    value = val ? val : null;
    return this.props.onChange(value);
  };

  TextLiteralComponent.prototype.escapeRegex = function(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };

  TextLiteralComponent.prototype.getOptions = function(input, cb) {
    var exprCompiler, query;
    exprCompiler = new ExprCompiler(this.props.schema);
    query = {
      type: "query",
      selects: [
        {
          type: "select",
          expr: exprCompiler.compileExpr({
            expr: this.props.refExpr,
            tableAlias: "main"
          }),
          alias: "value"
        }, {
          type: "select",
          expr: {
            type: "op",
            op: "count",
            exprs: []
          },
          alias: "number"
        }
      ],
      from: exprCompiler.compileTable(this.props.refExpr.table, "main"),
      where: {
        type: "op",
        op: "~*",
        exprs: [
          exprCompiler.compileExpr({
            expr: this.props.refExpr,
            tableAlias: "main"
          }), "^" + this.escapeRegex(input)
        ]
      },
      groupBy: [1],
      orderBy: [
        {
          ordinal: 2,
          direction: "desc"
        }, {
          ordinal: 1,
          direction: "asc"
        }
      ],
      limit: 250
    };
    this.props.dataSource.performQuery(query, (function(_this) {
      return function(err, rows) {
        if (err) {
          cb(err);
          return;
        }
        rows = _.filter(rows, function(r) {
          return r.value;
        });
        return cb(null, {
          options: _.map(rows, function(r) {
            return {
              value: r.value,
              label: r.value
            };
          }),
          complete: false
        });
      };
    })(this));
  };

  TextLiteralComponent.prototype.render = function() {
    var value;
    value = this.props.value || "";
    return H.div({
      style: {
        width: "100%"
      }
    }, React.createElement(ReactSelect, {
      placeholder: "All",
      value: value,
      asyncOptions: this.getOptions,
      onChange: this.props.onChange ? this.handleChange : void 0,
      disabled: this.props.onChange == null
    }));
  };

  return TextLiteralComponent;

})(React.Component);


},{"mwater-expressions":14,"react":"react","react-select":818}],1114:[function(require,module,exports){
var ExprItemsHtmlConverter, ExprUtils, ItemsHtmlConverter, _, d3Format, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

ItemsHtmlConverter = require('./ItemsHtmlConverter');

ExprUtils = require('mwater-expressions').ExprUtils;

uuid = require('uuid');

d3Format = require('d3-format');

module.exports = ExprItemsHtmlConverter = (function(superClass) {
  extend(ExprItemsHtmlConverter, superClass);

  function ExprItemsHtmlConverter(schema, designMode, exprValues, summarizeExprs, namedStrings) {
    ExprItemsHtmlConverter.__super__.constructor.call(this, namedStrings);
    this.schema = schema;
    this.designMode = designMode;
    this.exprValues = exprValues;
    this.summarizeExprs = summarizeExprs;
  }

  ExprItemsHtmlConverter.prototype.convertSpecialItemToHtml = function(item) {
    var exprHtml, exprUtils, html, label, text;
    html = "";
    if (item.type === "expr") {
      if (this.summarizeExprs) {
        text = new ExprUtils(this.schema).summarizeExpr(item.expr);
        if (text.length > 30) {
          text = text.substr(0, 30) + "...";
        }
        exprHtml = _.escape(text);
      } else if (_.has(this.exprValues, item.id)) {
        exprUtils = new ExprUtils(this.schema);
        if (this.exprValues[item.id] != null) {
          if (item.format && exprUtils.getExprType(item.expr) === "number") {
            text = d3Format.format(item.format)(this.exprValues[item.id]);
          } else {
            text = exprUtils.stringifyExprLiteral(item.expr, this.exprValues[item.id]);
          }
          exprHtml = _.escape(text);
        } else {
          exprHtml = '<span style="color: #DDD">---</span>';
        }
      } else {
        exprHtml = '<span class="text-muted">\u25a0\u25a0\u25a0</span>';
      }
      if (item.includeLabel) {
        label = item.labelText || (new ExprUtils(this.schema).summarizeExpr(item.expr) + ":\u00A0");
        exprHtml = '<span class="text-muted">' + _.escape(label) + "</span>" + exprHtml;
      }
      if (this.designMode) {
        html += '\u2060<span data-embed="' + _.escape(JSON.stringify(item)) + '" class="mwater-visualization-text-widget-expr">' + (exprHtml || "\u00A0") + '</span>\u2060';
      } else {
        html += exprHtml;
      }
    }
    return html;
  };

  ExprItemsHtmlConverter.prototype.convertElemToItems = function(elem) {
    var items, takenIds, uniqueify;
    items = ExprItemsHtmlConverter.__super__.convertElemToItems.call(this, elem);
    takenIds = {};
    uniqueify = function(items) {
      var i, item, len, results;
      results = [];
      for (i = 0, len = items.length; i < len; i++) {
        item = items[i];
        if (item.type === "expr") {
          if (takenIds[item.id]) {
            item.id = uuid();
          }
          takenIds[item.id] = true;
        }
        if (item.items) {
          results.push(uniqueify(item.items));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };
    uniqueify(items);
    return items;
  };

  return ExprItemsHtmlConverter;

})(ItemsHtmlConverter);


},{"./ItemsHtmlConverter":1115,"d3-format":133,"lodash":"lodash","mwater-expressions":14,"uuid":1007}],1115:[function(require,module,exports){
var ItemsHtmlConverter, _, allowedStyles, allowedTags;

_ = require('lodash');

module.exports = ItemsHtmlConverter = (function() {
  function ItemsHtmlConverter(namedStrings) {
    this.namedStrings = namedStrings;
  }

  ItemsHtmlConverter.isBlank = function(items) {
    if (!items) {
      return true;
    }
    return _.all(items, function(item) {
      if (_.isString(item)) {
        return item.length === 0;
      }
      if (_.isObject(item) && item.type === "element") {
        return ItemsHtmlConverter.isBlank(item.items);
      }
      return false;
    });
  };

  ItemsHtmlConverter.prototype.convertItemsToHtml = function(items) {
    var attrs, first, html, i, item, itemStr, key, len, ref, ref1, ref2, value;
    html = "";
    ref = items || [];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (_.isString(item)) {
        itemStr = item;
        itemStr = itemStr.replace(/\{\{.+?\}\}/g, (function(_this) {
          return function(match) {
            var name;
            name = match.substr(2, match.length - 4);
            if (_this.namedStrings && (_this.namedStrings[name] != null)) {
              return _this.namedStrings[name];
            } else {
              return match;
            }
          };
        })(this));
        html += _.escape(itemStr);
      } else if (item.type === "element") {
        if (!allowedTags[item.tag]) {
          html += this.convertItemsToHtml(item.items);
          continue;
        }
        attrs = "";
        if (item.style) {
          attrs += " style=\"";
          first = true;
          ref1 = item.style;
          for (key in ref1) {
            value = ref1[key];
            if (!allowedStyles[key]) {
              continue;
            }
            if (!first) {
              attrs += " ";
            }
            attrs += _.escape(key) + ": " + _.escape(value) + ";";
            first = false;
          }
          attrs += "\"";
        }
        if (item.href) {
          attrs += " href=\"" + _.escape(item.href) + '"';
        }
        if (item.target) {
          attrs += " target=\"" + _.escape(item.target) + '"';
        }
        if ((ref2 = item.tag) === 'br') {
          html += "<" + item.tag + attrs + ">";
        } else {
          html += ("<" + item.tag + attrs + ">") + this.convertItemsToHtml(item.items) + ("</" + item.tag + ">");
        }
      } else {
        html += this.convertSpecialItemToHtml(item);
      }
    }
    if (html.length === 0) {
      html = '\u2060';
    }
    return html;
  };

  ItemsHtmlConverter.prototype.convertSpecialItemToHtml = function(item) {
    return "";
  };

  ItemsHtmlConverter.prototype.convertElemToItems = function(elem) {
    var i, item, items, j, len, len1, node, ref, ref1, ref2, style, tag, text;
    items = [];
    ref = elem.childNodes;
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      if (node.nodeType === 1) {
        if ((ref1 = node.dataset) != null ? ref1.embed : void 0) {
          items.push(JSON.parse(node.dataset.embed));
          continue;
        }
        tag = node.tagName.toLowerCase();
        if (tag.match(/:/)) {
          tag = tag.split(":")[1];
        }
        if (!allowedTags[tag]) {
          items = items.concat(this.convertElemToItems(node));
          continue;
        }
        item = {
          type: "element",
          tag: tag,
          items: this.convertElemToItems(node)
        };
        if (node.style != null) {
          ref2 = node.style;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            style = ref2[j];
            if (!allowedStyles[style]) {
              continue;
            }
            item.style = item.style || {};
            item.style[style] = node.style[style];
          }
        }
        if (node.align) {
          item.style = item.style || {};
          item.style['text-align'] = node.align;
        }
        if (node.href) {
          item.href = node.href;
        }
        if (node.target) {
          item.target = node.target;
        }
        items.push(item);
      } else if (node.nodeType === 3) {
        text = node.nodeValue;
        text = text.replace(/\u2060/g, '');
        if (text.length > 0) {
          items.push(text);
        }
      }
    }
    return items;
  };

  return ItemsHtmlConverter;

})();

allowedTags = {
  div: 1,
  p: 1,
  ul: 1,
  ol: 1,
  li: 1,
  span: 1,
  b: 1,
  u: 1,
  em: 1,
  i: 1,
  br: 1,
  h1: 1,
  h2: 1,
  h3: 1,
  h4: 1,
  h5: 1,
  a: 1,
  strong: 1
};

allowedStyles = {
  "text-align": 1,
  "font-weight": 1,
  "font-style": 1,
  "text-decoration": 1
};


},{"lodash":"lodash"}],1116:[function(require,module,exports){
var ClickOutHandler, ContentEditableComponent, FloatAffixed, H, ItemsHtmlConverter, R, React, RichTextComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

ContentEditableComponent = require('mwater-expressions-ui').ContentEditableComponent;

ClickOutHandler = require('react-onclickout');

ItemsHtmlConverter = require('./ItemsHtmlConverter');

FloatAffixed = require('react-float-affixed');

module.exports = RichTextComponent = (function(superClass) {
  extend(RichTextComponent, superClass);

  RichTextComponent.propTypes = {
    items: React.PropTypes.array,
    onItemsChange: React.PropTypes.func,
    onItemClick: React.PropTypes.func,
    className: React.PropTypes.string,
    style: React.PropTypes.object,
    itemsHtmlConverter: React.PropTypes.object,
    includeHeadings: React.PropTypes.bool,
    extraPaletteButtons: React.PropTypes.node
  };

  RichTextComponent.defaultProps = {
    includeHeadings: true,
    items: [],
    itemsHtmlConverter: new ItemsHtmlConverter()
  };

  function RichTextComponent(props) {
    this.handleClick = bind(this.handleClick, this);
    this.handleCreateLink = bind(this.handleCreateLink, this);
    this.handleCommand = bind(this.handleCommand, this);
    this.handleBlur = bind(this.handleBlur, this);
    this.handleFocus = bind(this.handleFocus, this);
    this.handleChange = bind(this.handleChange, this);
    this.handleInsertExpr = bind(this.handleInsertExpr, this);
    RichTextComponent.__super__.constructor.call(this, props);
    this.state = {
      focused: false
    };
  }

  RichTextComponent.prototype.pasteHTML = function(html) {
    return this.refs.contentEditable.pasteHTML(html);
  };

  RichTextComponent.prototype.focus = function() {
    return this.refs.contentEditable.focus();
  };

  RichTextComponent.prototype.handleInsertExpr = function(item) {
    var html;
    html = '<div data-embed="' + _.escape(JSON.stringify(item)) + '"></div>';
    return this.refs.contentEditable.pasteHTML(html);
  };

  RichTextComponent.prototype.handleChange = function(elem) {
    var items;
    items = this.props.itemsHtmlConverter.convertElemToItems(elem);
    if (!_.isEqual(items, this.props.items)) {
      return this.props.onItemsChange(items);
    } else {
      return this.forceUpdate();
    }
  };

  RichTextComponent.prototype.handleFocus = function() {
    return this.setState({
      focused: true
    });
  };

  RichTextComponent.prototype.handleBlur = function() {
    return this.setState({
      focused: false
    });
  };

  RichTextComponent.prototype.handleCommand = function(command, param, ev) {
    if (param.preventDefault) {
      ev = param;
      param = null;
    }
    ev.preventDefault();
    return document.execCommand(command, false, param);
  };

  RichTextComponent.prototype.handleCreateLink = function(ev) {
    var url;
    ev.preventDefault();
    url = window.prompt("Enter URL to link to");
    if (url) {
      return document.execCommand("createLink", false, url);
    }
  };

  RichTextComponent.prototype.handleClick = function(ev) {
    var base, item, ref, ref1, ref2, ref3, ref4, ref5;
    if (!this.state.focused) {
      this.setState({
        focused: true
      });
    }
    if (((ref = ev.target.dataset) != null ? ref.embed : void 0) || ((ref1 = ev.target.parentElement) != null ? (ref2 = ref1.dataset) != null ? ref2.embed : void 0 : void 0)) {
      item = JSON.parse(((ref3 = ev.target.dataset) != null ? ref3.embed : void 0) || ((ref4 = ev.target.parentElement) != null ? (ref5 = ref4.dataset) != null ? ref5.embed : void 0 : void 0));
      if (item != null) {
        return typeof (base = this.props).onItemClick === "function" ? base.onItemClick(item) : void 0;
      }
    }
  };

  RichTextComponent.prototype.createHtml = function() {
    return this.props.itemsHtmlConverter.convertItemsToHtml(this.props.items);
  };

  RichTextComponent.prototype.renderPalette = function() {
    return R(FloatAffixed, {
      edges: "over,under,left,right",
      align: "center"
    }, H.div({
      key: "palette",
      className: "mwater-visualization-text-palette"
    }, H.div({
      key: "bold",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "bold")
    }, H.b(null, "B")), H.div({
      key: "italic",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "italic")
    }, H.i(null, "I")), H.div({
      key: "underline",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "underline")
    }, H.span({
      style: {
        textDecoration: "underline"
      }
    }, "U")), H.div({
      key: "link",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCreateLink
    }, H.i({
      className: "fa fa-link"
    })), H.div({
      key: "justifyLeft",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "justifyLeft")
    }, H.i({
      className: "fa fa-align-left"
    })), H.div({
      key: "justifyCenter",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "justifyCenter")
    }, H.i({
      className: "fa fa-align-center"
    })), H.div({
      key: "justifyRight",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "justifyRight")
    }, H.i({
      className: "fa fa-align-right"
    })), H.div({
      key: "justifyFull",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "justifyFull")
    }, H.i({
      className: "fa fa-align-justify"
    })), H.div({
      key: "insertUnorderedList",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "insertUnorderedList")
    }, H.i({
      className: "fa fa-list-ul"
    })), H.div({
      key: "insertOrderedList",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleCommand.bind(null, "insertOrderedList")
    }, H.i({
      className: "fa fa-list-ol"
    })), this.props.includeHeadings ? [
      H.div({
        key: "h1",
        className: "mwater-visualization-text-palette-item",
        onMouseDown: this.handleCommand.bind(null, "formatBlock", "<H1>")
      }, H.i({
        className: "fa fa-header"
      })), H.div({
        key: "h2",
        className: "mwater-visualization-text-palette-item",
        onMouseDown: this.handleCommand.bind(null, "formatBlock", "<H2>")
      }, H.i({
        className: "fa fa-header",
        style: {
          fontSize: "80%"
        }
      })), H.div({
        key: "p",
        className: "mwater-visualization-text-palette-item",
        onMouseDown: this.handleCommand.bind(null, "formatBlock", "<div>")
      }, "\u00b6")
    ] : void 0, this.props.extraPaletteButtons));
  };

  RichTextComponent.prototype.renderHtml = function() {
    var ref;
    if (this.props.onItemsChange != null) {
      return H.div({
        key: "contents",
        style: this.props.style,
        className: this.props.className
      }, R(ContentEditableComponent, {
        ref: "contentEditable",
        style: {
          outline: "none"
        },
        html: this.createHtml(),
        onChange: this.handleChange,
        onClick: this.handleClick,
        onFocus: this.handleFocus,
        onBlur: this.handleBlur
      }), ((ref = this.props.items) != null ? ref[0] : void 0) == null ? H.div({
        key: "placeholder",
        style: {
          color: "#DDD",
          position: "absolute",
          top: 0,
          left: 0,
          right: 0,
          pointerEvents: "none"
        }
      }, "Click to Edit") : void 0);
    } else {
      return H.div({
        key: "contents",
        style: this.props.style,
        className: this.props.className,
        dangerouslySetInnerHTML: {
          __html: this.createHtml()
        }
      });
    }
  };

  RichTextComponent.prototype.render = function() {
    return H.div({
      style: {
        position: "relative"
      }
    }, this.renderHtml(), this.state.focused ? this.renderPalette() : void 0);
  };

  return RichTextComponent;

})(React.Component);


},{"./ItemsHtmlConverter":1115,"lodash":"lodash","mwater-expressions-ui":362,"react":"react","react-float-affixed":775,"react-onclickout":812}],1117:[function(require,module,exports){
var DirectWidgetDataSource;

module.exports = DirectWidgetDataSource = (function() {
  function DirectWidgetDataSource(options) {
    this.options = options;
  }

  DirectWidgetDataSource.prototype.getData = function(design, filters, callback) {
    return this.options.widget.getData(design, this.options.schema, this.options.dataSource, filters, callback);
  };

  DirectWidgetDataSource.prototype.getMapDataSource = function(design) {
    var DirectMapDataSource;
    DirectMapDataSource = require('../maps/DirectMapDataSource');
    return new DirectMapDataSource({
      apiUrl: this.options.apiUrl,
      client: this.options.client,
      design: design,
      schema: this.options.schema,
      dataSource: this.options.dataSource
    });
  };

  DirectWidgetDataSource.prototype.getImageUrl = function(imageId, height) {
    return this.options.dataSource.getImageUrl(imageId, height);
  };

  return DirectWidgetDataSource;

})();


},{"../maps/DirectMapDataSource":1082}],1118:[function(require,module,exports){
var DropdownWidgetComponent, H, React, ReactDOM,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

ReactDOM = require('react-dom');

H = React.DOM;

module.exports = DropdownWidgetComponent = (function(superClass) {
  extend(DropdownWidgetComponent, superClass);

  function DropdownWidgetComponent() {
    this.closeMenu = bind(this.closeMenu, this);
    this.renderDropdownItem = bind(this.renderDropdownItem, this);
    return DropdownWidgetComponent.__super__.constructor.apply(this, arguments);
  }

  DropdownWidgetComponent.propTypes = {
    width: React.PropTypes.any,
    height: React.PropTypes.any,
    dropdownItems: React.PropTypes.arrayOf(React.PropTypes.shape({
      label: React.PropTypes.node.isRequired,
      icon: React.PropTypes.string,
      onClick: React.PropTypes.func.isRequired
    })).isRequired
  };

  DropdownWidgetComponent.prototype.renderDropdownItem = function(item, i) {
    return H.li({
      key: "" + i
    }, H.a({
      onClick: item.onClick
    }, item.icon ? H.span({
      className: "glyphicon glyphicon-" + item.icon + " text-muted"
    }) : void 0, item.icon ? " " : void 0, item.label));
  };

  DropdownWidgetComponent.prototype.renderDropdown = function() {
    var dropdownStyle, elem;
    if (this.props.dropdownItems.length === 0) {
      return null;
    }
    dropdownStyle = {
      position: "absolute",
      right: 3,
      top: 3,
      cursor: "pointer",
      zIndex: 10000
    };
    elem = H.div({
      style: dropdownStyle,
      "data-toggle": "dropdown"
    }, H.div({
      className: "mwater-visualization-simple-widget-gear-button"
    }, H.span({
      className: "glyphicon glyphicon-cog"
    })));
    return H.div({
      style: dropdownStyle
    }, elem, H.ul({
      className: "dropdown-menu dropdown-menu-right",
      style: {
        top: 25
      }
    }, _.map(this.props.dropdownItems, this.renderDropdownItem)));
  };

  DropdownWidgetComponent.prototype.closeMenu = function() {
    return $(ReactDOM.findDOMNode(this)).find('[data-toggle="dropdown"]').parent().removeClass('open');
  };

  DropdownWidgetComponent.prototype.render = function() {
    return H.div({
      className: "mwater-visualization-simple-widget",
      onMouseLeave: this.closeMenu,
      style: {
        width: this.props.width,
        height: this.props.height
      }
    }, this.props.children, this.renderDropdown());
  };

  return DropdownWidgetComponent;

})(React.Component);


},{"react":"react","react-dom":"react-dom"}],1119:[function(require,module,exports){
var H, IFrameWidget, R, React, Widget, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

Widget = require('./Widget');

module.exports = IFrameWidget = (function(superClass) {
  extend(IFrameWidget, superClass);

  function IFrameWidget() {
    return IFrameWidget.__super__.constructor.apply(this, arguments);
  }

  IFrameWidget.prototype.createViewElement = function(options) {
    var IFrameWidgetComponent;
    IFrameWidgetComponent = require('./IFrameWidgetComponent');
    return R(IFrameWidgetComponent, {
      design: options.design,
      onDesignChange: options.onDesignChange,
      width: options.width,
      height: options.height
    });
  };

  IFrameWidget.prototype.isAutoHeight = function() {
    return false;
  };

  return IFrameWidget;

})(Widget);


},{"./IFrameWidgetComponent":1120,"./Widget":1127,"lodash":"lodash","react":"react"}],1120:[function(require,module,exports){
var DropdownWidgetComponent, H, IFrameWidgetComponent, ModalPopupComponent, R, React, _, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

ui = require('react-library/lib/bootstrap');

DropdownWidgetComponent = require('./DropdownWidgetComponent');

ModalPopupComponent = require('react-library/lib/ModalPopupComponent');

module.exports = IFrameWidgetComponent = (function(superClass) {
  extend(IFrameWidgetComponent, superClass);

  IFrameWidgetComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number,
    height: React.PropTypes.number
  };

  function IFrameWidgetComponent(props) {
    this.handleEndEditing = bind(this.handleEndEditing, this);
    this.handleStartEditing = bind(this.handleStartEditing, this);
    IFrameWidgetComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editing: false,
      editUrl: null
    };
  }

  IFrameWidgetComponent.prototype.handleStartEditing = function() {
    return this.setState({
      editing: true,
      editUrl: this.props.design.url
    });
  };

  IFrameWidgetComponent.prototype.handleEndEditing = function() {
    this.setState({
      editing: false
    });
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      url: this.state.editUrl
    }));
  };

  IFrameWidgetComponent.prototype.renderEditor = function() {
    var content;
    if (!this.state.editing) {
      return null;
    }
    content = H.div({
      className: "form-group"
    }, H.label(null, "URL to embed"), H.input({
      type: "text",
      className: "form-control",
      value: this.state.editUrl || "",
      onChange: (function(_this) {
        return function(ev) {
          return _this.setState({
            editUrl: ev.target.value
          });
        };
      })(this)
    }), H.p({
      className: "help-block"
    }, 'e.g. https://www.youtube.com/embed/dQw4w9WgXcQ'));
    return R(ModalPopupComponent, {
      header: "Configure",
      showCloseX: true,
      onClose: this.handleEndEditing
    }, content);
  };

  IFrameWidgetComponent.prototype.renderEditLink = function() {
    return H.div({
      className: "mwater-visualization-widget-placeholder",
      onClick: this.handleStartEditing
    }, R(ui.Icon, {
      id: "fa-youtube-play"
    }));
  };

  IFrameWidgetComponent.prototype.render = function() {
    var dropdownItems;
    dropdownItems = [];
    if (this.props.onDesignChange != null) {
      dropdownItems.push({
        label: "Edit",
        icon: "pencil",
        onClick: this.handleStartEditing
      });
    }
    return R(DropdownWidgetComponent, {
      width: this.props.width,
      height: this.props.height,
      dropdownItems: dropdownItems
    }, this.renderEditor(), this.props.design.url ? H.iframe({
      src: this.props.design.url,
      width: this.props.width,
      height: this.props.height,
      frameborder: 0,
      allowfullscreen: true
    }) : this.props.onDesignChange != null ? this.renderEditLink() : void 0);
  };

  return IFrameWidgetComponent;

})(React.Component);


},{"./DropdownWidgetComponent":1118,"lodash":"lodash","react":"react","react-library/lib/ModalPopupComponent":786,"react-library/lib/bootstrap":793}],1121:[function(require,module,exports){
var Dropzone, H, ImageUploaderComponent, R, React, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

Dropzone = require('react-dropzone');

uuid = require('uuid');

module.exports = ImageUploaderComponent = (function(superClass) {
  extend(ImageUploaderComponent, superClass);

  ImageUploaderComponent.propTypes = {
    dataSource: React.PropTypes.object.isRequired,
    onUpload: React.PropTypes.func.isRequired,
    uid: React.PropTypes.string
  };

  function ImageUploaderComponent(props) {
    this.handleChangeImage = bind(this.handleChangeImage, this);
    this.uploadComplete = bind(this.uploadComplete, this);
    this.uploadProgress = bind(this.uploadProgress, this);
    this.onFileDrop = bind(this.onFileDrop, this);
    ImageUploaderComponent.__super__.constructor.call(this, props);
    this.state = {
      uid: props.uid,
      files: null,
      uploading: false,
      editing: props.uid ? false : true
    };
  }

  ImageUploaderComponent.prototype.onFileDrop = function(files) {
    var fd, id;
    this.setState({
      files: files,
      uploading: true
    });
    this.xhr = new XMLHttpRequest();
    fd = new FormData();
    fd.append("image", files[0]);
    this.xhr.upload.onprogress = this.uploadProgress;
    this.xhr.addEventListener("load", this.uploadComplete, false);
    id = this.createId();
    this.xhr.open("POST", this.props.dataSource.getImageUrl(id));
    this.xhr.send(fd);
    return this.setState({
      uid: id
    });
  };

  ImageUploaderComponent.prototype.uploadProgress = function(e) {
    var percentComplete;
    if (!this.progressBar) {
      return;
    }
    if (e.lengthComputable) {
      percentComplete = Math.round(e.loaded * 100 / e.total);
      return this.progressBar.style.width = percentComplete + "%";
    } else {
      return this.progressBar.style.width = "100%";
    }
  };

  ImageUploaderComponent.prototype.uploadComplete = function(e) {
    if (e.target.status === 200) {
      this.setState({
        uploading: false,
        files: null,
        editing: false
      });
      return this.props.onUpload(this.state.uid);
    } else {
      return alert("Upload failed: " + e.target.responseText);
    }
  };

  ImageUploaderComponent.prototype.createId = function() {
    return uuid().replace(/-/g, "");
  };

  ImageUploaderComponent.prototype.renderUploader = function() {
    return H.div(null, R(Dropzone, {
      className: 'dropzone',
      multiple: false,
      onDrop: this.onFileDrop
    }, this.state.uploading ? H.div({
      className: 'progress'
    }, H.div({
      className: 'progress-bar',
      style: {
        width: '0%'
      },
      ref: (function(_this) {
        return function(c) {
          return _this.progressBar = c;
        };
      })(this)
    })) : H.div(null, "Drop file here or click to select file")), this.state.uid ? H.a({
      onClick: ((function(_this) {
        return function() {
          return _this.setState({
            editing: false
          });
        };
      })(this))
    }, "Cancel") : void 0);
  };

  ImageUploaderComponent.prototype.renderPreview = function() {
    var thumbnailStyle;
    thumbnailStyle = {
      width: "100px",
      maxWidth: "100%",
      maxHeight: "100%",
      padding: 4,
      border: '1px solid #aeaeae',
      marginRight: 20
    };
    return H.div(null, H.img({
      style: thumbnailStyle,
      src: this.props.dataSource.getImageUrl(this.state.uid)
    }), H.a({
      className: 'btn btn-default',
      onClick: this.handleChangeImage
    }, "Change"));
  };

  ImageUploaderComponent.prototype.handleChangeImage = function() {
    return this.setState({
      editing: true
    });
  };

  ImageUploaderComponent.prototype.render = function() {
    return H.div(null, this.state.uid && !this.state.editing ? this.renderPreview() : void 0, this.state.editing || !this.state.uid ? this.renderUploader() : void 0);
  };

  return ImageUploaderComponent;

})(React.Component);


},{"react":"react","react-dropzone":773,"uuid":1007}],1122:[function(require,module,exports){
var ExprCompiler, H, ImageWidget, R, React, Widget, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

ExprCompiler = require('mwater-expressions').ExprCompiler;

injectTableAlias = require('mwater-expressions').injectTableAlias;

Widget = require('./Widget');

module.exports = ImageWidget = (function(superClass) {
  extend(ImageWidget, superClass);

  function ImageWidget() {
    return ImageWidget.__super__.constructor.apply(this, arguments);
  }

  ImageWidget.prototype.createViewElement = function(options) {
    var ImageWidgetComponent;
    ImageWidgetComponent = require('./ImageWidgetComponent');
    return R(ImageWidgetComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      widgetDataSource: options.widgetDataSource,
      filters: options.filters,
      design: options.design,
      onDesignChange: options.onDesignChange,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      singleRowTable: options.singleRowTable
    });
  };

  ImageWidget.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var exprCompiler, imageExpr, query, table, whereClauses;
    if (!design.expr) {
      return callback(null);
    }
    table = design.expr.table;
    exprCompiler = new ExprCompiler(schema);
    imageExpr = exprCompiler.compileExpr({
      expr: design.expr,
      tableAlias: "main"
    });
    query = {
      distinct: true,
      selects: [
        {
          type: "select",
          expr: imageExpr,
          alias: "value"
        }
      ],
      from: {
        type: "table",
        table: table,
        alias: "main"
      },
      limit: 2
    };
    filters = _.where(filters || [], {
      table: table
    });
    whereClauses = _.map(filters, function(f) {
      return injectTableAlias(f.jsonql, "main");
    });
    whereClauses.push({
      type: "op",
      op: "is not null",
      exprs: [imageExpr]
    });
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    return dataSource.performQuery(query, (function(_this) {
      return function(error, rows) {
        var value;
        if (error) {
          return callback(error);
        } else {
          if (rows.length !== 1) {
            return callback(null, null);
          } else {
            value = rows[0].value;
            if (_.isString(rows[0].value)) {
              value = JSON.parse(rows[0].value);
            }
            return callback(null, value);
          }
        }
      };
    })(this));
  };

  ImageWidget.prototype.isAutoHeight = function() {
    return false;
  };

  ImageWidget.prototype.getFilterableTables = function(design, schema) {
    var ref;
    if ((ref = design.expr) != null ? ref.table : void 0) {
      return [design.expr.table];
    }
    return [];
  };

  return ImageWidget;

})(Widget);


},{"./ImageWidgetComponent":1123,"./Widget":1127,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1123:[function(require,module,exports){
var AsyncLoadComponent, AutoSizeComponent, DropdownWidgetComponent, Dropzone, ExprComponent, H, ImageUploaderComponent, ImageWidgetComponent, ImageWidgetDesignComponent, ImagelistCarouselComponent, ModalPopupComponent, R, React, TabbedComponent, TableSelectComponent, _, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

uuid = require('uuid');

Dropzone = require('react-dropzone');

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

AutoSizeComponent = require('react-library/lib/AutoSizeComponent');

DropdownWidgetComponent = require('./DropdownWidgetComponent');

ModalPopupComponent = require('react-library/lib/ModalPopupComponent');

TabbedComponent = require('react-library/lib/TabbedComponent');

ExprComponent = require("mwater-expressions-ui").ExprComponent;

TableSelectComponent = require('../TableSelectComponent');

ImageUploaderComponent = require('./ImageUploaderComponent');

ImagelistCarouselComponent = require('./ImagelistCarouselComponent');

module.exports = ImageWidgetComponent = (function(superClass) {
  extend(ImageWidgetComponent, superClass);

  function ImageWidgetComponent() {
    this.handleStartEditing = bind(this.handleStartEditing, this);
    return ImageWidgetComponent.__super__.constructor.apply(this, arguments);
  }

  ImageWidgetComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    filters: React.PropTypes.array,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    widgetDataSource: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    singleRowTable: React.PropTypes.string
  };

  ImageWidgetComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    return newProps.design.expr && (!_.isEqual(newProps.design.expr, oldProps.design.expr) || !_.isEqual(newProps.filters, oldProps.filters));
  };

  ImageWidgetComponent.prototype.load = function(props, prevProps, callback) {
    return props.widgetDataSource.getData(props.design, props.filters, (function(_this) {
      return function(error, data) {
        return callback({
          error: error,
          data: data
        });
      };
    })(this));
  };

  ImageWidgetComponent.prototype.handleStartEditing = function() {
    return this.refs.editor.edit();
  };

  ImageWidgetComponent.prototype.renderEditLink = function() {
    return H.div({
      className: "mwater-visualization-widget-placeholder",
      onClick: this.handleStartEditing
    }, H.i({
      className: "icon fa fa-image"
    }));
  };

  ImageWidgetComponent.prototype.renderEditor = function() {
    return R(ImageWidgetDesignComponent, {
      ref: "editor",
      key: "editor",
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource
    });
  };

  ImageWidgetComponent.prototype.renderExpression = function() {
    if (this.state.loading) {
      return H.span(null, "Loading");
    } else if (this.state.data) {
      if (!_.isArray(this.state.data)) {
        return R(AutoSizeComponent, {
          injectHeight: true
        }, (function(_this) {
          return function(size) {
            return R(ImagelistCarouselComponent, {
              widgetDataSource: _this.props.widgetDataSource,
              imagelist: [_this.state.data],
              height: size.height
            });
          };
        })(this));
      } else {
        return R(AutoSizeComponent, {
          injectHeight: true
        }, (function(_this) {
          return function(size) {
            return R(ImagelistCarouselComponent, {
              widgetDataSource: _this.props.widgetDataSource,
              imagelist: _this.state.data,
              height: size.height
            });
          };
        })(this));
      }
    }
  };

  ImageWidgetComponent.prototype.renderContent = function() {
    var imageHeight, source;
    if (this.props.design.imageUrl || this.props.design.uid) {
      imageHeight = null;
      if (this.props.height <= 160) {
        imageHeight = 160;
      } else if (this.props.height <= 320) {
        imageHeight = 320;
      } else if (this.props.height <= 640) {
        imageHeight = 640;
      } else if (this.props.height <= 1280) {
        imageHeight = 1280;
      }
      source = this.props.design.imageUrl || this.props.widgetDataSource.getImageUrl(this.props.design.uid, imageHeight);
      return H.img({
        style: {
          maxWidth: "100%",
          maxHeight: "100%"
        },
        src: source
      });
    } else {
      return this.renderExpression();
    }
  };

  ImageWidgetComponent.prototype.render = function() {
    var dropdownItems;
    dropdownItems = [];
    if (this.props.onDesignChange != null) {
      dropdownItems.push({
        label: "Edit",
        icon: "pencil",
        onClick: this.handleStartEditing
      });
    }
    return R(DropdownWidgetComponent, {
      width: this.props.width,
      height: this.props.height,
      dropdownItems: dropdownItems
    }, this.renderEditor(), !this.props.design.imageUrl && !this.props.design.expr && !this.props.design.uid && this.props.onDesignChange ? this.renderEditLink() : H.div({
      className: "mwater-visualization-image-widget",
      style: {
        position: "relative",
        width: this.props.width,
        height: this.props.height
      }
    }, H.div({
      className: "image"
    }, this.renderContent()), H.div({
      className: "caption"
    }, this.props.design.caption)));
  };

  return ImageWidgetComponent;

})(AsyncLoadComponent);

ImageWidgetDesignComponent = (function(superClass) {
  extend(ImageWidgetDesignComponent, superClass);

  ImageWidgetDesignComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired
  };

  function ImageWidgetDesignComponent(props) {
    this.handleCancel = bind(this.handleCancel, this);
    this.handleSave = bind(this.handleSave, this);
    this.handleCaptionChange = bind(this.handleCaptionChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleExpressionChange = bind(this.handleExpressionChange, this);
    this.handleFileUpload = bind(this.handleFileUpload, this);
    this.handleUrlChange = bind(this.handleUrlChange, this);
    this.edit = bind(this.edit, this);
    ImageWidgetDesignComponent.__super__.constructor.call(this, props);
    this.state = {
      data: null,
      error: null,
      editing: false,
      imageUrl: null,
      expr: null,
      table: null,
      uid: null,
      files: null,
      uploading: false,
      caption: null,
      currentTab: "url"
    };
  }

  ImageWidgetDesignComponent.prototype.edit = function() {
    var ref, state;
    this.setCurrentTab();
    state = {
      editing: true,
      imageUrl: this.props.design.imageUrl,
      uid: this.props.design.uid,
      expr: this.props.design.expr,
      table: (ref = this.props.design.expr) != null ? ref.table : void 0,
      caption: this.props.design.caption
    };
    return this.setState(state);
  };

  ImageWidgetDesignComponent.prototype.setCurrentTab = function() {
    var tab;
    tab = "upload";
    if (this.props.design.url) {
      tab = "url";
    }
    if (this.props.design.expr) {
      tab = "expression";
    }
    return this.setState({
      currentTab: tab
    });
  };

  ImageWidgetDesignComponent.prototype.handleUrlChange = function(e) {
    return this.setState({
      imageUrl: e.target.value,
      uid: null,
      expr: null
    });
  };

  ImageWidgetDesignComponent.prototype.renderUploadEditor = function() {
    return R(ImageUploaderComponent, {
      dataSource: this.props.dataSource,
      onUpload: this.handleFileUpload,
      uid: this.props.design.uid
    });
  };

  ImageWidgetDesignComponent.prototype.handleFileUpload = function(uid) {
    return this.setState({
      imageUrl: null,
      uid: uid,
      expr: null
    });
  };

  ImageWidgetDesignComponent.prototype.handleExpressionChange = function(expr) {
    return this.setState({
      imageUrl: null,
      uid: null,
      expr: expr
    });
  };

  ImageWidgetDesignComponent.prototype.handleTableChange = function(table) {
    return this.setState({
      table: table
    });
  };

  ImageWidgetDesignComponent.prototype.handleCaptionChange = function(ev) {
    return this.setState({
      caption: ev.target.value
    });
  };

  ImageWidgetDesignComponent.prototype.handleSave = function() {
    var updates;
    this.setState({
      editing: false
    });
    updates = {
      imageUrl: this.state.imageUrl,
      uid: this.state.uid,
      expr: this.state.expr,
      caption: this.state.caption
    };
    return this.props.onDesignChange(_.extend({}, this.props.design, updates));
  };

  ImageWidgetDesignComponent.prototype.handleCancel = function() {
    this.setCurrentTab();
    return this.setState({
      editing: false,
      imageUrl: null,
      uid: null,
      expr: null,
      table: null,
      files: null,
      uploading: false
    });
  };

  ImageWidgetDesignComponent.prototype.renderExpressionEditor = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.state.table,
      onChange: this.handleTableChange
    }), H.br(), this.state.table ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Field"), ": ", R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.state.table,
      types: ['image', 'imagelist'],
      value: this.state.expr,
      aggrStatuses: ["individual", "literal"],
      onChange: this.handleExpressionChange
    })) : void 0);
  };

  ImageWidgetDesignComponent.prototype.renderUrlEditor = function() {
    return H.div({
      className: "form-group"
    }, H.label(null, "URL of image"), H.input({
      type: "text",
      className: "form-control",
      value: this.state.imageUrl || "",
      onChange: this.handleUrlChange
    }), H.p({
      className: "help-block"
    }, 'e.g. http://somesite.com/image.jpg'));
  };

  ImageWidgetDesignComponent.prototype.render = function() {
    var content, footer;
    if (!this.state.editing) {
      return null;
    }
    content = H.div(null, H.div({
      className: "form-group"
    }, H.label(null, "Caption"), H.input({
      type: "text",
      className: "form-control",
      value: this.state.caption || "",
      onChange: this.handleCaptionChange,
      placeholder: "Optional caption to display below image"
    })), R(TabbedComponent, {
      tabs: [
        {
          id: "upload",
          label: "Upload",
          elem: this.renderUploadEditor()
        }, {
          id: "expression",
          label: "From Data",
          elem: this.renderExpressionEditor()
        }, {
          id: "url",
          label: "From URL",
          elem: this.renderUrlEditor()
        }
      ],
      initialTabId: this.state.currentTab
    }));
    footer = H.div(null, H.button({
      key: "save",
      type: "button",
      className: "btn btn-primary",
      onClick: this.handleSave
    }, "Save"), H.button({
      key: "cancel",
      type: "button",
      className: "btn btn-default",
      onClick: this.handleCancel
    }, "Cancel"));
    return R(ModalPopupComponent, {
      header: "Image",
      scrollDisabled: true,
      footer: footer
    }, content);
  };

  return ImageWidgetDesignComponent;

})(React.Component);


},{"../TableSelectComponent":1025,"./DropdownWidgetComponent":1118,"./ImageUploaderComponent":1121,"./ImagelistCarouselComponent":1124,"lodash":"lodash","mwater-expressions-ui":362,"react":"react","react-dropzone":773,"react-library/lib/AsyncLoadComponent":782,"react-library/lib/AutoSizeComponent":783,"react-library/lib/ModalPopupComponent":786,"react-library/lib/TabbedComponent":792,"uuid":1007}],1124:[function(require,module,exports){
var H, ImagelistCarouselComponent, R, React, RotationAwareImageComponent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

RotationAwareImageComponent = require("mwater-forms/lib/RotationAwareImageComponent");

module.exports = ImagelistCarouselComponent = (function(superClass) {
  extend(ImagelistCarouselComponent, superClass);

  ImagelistCarouselComponent.propTypes = {
    imagelist: React.PropTypes.array,
    widgetDataSource: React.PropTypes.object.isRequired,
    height: React.PropTypes.number
  };

  function ImagelistCarouselComponent() {
    this.handleRight = bind(this.handleRight, this);
    this.handleLeft = bind(this.handleLeft, this);
    ImagelistCarouselComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      activeImage: _.findIndex(this.props.imagelist, {
        cover: true
      })
    };
    if (this.state.activeImage < 0) {
      this.state.activeImage = 0;
    }
  }

  ImagelistCarouselComponent.prototype.handleLeft = function() {
    var activeImage;
    if (this.props.imagelist && this.props.imagelist.length > 0) {
      activeImage = (this.state.activeImage - 1 + this.props.imagelist.length) % this.props.imagelist.length;
      return this.setState({
        activeImage: activeImage
      });
    }
  };

  ImagelistCarouselComponent.prototype.handleRight = function() {
    var activeImage;
    if (this.props.imagelist && this.props.imagelist.length > 0) {
      activeImage = (this.state.activeImage + 1 + this.props.imagelist.length) % this.props.imagelist.length;
      return this.setState({
        activeImage: activeImage
      });
    }
  };

  ImagelistCarouselComponent.prototype.renderImage = function(img, i, imageManager) {
    return H.div({
      className: "item " + (i === this.state.activeImage ? "active" : ""),
      style: {
        height: this.props.height
      }
    }, R(RotationAwareImageComponent, {
      imageManager: imageManager,
      image: img
    }));
  };

  ImagelistCarouselComponent.prototype.renderImages = function(imageManager) {
    var i, imageObj, j, len, ref, results;
    ref = this.props.imagelist;
    results = [];
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      imageObj = ref[i];
      results.push(this.renderImage(imageObj, i, imageManager));
    }
    return results;
  };

  ImagelistCarouselComponent.prototype.render = function() {
    var imageManager;
    imageManager = {
      getImageThumbnailUrl: (function(_this) {
        return function(id, success, error) {
          return success(_this.props.widgetDataSource.getImageUrl(id, 100));
        };
      })(this),
      getImageUrl: (function(_this) {
        return function(id, success, error) {
          return success(_this.props.widgetDataSource.getImageUrl(id, 640));
        };
      })(this)
    };
    if (this.props.imagelist.length === 1) {
      return this.renderImage(this.props.imagelist[0], 0, imageManager);
    }
    if (this.props.imagelist.length === 0) {
      return null;
    }
    return H.div({
      className: "image-carousel-component carousel slide",
      style: {
        height: this.props.height,
        overflow: 'hidden'
      }
    }, this.props.imagelist.length < 10 ? H.ol({
      className: "carousel-indicators"
    }, _.map(this.props.imagelist, (function(_this) {
      return function(img, i) {
        return H.li({
          className: i === _this.state.activeImage ? "active" : void 0
        });
      };
    })(this))) : void 0, H.div({
      className: "carousel-inner"
    }, this.renderImages(imageManager)), H.a({
      className: "left carousel-control"
    }, H.span({
      className: "glyphicon glyphicon-chevron-left",
      onClick: this.handleLeft
    })), H.a({
      className: "right carousel-control"
    }, H.span({
      className: "glyphicon glyphicon-chevron-right",
      onClick: this.handleRight
    })));
  };

  return ImagelistCarouselComponent;

})(React.Component);


},{"mwater-forms/lib/RotationAwareImageComponent":370,"react":"react"}],1125:[function(require,module,exports){
var DropdownWidgetComponent, H, LayerFactory, MapWidget, MapWidgetComponent, ModalWindowComponent, React, Widget, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

H = React.DOM;

_ = require('lodash');

Widget = require('./Widget');

DropdownWidgetComponent = require('./DropdownWidgetComponent');

ModalWindowComponent = require('react-library/lib/ModalWindowComponent');

LayerFactory = require('../maps/LayerFactory');

module.exports = MapWidget = (function(superClass) {
  extend(MapWidget, superClass);

  function MapWidget() {
    return MapWidget.__super__.constructor.apply(this, arguments);
  }

  MapWidget.prototype.createViewElement = function(options) {
    return React.createElement(MapWidgetComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      widgetDataSource: options.widgetDataSource,
      design: options.design,
      onDesignChange: options.onDesignChange,
      scope: options.scope,
      filters: options.filters,
      onScopeChange: options.onScopeChange,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      onRowClick: options.onRowClick
    });
  };

  MapWidget.prototype.getFilterableTables = function(design, schema) {
    var filterableTables, i, layer, layerView, len, ref;
    filterableTables = [];
    ref = design.layerViews;
    for (i = 0, len = ref.length; i < len; i++) {
      layerView = ref[i];
      layer = LayerFactory.createLayer(layerView.type);
      filterableTables = filterableTables.concat(layer.getFilterableTables(layerView.design, schema));
    }
    return _.uniq(_.compact(filterableTables));
  };

  return MapWidget;

})(Widget);

MapWidgetComponent = (function(superClass) {
  extend(MapWidgetComponent, superClass);

  MapWidgetComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    widgetDataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    scope: React.PropTypes.any,
    filters: React.PropTypes.array,
    onScopeChange: React.PropTypes.func,
    onRowClick: React.PropTypes.func
  };

  function MapWidgetComponent(props) {
    this.handleEditDesignChange = bind(this.handleEditDesignChange, this);
    this.handleEndEditing = bind(this.handleEndEditing, this);
    this.handleStartEditing = bind(this.handleStartEditing, this);
    MapWidgetComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editDesign: null
    };
  }

  MapWidgetComponent.prototype.handleStartEditing = function() {
    return this.setState({
      editDesign: this.props.design
    });
  };

  MapWidgetComponent.prototype.handleEndEditing = function() {
    this.props.onDesignChange(this.state.editDesign);
    return this.setState({
      editDesign: null
    });
  };

  MapWidgetComponent.prototype.handleEditDesignChange = function(design) {
    return this.setState({
      editDesign: design
    });
  };

  MapWidgetComponent.prototype.renderEditor = function() {
    var MapDesignerComponent, chart, content, editor, height, width;
    if (!this.state.editDesign) {
      return null;
    }
    MapDesignerComponent = require('../maps/MapDesignerComponent');
    editor = React.createElement(MapDesignerComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.state.editDesign,
      onDesignChange: this.handleEditDesignChange
    });
    width = Math.min(document.body.clientWidth / 2, this.props.width);
    height = this.props.height * width / this.props.width;
    chart = this.renderContent(this.state.editDesign, this.handleEditDesignChange, width, height);
    content = H.div({
      style: {
        height: "100%",
        width: "100%"
      }
    }, H.div({
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        border: "solid 2px #EEE",
        borderRadius: 8,
        padding: 10,
        width: width + 20,
        height: height + 20
      }
    }, chart), H.div({
      style: {
        width: "100%",
        height: "100%",
        paddingLeft: width + 40
      }
    }, H.div({
      style: {
        width: "100%",
        height: "100%",
        overflowY: "auto",
        paddingLeft: 20,
        borderLeft: "solid 3px #AAA"
      }
    }, editor)));
    return React.createElement(ModalWindowComponent, {
      isOpen: true,
      onRequestClose: this.handleEndEditing
    }, content);
  };

  MapWidgetComponent.prototype.renderContent = function(design, onDesignChange, width, height) {
    var MapViewComponent;
    MapViewComponent = require('../maps/MapViewComponent');
    return H.div({
      style: {
        width: width,
        height: height,
        padding: 10
      }
    }, React.createElement(MapViewComponent, {
      schema: this.props.schema,
      design: design,
      dataSource: this.props.dataSource,
      mapDataSource: this.props.widgetDataSource.getMapDataSource(design),
      onDesignChange: onDesignChange,
      scope: this.props.scope,
      onScopeChange: this.props.onScopeChange,
      extraFilters: this.props.filters,
      width: width - 20,
      height: height - 20,
      scrollWheelZoom: false,
      onRowClick: this.props.onRowClick
    }));
  };

  MapWidgetComponent.prototype.render = function() {
    var dropdownItems;
    dropdownItems = [];
    if (this.props.onDesignChange != null) {
      dropdownItems.push({
        label: "Edit",
        icon: "pencil",
        onClick: this.handleStartEditing
      });
    }
    return H.div(null, this.props.onDesignChange != null ? this.renderEditor() : void 0, React.createElement(DropdownWidgetComponent, {
      width: this.props.width,
      height: this.props.height,
      dropdownItems: dropdownItems
    }, this.renderContent(this.props.design, null, this.props.width, this.props.height)));
  };

  return MapWidgetComponent;

})(React.Component);


},{"../maps/LayerFactory":1085,"../maps/MapDesignerComponent":1095,"../maps/MapViewComponent":1100,"./DropdownWidgetComponent":1118,"./Widget":1127,"lodash":"lodash","react":"react","react-library/lib/ModalWindowComponent":787}],1126:[function(require,module,exports){
var DropdownWidgetComponent, H, MarkdownWidget, MarkdownWidgetComponent, MarkdownWidgetDesignerComponent, MarkdownWidgetViewComponent, ModalWindowComponent, React, Widget, _, markdown,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

H = React.DOM;

_ = require('lodash');

Widget = require('./Widget');

DropdownWidgetComponent = require('./DropdownWidgetComponent');

markdown = require("markdown").markdown;

ModalWindowComponent = require('react-library/lib/ModalWindowComponent');

module.exports = MarkdownWidget = (function(superClass) {
  extend(MarkdownWidget, superClass);

  function MarkdownWidget() {
    return MarkdownWidget.__super__.constructor.apply(this, arguments);
  }

  MarkdownWidget.prototype.createViewElement = function(options) {
    return React.createElement(MarkdownWidgetComponent, {
      design: options.design,
      onDesignChange: options.onDesignChange,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth
    });
  };

  MarkdownWidget.prototype.isAutoHeight = function() {
    return true;
  };

  return MarkdownWidget;

})(Widget);

MarkdownWidgetComponent = (function(superClass) {
  extend(MarkdownWidgetComponent, superClass);

  MarkdownWidgetComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number
  };

  function MarkdownWidgetComponent(props) {
    this.handleEditDesignChange = bind(this.handleEditDesignChange, this);
    this.handleEndEditing = bind(this.handleEndEditing, this);
    this.handleStartEditing = bind(this.handleStartEditing, this);
    MarkdownWidgetComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editDesign: null
    };
  }

  MarkdownWidgetComponent.prototype.handleStartEditing = function() {
    return this.setState({
      editDesign: this.props.design
    });
  };

  MarkdownWidgetComponent.prototype.handleEndEditing = function() {
    this.props.onDesignChange(this.state.editDesign);
    return this.setState({
      editDesign: null
    });
  };

  MarkdownWidgetComponent.prototype.handleEditDesignChange = function(design) {
    return this.setState({
      editDesign: design
    });
  };

  MarkdownWidgetComponent.prototype.renderEditor = function() {
    var chart, content, editor, width;
    if (!this.state.editDesign) {
      return null;
    }
    editor = React.createElement(MarkdownWidgetDesignerComponent, {
      design: this.state.editDesign,
      onDesignChange: this.handleEditDesignChange
    });
    width = Math.min(document.body.clientWidth / 2, this.props.width);
    chart = this.renderContent(this.state.editDesign);
    content = H.div({
      style: {
        height: "100%",
        width: "100%"
      }
    }, H.div({
      style: {
        position: "absolute",
        left: 0,
        top: 0,
        border: "solid 2px #EEE",
        borderRadius: 8,
        padding: 10,
        width: width + 20,
        height: this.props.height + 20
      }
    }, chart), H.div({
      style: {
        width: "100%",
        height: "100%",
        paddingLeft: width + 40
      }
    }, H.div({
      style: {
        width: "100%",
        height: "100%",
        overflowY: "auto",
        paddingLeft: 20,
        borderLeft: "solid 3px #AAA"
      }
    }, editor)));
    return React.createElement(ModalWindowComponent, {
      isOpen: this.state.editing,
      onRequestClose: ((function(_this) {
        return function() {
          return _this.setState({
            editing: false
          });
        };
      })(this))
    }, content);
  };

  MarkdownWidgetComponent.prototype.renderContent = function(design) {
    return React.createElement(MarkdownWidgetViewComponent, {
      design: design,
      width: this.props.width,
      height: this.props.height,
      standardWidth: this.props.standardWidth
    });
  };

  MarkdownWidgetComponent.prototype.render = function() {
    var dropdownItems;
    dropdownItems = [];
    if (this.props.onDesignChange != null) {
      dropdownItems.push({
        label: "Edit",
        icon: "pencil",
        onClick: this.handleStartEditing
      });
    }
    return H.div({
      onDoubleClick: this.handleStartEditing
    }, this.props.onDesignChange != null ? this.renderEditor() : void 0, React.createElement(DropdownWidgetComponent, {
      width: this.props.width,
      height: this.props.height,
      dropdownItems: dropdownItems
    }, this.renderContent(this.props.design)));
  };

  return MarkdownWidgetComponent;

})(React.Component);

MarkdownWidgetViewComponent = (function(superClass) {
  extend(MarkdownWidgetViewComponent, superClass);

  function MarkdownWidgetViewComponent() {
    return MarkdownWidgetViewComponent.__super__.constructor.apply(this, arguments);
  }

  MarkdownWidgetViewComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number
  };

  MarkdownWidgetViewComponent.prototype.render = function() {
    return H.div({
      style: {
        width: this.props.standardWidth,
        height: this.props.height && this.props.standardWidth && this.props.width ? this.props.height * (this.props.standardWidth / this.props.width) : void 0,
        transform: this.props.height && this.props.standardWidth && this.props.width ? "scale(" + (this.props.width / this.props.standardWidth) + ", " + (this.props.width / this.props.standardWidth) + ")" : void 0,
        transformOrigin: this.props.height && this.props.standardWidth && this.props.width ? "0 0" : void 0
      },
      className: "mwater-visualization-markdown",
      dangerouslySetInnerHTML: {
        __html: markdown.toHTML(this.props.design.markdown || "")
      }
    });
  };

  return MarkdownWidgetViewComponent;

})(React.Component);

MarkdownWidgetDesignerComponent = (function(superClass) {
  extend(MarkdownWidgetDesignerComponent, superClass);

  function MarkdownWidgetDesignerComponent() {
    this.handleMarkdownChange = bind(this.handleMarkdownChange, this);
    return MarkdownWidgetDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  MarkdownWidgetDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  MarkdownWidgetDesignerComponent.prototype.handleMarkdownChange = function(ev) {
    var design;
    design = _.extend({}, this.props.design, {
      markdown: ev.target.value
    });
    return this.props.onDesignChange(design);
  };

  MarkdownWidgetDesignerComponent.prototype.render = function() {
    return H.textarea({
      className: "form-control",
      style: {
        width: "100%",
        height: "100%"
      },
      value: this.props.design.markdown,
      onChange: this.handleMarkdownChange
    });
  };

  return MarkdownWidgetDesignerComponent;

})(React.Component);


},{"./DropdownWidgetComponent":1118,"./Widget":1127,"lodash":"lodash","markdown":334,"react":"react","react-library/lib/ModalWindowComponent":787}],1127:[function(require,module,exports){
var Widget;

module.exports = Widget = (function() {
  function Widget() {}

  Widget.prototype.createViewElement = function(options) {
    throw new Error("Not implemented");
  };

  Widget.prototype.getData = function(design, schema, dataSource, filters, callback) {
    throw new Error("Not implemented");
  };

  Widget.prototype.isAutoHeight = function() {
    return false;
  };

  Widget.prototype.getFilterableTables = function(design, schema) {
    return [];
  };

  return Widget;

})();


},{}],1128:[function(require,module,exports){
var CalendarChart, ChartWidget, IFrameWidget, ImageMosaicChart, ImageWidget, LayeredChart, MapWidget, MarkdownWidget, PivotChart, TableChart, TextWidget, WidgetFactory;

ChartWidget = require('./charts/ChartWidget');

LayeredChart = require('./charts/layered/LayeredChart');

TableChart = require('./charts/table/TableChart');

CalendarChart = require('./charts/calendar/CalendarChart');

ImageMosaicChart = require('./charts/imagemosaic/ImageMosaicChart');

PivotChart = require('./charts/pivot/PivotChart');

MarkdownWidget = require('./MarkdownWidget');

TextWidget = require('./text/TextWidget');

ImageWidget = require('./ImageWidget');

MapWidget = require('./MapWidget');

IFrameWidget = require('./IFrameWidget');

module.exports = WidgetFactory = (function() {
  function WidgetFactory() {}

  WidgetFactory.createWidget = function(type) {
    switch (type) {
      case "LayeredChart":
        return new ChartWidget(new LayeredChart());
      case "TableChart":
        return new ChartWidget(new TableChart());
      case "CalendarChart":
        return new ChartWidget(new CalendarChart());
      case "ImageMosaicChart":
        return new ChartWidget(new ImageMosaicChart());
      case "PivotChart":
        return new ChartWidget(new PivotChart());
      case "Markdown":
        return new MarkdownWidget();
      case "Map":
        return new MapWidget();
      case "Text":
        return new TextWidget();
      case "Image":
        return new ImageWidget();
      case "IFrame":
        return new IFrameWidget();
      default:
        throw new Error("Unknown widget type " + type);
    }
  };

  return WidgetFactory;

})();


},{"./IFrameWidget":1119,"./ImageWidget":1122,"./MapWidget":1125,"./MarkdownWidget":1126,"./charts/ChartWidget":1133,"./charts/calendar/CalendarChart":1134,"./charts/imagemosaic/ImageMosaicChart":1137,"./charts/layered/LayeredChart":1140,"./charts/pivot/PivotChart":1148,"./charts/table/TableChart":1157,"./text/TextWidget":1164}],1129:[function(require,module,exports){
var WidgetScoper, _;

_ = require('lodash');

module.exports = WidgetScoper = (function() {
  function WidgetScoper(scopes) {
    this.scopes = scopes || {};
  }

  WidgetScoper.prototype.applyScope = function(widgetId, scope) {
    var data, scopes;
    data = {};
    data[widgetId] = scope;
    scopes = _.extend({}, this.scopes, data);
    return new WidgetScoper(scopes);
  };

  WidgetScoper.prototype.getScope = function(widgetId) {
    if (this.scopes[widgetId]) {
      return this.scopes[widgetId];
    }
  };

  WidgetScoper.prototype.getScopes = function() {
    return this.scopes;
  };

  WidgetScoper.prototype.getFilters = function(widgetId) {
    var filters, key, ref, value;
    filters = [];
    ref = this.scopes;
    for (key in ref) {
      value = ref[key];
      if (key !== widgetId && value && value.filter) {
        filters.push(value.filter);
      }
    }
    return filters;
  };

  WidgetScoper.prototype.reset = function() {
    return new WidgetScoper();
  };

  return WidgetScoper;

})();


},{"lodash":"lodash"}],1130:[function(require,module,exports){
var H, React, WidgetScopesViewComponent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

module.exports = WidgetScopesViewComponent = (function(superClass) {
  extend(WidgetScopesViewComponent, superClass);

  function WidgetScopesViewComponent() {
    this.renderScope = bind(this.renderScope, this);
    return WidgetScopesViewComponent.__super__.constructor.apply(this, arguments);
  }

  WidgetScopesViewComponent.propTypes = {
    scopes: React.PropTypes.object.isRequired,
    onRemoveScope: React.PropTypes.func.isRequired
  };

  WidgetScopesViewComponent.prototype.renderScope = function(id, scope) {
    var style;
    style = {
      cursor: "pointer",
      borderRadius: 4,
      border: "solid 1px #BBB",
      padding: "1px 5px 1px 5px",
      color: "#666",
      backgroundColor: "#EEE",
      display: "inline-block",
      marginLeft: 4,
      marginRight: 4
    };
    if (!scope) {
      return null;
    }
    return H.div({
      key: id,
      style: style,
      onClick: this.props.onRemoveScope.bind(null, id)
    }, scope.name, " ", H.span({
      className: "glyphicon glyphicon-remove"
    }));
  };

  WidgetScopesViewComponent.prototype.render = function() {
    var scopes;
    scopes = this.props.scopes;
    if (_.compact(_.values(scopes)).length === 0) {
      return null;
    }
    return H.div({
      className: "alert alert-info"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " Filters: ", _.map(_.keys(scopes), (function(_this) {
      return function(id) {
        return _this.renderScope(id, scopes[id]);
      };
    })(this)));
  };

  return WidgetScopesViewComponent;

})(React.Component);


},{"react":"react"}],1131:[function(require,module,exports){
var Chart;

module.exports = Chart = (function() {
  function Chart() {}

  Chart.prototype.cleanDesign = function(design, schema) {
    throw new Error("Not implemented");
  };

  Chart.prototype.validateDesign = function(design, schema) {
    throw new Error("Not implemented");
  };

  Chart.prototype.isEmpty = function(design) {
    return false;
  };

  Chart.prototype.isAutoHeight = function() {
    return false;
  };

  Chart.prototype.hasDesignerPreview = function() {
    return true;
  };

  Chart.prototype.getEditLabel = function() {
    return "Edit";
  };

  Chart.prototype.createDesignerElement = function(options) {
    throw new Error("Not implemented");
  };

  Chart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    throw new Error("Not implemented");
  };

  Chart.prototype.createViewElement = function(options) {
    throw new Error("Not implemented");
  };

  Chart.prototype.createDropdownItems = function(design, schema, widgetDataSource, filters) {
    return [];
  };

  Chart.prototype.createDataTable = function(design, schema, dataSource, data, locale) {
    throw new Error("Not implemented");
  };

  Chart.prototype.getFilterableTables = function(design, schema) {
    throw new Error("Not implemented");
  };

  Chart.prototype.getType = function() {
    return 'chart';
  };

  return Chart;

})();


},{}],1132:[function(require,module,exports){
var ChartViewComponent, H, React, asyncLatest,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

asyncLatest = require('async-latest');

module.exports = ChartViewComponent = (function(superClass) {
  extend(ChartViewComponent, superClass);

  ChartViewComponent.propTypes = {
    chart: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    widgetDataSource: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    filters: React.PropTypes.array,
    onScopeChange: React.PropTypes.func,
    onRowClick: React.PropTypes.func
  };

  function ChartViewComponent() {
    ChartViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      validDesign: null,
      data: null,
      dataLoading: false,
      dataError: null
    };
    this.loadData = asyncLatest(this.loadData, {
      serial: true
    });
    this.state = {};
  }

  ChartViewComponent.prototype.componentDidMount = function() {
    return this.updateData(this.props);
  };

  ChartViewComponent.prototype.componentWillReceiveProps = function(nextProps) {
    if (!_.isEqual(nextProps.design, this.props.design) || !_.isEqual(nextProps.filters, this.props.filters)) {
      return this.updateData(nextProps);
    }
  };

  ChartViewComponent.prototype.updateData = function(props) {
    var design, errors;
    design = props.chart.cleanDesign(props.design, props.schema);
    errors = props.chart.validateDesign(design, props.schema);
    if (errors) {
      return;
    }
    this.setState({
      dataLoading: true
    });
    return this.loadData(props, (function(_this) {
      return function(error, data) {
        return _this.setState({
          dataLoading: false,
          dataError: error,
          data: data,
          validDesign: design
        });
      };
    })(this));
  };

  ChartViewComponent.prototype.loadData = function(props, callback) {
    return props.widgetDataSource.getData(props.design, props.filters, callback);
  };

  ChartViewComponent.prototype.renderSpinner = function() {
    return H.div({
      style: {
        position: "absolute",
        bottom: "50%",
        left: 0,
        right: 0,
        textAlign: "center",
        fontSize: 20
      }
    }, H.i({
      className: "fa fa-spinner fa-spin"
    }));
  };

  ChartViewComponent.prototype.render = function() {
    var style;
    style = {
      width: this.props.width,
      height: this.props.height
    };
    if (this.state.dataLoading) {
      style.opacity = 0.5;
    }
    if (!this.state.validDesign) {
      style.backgroundColor = "#E0E0E0";
      style.opacity = 0.35;
      if (!this.props.height && this.props.width) {
        style.height = this.props.width / 1.6;
      }
    }
    if (this.state.dataError) {
      return H.div({
        className: "alert alert-danger"
      }, "Error loading data: " + (this.state.dataError.message || this.state.dataError));
    }
    return H.div({
      style: style
    }, this.state.validDesign ? this.props.chart.createViewElement({
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.state.validDesign,
      onDesignChange: this.props.onDesignChange,
      data: this.state.data,
      scope: this.props.scope,
      onScopeChange: this.props.onScopeChange,
      width: this.props.width,
      height: this.props.height,
      standardWidth: this.props.standardWidth,
      onRowClick: this.props.onRowClick
    }) : void 0, this.state.dataLoading ? this.renderSpinner() : void 0);
  };

  return ChartViewComponent;

})(React.Component);


},{"async-latest":28,"react":"react"}],1133:[function(require,module,exports){
var ActionCancelModalComponent, ChartViewComponent, ChartWidget, ChartWidgetComponent, CsvBuilder, DropdownWidgetComponent, H, ModalWindowComponent, R, React, Widget, placeholderIconMap, ui,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

React = require('react');

H = React.DOM;

R = React.createElement;

Widget = require('./../Widget');

DropdownWidgetComponent = require('./../DropdownWidgetComponent');

CsvBuilder = require('./../../CsvBuilder');

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

ChartViewComponent = require('./ChartViewComponent');

ModalWindowComponent = require('react-library/lib/ModalWindowComponent');

ui = require('react-library/lib/bootstrap');

placeholderIconMap = {
  "table": "fa-table",
  "chart": "fa-bar-chart",
  "image-mosaic": "fa-th",
  "calendar": "fa-calendar"
};

module.exports = ChartWidget = (function(superClass) {
  extend(ChartWidget, superClass);

  function ChartWidget(chart) {
    this.chart = chart;
  }

  ChartWidget.prototype.createViewElement = function(options) {
    return R(ChartWidgetComponent, {
      chart: this.chart,
      design: options.design,
      schema: options.schema,
      widgetDataSource: options.widgetDataSource,
      dataSource: options.dataSource,
      scope: options.scope,
      filters: options.filters,
      onScopeChange: options.onScopeChange,
      onDesignChange: options.onDesignChange,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      onRowClick: options.onRowClick
    });
  };

  ChartWidget.prototype.getData = function(design, schema, dataSource, filters, callback) {
    design = this.chart.cleanDesign(design, schema);
    return this.chart.getData(design, schema, dataSource, filters, callback);
  };

  ChartWidget.prototype.getFilterableTables = function(design, schema) {
    design = this.chart.cleanDesign(design, schema);
    return this.chart.getFilterableTables(design, schema);
  };

  ChartWidget.prototype.isAutoHeight = function() {
    return this.chart.isAutoHeight();
  };

  return ChartWidget;

})(Widget);

ChartWidgetComponent = (function(superClass) {
  extend(ChartWidgetComponent, superClass);

  ChartWidgetComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    widgetDataSource: React.PropTypes.object.isRequired,
    chart: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    dataSource: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    filters: React.PropTypes.array,
    onScopeChange: React.PropTypes.func,
    onRowClick: React.PropTypes.func,
    connectMoveHandle: React.PropTypes.func,
    connectResizeHandle: React.PropTypes.func
  };

  ChartWidgetComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function ChartWidgetComponent(props) {
    this.handleEditDesignChange = bind(this.handleEditDesignChange, this);
    this.handleCancelEditing = bind(this.handleCancelEditing, this);
    this.handleEndEditing = bind(this.handleEndEditing, this);
    this.handleStartEditing = bind(this.handleStartEditing, this);
    this.handleSaveCsvFile = bind(this.handleSaveCsvFile, this);
    ChartWidgetComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editDesign: null
    };
  }

  ChartWidgetComponent.prototype.handleSaveCsvFile = function() {
    return this.props.widgetDataSource.getData(this.props.design, this.props.filters, (function(_this) {
      return function(err, data) {
        var blob, csv, filesaver, table;
        if (err) {
          return alert("Failed to get data");
        }
        table = _this.props.chart.createDataTable(_this.props.design, _this.props.schema, _this.props.dataSource, data, _this.context.locale);
        if (!table) {
          return;
        }
        csv = new CsvBuilder().build(table);
        csv = "\uFEFF" + csv;
        blob = new Blob([csv], {
          type: "text/csv"
        });
        filesaver = require('filesaver.js');
        return filesaver(blob, "Exported Data.csv");
      };
    })(this));
  };

  ChartWidgetComponent.prototype.handleStartEditing = function() {
    return this.setState({
      editDesign: this.props.design
    });
  };

  ChartWidgetComponent.prototype.handleEndEditing = function() {
    this.props.onDesignChange(this.state.editDesign);
    return this.setState({
      editDesign: null
    });
  };

  ChartWidgetComponent.prototype.handleCancelEditing = function() {
    return this.setState({
      editDesign: null
    });
  };

  ChartWidgetComponent.prototype.handleEditDesignChange = function(design) {
    return this.setState({
      editDesign: design
    });
  };

  ChartWidgetComponent.prototype.renderChart = function(design, onDesignChange, width, height, standardWidth) {
    return R(ChartViewComponent, {
      chart: this.props.chart,
      design: design,
      onDesignChange: onDesignChange,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      widgetDataSource: this.props.widgetDataSource,
      scope: this.props.scope,
      filters: this.props.filters,
      width: width,
      height: height,
      standardWidth: standardWidth,
      onScopeChange: this.props.onScopeChange,
      onRowClick: this.props.onRowClick
    });
  };

  ChartWidgetComponent.prototype.renderEditor = function() {
    var chart, chartHeight, chartWidth, content, editor;
    if (!this.state.editDesign) {
      return null;
    }
    editor = this.props.chart.createDesignerElement({
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      design: this.state.editDesign,
      onDesignChange: this.handleEditDesignChange
    });
    if (this.props.chart.hasDesignerPreview()) {
      chartWidth = Math.min(document.body.clientWidth / 2, this.props.width);
      chartHeight = this.props.height * (chartWidth / this.props.width);
      chart = this.renderChart(this.state.editDesign, ((function(_this) {
        return function(design) {
          return _this.setState({
            editDesign: design
          });
        };
      })(this)), chartWidth, chartHeight, chartWidth);
      content = H.div({
        style: {
          height: "100%",
          width: "100%"
        }
      }, H.div({
        style: {
          position: "absolute",
          left: 0,
          top: 0,
          border: "solid 2px #EEE",
          borderRadius: 8,
          padding: 10,
          width: chartWidth + 20,
          height: chartHeight + 20,
          overflow: "hidden"
        }
      }, chart), H.div({
        style: {
          width: "100%",
          height: "100%",
          paddingLeft: chartWidth + 40
        }
      }, H.div({
        style: {
          width: "100%",
          height: "100%",
          overflowY: "auto",
          paddingLeft: 20,
          borderLeft: "solid 3px #AAA"
        }
      }, editor)));
      return R(ModalWindowComponent, {
        isOpen: true,
        onRequestClose: this.handleEndEditing
      }, content);
    } else {
      return R(ActionCancelModalComponent, {
        size: "large",
        onCancel: this.handleCancelEditing,
        onAction: this.handleEndEditing
      }, editor);
    }
  };

  ChartWidgetComponent.prototype.renderEditLink = function() {
    return H.div({
      className: "mwater-visualization-widget-placeholder",
      onClick: this.handleStartEditing
    }, R(ui.Icon, {
      id: placeholderIconMap[this.props.chart.getType()]
    }));
  };

  ChartWidgetComponent.prototype.render = function() {
    var design, dropdownItems, emptyDesign, validDesign;
    design = this.props.chart.cleanDesign(this.props.design, this.props.schema);
    validDesign = !this.props.chart.validateDesign(design, this.props.schema);
    emptyDesign = this.props.chart.isEmpty(design);
    dropdownItems = this.props.chart.createDropdownItems(design, this.props.schema, this.props.widgetDataSource, this.props.filters);
    if (validDesign) {
      dropdownItems.push({
        label: "Export Data",
        icon: "save-file",
        onClick: this.handleSaveCsvFile
      });
    }
    if (this.props.onDesignChange != null) {
      dropdownItems.unshift({
        label: this.props.chart.getEditLabel(),
        icon: "pencil",
        onClick: this.handleStartEditing
      });
    }
    return H.div({
      onDoubleClick: (this.props.onDesignChange != null ? this.handleStartEditing : void 0),
      style: {
        position: "relative",
        width: this.props.width
      }
    }, this.props.onDesignChange != null ? this.renderEditor() : void 0, React.createElement(DropdownWidgetComponent, {
      width: this.props.width,
      height: this.props.height,
      dropdownItems: dropdownItems
    }, this.renderChart(design, this.props.onDesignChange, this.props.width, this.props.height, this.props.standardWidth)), (emptyDesign || !validDesign) && (this.props.onDesignChange != null) ? this.renderEditLink() : void 0);
  };

  return ChartWidgetComponent;

})(React.Component);


},{"./../../CsvBuilder":1018,"./../DropdownWidgetComponent":1118,"./../Widget":1127,"./ChartViewComponent":1132,"filesaver.js":275,"react":"react","react-library/lib/ActionCancelModalComponent":781,"react-library/lib/ModalWindowComponent":787,"react-library/lib/bootstrap":793}],1134:[function(require,module,exports){
var AxisBuilder, CalendarChart, Chart, ExprCleaner, ExprCompiler, H, React, _, injectTableAlias, moment,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

moment = require('moment');

injectTableAlias = require('mwater-expressions').injectTableAlias;

Chart = require('../Chart');

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprCompiler = require('mwater-expressions').ExprCompiler;

AxisBuilder = require('../../../axes/AxisBuilder');


/*
Design is:
  
  table: table to use for data source
  titleText: title text
  dateAxis: date axis to use
  valueAxis: axis for value
  filter: optional logical expression to filter by
 */

module.exports = CalendarChart = (function(superClass) {
  extend(CalendarChart, superClass);

  function CalendarChart() {
    return CalendarChart.__super__.constructor.apply(this, arguments);
  }

  CalendarChart.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.version = design.version || 1;
    design.dateAxis = axisBuilder.cleanAxis({
      axis: design.dateAxis,
      table: design.table,
      aggrNeed: "none",
      types: ["date"]
    });
    design.valueAxis = axisBuilder.cleanAxis({
      axis: design.valueAxis,
      table: design.table,
      aggrNeed: "required",
      types: ["number"]
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table,
      types: ["boolean"]
    });
    return design;
  };

  CalendarChart.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing data source";
    }
    error = null;
    if (!design.dateAxis) {
      error = error || "Missing date";
    }
    if (!design.valueAxis) {
      error = error || "Missing value";
    }
    error = error || axisBuilder.validateAxis({
      axis: design.dateAxis
    });
    error = error || axisBuilder.validateAxis({
      axis: design.valueAxis
    });
    return error;
  };

  CalendarChart.prototype.isEmpty = function(design) {
    return !design.dateAxis || !design.valueAxis;
  };

  CalendarChart.prototype.createDesignerElement = function(options) {
    var CalendarChartDesignerComponent, props;
    CalendarChartDesignerComponent = require('./CalendarChartDesignerComponent');
    props = {
      schema: options.schema,
      design: this.cleanDesign(options.design, options.schema),
      dataSource: options.dataSource,
      onDesignChange: (function(_this) {
        return function(design) {
          design = _this.cleanDesign(design, options.schema);
          return options.onDesignChange(design);
        };
      })(this)
    };
    return React.createElement(CalendarChartDesignerComponent, props);
  };

  CalendarChart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var axisBuilder, dateExpr, exprCompiler, query, whereClauses;
    exprCompiler = new ExprCompiler(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    query = {
      type: "query",
      selects: [],
      from: exprCompiler.compileTable(design.table, "main"),
      groupBy: [1],
      orderBy: [
        {
          ordinal: 1
        }
      ],
      limit: 5000
    };
    dateExpr = axisBuilder.compileAxis({
      axis: design.dateAxis,
      tableAlias: "main"
    });
    query.selects.push({
      type: "select",
      expr: dateExpr,
      alias: "date"
    });
    query.selects.push({
      type: "select",
      expr: axisBuilder.compileAxis({
        axis: design.valueAxis,
        tableAlias: "main"
      }),
      alias: "value"
    });
    filters = _.where(filters || [], {
      table: design.table
    });
    whereClauses = _.map(filters, function(f) {
      return injectTableAlias(f.jsonql, "main");
    });
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    whereClauses.push({
      type: "op",
      op: "is not null",
      exprs: [dateExpr]
    });
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    return dataSource.performQuery(query, callback);
  };

  CalendarChart.prototype.createViewElement = function(options) {
    var CalendarChartViewComponent, props;
    CalendarChartViewComponent = require('./CalendarChartViewComponent');
    props = {
      schema: options.schema,
      design: this.cleanDesign(options.design, options.schema),
      data: options.data,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      scope: options.scope,
      onScopeChange: options.onScopeChange,
      cellStrokeColor: "#DDD"
    };
    return React.createElement(CalendarChartViewComponent, props);
  };

  CalendarChart.prototype.createDataTable = function(design, schema, dataSource, data) {
    var header, rows;
    header = ["Date", "Value"];
    rows = _.map(data, function(row) {
      return [moment(row.date).format("YYYY-MM-DD"), row.value];
    });
    return [header].concat(rows);
  };

  CalendarChart.prototype.getFilterableTables = function(design, schema) {
    return _.compact([design.table]);
  };

  CalendarChart.prototype.getType = function() {
    return "calendar";
  };

  return CalendarChart;

})(Chart);


},{"../../../axes/AxisBuilder":1029,"../Chart":1131,"./CalendarChartDesignerComponent":1135,"./CalendarChartViewComponent":1136,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],1135:[function(require,module,exports){
var AxisBuilder, AxisComponent, CalendarChartDesignerComponent, ExprUtils, FilterExprComponent, H, R, React, TableSelectComponent, _, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ui = require('../../../UIComponents');

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

AxisComponent = require('../../../axes/AxisComponent');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

TableSelectComponent = require('../../../TableSelectComponent');

module.exports = CalendarChartDesignerComponent = (function(superClass) {
  extend(CalendarChartDesignerComponent, superClass);

  function CalendarChartDesignerComponent() {
    this.handleValueAxisChange = bind(this.handleValueAxisChange, this);
    this.handleDateAxisChange = bind(this.handleDateAxisChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleTitleTextChange = bind(this.handleTitleTextChange, this);
    return CalendarChartDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  CalendarChartDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  CalendarChartDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  CalendarChartDesignerComponent.prototype.handleTitleTextChange = function(ev) {
    return this.updateDesign({
      titleText: ev.target.value
    });
  };

  CalendarChartDesignerComponent.prototype.handleTableChange = function(table) {
    return this.updateDesign({
      table: table
    });
  };

  CalendarChartDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.updateDesign({
      filter: filter
    });
  };

  CalendarChartDesignerComponent.prototype.handleDateAxisChange = function(dateAxis) {
    var valueAxis;
    if (!this.props.design.valueAxis && dateAxis) {
      valueAxis = {
        expr: {
          type: "op",
          op: "count",
          table: this.props.design.table,
          exprs: []
        },
        xform: null
      };
      return this.updateDesign({
        dateAxis: dateAxis,
        valueAxis: valueAxis
      });
    } else {
      return this.updateDesign({
        dateAxis: dateAxis
      });
    }
  };

  CalendarChartDesignerComponent.prototype.handleValueAxisChange = function(valueAxis) {
    return this.updateDesign({
      valueAxis: valueAxis
    });
  };

  CalendarChartDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    }));
  };

  CalendarChartDesignerComponent.prototype.renderTitle = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Title"), H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.titleText,
      onChange: this.handleTitleTextChange,
      placeholder: "Untitled"
    }));
  };

  CalendarChartDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " ", "Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  CalendarChartDesignerComponent.prototype.renderDateAxis = function() {
    if (!this.props.design.table) {
      return;
    }
    return R(ui.SectionComponent, {
      label: "Date Axis"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["date"],
      aggrNeed: "none",
      required: true,
      value: this.props.design.dateAxis,
      onChange: this.handleDateAxisChange
    }));
  };

  CalendarChartDesignerComponent.prototype.renderValueAxis = function() {
    if (!this.props.design.table || !this.props.design.dateAxis) {
      return;
    }
    return R(ui.SectionComponent, {
      label: "Value Axis"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["number"],
      aggrNeed: "required",
      required: true,
      value: this.props.design.valueAxis,
      onChange: this.handleValueAxisChange
    }));
  };

  CalendarChartDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderDateAxis(), this.renderValueAxis(), this.renderFilter(), H.hr(), this.renderTitle());
  };

  return CalendarChartDesignerComponent;

})(React.Component);


},{"../../../TableSelectComponent":1025,"../../../UIComponents":1026,"../../../axes/AxisBuilder":1029,"../../../axes/AxisComponent":1031,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1136:[function(require,module,exports){
var AxisBuilder, CalendarChartViewComponent, ExprUtils, H, React, _, d3Tip, moment,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

moment = require('moment');

AxisBuilder = require('../../../axes/AxisBuilder');

ExprUtils = require('mwater-expressions').ExprUtils;

d3Tip = require('d3-tip');

module.exports = CalendarChartViewComponent = (function(superClass) {
  extend(CalendarChartViewComponent, superClass);

  CalendarChartViewComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.array.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func,
    monthsStrokeColor: React.PropTypes.string,
    monthsStrokeWidth: React.PropTypes.number,
    cellColor: React.PropTypes.string,
    cellStrokeColor: React.PropTypes.string,
    highlightCellFillColor: React.PropTypes.string
  };

  function CalendarChartViewComponent(options) {
    this.schema = options.schema;
    this.axisBuilder = new AxisBuilder({
      schema: this.schema
    });
  }

  CalendarChartViewComponent.defaultProps = {
    monthsStrokeColor: "#222",
    monthsStrokeWidth: 1,
    cellColor: "#FDAE61",
    highlightCellFillColor: "#000000"
  };

  CalendarChartViewComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  CalendarChartViewComponent.prototype.shouldComponentUpdate = function(prevProps) {
    return !_.isEqual(prevProps, this.props);
  };

  CalendarChartViewComponent.prototype.getCellSize = function() {
    var cellSizeForHeight, cellSizeForWidth, remainingSpace, years;
    cellSizeForWidth = (this.props.width - this.props.monthsStrokeWidth * 2 - 26) / 53;
    years = this.getYears();
    remainingSpace = this.props.height - years.length * 7 - this.props.monthsStrokeWidth * 2 * years.length;
    if (this.props.design.titleText) {
      remainingSpace = remainingSpace - $(this.refs.title).outerHeight();
    }
    cellSizeForHeight = remainingSpace / (years.length * 7);
    return Math.min(cellSizeForHeight, cellSizeForWidth);
  };

  CalendarChartViewComponent.prototype.getYears = function() {
    var years;
    years = _.map(this.props.data, (function(_this) {
      return function(entry) {
        return (new Date(entry.date)).getFullYear();
      };
    })(this));
    years = _.uniq(years, true);
    years = _.filter(years, function(y) {
      return y > 1970 && y < 2050;
    });
    years = _.take(years, 10);
    return years;
  };

  CalendarChartViewComponent.prototype.componentDidMount = function() {
    return this.redraw();
  };

  CalendarChartViewComponent.prototype.componentDidUpdate = function(prevProps) {
    return this.redraw();
  };

  CalendarChartViewComponent.prototype.handleCellClick = function(cell, data) {
    var base, base1, ref, scopeData;
    if (((ref = this.props.scope) != null ? ref.data : void 0) === data) {
      if (typeof (base = this.props).onScopeChange === "function") {
        base.onScopeChange(null);
      }
      return;
    }
    scopeData = {
      name: this.axisBuilder.summarizeAxis(this.props.design.dateAxis, this.context.locale) + " is " + this.axisBuilder.formatValue(this.props.design.dateAxis, data, this.context.locale),
      filter: {
        jsonql: this.axisBuilder.createValueFilter(this.props.design.dateAxis, data),
        table: this.props.design.table
      },
      data: data
    };
    return typeof (base1 = this.props).onScopeChange === "function" ? base1.onScopeChange(scopeData) : void 0;
  };

  CalendarChartViewComponent.prototype.redraw = function() {
    var cellSize, cellStroke, color, container, data, format, height, monthPath, percent, rect, rgb, self, svg, tip, yearGroupTranslateX, years;
    this.reloading = true;
    container = this.refs.chart_container;
    container.innerHTML = '';
    cellSize = this.getCellSize();
    height = Math.ceil(cellSize * 7) + 7;
    format = d3.time.format("%Y-%m-%d");
    percent = d3.format(".1%");
    cellStroke = this.props.cellStrokeColor || this.props.cellColor;
    self = this;
    rgb = d3.rgb(this.props.cellColor);
    years = this.getYears();
    if (years.length === 0) {
      return;
    }
    data = d3.nest().key(function(d) {
      return d.date;
    }).rollup(function(d) {
      return d[0].value;
    }).map(this.props.data, d3.map);
    tip = d3Tip().attr('class', 'd3-tip').html(function(d) {
      var _date, title;
      _date = moment(d);
      title = '<p>' + _date.format('LL') + '</p>';
      title += '<p>' + (data.has(d) ? data.get(d) : 0 + '<p>');
      return title;
    });
    color = d3.scale.quantize().domain([1, d3.max(data.values())]).range(d3.range(10).map(function(d) {
      return rgb.darker(d * 0.1).toString();
    }));
    yearGroupTranslateX = (this.props.width - cellSize * 53 - 16) / 2 + 16;
    svg = d3.select(container).selectAll("svg").data(years).enter().append("svg").attr("width", this.props.width).attr("height", height).attr("class", "calendar-chart-year").append("g").attr("transform", "translate(" + yearGroupTranslateX + ",0)");
    svg.call(tip);
    svg.append("text").text(function(d, i) {
      return d;
    }).attr("transform", "translate(-6," + cellSize * 3.5 + ")rotate(-90)").attr("font-size", function(d) {
      return Math.min(14, (cellSize * 7) / this.getComputedTextLength() * 14) + "px";
    }).style("text-anchor", "middle");
    rect = svg.selectAll(".calendar-chart-day").data(function(d) {
      return d3.time.days(new Date(d, 0, 1), new Date(d + 1, 0, 1));
    }).enter().append("rect").attr("class", "calendar-chart-day").attr("fill", "#fff").attr("stroke", cellStroke).attr("stroke-width", this.props.monthsStrokeWidth).attr("width", cellSize).attr("height", cellSize).attr("x", function(d) {
      return d3.time.weekOfYear(d) * cellSize;
    }).attr("y", function(d) {
      return d.getDay() * cellSize;
    }).on("mouseenter", (function(_this) {
      return function(d, i) {
        if (!_this.reloading) {
          return tip.show(d, i);
        }
      };
    })(this)).on("mouseleave", tip.hide).datum(format);
    rect.on("click", function(e) {
      var selectedRect;
      tip.hide();
      selectedRect = d3.select(this);
      return self.handleCellClick(selectedRect, e);
    });
    rect.filter(function(d) {
      return data.has(d);
    }).attr("fill", (function(_this) {
      return function(d) {
        var _color, ref;
        _color = color(data.get(d));
        if (((ref = _this.props.scope) != null ? ref.data : void 0) === d) {
          return _this.props.highlightCellFillColor;
        }
        return _color;
      };
    })(this));
    monthPath = function(t0) {
      var d0, d1, t1, w0, w1;
      t1 = new Date(t0.getFullYear(), t0.getMonth() + 1, 0);
      d0 = t0.getDay();
      w0 = d3.time.weekOfYear(t0);
      d1 = t1.getDay();
      w1 = d3.time.weekOfYear(t1);
      return "M" + (w0 + 1) * cellSize + "," + d0 * cellSize + "H" + w0 * cellSize + "V" + 7 * cellSize + "H" + w1 * cellSize + "V" + (d1 + 1) * cellSize + "H" + (w1 + 1) * cellSize + "V" + 0 + "H" + (w0 + 1) * cellSize + "Z";
    };
    svg.selectAll(".calendar-chart-month").data(function(d) {
      return d3.time.months(new Date(d, 0, 1), new Date(d + 1, 0, 1));
    }).enter().append("path").attr("fill", "none").attr("class", "calendar-chart-month").attr("stroke", this.props.monthsStrokeColor).attr("stroke-width", this.props.monthsStrokeWidth).attr("d", monthPath);
    this.reloading = false;
  };

  CalendarChartViewComponent.prototype.render = function() {
    var style, title, titleStyle;
    titleStyle = {
      textAlign: "center",
      fontSize: "14px",
      fontWeight: "bold",
      margin: 0
    };
    style = {
      width: this.props.width,
      height: this.props.height,
      shapeRendering: "crispEdges",
      lineHeight: 1
    };
    title = this.props.design.titleText;
    return H.div({
      style: style
    }, title ? H.p({
      style: titleStyle,
      ref: "title"
    }, title) : void 0, H.div({
      ref: "chart_container"
    }));
  };

  return CalendarChartViewComponent;

})(React.Component);


},{"../../../axes/AxisBuilder":1029,"d3-tip":139,"lodash":"lodash","moment":337,"mwater-expressions":14,"react":"react"}],1137:[function(require,module,exports){
var AxisBuilder, Chart, ExprCleaner, ExprCompiler, H, ImageMosaicChart, React, _, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

injectTableAlias = require('mwater-expressions').injectTableAlias;

Chart = require('../Chart');

ExprCleaner = require('mwater-expressions').ExprCleaner;

ExprCompiler = require('mwater-expressions').ExprCompiler;

AxisBuilder = require('../../../axes/AxisBuilder');


/*
Design is:
  
  table: table to use for data source
  titleText: title text
  imageAxis: image axis to use
  filter: optional logical expression to filter by
 */

module.exports = ImageMosaicChart = (function(superClass) {
  extend(ImageMosaicChart, superClass);

  function ImageMosaicChart() {
    return ImageMosaicChart.__super__.constructor.apply(this, arguments);
  }

  ImageMosaicChart.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, exprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.version = design.version || 1;
    design.imageAxis = axisBuilder.cleanAxis({
      axis: design.imageAxis,
      table: design.table,
      aggrNeed: "none",
      types: ["image", "imagelist"]
    });
    design.filter = exprCleaner.cleanExpr(design.filter, {
      table: design.table,
      types: ["boolean"]
    });
    return design;
  };

  ImageMosaicChart.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing data source";
    }
    error = null;
    if (!design.imageAxis) {
      error = error || "Missing image";
    }
    error = error || axisBuilder.validateAxis({
      axis: design.imageAxis
    });
    return error;
  };

  ImageMosaicChart.prototype.isEmpty = function(design) {
    return !design.imageAxis;
  };

  ImageMosaicChart.prototype.createDesignerElement = function(options) {
    var ImageMosaicChartDesignerComponent, props;
    ImageMosaicChartDesignerComponent = require('./ImageMosaicChartDesignerComponent');
    props = {
      schema: options.schema,
      design: this.cleanDesign(options.design, options.schema),
      dataSource: options.dataSource,
      onDesignChange: (function(_this) {
        return function(design) {
          design = _this.cleanDesign(design, options.schema);
          return options.onDesignChange(design);
        };
      })(this)
    };
    return React.createElement(ImageMosaicChartDesignerComponent, props);
  };

  ImageMosaicChart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var axisBuilder, exprCompiler, imageExpr, query, whereClauses;
    exprCompiler = new ExprCompiler(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    query = {
      type: "query",
      selects: [],
      from: exprCompiler.compileTable(design.table, "main"),
      limit: 500
    };
    imageExpr = axisBuilder.compileAxis({
      axis: design.imageAxis,
      tableAlias: "main"
    });
    query.selects.push({
      type: "select",
      expr: imageExpr,
      alias: "image"
    });
    filters = _.where(filters || [], {
      table: design.table
    });
    whereClauses = _.map(filters, function(f) {
      return injectTableAlias(f.jsonql, "main");
    });
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    whereClauses.push({
      type: "op",
      op: "is not null",
      exprs: [imageExpr]
    });
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    return dataSource.performQuery(query, callback);
  };

  ImageMosaicChart.prototype.createViewElement = function(options) {
    var ImageMosaicChartViewComponent, props;
    ImageMosaicChartViewComponent = require('./ImageMosaicChartViewComponent');
    props = {
      schema: options.schema,
      design: this.cleanDesign(options.design, options.schema),
      data: options.data,
      dataSource: options.dataSource,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      scope: options.scope,
      onScopeChange: options.onScopeChange
    };
    return React.createElement(ImageMosaicChartViewComponent, props);
  };

  ImageMosaicChart.prototype.createDataTable = function(design, schema, dataSource, data) {
    alert("Not available for Image Mosaics");
    return null;
  };

  ImageMosaicChart.prototype.getFilterableTables = function(design, schema) {
    return _.compact([design.table]);
  };

  ImageMosaicChart.prototype.getType = function() {
    return "image-mosaic";
  };

  return ImageMosaicChart;

})(Chart);


},{"../../../axes/AxisBuilder":1029,"../Chart":1131,"./ImageMosaicChartDesignerComponent":1138,"./ImageMosaicChartViewComponent":1139,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1138:[function(require,module,exports){
var AxisBuilder, AxisComponent, ExprUtils, FilterExprComponent, H, ImageMosaicChartDesignerComponent, R, React, TableSelectComponent, _, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ui = require('../../../UIComponents');

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

AxisComponent = require('../../../axes/AxisComponent');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

TableSelectComponent = require('../../../TableSelectComponent');

module.exports = ImageMosaicChartDesignerComponent = (function(superClass) {
  extend(ImageMosaicChartDesignerComponent, superClass);

  function ImageMosaicChartDesignerComponent() {
    this.handleImageAxisChange = bind(this.handleImageAxisChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleTitleTextChange = bind(this.handleTitleTextChange, this);
    return ImageMosaicChartDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  ImageMosaicChartDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  ImageMosaicChartDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  ImageMosaicChartDesignerComponent.prototype.handleTitleTextChange = function(ev) {
    return this.updateDesign({
      titleText: ev.target.value
    });
  };

  ImageMosaicChartDesignerComponent.prototype.handleTableChange = function(table) {
    return this.updateDesign({
      table: table
    });
  };

  ImageMosaicChartDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.updateDesign({
      filter: filter
    });
  };

  ImageMosaicChartDesignerComponent.prototype.handleImageAxisChange = function(imageAxis) {
    return this.updateDesign({
      imageAxis: imageAxis
    });
  };

  ImageMosaicChartDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    }));
  };

  ImageMosaicChartDesignerComponent.prototype.renderTitle = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Title"), H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.titleText,
      onChange: this.handleTitleTextChange,
      placeholder: "Untitled"
    }));
  };

  ImageMosaicChartDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " ", "Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  ImageMosaicChartDesignerComponent.prototype.renderImageAxis = function() {
    if (!this.props.design.table) {
      return;
    }
    return R(ui.SectionComponent, {
      label: "Image Axis"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["image", "imagelist"],
      aggrNeed: "none",
      required: true,
      value: this.props.design.imageAxis,
      onChange: this.handleImageAxisChange
    }));
  };

  ImageMosaicChartDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderImageAxis(), this.renderFilter(), H.hr(), this.renderTitle());
  };

  return ImageMosaicChartDesignerComponent;

})(React.Component);


},{"../../../TableSelectComponent":1025,"../../../UIComponents":1026,"../../../axes/AxisBuilder":1029,"../../../axes/AxisComponent":1031,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1139:[function(require,module,exports){
var AxisBuilder, H, ImageMosaicChartViewComponent, LazyLoad, R, React, RotationAwareImageComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

AxisBuilder = require('../../../axes/AxisBuilder');

LazyLoad = require('react-lazy-load')["default"];

RotationAwareImageComponent = require("mwater-forms/lib/RotationAwareImageComponent");

module.exports = ImageMosaicChartViewComponent = (function(superClass) {
  extend(ImageMosaicChartViewComponent, superClass);

  function ImageMosaicChartViewComponent() {
    return ImageMosaicChartViewComponent.__super__.constructor.apply(this, arguments);
  }

  ImageMosaicChartViewComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.array.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func
  };

  ImageMosaicChartViewComponent.prototype.shouldComponentUpdate = function(prevProps) {
    return !_.isEqual(prevProps, this.props);
  };

  ImageMosaicChartViewComponent.prototype.renderImage = function(image, imageManager) {
    return R(LazyLoad, {
      key: image.id
    }, R(RotationAwareImageComponent, {
      imageManager: imageManager,
      image: image,
      thumbnail: true,
      height: 120,
      width: 80
    }));
  };

  ImageMosaicChartViewComponent.prototype.renderImages = function() {
    var i, image, imageElems, imageManager, imageObj, len, ref, results, row;
    imageElems = [];
    imageManager = {
      getImageThumbnailUrl: (function(_this) {
        return function(id, success, error) {
          return success(_this.props.dataSource.getImageUrl(id, 100));
        };
      })(this),
      getImageUrl: (function(_this) {
        return function(id, success, error) {
          return success(_this.props.dataSource.getImageUrl(id));
        };
      })(this)
    };
    ref = this.props.data;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      row = ref[i];
      imageObj = row.image;
      if (!imageObj) {
        continue;
      }
      if (_.isString(imageObj)) {
        imageObj = JSON.parse(imageObj);
      }
      if (_.isArray(imageObj)) {
        results.push((function() {
          var j, len1, results1;
          results1 = [];
          for (j = 0, len1 = imageObj.length; j < len1; j++) {
            image = imageObj[j];
            results1.push(this.renderImage(image, imageManager));
          }
          return results1;
        }).call(this));
      } else {
        results.push(this.renderImage(imageObj, imageManager));
      }
    }
    return results;
  };

  ImageMosaicChartViewComponent.prototype.render = function() {
    var style, title, titleStyle;
    titleStyle = {
      textAlign: "center",
      fontSize: "14px",
      fontWeight: "bold"
    };
    style = {
      width: this.props.width,
      height: this.props.height,
      overflowY: "auto"
    };
    title = this.props.design.titleText;
    return H.div({
      style: style,
      className: 'image-mosaic'
    }, title ? H.p({
      style: titleStyle
    }, title) : void 0, H.div(null, this.renderImages()));
  };

  return ImageMosaicChartViewComponent;

})(React.Component);


},{"../../../axes/AxisBuilder":1029,"lodash":"lodash","mwater-forms/lib/RotationAwareImageComponent":370,"react":"react","react-lazy-load":777}],1140:[function(require,module,exports){
var AxisBuilder, Chart, ExprCleaner, H, LayeredChart, LayeredChartCompiler, LayeredChartSvgFileSaver, LayeredChartUtils, React, TextWidget, _, async,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

async = require('async');

Chart = require('../Chart');

LayeredChartCompiler = require('./LayeredChartCompiler');

ExprCleaner = require('mwater-expressions').ExprCleaner;

AxisBuilder = require('../../../axes/AxisBuilder');

LayeredChartSvgFileSaver = require('./LayeredChartSvgFileSaver');

LayeredChartUtils = require('./LayeredChartUtils');

TextWidget = require('../../text/TextWidget');

module.exports = LayeredChart = (function(superClass) {
  extend(LayeredChart, superClass);

  function LayeredChart() {
    return LayeredChart.__super__.constructor.apply(this, arguments);
  }

  LayeredChart.prototype.cleanDesign = function(design, schema) {
    var aggrNeed, axis, axisBuilder, axisKey, compiler, exprCleaner, i, layer, layerId, ref, ref1, ref2;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    compiler = new LayeredChartCompiler({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.version = design.version || 2;
    design.layers = design.layers || [{}];
    design.header = design.header || {
      style: "header",
      items: _.compact([design.titleText || null])
    };
    design.footer = design.footer || {
      style: "footer",
      items: []
    };
    if (design.version < 2) {
      if (design.xAxisLabelText == null) {
        design.xAxisLabelText = "";
      }
      if (design.yAxisLabelText == null) {
        design.yAxisLabelText = "";
      }
      design.version = 2;
    }
    for (layerId = i = 0, ref = design.layers.length; 0 <= ref ? i < ref : i > ref; layerId = 0 <= ref ? ++i : --i) {
      layer = design.layers[layerId];
      layer.axes = layer.axes || {};
      ref1 = layer.axes;
      for (axisKey in ref1) {
        axis = ref1[axisKey];
        if (axisKey === "y" && compiler.doesLayerNeedGrouping(design, layerId)) {
          aggrNeed = "required";
        } else {
          aggrNeed = "none";
        }
        layer.axes[axisKey] = axisBuilder.cleanAxis({
          axis: axis,
          table: layer.table,
          aggrNeed: aggrNeed,
          types: LayeredChartUtils.getAxisTypes(design, layer, axisKey)
        });
      }
      if (!compiler.canLayerUseXExpr(design, layerId) && layer.axes.x) {
        delete layer.axes.x;
      }
      if (!layer.axes.x || ((ref2 = axisBuilder.getAxisType(layer.axes.x)) !== 'date' && ref2 !== 'number')) {
        delete layer.cumulative;
      }
      layer.filter = exprCleaner.cleanExpr(layer.filter, {
        table: layer.table,
        types: ['boolean']
      });
    }
    return design;
  };

  LayeredChart.prototype.validateDesign = function(design, schema) {
    var axisBuilder, compiler, error, i, layer, layerId, ref, xAxisTypes;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    compiler = new LayeredChartCompiler({
      schema: schema
    });
    xAxisTypes = _.uniq(_.map(design.layers, (function(_this) {
      return function(l) {
        axisBuilder = new AxisBuilder({
          schema: schema
        });
        return axisBuilder.getAxisType(l.axes.x);
      };
    })(this)));
    if (xAxisTypes.length > 1) {
      return "All x axes must be of same type";
    }
    for (layerId = i = 0, ref = design.layers.length; 0 <= ref ? i < ref : i > ref; layerId = 0 <= ref ? ++i : --i) {
      layer = design.layers[layerId];
      if (!layer.table) {
        return "Missing data source";
      }
      if (!layer.axes.y) {
        return "Missing Y Axis";
      }
      if (!layer.axes.x && compiler.isXAxisRequired(design, layerId)) {
        return "Missing X Axis";
      }
      if (!layer.axes.color && compiler.isColorAxisRequired(design, layerId)) {
        return "Missing Color Axis";
      }
      error = null;
      error = error || axisBuilder.validateAxis({
        axis: layer.axes.x
      });
      error = error || axisBuilder.validateAxis({
        axis: layer.axes.y
      });
      error = error || axisBuilder.validateAxis({
        axis: layer.axes.color
      });
    }
    return error;
  };

  LayeredChart.prototype.isEmpty = function(design) {
    return !design.layers || !design.layers[0] || !design.layers[0].table;
  };

  LayeredChart.prototype.createDesignerElement = function(options) {
    var LayeredChartDesignerComponent, props;
    LayeredChartDesignerComponent = require('./LayeredChartDesignerComponent');
    props = {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          design = _this.cleanDesign(design, options.schema);
          return options.onDesignChange(design);
        };
      })(this)
    };
    return React.createElement(LayeredChartDesignerComponent, props);
  };

  LayeredChart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var compiler, queries;
    compiler = new LayeredChartCompiler({
      schema: schema
    });
    queries = compiler.createQueries(design, filters);
    return async.map(_.pairs(queries), (function(_this) {
      return function(item, cb) {
        return dataSource.performQuery(item[1], function(err, rows) {
          return cb(err, [item[0], rows]);
        });
      };
    })(this), (function(_this) {
      return function(err, items) {
        var data, textWidget;
        if (err) {
          return callback(err);
        }
        data = _.object(items);
        textWidget = new TextWidget();
        return textWidget.getData(design.header, schema, dataSource, filters, function(error, headerData) {
          if (error) {
            return callback(error);
          }
          data.header = headerData;
          return textWidget.getData(design.footer, schema, dataSource, filters, function(error, footerData) {
            if (error) {
              return callback(error);
            }
            data.footer = footerData;
            return callback(null, data);
          });
        });
      };
    })(this));
  };

  LayeredChart.prototype.createViewElement = function(options) {
    var LayeredChartViewComponent, props;
    LayeredChartViewComponent = require('./LayeredChartViewComponent');
    props = {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: options.onDesignChange,
      data: options.data,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      scope: options.scope,
      onScopeChange: options.onScopeChange
    };
    return React.createElement(LayeredChartViewComponent, props);
  };

  LayeredChart.prototype.createDropdownItems = function(design, schema, widgetDataSource, filters) {
    var save;
    save = (function(_this) {
      return function(format) {
        design = _this.cleanDesign(design, schema);
        return widgetDataSource.getData(design, filters, function(err, data) {
          if (err) {
            return alert("Unable to load data");
          } else {
            return LayeredChartSvgFileSaver.save(design, data, schema, format);
          }
        });
      };
    })(this);
    if (this.validateDesign(this.cleanDesign(design, schema), schema)) {
      return [];
    }
    return [
      {
        label: "Save as SVG",
        icon: "picture",
        onClick: save.bind(null, "svg")
      }, {
        label: "Save as PNG",
        icon: "camera",
        onClick: save.bind(null, "png")
      }
    ];
  };

  LayeredChart.prototype.createDataTable = function(design, schema, dataSource, data, locale) {
    var axisBuilder, headers, i, len, r, ref, row, table;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    headers = [];
    if (design.layers[0].axes.x) {
      headers.push(axisBuilder.summarizeAxis(design.layers[0].axes.x, locale));
    }
    if (design.layers[0].axes.color) {
      headers.push(axisBuilder.summarizeAxis(design.layers[0].axes.color, locale));
    }
    if (design.layers[0].axes.y) {
      headers.push(axisBuilder.summarizeAxis(design.layers[0].axes.y, locale));
    }
    table = [headers];
    ref = data.layer0;
    for (i = 0, len = ref.length; i < len; i++) {
      row = ref[i];
      r = [];
      if (design.layers[0].axes.x) {
        r.push(axisBuilder.formatValue(design.layers[0].axes.x, row.x, locale));
      }
      if (design.layers[0].axes.color) {
        r.push(axisBuilder.formatValue(design.layers[0].axes.color, row.color, locale));
      }
      if (design.layers[0].axes.y) {
        r.push(axisBuilder.formatValue(design.layers[0].axes.y, row.y, locale));
      }
      table.push(r);
    }
    return table;
  };

  LayeredChart.prototype.getFilterableTables = function(design, schema) {
    var filterableTables, textWidget;
    filterableTables = _.uniq(_.compact(_.map(design.layers, function(layer) {
      return layer.table;
    })));
    textWidget = new TextWidget();
    filterableTables = _.union(filterableTables, textWidget.getFilterableTables(design.header, schema));
    filterableTables = _.union(filterableTables, textWidget.getFilterableTables(design.footer, schema));
    return filterableTables;
  };

  return LayeredChart;

})(Chart);


},{"../../../axes/AxisBuilder":1029,"../../text/TextWidget":1164,"../Chart":1131,"./LayeredChartCompiler":1141,"./LayeredChartDesignerComponent":1142,"./LayeredChartSvgFileSaver":1144,"./LayeredChartUtils":1145,"./LayeredChartViewComponent":1146,"async":29,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1141:[function(require,module,exports){
(function (global){
var AxisBuilder, ExprCompiler, ExprUtils, LayeredChartCompiler, _, cleanString, injectTableAlias, pieLabelValueFormatter, tickFormatter;

_ = require('lodash');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

injectTableAlias = require('mwater-expressions').injectTableAlias;

if (global.d3) {
  tickFormatter = d3.format(",");
  pieLabelValueFormatter = (function(_this) {
    return function(value, ratio, id) {
      return (d3.format(",")(value)) + " (" + (d3.format('.1%')(ratio)) + ")";
    };
  })(this);
} else {
  tickFormatter = null;
  pieLabelValueFormatter = null;
}

module.exports = LayeredChartCompiler = (function() {
  function LayeredChartCompiler(options) {
    this.schema = options.schema;
    this.exprUtils = new ExprUtils(this.schema);
    this.axisBuilder = new AxisBuilder({
      schema: this.schema
    });
  }

  LayeredChartCompiler.prototype.createQueries = function(design, extraFilters) {
    var exprCompiler, filter, j, k, layer, layerIndex, len, queries, query, ref, relevantFilters, whereClauses;
    exprCompiler = new ExprCompiler(this.schema);
    queries = {};
    for (layerIndex = j = 0, ref = design.layers.length; 0 <= ref ? j < ref : j > ref; layerIndex = 0 <= ref ? ++j : --j) {
      layer = design.layers[layerIndex];
      query = {
        type: "query",
        selects: [],
        from: exprCompiler.compileTable(layer.table, "main"),
        limit: 1000,
        groupBy: [],
        orderBy: []
      };
      if (layer.axes.x) {
        query.selects.push({
          type: "select",
          expr: this.axisBuilder.compileAxis({
            axis: layer.axes.x,
            tableAlias: "main"
          }),
          alias: "x"
        });
      }
      if (layer.axes.color) {
        query.selects.push({
          type: "select",
          expr: this.axisBuilder.compileAxis({
            axis: layer.axes.color,
            tableAlias: "main"
          }),
          alias: "color"
        });
      }
      if (layer.axes.y) {
        query.selects.push({
          type: "select",
          expr: this.axisBuilder.compileAxis({
            axis: layer.axes.y,
            tableAlias: "main"
          }),
          alias: "y"
        });
      }
      if (layer.axes.x || layer.axes.color) {
        query.orderBy.push({
          ordinal: 1
        });
      }
      if (layer.axes.x && layer.axes.color) {
        query.orderBy.push({
          ordinal: 2
        });
      }
      if (this.doesLayerNeedGrouping(design, layerIndex)) {
        if (layer.axes.x || layer.axes.color) {
          query.groupBy.push(1);
        }
        if (layer.axes.x && layer.axes.color) {
          query.groupBy.push(2);
        }
      }
      whereClauses = [];
      if (layer.filter) {
        whereClauses.push(this.compileExpr(layer.filter));
      }
      if (extraFilters && extraFilters.length > 0) {
        relevantFilters = _.where(extraFilters, {
          table: layer.table
        });
        if (relevantFilters.length > 0) {
          for (k = 0, len = relevantFilters.length; k < len; k++) {
            filter = relevantFilters[k];
            whereClauses.push(injectTableAlias(filter.jsonql, "main"));
          }
        }
      }
      whereClauses = _.compact(whereClauses);
      if (whereClauses.length > 1) {
        query.where = {
          type: "op",
          op: "and",
          exprs: whereClauses
        };
      } else {
        query.where = whereClauses[0];
      }
      queries["layer" + layerIndex] = query;
    }
    return queries;
  };

  LayeredChartCompiler.prototype.createDataMap = function(design, data) {
    return this.compileData(design, data).dataMap;
  };

  LayeredChartCompiler.prototype.createChartOptions = function(options) {
    var c3Data, chartDesign;
    c3Data = this.compileData(options.design, options.data, options.locale);
    chartDesign = {
      data: {
        types: c3Data.types,
        columns: c3Data.columns,
        names: c3Data.names,
        types: c3Data.types,
        groups: c3Data.groups,
        xs: c3Data.xs,
        colors: c3Data.colors,
        labels: options.design.labels,
        order: c3Data.order
      },
      legend: {
        hide: options.design.layers.length === 1 && !options.design.layers[0].axes.color
      },
      grid: {
        focus: {
          show: false
        }
      },
      axis: {
        x: {
          type: c3Data.xAxisType,
          label: {
            text: cleanString(c3Data.xAxisLabelText),
            position: options.design.transpose ? 'outer-middle' : 'outer-center'
          },
          tick: {
            fit: c3Data.xAxisTickFit
          }
        },
        y: {
          label: {
            text: cleanString(c3Data.yAxisLabelText),
            position: options.design.transpose ? 'outer-center' : 'outer-middle'
          },
          max: options.design.type === "bar" && options.design.proportional ? 100 : void 0,
          padding: options.design.type === "bar" && options.design.proportional ? {
            top: 0,
            bottom: 0
          } : void 0,
          tick: {
            format: tickFormatter
          }
        },
        rotated: options.design.transpose
      },
      size: {
        width: options.width,
        height: options.height
      },
      pie: {
        label: {
          format: options.design.labels ? pieLabelValueFormatter : void 0
        },
        expand: false
      },
      donut: {
        label: {
          format: options.design.labels ? pieLabelValueFormatter : void 0
        },
        expand: false
      },
      transition: {
        duration: 0
      }
    };
    if (options.design.labels && (options.design.type === "pie" || options.design.type === "donut")) {
      chartDesign.tooltip = {
        format: {
          value: pieLabelValueFormatter
        }
      };
    }
    return chartDesign;
  };

  LayeredChartCompiler.prototype.isCategoricalX = function(design) {
    var categoricalX, xType;
    categoricalX = design.type === "bar" || _.any(design.layers, function(l) {
      return l.type === "bar";
    });
    xType = this.axisBuilder.getAxisType(design.layers[0].axes.x);
    if (xType === "enum" || xType === "text" || xType === "boolean") {
      categoricalX = true;
    }
    if (xType === "date" && design.stacked) {
      categoricalX = true;
    }
    return categoricalX;
  };

  LayeredChartCompiler.prototype.compileData = function(design, data, locale) {
    var ref;
    if (((ref = design.type) === 'pie' || ref === 'donut') || _.any(design.layers, function(l) {
      var ref1;
      return (ref1 = l.type) === 'pie' || ref1 === 'donut';
    })) {
      return this.compileDataPolar(design, data, locale);
    }
    if (this.isCategoricalX(design)) {
      return this.compileDataCategorical(design, data, locale);
    } else {
      return this.compileDataNonCategorical(design, data, locale);
    }
  };

  LayeredChartCompiler.prototype.compileDataPolar = function(design, data, locale) {
    var colors, columns, dataMap, names, types;
    columns = [];
    types = {};
    names = {};
    dataMap = {};
    colors = {};
    _.each(design.layers, (function(_this) {
      return function(layer, layerIndex) {
        var categories, categoryOrder, layerData, row, series;
        if (layer.axes.color) {
          layerData = data["layer" + layerIndex];
          categories = _this.axisBuilder.getCategories(layer.axes.color, _.pluck(layerData, "color"), locale);
          categoryOrder = _.zipObject(_.map(categories, function(c, i) {
            return [c.value, i];
          }));
          layerData = _.sortBy(layerData, function(row) {
            return categoryOrder[row.color];
          });
          return _.each(layerData, function(row, rowIndex) {
            var color, series;
            if (_.includes(layer.axes.color.excludedValues, row.color)) {
              return;
            }
            series = layerIndex + ":" + rowIndex;
            columns.push([series, row.y]);
            types[series] = _this.getLayerType(design, layerIndex);
            names[series] = _this.axisBuilder.formatValue(layer.axes.color, row.color, locale);
            dataMap[series] = {
              layerIndex: layerIndex,
              row: row
            };
            color = _this.axisBuilder.getValueColor(layer.axes.color, row.color);
            if (color) {
              return colors[series] = color;
            }
          });
        } else {
          row = data["layer" + layerIndex][0];
          if (row) {
            series = "" + layerIndex;
            columns.push([series, row.y]);
            types[series] = _this.getLayerType(design, layerIndex);
            names[series] = layer.name || ("Series " + (layerIndex + 1));
            dataMap[series] = {
              layerIndex: layerIndex,
              row: row
            };
            if (layer.color) {
              return colors[series] = layer.color;
            }
          }
        }
      };
    })(this));
    return {
      columns: columns,
      types: types,
      names: names,
      dataMap: dataMap,
      colors: colors,
      xAxisType: "category",
      titleText: this.compileTitleText(design, locale),
      order: "desc"
    };
  };

  LayeredChartCompiler.prototype.compileDataNonCategorical = function(design, data, locale) {
    var colors, columns, dataMap, groups, names, types, xType, xs;
    columns = [];
    types = {};
    names = {};
    dataMap = {};
    colors = {};
    xs = {};
    groups = [];
    xType = this.axisBuilder.getAxisType(design.layers[0].axes.x);
    _.each(design.layers, (function(_this) {
      return function(layer, layerIndex) {
        var categories, categoryOrder, colorValues, layerData, seriesX, seriesY, yValues;
        layerData = data["layer" + layerIndex];
        _this.fixStringYValues(layerData);
        if (layer.cumulative) {
          layerData = _this.makeRowsCumulative(layerData);
        }
        layerData = _.filter(layerData, function(row) {
          return !_.includes(layer.axes.x.excludedValues, row.x);
        });
        if (layer.axes.color) {
          colorValues = _.uniq(_.pluck(layerData, "color"));
          categories = _this.axisBuilder.getCategories(layer.axes.color, colorValues, locale);
          categoryOrder = _.zipObject(_.map(categories, function(c, i) {
            return [c.value, i];
          }));
          colorValues = _.sortBy(colorValues, function(v) {
            return categoryOrder[v];
          });
          colorValues = _.difference(colorValues, layer.axes.color.excludedValues);
          return _.each(colorValues, function(colorValue) {
            var color, rows, seriesX, seriesY, yValues;
            seriesX = layerIndex + ":" + colorValue + ":x";
            seriesY = layerIndex + ":" + colorValue + ":y";
            color = _this.axisBuilder.getValueColor(layer.axes.color, colorValue);
            color = color || layer.color;
            if (color) {
              colors[seriesY] = color;
            }
            rows = _.where(layerData, {
              color: colorValue
            });
            yValues = _.pluck(rows, "y");
            columns.push([seriesY].concat(yValues));
            columns.push([seriesX].concat(_.pluck(rows, "x")));
            types[seriesY] = _this.getLayerType(design, layerIndex);
            names[seriesY] = _this.axisBuilder.formatValue(layer.axes.color, colorValue, locale);
            xs[seriesY] = seriesX;
            return _.each(rows, function(row, rowIndex) {
              return dataMap[seriesY + ":" + rowIndex] = {
                layerIndex: layerIndex,
                row: row
              };
            });
          });
        } else {
          seriesX = layerIndex + ":x";
          seriesY = layerIndex + ":y";
          yValues = _.pluck(layerData, "y");
          columns.push([seriesY].concat(yValues));
          columns.push([seriesX].concat(_.pluck(layerData, "x")));
          types[seriesY] = _this.getLayerType(design, layerIndex);
          names[seriesY] = layer.name || ("Series " + (layerIndex + 1));
          xs[seriesY] = seriesX;
          colors[seriesY] = layer.color;
          return _.each(layerData, function(row, rowIndex) {
            return dataMap[seriesY + ":" + rowIndex] = {
              layerIndex: layerIndex,
              row: row
            };
          });
        }
      };
    })(this));
    if (design.stacked) {
      groups = [_.keys(names)];
    }
    return {
      columns: columns,
      types: types,
      names: names,
      groups: groups,
      dataMap: dataMap,
      colors: colors,
      xs: xs,
      xAxisType: (xType === "date") ? "timeseries" : "indexed",
      xAxisTickFit: false,
      xAxisLabelText: this.compileXAxisLabelText(design, locale),
      yAxisLabelText: this.compileYAxisLabelText(design, locale),
      titleText: this.compileTitleText(design, locale),
      order: null
    };
  };

  LayeredChartCompiler.prototype.fixStringYValues = function(rows) {
    var j, len, row;
    for (j = 0, len = rows.length; j < len; j++) {
      row = rows[j];
      if (_.isString(row.y)) {
        row.y = parseFloat(row.y);
      }
    }
    return rows;
  };

  LayeredChartCompiler.prototype.flattenRowData = function(rows) {
    var existingRow, flatRows, j, k, len, len1, row, x, xs;
    flatRows = [];
    for (j = 0, len = rows.length; j < len; j++) {
      row = rows[j];
      if (!row.x) {
        flatRows.push(row);
        continue;
      }
      if (_.isString(row.x)) {
        try {
          xs = JSON.parse(row.x);
        } catch (error) {
          xs = row.x;
        }
      } else {
        xs = row.x;
      }
      for (k = 0, len1 = xs.length; k < len1; k++) {
        x = xs[k];
        existingRow = _.find(flatRows, function(r) {
          return r.x === x && r.color === row.color;
        });
        if (existingRow) {
          existingRow.y += row.y;
        } else {
          flatRows.push(_.extend({}, row, {
            x: x
          }));
        }
      }
    }
    return flatRows;
  };

  LayeredChartCompiler.prototype.compileDataCategorical = function(design, data, locale) {
    var categories, categoryMap, categoryOrder, categoryXs, colors, column, columns, dataMap, groups, i, j, k, len, len1, m, n, names, ref, ref1, types, xAxis, xType, xValues, xs, xtotals;
    columns = [];
    types = {};
    names = {};
    dataMap = {};
    colors = {};
    xs = {};
    groups = [];
    xAxis = design.layers[0].axes.x;
    xType = this.axisBuilder.getAxisType(xAxis);
    xValues = [];
    _.each(design.layers, (function(_this) {
      return function(layer, layerIndex) {
        var layerData;
        layerData = data["layer" + layerIndex];
        return xValues = _.union(xValues, _.uniq(_.pluck(layerData, "x")));
      };
    })(this));
    categories = this.axisBuilder.getCategories(xAxis, xValues, locale);
    categoryOrder = _.zipObject(_.map(categories, function(c, i) {
      return [c.value, i];
    }));
    categories = _.filter(categories, (function(_this) {
      return function(category) {
        return !_.includes(xAxis.excludedValues, category.value);
      };
    })(this));
    if (xType !== "enumset") {
      categories = _.takeRight(categories, 40);
      categoryXs = _.indexBy(categories, "value");
    }
    categoryMap = _.object(_.map(categories, function(c, i) {
      return [c.value, i];
    }));
    columns.push(["x"].concat(_.pluck(categories, "label")));
    _.each(design.layers, (function(_this) {
      return function(layer, layerIndex) {
        var colorCategories, colorCategoryOrder, colorValues, column, layerData, series;
        layerData = data["layer" + layerIndex];
        layerData = _this.fixStringYValues(layerData);
        if (xType === "enumset") {
          layerData = _this.flattenRowData(layerData);
        }
        layerData = _.sortBy(layerData, function(row) {
          return categoryOrder[row.x];
        });
        if (layer.cumulative) {
          layerData = _this.makeRowsCumulative(layerData);
        }
        if (xType !== "enumset") {
          layerData = _.filter(layerData, function(row) {
            return categoryXs[row.x] != null;
          });
        }
        if (layer.axes.color) {
          colorValues = _.uniq(_.pluck(layerData, "color"));
          colorCategories = _this.axisBuilder.getCategories(layer.axes.color, colorValues, locale);
          colorCategoryOrder = _.zipObject(_.map(colorCategories, function(c, i) {
            return [c.value, i];
          }));
          colorValues = _.sortBy(colorValues, function(v) {
            return colorCategoryOrder[v];
          });
          colorValues = _.difference(colorValues, layer.axes.color.excludedValues);
          return _.each(colorValues, function(colorValue) {
            var color, column, i, j, len, rows, series, value;
            series = layerIndex + ":" + colorValue;
            color = _this.axisBuilder.getValueColor(layer.axes.color, colorValue);
            color = color || layer.color;
            if (color) {
              colors[series] = color;
            }
            rows = _.where(layerData, {
              color: colorValue
            });
            column = _.map(categories, function(c) {
              return null;
            });
            _.each(rows, function(row) {
              var index;
              index = categoryMap[row.x];
              if (index != null) {
                column[index] = row.y;
                return dataMap[series + ":" + index] = {
                  layerIndex: layerIndex,
                  row: row
                };
              }
            });
            if (layer.cumulative) {
              for (i = j = 0, len = column.length; j < len; i = ++j) {
                value = column[i];
                if ((value == null) && i > 0) {
                  column[i] = column[i - 1];
                }
              }
            }
            columns.push([series].concat(column));
            types[series] = _this.getLayerType(design, layerIndex);
            names[series] = _this.axisBuilder.formatValue(layer.axes.color, colorValue, locale);
            return xs[series] = "x";
          });
        } else {
          series = "" + layerIndex;
          column = _.map(categories, function(c) {
            return null;
          });
          _.each(layerData, function(row) {
            var index;
            if (_.includes(layer.axes.x.excludedValues, row.x)) {
              return;
            }
            index = categoryMap[row.x];
            column[index] = row.y;
            return dataMap[series + ":" + index] = {
              layerIndex: layerIndex,
              row: row
            };
          });
          columns.push([series].concat(column));
          types[series] = _this.getLayerType(design, layerIndex);
          names[series] = layer.name || ("Series " + (layerIndex + 1));
          xs[series] = "x";
          return colors[series] = layer.color;
        }
      };
    })(this));
    if (design.stacked) {
      groups = [_.keys(names)];
    } else if (design.layers.length > 1 && _.any(design.layers, function(layer) {
      return layer.axes.color;
    })) {
      groups = _.groupBy(_.keys(names), function(series) {
        return series.split(":")[0];
      });
      groups = _.filter(groups, function(g) {
        return g.length > 1;
      });
    }
    if (design.proportional) {
      xtotals = [];
      for (j = 0, len = columns.length; j < len; j++) {
        column = columns[j];
        if (column[0] === 'x') {
          continue;
        }
        for (i = k = 1, ref = column.length; 1 <= ref ? k < ref : k > ref; i = 1 <= ref ? ++k : --k) {
          xtotals[i] = (xtotals[i] || 0) + (column[i] || 0);
        }
      }
      for (m = 0, len1 = columns.length; m < len1; m++) {
        column = columns[m];
        if (column[0] === 'x') {
          continue;
        }
        for (i = n = 1, ref1 = column.length; 1 <= ref1 ? n < ref1 : n > ref1; i = 1 <= ref1 ? ++n : --n) {
          if (column[i] > 0) {
            column[i] = Math.round(100 * column[i] / xtotals[i] * 10) / 10;
          }
        }
      }
    }
    return {
      columns: columns,
      types: types,
      names: names,
      dataMap: dataMap,
      colors: colors,
      xs: xs,
      groups: groups,
      xAxisType: "category",
      xAxisTickFit: xType !== "date",
      xAxisLabelText: this.compileXAxisLabelText(design, locale),
      yAxisLabelText: this.compileYAxisLabelText(design, locale),
      titleText: this.compileTitleText(design, locale),
      order: null
    };
  };

  LayeredChartCompiler.prototype.compileExpr = function(expr) {
    var exprCompiler;
    exprCompiler = new ExprCompiler(this.schema);
    return exprCompiler.compileExpr({
      expr: expr,
      tableAlias: "main"
    });
  };

  LayeredChartCompiler.prototype.getLayerType = function(design, layerIndex) {
    return design.layers[layerIndex].type || design.type;
  };

  LayeredChartCompiler.prototype.doesLayerNeedGrouping = function(design, layerIndex) {
    return this.getLayerType(design, layerIndex) !== "scatter";
  };

  LayeredChartCompiler.prototype.canLayerUseXExpr = function(design, layerIndex) {
    var ref;
    return (ref = this.getLayerType(design, layerIndex)) !== 'pie' && ref !== 'donut';
  };

  LayeredChartCompiler.prototype.isXAxisRequired = function(design, layerIndex) {
    return _.any(design.layers, (function(_this) {
      return function(layer, i) {
        var ref;
        return (ref = _this.getLayerType(design, i)) !== 'pie' && ref !== 'donut';
      };
    })(this));
  };

  LayeredChartCompiler.prototype.isColorAxisRequired = function(design, layerIndex) {
    var ref;
    return (ref = this.getLayerType(design, layerIndex)) === 'pie' || ref === 'donut';
  };

  LayeredChartCompiler.prototype.compileDefaultTitleText = function(design, locale) {
    return "";
  };

  LayeredChartCompiler.prototype.compileDefaultYAxisLabelText = function(design, locale) {
    return this.axisBuilder.summarizeAxis(design.layers[0].axes.y, locale);
  };

  LayeredChartCompiler.prototype.compileDefaultXAxisLabelText = function(design, locale) {
    return this.axisBuilder.summarizeAxis(design.layers[0].axes.x, locale);
  };

  LayeredChartCompiler.prototype.compileTitleText = function(design, locale) {
    return design.titleText || this.compileDefaultTitleText(design, locale);
  };

  LayeredChartCompiler.prototype.compileYAxisLabelText = function(design, locale) {
    if (design.yAxisLabelText === "") {
      return this.compileDefaultYAxisLabelText(design, locale);
    }
    return design.yAxisLabelText;
  };

  LayeredChartCompiler.prototype.compileXAxisLabelText = function(design, locale) {
    if (design.xAxisLabelText === "") {
      return this.compileDefaultXAxisLabelText(design, locale);
    }
    return design.xAxisLabelText;
  };

  LayeredChartCompiler.prototype.createScope = function(design, layerIndex, row, locale) {
    var data, expressionBuilder, filter, filters, layer, names, scope;
    expressionBuilder = new ExprUtils(this.schema);
    layer = design.layers[layerIndex];
    filters = [];
    names = [];
    data = {
      layerIndex: layerIndex
    };
    if (layer.axes.x) {
      if (this.axisBuilder.getAxisType(layer.axes.x) === "enumset") {
        filters.push({
          type: "op",
          op: "@>",
          exprs: [
            {
              type: "op",
              op: "::jsonb",
              exprs: [
                this.axisBuilder.compileAxis({
                  axis: layer.axes.x,
                  tableAlias: "{alias}"
                })
              ]
            }, {
              type: "op",
              op: "::jsonb",
              exprs: [JSON.stringify(row.x)]
            }
          ]
        });
        names.push(this.axisBuilder.summarizeAxis(layer.axes.x, locale) + " includes " + this.exprUtils.stringifyExprLiteral(layer.axes.x.expr, [row.x], locale));
        data.x = row.x;
      } else {
        filters.push(this.axisBuilder.createValueFilter(layer.axes.x, row.x));
        names.push(this.axisBuilder.summarizeAxis(layer.axes.x, locale) + " is " + this.axisBuilder.formatValue(layer.axes.x, row.x, locale));
        data.x = row.x;
      }
    }
    if (layer.axes.color) {
      filters.push(this.axisBuilder.createValueFilter(layer.axes.color, row.color));
      names.push(this.axisBuilder.summarizeAxis(layer.axes.color, locale) + " is " + this.axisBuilder.formatValue(layer.axes.color, row.color, locale));
      data.color = row.color;
    }
    if (filters.length > 1) {
      filter = {
        table: layer.table,
        jsonql: {
          type: "op",
          op: "and",
          exprs: filters
        }
      };
    } else {
      filter = {
        table: layer.table,
        jsonql: filters[0]
      };
    }
    scope = {
      name: ExprUtils.localizeString(this.schema.getTable(layer.table).name, locale) + " " + names.join(" and "),
      filter: filter,
      data: data
    };
    return scope;
  };

  LayeredChartCompiler.prototype.makeRowsCumulative = function(rows) {
    var j, len, newRows, row, total, totals, y;
    totals = {};
    newRows = [];
    for (j = 0, len = rows.length; j < len; j++) {
      row = rows[j];
      total = totals[row.color] || 0;
      y = total + row.y;
      totals[row.color] = y;
      newRows.push(_.extend({}, row, {
        y: y
      }));
    }
    return newRows;
  };

  return LayeredChartCompiler;

})();

cleanString = function(str) {
  if (!str) {
    return str;
  }
  return str.replace("\u00A0", " ");
};


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../axes/AxisBuilder":1029,"lodash":"lodash","mwater-expressions":14}],1142:[function(require,module,exports){
var H, LayeredChartCompiler, LayeredChartDesignerComponent, LayeredChartLayerDesignerComponent, R, React, TabbedComponent, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

LayeredChartLayerDesignerComponent = require('./LayeredChartLayerDesignerComponent');

LayeredChartCompiler = require('./LayeredChartCompiler');

TabbedComponent = require('react-library/lib/TabbedComponent');

ui = require('../../../UIComponents');

module.exports = LayeredChartDesignerComponent = (function(superClass) {
  extend(LayeredChartDesignerComponent, superClass);

  function LayeredChartDesignerComponent() {
    this.renderLayer = bind(this.renderLayer, this);
    this.handleToggleYAxisLabelClick = bind(this.handleToggleYAxisLabelClick, this);
    this.handleToggleXAxisLabelClick = bind(this.handleToggleXAxisLabelClick, this);
    this.handleYAxisLabelTextChange = bind(this.handleYAxisLabelTextChange, this);
    this.handleXAxisLabelTextChange = bind(this.handleXAxisLabelTextChange, this);
    this.handleAddLayer = bind(this.handleAddLayer, this);
    this.handleRemoveLayer = bind(this.handleRemoveLayer, this);
    this.handleLayerChange = bind(this.handleLayerChange, this);
    this.handleLabelsChange = bind(this.handleLabelsChange, this);
    this.handleProportionalChange = bind(this.handleProportionalChange, this);
    this.handleStackedChange = bind(this.handleStackedChange, this);
    this.handleTransposeChange = bind(this.handleTransposeChange, this);
    this.handleTypeChange = bind(this.handleTypeChange, this);
    return LayeredChartDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  LayeredChartDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  LayeredChartDesignerComponent.prototype.areAxesLabelsNeeded = function(layer) {
    var ref;
    return (ref = this.props.design.type) !== 'pie' && ref !== 'donut';
  };

  LayeredChartDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  LayeredChartDesignerComponent.prototype.handleTypeChange = function(type) {
    return this.updateDesign({
      type: type
    });
  };

  LayeredChartDesignerComponent.prototype.handleTransposeChange = function(ev) {
    return this.updateDesign({
      transpose: ev.target.checked
    });
  };

  LayeredChartDesignerComponent.prototype.handleStackedChange = function(ev) {
    return this.updateDesign({
      stacked: ev.target.checked
    });
  };

  LayeredChartDesignerComponent.prototype.handleProportionalChange = function(ev) {
    return this.updateDesign({
      proportional: ev.target.checked
    });
  };

  LayeredChartDesignerComponent.prototype.handleLabelsChange = function(ev) {
    return this.updateDesign({
      labels: ev.target.checked
    });
  };

  LayeredChartDesignerComponent.prototype.handleLayerChange = function(index, layer) {
    var layers;
    layers = this.props.design.layers.slice();
    layers[index] = layer;
    return this.updateDesign({
      layers: layers
    });
  };

  LayeredChartDesignerComponent.prototype.handleRemoveLayer = function(index) {
    var layers;
    layers = this.props.design.layers.slice();
    layers.splice(index, 1);
    return this.updateDesign({
      layers: layers
    });
  };

  LayeredChartDesignerComponent.prototype.handleAddLayer = function() {
    var layers;
    layers = this.props.design.layers.slice();
    layers.push({});
    return this.updateDesign({
      layers: layers
    });
  };

  LayeredChartDesignerComponent.prototype.handleXAxisLabelTextChange = function(ev) {
    return this.updateDesign({
      xAxisLabelText: ev.target.value
    });
  };

  LayeredChartDesignerComponent.prototype.handleYAxisLabelTextChange = function(ev) {
    return this.updateDesign({
      yAxisLabelText: ev.target.value
    });
  };

  LayeredChartDesignerComponent.prototype.handleToggleXAxisLabelClick = function(ev) {
    return this.updateDesign({
      xAxisLabelText: this.props.design.xAxisLabelText != null ? null : ""
    });
  };

  LayeredChartDesignerComponent.prototype.handleToggleYAxisLabelClick = function(ev) {
    return this.updateDesign({
      yAxisLabelText: this.props.design.yAxisLabelText != null ? null : ""
    });
  };

  LayeredChartDesignerComponent.prototype.renderLabels = function() {
    var compiler;
    if (!this.props.design.type) {
      return;
    }
    compiler = new LayeredChartCompiler({
      schema: this.props.schema
    });
    return H.div(null, H.p({
      className: "help-block"
    }, "To edit title of chart, click on it directly"), this.areAxesLabelsNeeded() ? H.div({
      className: "form-group"
    }, H.span(null, H.label({
      className: "text-muted"
    }, this.props.design.transpose ? "Vertical Axis Label" : "Horizontal Axis Label"), " ", H.button({
      className: "btn btn-default btn-xs",
      onClick: this.handleToggleXAxisLabelClick
    }, this.props.design.xAxisLabelText != null ? "Hide" : "Show")), this.props.design.xAxisLabelText != null ? H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.xAxisLabelText,
      onChange: this.handleXAxisLabelTextChange,
      placeholder: compiler.compileDefaultXAxisLabelText(this.props.design)
    }) : void 0) : void 0, this.areAxesLabelsNeeded() ? H.div({
      className: "form-group"
    }, H.span(null, H.label({
      className: "text-muted"
    }, !this.props.design.transpose ? "Vertical Axis Label" : "Horizontal Axis Label"), " ", H.button({
      className: "btn btn-default btn-xs",
      onClick: this.handleToggleYAxisLabelClick
    }, this.props.design.yAxisLabelText != null ? "Hide" : "Show")), this.props.design.yAxisLabelText != null ? H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.yAxisLabelText,
      onChange: this.handleYAxisLabelTextChange,
      placeholder: compiler.compileDefaultYAxisLabelText(this.props.design)
    }) : void 0) : void 0);
  };

  LayeredChartDesignerComponent.prototype.renderType = function() {
    var chartTypes, current;
    chartTypes = [
      {
        id: "bar",
        name: "Bar",
        desc: "Best for most charts"
      }, {
        id: "pie",
        name: "Pie",
        desc: "Compare ratios of one variable"
      }, {
        id: "donut",
        name: "Donut",
        desc: "Pie chart with center removed"
      }, {
        id: "line",
        name: "Line",
        desc: "Show how data changes smoothly over time"
      }, {
        id: "spline",
        name: "Smoothed Line",
        desc: "For noisy data over time"
      }, {
        id: "scatter",
        name: "Scatter",
        desc: "Show correlation between two number variables"
      }, {
        id: "area",
        name: "Area",
        desc: "For cumulative data over time"
      }
    ];
    current = _.findWhere(chartTypes, {
      id: this.props.design.type
    });
    return R(ui.SectionComponent, {
      icon: "glyphicon-th",
      label: "Chart Type"
    }, R(ui.ToggleEditComponent, {
      forceOpen: !this.props.design.type,
      label: current ? current.name : "",
      editor: (function(_this) {
        return function(onClose) {
          return R(ui.OptionListComponent, {
            hint: "Select a Chart Type",
            items: _.map(chartTypes, function(ct) {
              return {
                name: ct.name,
                desc: ct.desc,
                onClick: function() {
                  onClose();
                  return _this.handleTypeChange(ct.id);
                }
              };
            })
          });
        };
      })(this)
    }), this.renderOptions());
  };

  LayeredChartDesignerComponent.prototype.renderLayer = function(index) {
    var style;
    style = {
      paddingTop: 10,
      paddingBottom: 10
    };
    return H.div({
      style: style,
      key: index
    }, R(LayeredChartLayerDesignerComponent, {
      design: this.props.design,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      index: index,
      onChange: this.handleLayerChange.bind(null, index),
      onRemove: this.handleRemoveLayer.bind(null, index)
    }));
  };

  LayeredChartDesignerComponent.prototype.renderLayers = function() {
    if (!this.props.design.type) {
      return;
    }
    return H.div(null, _.map(this.props.design.layers, (function(_this) {
      return function(layer, i) {
        return _this.renderLayer(i);
      };
    })(this)), this.props.design.layers.length > 0 && _.last(this.props.design.layers).table ? H.button({
      className: "btn btn-link",
      type: "button",
      onClick: this.handleAddLayer
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Another Series") : void 0);
  };

  LayeredChartDesignerComponent.prototype.renderOptions = function() {
    var canStack, canTranspose, design, ref, ref1;
    design = this.props.design;
    if (!design.type) {
      return;
    }
    canStack = ((ref = design.type) !== 'pie' && ref !== 'donut') && design.layers.length > 0;
    if (design.layers.length === 1 && !design.layers[0].axes.color) {
      canStack = false;
    }
    canTranspose = (ref1 = design.type) !== 'pie' && ref1 !== 'donut';
    return H.div({
      className: "text-muted"
    }, canTranspose ? H.label({
      className: "checkbox-inline",
      key: "transpose"
    }, H.input({
      type: "checkbox",
      checked: design.transpose,
      onChange: this.handleTransposeChange
    }), "Horizontal") : void 0, canStack ? H.label({
      className: "checkbox-inline",
      key: "stacked"
    }, H.input({
      type: "checkbox",
      checked: design.stacked,
      onChange: this.handleStackedChange
    }), "Stacked") : void 0, canStack ? H.label({
      className: "checkbox-inline",
      key: "proportional"
    }, H.input({
      type: "checkbox",
      checked: design.proportional,
      onChange: this.handleProportionalChange
    }), "Proportional") : void 0, H.label({
      className: "checkbox-inline",
      key: "labels"
    }, H.input({
      type: "checkbox",
      checked: design.labels || false,
      onChange: this.handleLabelsChange
    }), "Show Values"));
  };

  LayeredChartDesignerComponent.prototype.render = function() {
    var tabs;
    tabs = [];
    tabs.push({
      id: "design",
      label: "Design",
      elem: H.div(null, H.br(), this.renderType(), this.renderLayers())
    });
    if (this.props.design.type) {
      tabs.push({
        id: "labels",
        label: "Labels",
        elem: H.div(null, H.br(), this.renderLabels())
      });
    }
    return R(TabbedComponent, {
      initialTabId: "design",
      tabs: tabs
    });
  };

  return LayeredChartDesignerComponent;

})(React.Component);


},{"../../../UIComponents":1026,"./LayeredChartCompiler":1141,"./LayeredChartLayerDesignerComponent":1143,"react":"react","react-library/lib/TabbedComponent":792}],1143:[function(require,module,exports){
var AxisBuilder, AxisComponent, ColorComponent, ExprUtils, FilterExprComponent, H, LayeredChartCompiler, LayeredChartLayerDesignerComponent, LayeredChartUtils, R, React, TableSelectComponent, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

AxisComponent = require('../../../axes/AxisComponent');

AxisBuilder = require('../../../axes/AxisBuilder');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprUtils = require('mwater-expressions').ExprUtils;

ColorComponent = require('../../../ColorComponent');

LayeredChartUtils = require('./LayeredChartUtils');

LayeredChartCompiler = require('./LayeredChartCompiler');

ui = require('../../../UIComponents');

TableSelectComponent = require('../../../TableSelectComponent');

module.exports = LayeredChartLayerDesignerComponent = (function(superClass) {
  extend(LayeredChartLayerDesignerComponent, superClass);

  function LayeredChartLayerDesignerComponent() {
    this.handleCumulativeChange = bind(this.handleCumulativeChange, this);
    this.handleColorChange = bind(this.handleColorChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleYAxisChange = bind(this.handleYAxisChange, this);
    this.handleColorAxisChange = bind(this.handleColorAxisChange, this);
    this.handleXAxisChange = bind(this.handleXAxisChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleNameChange = bind(this.handleNameChange, this);
    return LayeredChartLayerDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  LayeredChartLayerDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    index: React.PropTypes.number.isRequired,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired
  };

  LayeredChartLayerDesignerComponent.prototype.isLayerPolar = function(layer) {
    var ref;
    return (ref = layer.type || this.props.design.type) === 'pie' || ref === 'donut';
  };

  LayeredChartLayerDesignerComponent.prototype.doesLayerNeedGrouping = function(layer) {
    var ref;
    return (ref = layer.type || this.props.design.type) !== 'scatter';
  };

  LayeredChartLayerDesignerComponent.prototype.isXAxisRequired = function(layer) {
    return !this.isLayerPolar(layer);
  };

  LayeredChartLayerDesignerComponent.prototype.getAxisTypes = function(layer, axisKey) {
    return LayeredChartUtils.getAxisTypes(this.props.design, layer, axisKey);
  };

  LayeredChartLayerDesignerComponent.prototype.getAxisLabel = function(icon, label) {
    return H.span(null, H.span({
      className: "glyphicon glyphicon-" + icon
    }), " " + label);
  };

  LayeredChartLayerDesignerComponent.prototype.getXAxisLabel = function(layer) {
    if (this.props.design.transpose) {
      return this.getAxisLabel("resize-vertical", "Vertical Axis");
    } else {
      return this.getAxisLabel("resize-horizontal", "Horizontal Axis");
    }
  };

  LayeredChartLayerDesignerComponent.prototype.getYAxisLabel = function(layer) {
    if (this.isLayerPolar(layer)) {
      return this.getAxisLabel("repeat", "Angle Axis");
    } else if (this.props.design.transpose) {
      return this.getAxisLabel("resize-horizontal", "Horizontal Axis");
    } else {
      return this.getAxisLabel("resize-vertical", "Vertical Axis");
    }
  };

  LayeredChartLayerDesignerComponent.prototype.getColorAxisLabel = function(layer) {
    if (this.isLayerPolar(layer)) {
      return this.getAxisLabel("text-color", "Label Axis");
    } else {
      return this.getAxisLabel("equalizer", "Split Axis");
    }
  };

  LayeredChartLayerDesignerComponent.prototype.updateLayer = function(changes) {
    var layer;
    layer = _.extend({}, this.props.design.layers[this.props.index], changes);
    return this.props.onChange(layer);
  };

  LayeredChartLayerDesignerComponent.prototype.updateAxes = function(changes) {
    var axes;
    axes = _.extend({}, this.props.design.layers[this.props.index].axes, changes);
    return this.updateLayer({
      axes: axes
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleNameChange = function(ev) {
    return this.updateLayer({
      name: ev.target.value
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleTableChange = function(table) {
    return this.updateLayer({
      table: table
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleXAxisChange = function(axis) {
    var axesChanges, layer, ref;
    layer = this.props.design.layers[this.props.index];
    axesChanges = {
      x: axis
    };
    if (axis && this.doesLayerNeedGrouping(layer) && !((ref = layer.axes) != null ? ref.y : void 0)) {
      axesChanges.y = {
        expr: {
          type: "op",
          op: "count",
          table: layer.table,
          exprs: []
        }
      };
    }
    return this.updateAxes(axesChanges);
  };

  LayeredChartLayerDesignerComponent.prototype.handleColorAxisChange = function(axis) {
    var axesChanges, layer, ref;
    layer = this.props.design.layers[this.props.index];
    axesChanges = {
      color: axis
    };
    if (axis && this.doesLayerNeedGrouping(layer) && !((ref = layer.axes) != null ? ref.y : void 0)) {
      axesChanges.y = {
        expr: {
          type: "op",
          op: "count",
          table: layer.table,
          exprs: []
        }
      };
    }
    return this.updateAxes(axesChanges);
  };

  LayeredChartLayerDesignerComponent.prototype.handleYAxisChange = function(axis) {
    return this.updateAxes({
      y: axis
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.updateLayer({
      filter: filter
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleColorChange = function(color) {
    return this.updateLayer({
      color: color
    });
  };

  LayeredChartLayerDesignerComponent.prototype.handleCumulativeChange = function(ev) {
    return this.updateLayer({
      cumulative: ev.target.checked
    });
  };

  LayeredChartLayerDesignerComponent.prototype.renderName = function() {
    var layer;
    if (this.props.design.layers.length <= 1) {
      return;
    }
    layer = this.props.design.layers[this.props.index];
    return H.input({
      type: "text",
      className: "form-control input-sm",
      value: layer.name,
      onChange: this.handleNameChange,
      placeholder: "Series " + (this.props.index + 1)
    });
  };

  LayeredChartLayerDesignerComponent.prototype.renderRemove = function() {
    if (this.props.design.layers.length > 1) {
      return H.button({
        className: "btn btn-xs btn-link pull-right",
        type: "button",
        onClick: this.props.onRemove
      }, H.span({
        className: "glyphicon glyphicon-remove"
      }));
    }
  };

  LayeredChartLayerDesignerComponent.prototype.renderTable = function() {
    var layer;
    layer = this.props.design.layers[this.props.index];
    return R(ui.SectionComponent, {
      icon: "fa-database",
      label: "Data Source"
    }, React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: layer.table,
      onChange: this.handleTableChange
    }));
  };

  LayeredChartLayerDesignerComponent.prototype.renderXAxis = function() {
    var layer, title;
    layer = this.props.design.layers[this.props.index];
    if (!layer.table) {
      return;
    }
    if (!this.isXAxisRequired(layer)) {
      return;
    }
    title = this.getXAxisLabel(layer);
    return R(ui.SectionComponent, {
      label: title
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: layer.table,
      types: this.getAxisTypes(layer, "x"),
      aggrNeed: "none",
      required: true,
      value: layer.axes.x,
      onChange: this.handleXAxisChange,
      allowExcludedValues: new LayeredChartCompiler({
        schema: this.props.schema
      }).isCategoricalX(this.props.design)
    }));
  };

  LayeredChartLayerDesignerComponent.prototype.renderColorAxis = function() {
    var layer, title;
    layer = this.props.design.layers[this.props.index];
    if (!layer.table) {
      return;
    }
    title = this.getColorAxisLabel(layer);
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, title), H.div({
      style: {
        marginLeft: 10
      }
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: layer.table,
      types: this.getAxisTypes(layer, "color"),
      aggrNeed: "none",
      required: this.isLayerPolar(layer),
      showColorMap: true,
      value: layer.axes.color,
      onChange: this.handleColorAxisChange,
      allowExcludedValues: true
    })));
  };

  LayeredChartLayerDesignerComponent.prototype.renderYAxis = function() {
    var layer, title;
    layer = this.props.design.layers[this.props.index];
    if (!layer.table) {
      return;
    }
    title = this.getYAxisLabel(layer);
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, title), H.div({
      style: {
        marginLeft: 10
      }
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: layer.table,
      types: this.getAxisTypes(layer, "y"),
      aggrNeed: "required",
      value: layer.axes.y,
      required: true,
      onChange: this.handleYAxisChange
    }), this.renderCumulative()));
  };

  LayeredChartLayerDesignerComponent.prototype.renderCumulative = function() {
    var axisBuilder, layer, ref;
    layer = this.props.design.layers[this.props.index];
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    if (!layer.axes.y || !layer.axes.x || ((ref = axisBuilder.getAxisType(layer.axes.x)) !== 'date' && ref !== 'number')) {
      return;
    }
    return H.div({
      key: "cumulative"
    }, H.label({
      className: "checkbox-inline"
    }, H.input({
      type: "checkbox",
      checked: layer.cumulative,
      onChange: this.handleCumulativeChange
    }), "Cumulative"));
  };

  LayeredChartLayerDesignerComponent.prototype.renderColor = function() {
    var layer;
    layer = this.props.design.layers[this.props.index];
    if (!layer.table) {
      return;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, layer.axes.color ? "Default Color" : "Color"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(ColorComponent, {
      color: layer.color,
      onChange: this.handleColorChange
    })));
  };

  LayeredChartLayerDesignerComponent.prototype.renderFilter = function() {
    var layer;
    layer = this.props.design.layers[this.props.index];
    if (!layer.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " ", "Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: layer.table,
      value: layer.filter
    })));
  };

  LayeredChartLayerDesignerComponent.prototype.render = function() {
    var layer;
    layer = this.props.design.layers[this.props.index];
    return H.div(null, this.props.index > 0 ? H.hr() : void 0, this.renderRemove(), this.renderTable(), this.isLayerPolar(layer) ? this.renderColorAxis() : void 0, this.renderXAxis(), layer.axes.x || layer.axes.color ? this.renderYAxis() : void 0, layer.axes.x && layer.axes.y && !this.isLayerPolar(layer) ? this.renderColorAxis() : void 0, !this.isLayerPolar(layer) ? layer.axes.y ? this.renderColor() : void 0 : void 0, layer.axes.y ? this.renderFilter() : void 0, layer.axes.y ? this.renderName() : void 0);
  };

  return LayeredChartLayerDesignerComponent;

})(React.Component);


},{"../../../ColorComponent":1016,"../../../TableSelectComponent":1025,"../../../UIComponents":1026,"../../../axes/AxisBuilder":1029,"../../../axes/AxisComponent":1031,"./LayeredChartCompiler":1141,"./LayeredChartUtils":1145,"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1144:[function(require,module,exports){
var LayeredChartCompiler, getC3Css, getC3String, saveSvgAsPng, saveSvgToFile;

saveSvgAsPng = require('save-svg-as-png');

LayeredChartCompiler = require('./LayeredChartCompiler');

getC3Css = (function(_this) {
  return function() {
    var css, i, j, len, len1, ref, rule, rules, sheet;
    css = [];
    if (document.styleSheets) {
      ref = document.styleSheets;
      for (i = 0, len = ref.length; i < len; i++) {
        sheet = ref[i];
        rules = (sheet != null ? sheet.cssRules : void 0) || sheet.rules;
        if (rules) {
          for (j = 0, len1 = rules.length; j < len1; j++) {
            rule = rules[j];
            if (rule.cssText && rule.cssText.startsWith(".c3")) {
              css.push(rule.cssText);
            }
          }
        }
      }
    }
    return css.join('\n');
  };
})(this);

getC3String = (function(_this) {
  return function(c3Node) {
    var cdata, css, styleNode, svgFinalStr, svgNode, svgStr, xml;
    svgStr = c3Node.outerHTML;
    xml = $.parseXML(svgStr);
    svgNode = xml.documentElement;
    svgNode.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svgNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
    styleNode = xml.createElement("style");
    styleNode.setAttribute("type", "text/css");
    css = getC3Css();
    css += "svg { font-style: normal; font-variant: normal; font-weight: normal; font-stretch: normal; font-size: 10px; line-height: normal; font-family: sans-serif; -webkit-tap-highlight-color: transparent; }\n";
    css += "path, line { fill: none; stroke: rgb(0, 0, 0); }\n";
    css += "text { user-select: none; }\n";
    cdata = xml.createCDATASection(css);
    styleNode.appendChild(cdata);
    svgNode.insertBefore(styleNode, svgNode.firstChild);
    svgFinalStr = new XMLSerializer().serializeToString(xml);
    return svgFinalStr;
  };
})(this);

saveSvgToFile = function(containerDiv, title) {
  var blob, filesaver, svgFinalStr;
  svgFinalStr = getC3String(containerDiv.firstChild);
  blob = new Blob([svgFinalStr], {
    type: "image/svg+xml"
  });
  filesaver = require('filesaver.js');
  return filesaver(blob, (title || "unnamed-chart") + ".svg");
};

module.exports = {
  save: function(design, data, schema, format) {
    var chart, chartOptions, compiler, containerDiv, onRender, props, title;
    compiler = new LayeredChartCompiler({
      schema: schema
    });
    props = {
      design: design,
      data: data,
      width: 600,
      height: 600
    };
    chartOptions = compiler.createChartOptions(props);
    containerDiv = document.createElement("div");
    containerDiv.className += "c3";
    chartOptions.bindto = containerDiv;
    title = design.titleText;
    chart = null;
    onRender = (function(_this) {
      return function() {
        return _.defer(function() {
          var el;
          if (format === "svg") {
            saveSvgToFile(containerDiv, title);
          } else if (format === "png") {
            el = $(containerDiv).find("svg")[0];
            el.style.fontFamily = "sans-serif";
            el.style.fontStyle = "normal";
            el.style.fontVariant = "normal";
            el.style.fontWeight = "normal";
            el.style.fontStretch = "normal";
            el.style.fontSize = "10px";
            el.style.lineHeight = "normal";
            saveSvgAsPng.saveSvgAsPng(el, (title || "untitled") + ".png", {
              selectorRemap: function(selector) {
                if (selector === ".c3 path, .c3 line") {
                  return "path, line";
                }
                if (selector.indexOf(".c3 ") === 0) {
                  return selector.substr(4);
                } else {
                  return selector;
                }
              },
              backgroundColor: "#fff"
            });
          }
          return chart.destroy();
        });
      };
    })(this);
    chartOptions.onrendered = _.debounce(_.once(onRender), 1000);
    return chart = c3.generate(chartOptions);
  }
};


},{"./LayeredChartCompiler":1141,"filesaver.js":275,"save-svg-as-png":997}],1145:[function(require,module,exports){
exports.getAxisTypes = function(design, layer, axis) {
  var layerType;
  layerType = layer.type || design.type;
  switch (axis) {
    case "x":
      if (layerType === 'bar') {
        return ['enum', 'enumset', 'text', 'date', 'boolean'];
      }
      return ['enum', 'text', 'number', 'boolean', 'date'];
    case "color":
      return ['enum', 'text', 'date', 'boolean'];
    case "y":
      return ['number'];
  }
};


},{}],1146:[function(require,module,exports){
var C3ChartComponent, ExprUtils, H, LayeredChartCompiler, LayeredChartViewComponent, R, React, ReactDOM, TextComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

ReactDOM = require('react-dom');

R = React.createElement;

H = React.DOM;

ExprUtils = require('mwater-expressions').ExprUtils;

LayeredChartCompiler = require('./LayeredChartCompiler');

TextComponent = require('../../text/TextComponent');

module.exports = LayeredChartViewComponent = (function(superClass) {
  extend(LayeredChartViewComponent, superClass);

  LayeredChartViewComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    standardWidth: React.PropTypes.number.isRequired,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func
  };

  LayeredChartViewComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function LayeredChartViewComponent() {
    this.handleFooterChange = bind(this.handleFooterChange, this);
    this.handleHeaderChange = bind(this.handleHeaderChange, this);
    LayeredChartViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      headerHeight: null,
      footerHeight: null
    };
  }

  LayeredChartViewComponent.prototype.componentDidMount = function() {
    return this.updateHeights();
  };

  LayeredChartViewComponent.prototype.componentDidUpdate = function() {
    return this.updateHeights();
  };

  LayeredChartViewComponent.prototype.updateHeights = function() {
    if (this.refs.header && this.state.headerHeight !== this.refs.header.offsetHeight) {
      this.setState({
        headerHeight: this.refs.header.offsetHeight
      });
    }
    if (this.refs.footer && this.state.footerHeight !== this.refs.footer.offsetHeight) {
      return this.setState({
        footerHeight: this.refs.footer.offsetHeight
      });
    }
  };

  LayeredChartViewComponent.prototype.handleHeaderChange = function(header) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      header: header
    }));
  };

  LayeredChartViewComponent.prototype.handleFooterChange = function(footer) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      footer: footer
    }));
  };

  LayeredChartViewComponent.prototype.renderHeader = function() {
    return H.div({
      ref: "header"
    }, R(TextComponent, {
      design: this.props.design.header,
      onDesignChange: this.props.onDesignChange ? this.handleHeaderChange : void 0,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprValues: this.props.data.header || {},
      width: this.props.width,
      standardWidth: this.props.standardWidth
    }));
  };

  LayeredChartViewComponent.prototype.renderFooter = function() {
    return H.div({
      ref: "footer"
    }, R(TextComponent, {
      design: this.props.design.footer,
      onDesignChange: this.props.onDesignChange ? this.handleFooterChange : void 0,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprValues: this.props.data.footer || {},
      width: this.props.width,
      standardWidth: this.props.standardWidth
    }));
  };

  LayeredChartViewComponent.prototype.render = function() {
    return H.div({
      style: {
        width: this.props.width,
        height: this.props.height
      }
    }, this.renderHeader(), (this.state.headerHeight != null) && (this.state.footerHeight != null) ? R(C3ChartComponent, {
      schema: this.props.schema,
      design: this.props.design,
      data: this.props.data,
      onDesignChange: this.props.onDesignChange,
      width: this.props.width,
      height: this.props.height - this.state.headerHeight - this.state.footerHeight,
      standardWidth: this.props.standardWidth,
      scope: this.props.scope,
      onScopeChange: this.props.onScopeChange
    }) : void 0, this.renderFooter());
  };

  return LayeredChartViewComponent;

})(React.Component);

C3ChartComponent = (function(superClass) {
  extend(C3ChartComponent, superClass);

  C3ChartComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    standardWidth: React.PropTypes.number.isRequired,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func
  };

  C3ChartComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function C3ChartComponent() {
    this.handleDataClick = bind(this.handleDataClick, this);
    this.updateScope = bind(this.updateScope, this);
    this.createChart = bind(this.createChart, this);
    C3ChartComponent.__super__.constructor.apply(this, arguments);
    this.throttledCreateChart = _.throttle(this.createChart, 1000);
  }

  C3ChartComponent.prototype.componentDidMount = function() {
    this.createChart(this.props);
    return this.updateScope();
  };

  C3ChartComponent.prototype.createChart = function(props) {
    var chartOptions, compiler, el;
    if (this.chart) {
      this.chart.destroy();
    }
    compiler = new LayeredChartCompiler({
      schema: props.schema
    });
    el = ReactDOM.findDOMNode(this.refs.chart);
    chartOptions = compiler.createChartOptions({
      design: this.props.design,
      data: this.props.data,
      width: this.props.width,
      height: this.props.height,
      locale: this.context.locale
    });
    chartOptions.bindto = el;
    chartOptions.data.onclick = this.handleDataClick;
    chartOptions.onrendered = (function(_this) {
      return function() {
        return _.defer(_this.updateScope);
      };
    })(this);
    return this.chart = c3.generate(chartOptions);
  };

  C3ChartComponent.prototype.componentDidUpdate = function(prevProps, prevState, prevContext) {
    var newChartOptions, newCompiler, oldChartOptions, oldCompiler;
    oldCompiler = new LayeredChartCompiler({
      schema: prevProps.schema
    });
    newCompiler = new LayeredChartCompiler({
      schema: this.props.schema
    });
    oldChartOptions = oldCompiler.createChartOptions({
      design: prevProps.design,
      data: prevProps.data,
      width: prevProps.width,
      height: prevProps.height,
      locale: prevContext.locale
    });
    newChartOptions = newCompiler.createChartOptions({
      design: this.props.design,
      data: this.props.data,
      width: this.props.width,
      height: this.props.height,
      locale: this.context.locale
    });
    if (!_.isEqual(oldChartOptions, newChartOptions) || this.context.locale !== prevContext.locale) {
      if (_.isEqual(_.omit(oldChartOptions, "size"), _.omit(newChartOptions, "size")) && this.context.locale === prevContext.locale) {
        this.chart.resize({
          width: this.props.width,
          height: this.props.height
        });
        this.updateScope();
        return;
      }
      return this.throttledCreateChart(this.props);
    } else {
      if (!_.isEqual(this.props.scope, prevProps.scope)) {
        return this.updateScope();
      }
    }
  };

  C3ChartComponent.prototype.updateScope = function() {
    var compiler, dataMap, el;
    dataMap = this.getDataMap();
    compiler = new LayeredChartCompiler({
      schema: this.props.schema
    });
    el = ReactDOM.findDOMNode(this.refs.chart);
    d3.select(el).selectAll(".c3-chart-bar .c3-bar, .c3-chart-line .c3-circle").style("opacity", (function(_this) {
      return function(d, i) {
        var dataPoint, scope;
        dataPoint = _this.lookupDataPoint(dataMap, d);
        if (dataPoint) {
          scope = compiler.createScope(_this.props.design, dataPoint.layerIndex, dataPoint.row, _this.context.locale);
        }
        if (scope && _this.props.scope) {
          if (_.isEqual(_this.props.scope.data, scope.data)) {
            return 1;
          } else {
            return 0.3;
          }
        } else {
          return 1;
        }
      };
    })(this));
    return d3.select(el).selectAll(".c3-chart-arcs .c3-chart-arc").style("opacity", (function(_this) {
      return function(d, i) {
        var dataPoint, scope;
        dataPoint = _this.lookupDataPoint(dataMap, d);
        if (dataPoint) {
          scope = compiler.createScope(_this.props.design, dataPoint.layerIndex, dataPoint.row, _this.context.locale);
        }
        if (_this.props.scope) {
          if (_.isEqual(_this.props.scope.data, scope.data)) {
            return 1;
          } else {
            return 0.3;
          }
        } else {
          return 1;
        }
      };
    })(this));
  };

  C3ChartComponent.prototype.lookupDataPoint = function(dataMap, d) {
    var dataPoint, isPolarChart, ref;
    if (d.data) {
      d = d.data;
    }
    isPolarChart = (ref = this.props.design.type) === 'pie' || ref === 'donut';
    if (isPolarChart) {
      dataPoint = dataMap["" + d.id];
    } else {
      dataPoint = dataMap[d.id + ":" + d.index];
    }
    return dataPoint;
  };

  C3ChartComponent.prototype.getDataMap = function() {
    var compiler;
    compiler = new LayeredChartCompiler({
      schema: this.props.schema
    });
    return compiler.createDataMap(this.props.design, this.props.data);
  };

  C3ChartComponent.prototype.handleDataClick = function(d) {
    var base, base1, compiler, dataMap, dataPoint, scope;
    dataMap = this.getDataMap();
    dataPoint = this.lookupDataPoint(dataMap, d);
    if (!dataPoint) {
      return;
    }
    compiler = new LayeredChartCompiler({
      schema: this.props.schema
    });
    scope = compiler.createScope(this.props.design, dataPoint.layerIndex, dataPoint.row, this.context.locale);
    if (this.props.scope && _.isEqual(scope.data, this.props.scope.data)) {
      if (typeof (base = this.props).onScopeChange === "function") {
        base.onScopeChange(null);
      }
      return;
    }
    return typeof (base1 = this.props).onScopeChange === "function" ? base1.onScopeChange(scope) : void 0;
  };

  C3ChartComponent.prototype.componentWillUnmount = function() {
    return this.chart.destroy();
  };

  C3ChartComponent.prototype.render = function() {
    var css, scale;
    scale = this.props.width / this.props.standardWidth;
    scale = Math.min(scale, 1);
    css = ".c3 svg { font-size: " + (scale * 10) + "px; }\n";
    css += ".c3-legend-item { font-size: " + (scale * 12) + "px; }\n";
    css += ".c3-chart-arc text { font-size: " + (scale * 13) + "px; }\n";
    css += ".c3-title { font-size: " + (scale * 14) + "px; }\n";
    return H.div(null, H.style(null, css), H.div({
      ref: "chart"
    }));
  };

  return C3ChartComponent;

})(React.Component);


},{"../../text/TextComponent":1163,"./LayeredChartCompiler":1141,"lodash":"lodash","mwater-expressions":14,"react":"react","react-dom":"react-dom"}],1147:[function(require,module,exports){
var AxisComponent, BackgroundColorConditionComponent, BackgroundColorConditionsComponent, ColorComponent, ExprComponent, FilterExprComponent, H, IntersectionDesignerComponent, R, Rcslider, React, _, ui, update,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ui = require('react-library/lib/bootstrap');

update = require('react-library/lib/update');

Rcslider = require('rc-slider');

AxisComponent = require('../../../axes/AxisComponent');

ColorComponent = require('../../../ColorComponent');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

module.exports = IntersectionDesignerComponent = (function(superClass) {
  extend(IntersectionDesignerComponent, superClass);

  function IntersectionDesignerComponent() {
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleBackgroundColorOpacityChange = bind(this.handleBackgroundColorOpacityChange, this);
    this.handleBackgroundColorConditionsChange = bind(this.handleBackgroundColorConditionsChange, this);
    this.handleBackgroundColorChange = bind(this.handleBackgroundColorChange, this);
    this.handleBackgroundColorAxisChange = bind(this.handleBackgroundColorAxisChange, this);
    this.update = bind(this.update, this);
    return IntersectionDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  IntersectionDesignerComponent.propTypes = {
    intersection: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  IntersectionDesignerComponent.prototype.update = function() {
    return update(this.props.intersection, this.props.onChange, arguments);
  };

  IntersectionDesignerComponent.prototype.handleBackgroundColorAxisChange = function(backgroundColorAxis) {
    var opacity;
    opacity = this.props.intersection.backgroundColorOpacity || 1;
    return this.update({
      backgroundColorAxis: backgroundColorAxis,
      backgroundColorOpacity: opacity
    });
  };

  IntersectionDesignerComponent.prototype.handleBackgroundColorChange = function(backgroundColor) {
    var opacity;
    opacity = this.props.intersection.backgroundColorOpacity || 1;
    return this.update({
      backgroundColor: backgroundColor,
      backgroundColorOpacity: opacity
    });
  };

  IntersectionDesignerComponent.prototype.handleBackgroundColorConditionsChange = function(backgroundColorConditions) {
    var opacity;
    opacity = this.props.intersection.backgroundColorOpacity || 1;
    return this.update({
      backgroundColorConditions: backgroundColorConditions,
      backgroundColorOpacity: opacity
    });
  };

  IntersectionDesignerComponent.prototype.handleBackgroundColorOpacityChange = function(newValue) {
    return this.update({
      backgroundColorOpacity: newValue / 100
    });
  };

  IntersectionDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.update({
      filter: filter
    });
  };

  IntersectionDesignerComponent.prototype.renderValueAxis = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Calculation",
      help: "This is the calculated value that is displayed. Leave as blank to make an empty section"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ["enum", "text", "boolean", "date", "number"],
      aggrNeed: "required",
      value: this.props.intersection.valueAxis,
      onChange: this.update("valueAxis"),
      showFormat: true
    }));
  };

  IntersectionDesignerComponent.prototype.renderNullValue = function() {
    if (this.props.intersection.valueAxis) {
      return R(ui.FormGroup, {
        labelMuted: true,
        label: "Show Empty Cells as"
      }, R(ui.TextInput, {
        value: this.props.intersection.valueAxis.nullLabel,
        emptyNull: true,
        onChange: this.update("valueAxis.nullLabel"),
        placeholder: "Blank"
      }));
    }
  };

  IntersectionDesignerComponent.prototype.renderFilter = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: [
        R(ui.Icon, {
          id: "glyphicon-filter"
        }), " Filters"
      ]
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.table,
      value: this.props.intersection.filter
    }));
  };

  IntersectionDesignerComponent.prototype.renderStyling = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      key: "styling",
      label: "Styling"
    }, R(ui.Checkbox, {
      key: "bold",
      inline: true,
      value: this.props.intersection.bold,
      onChange: this.update("bold")
    }, "Bold"), R(ui.Checkbox, {
      key: "italic",
      inline: true,
      value: this.props.intersection.italic,
      onChange: this.update("italic")
    }, "Italic"));
  };

  IntersectionDesignerComponent.prototype.renderBackgroundColorConditions = function() {
    return R(BackgroundColorConditionsComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      colorConditions: this.props.intersection.backgroundColorConditions,
      onChange: this.handleBackgroundColorConditionsChange
    });
  };

  IntersectionDesignerComponent.prototype.renderBackgroundColorAxis = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Background Color From Values",
      help: "This is an optional background color to set on cells that is controlled by the data"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ["enum", "text", "boolean", "date"],
      aggrNeed: "required",
      value: this.props.intersection.backgroundColorAxis,
      onChange: this.handleBackgroundColorAxisChange,
      showColorMap: true
    }));
  };

  IntersectionDesignerComponent.prototype.renderBackgroundColor = function() {
    if (this.props.intersection.backgroundColorAxis) {
      return;
    }
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Background Color",
      help: "This is an optional background color to set on all cells"
    }, R(ColorComponent, {
      color: this.props.intersection.backgroundColor,
      onChange: this.handleBackgroundColorChange
    }));
  };

  IntersectionDesignerComponent.prototype.renderBackgroundColorOpacityControl = function() {
    var ref;
    if (!this.props.intersection.backgroundColorAxis && !this.props.intersection.backgroundColor && !((ref = this.props.intersection.backgroundColorConditions) != null ? ref[0] : void 0)) {
      return;
    }
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Background Opacity: " + (Math.round(this.props.intersection.backgroundColorOpacity * 100)) + "%"
    }, R(Rcslider, {
      min: 0,
      max: 100,
      step: 1,
      tipTransitionName: "rc-slider-tooltip-zoom-down",
      value: this.props.intersection.backgroundColorOpacity * 100,
      onChange: this.handleBackgroundColorOpacityChange
    }));
  };

  IntersectionDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderValueAxis(), this.renderNullValue(), this.renderFilter(), this.renderStyling(), this.renderBackgroundColorAxis(), this.renderBackgroundColorConditions(), this.renderBackgroundColor(), this.renderBackgroundColorOpacityControl());
  };

  return IntersectionDesignerComponent;

})(React.Component);

BackgroundColorConditionsComponent = (function(superClass) {
  extend(BackgroundColorConditionsComponent, superClass);

  function BackgroundColorConditionsComponent() {
    this.handleRemove = bind(this.handleRemove, this);
    this.handleChange = bind(this.handleChange, this);
    this.handleAdd = bind(this.handleAdd, this);
    return BackgroundColorConditionsComponent.__super__.constructor.apply(this, arguments);
  }

  BackgroundColorConditionsComponent.propTypes = {
    colorConditions: React.PropTypes.array,
    table: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  BackgroundColorConditionsComponent.prototype.handleAdd = function() {
    var colorConditions;
    colorConditions = (this.props.colorConditions || []).slice();
    colorConditions.push({});
    return this.props.onChange(colorConditions);
  };

  BackgroundColorConditionsComponent.prototype.handleChange = function(index, colorCondition) {
    var colorConditions;
    colorConditions = this.props.colorConditions.slice();
    colorConditions[index] = colorCondition;
    return this.props.onChange(colorConditions);
  };

  BackgroundColorConditionsComponent.prototype.handleRemove = function(index) {
    var colorConditions;
    colorConditions = this.props.colorConditions.slice();
    colorConditions.splice(index, 1);
    return this.props.onChange(colorConditions);
  };

  BackgroundColorConditionsComponent.prototype.render = function() {
    return R(ui.FormGroup, {
      label: "Color Conditions",
      labelMuted: true,
      help: "Add conditions that, if met, set the color of the cell. Useful for flagging certain values"
    }, _.map(this.props.colorConditions, (function(_this) {
      return function(colorCondition, i) {
        return R(BackgroundColorConditionComponent, {
          key: i,
          colorCondition: colorCondition,
          table: _this.props.table,
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          onChange: _this.handleChange.bind(null, i),
          onRemove: _this.handleRemove.bind(null, i)
        });
      };
    })(this)), R(ui.Button, {
      type: "link",
      size: "sm",
      onClick: this.handleAdd
    }, R(ui.Icon, {
      id: "fa-plus"
    }), " Add Condition"));
  };

  return BackgroundColorConditionsComponent;

})(React.Component);

BackgroundColorConditionComponent = (function(superClass) {
  extend(BackgroundColorConditionComponent, superClass);

  function BackgroundColorConditionComponent() {
    this.update = bind(this.update, this);
    return BackgroundColorConditionComponent.__super__.constructor.apply(this, arguments);
  }

  BackgroundColorConditionComponent.propTypes = {
    colorCondition: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  BackgroundColorConditionComponent.prototype.update = function() {
    return update(this.props.colorCondition, this.props.onChange, arguments);
  };

  BackgroundColorConditionComponent.prototype.render = function() {
    return H.div({
      className: "panel panel-default"
    }, H.div({
      className: "panel-body"
    }, R(ui.FormGroup, {
      labelMuted: true,
      label: "Condition"
    }, R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.update("condition"),
      types: ['boolean'],
      aggrStatuses: ["aggregate", "literal"],
      table: this.props.table,
      value: this.props.colorCondition.condition
    })), R(ui.FormGroup, {
      labelMuted: true,
      label: "Color",
      hint: "Color to display when condition is met"
    }, R(ColorComponent, {
      color: this.props.colorCondition.color,
      onChange: this.update("color")
    }))));
  };

  return BackgroundColorConditionComponent;

})(React.Component);


},{"../../../ColorComponent":1016,"../../../axes/AxisComponent":1031,"lodash":"lodash","mwater-expressions-ui":362,"rc-slider":416,"react":"react","react-library/lib/bootstrap":793,"react-library/lib/update":797}],1148:[function(require,module,exports){
var AxisBuilder, Chart, ExprCleaner, H, PivotChart, PivotChartLayoutBuilder, PivotChartQueryBuilder, PivotChartUtils, React, TextWidget, _, async, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

async = require('async');

uuid = require('uuid');

Chart = require('../Chart');

ExprCleaner = require('mwater-expressions').ExprCleaner;

AxisBuilder = require('../../../axes/AxisBuilder');

TextWidget = require('../../text/TextWidget');

PivotChartUtils = require('./PivotChartUtils');

PivotChartQueryBuilder = require('./PivotChartQueryBuilder');

PivotChartLayoutBuilder = require('./PivotChartLayoutBuilder');

module.exports = PivotChart = (function(superClass) {
  extend(PivotChart, superClass);

  function PivotChart() {
    return PivotChart.__super__.constructor.apply(this, arguments);
  }

  PivotChart.prototype.cleanDesign = function(design, schema) {
    var axisBuilder, cleanSegment, columnPath, exprCleaner, i, intersection, intersectionId, intersections, j, k, l, len, len1, len2, len3, ref, ref1, ref2, ref3, ref4, rowPath, segment;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.version = design.version || 1;
    design.rows = design.rows || [];
    design.columns = design.columns || [];
    design.intersections = design.intersections || {};
    design.header = design.header || {
      style: "footer",
      items: []
    };
    design.footer = design.footer || {
      style: "footer",
      items: []
    };
    if (design.table) {
      if (design.rows.length === 0) {
        design.rows.push({
          id: uuid()
        });
      }
      if (design.columns.length === 0) {
        design.columns.push({
          id: uuid()
        });
      }
      cleanSegment = (function(_this) {
        return function(segment) {
          if (segment.valueAxis) {
            segment.valueAxis = axisBuilder.cleanAxis({
              axis: segment.valueAxis,
              table: design.table,
              aggrNeed: "none",
              types: ["enum", "text", "boolean", "date"]
            });
          }
          if (!segment.valueAxis) {
            return delete segment.valueLabelBold;
          }
        };
      })(this);
      ref = PivotChartUtils.getAllSegments(design.rows);
      for (i = 0, len = ref.length; i < len; i++) {
        segment = ref[i];
        cleanSegment(segment);
      }
      ref1 = PivotChartUtils.getAllSegments(design.columns);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        segment = ref1[j];
        cleanSegment(segment);
      }
      ref2 = design.intersections;
      for (intersectionId in ref2) {
        intersection = ref2[intersectionId];
        if (intersection.valueAxis) {
          intersection.valueAxis = axisBuilder.cleanAxis({
            axis: intersection.valueAxis,
            table: design.table,
            aggrNeed: "required",
            types: ["enum", "text", "boolean", "date", "number"]
          });
        }
        if (intersection.backgroundColorAxis) {
          intersection.backgroundColorAxis = axisBuilder.cleanAxis({
            axis: intersection.backgroundColorAxis,
            table: design.table,
            aggrNeed: "required",
            types: ["enum", "text", "boolean", "date"]
          });
          if (intersection.backgroundColorOpacity == null) {
            intersection.backgroundColorOpacity = 1;
          }
        }
      }
      intersections = {};
      ref3 = PivotChartUtils.getSegmentPaths(design.rows);
      for (k = 0, len2 = ref3.length; k < len2; k++) {
        rowPath = ref3[k];
        ref4 = PivotChartUtils.getSegmentPaths(design.columns);
        for (l = 0, len3 = ref4.length; l < len3; l++) {
          columnPath = ref4[l];
          intersectionId = PivotChartUtils.getIntersectionId(rowPath, columnPath);
          intersections[intersectionId] = design.intersections[intersectionId] || {};
        }
      }
      design.intersections = intersections;
      design.filter = exprCleaner.cleanExpr(design.filter, {
        table: design.table,
        types: ['boolean']
      });
    }
    return design;
  };

  PivotChart.prototype.validateDesign = function(design, schema) {
    var axisBuilder, error, i, intersection, intersectionId, j, len, len1, ref, ref1, ref2, segment;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing data source";
    }
    if (design.rows.length === 0) {
      return "Missing rows";
    }
    if (design.columns.length === 0) {
      return "Missing columns";
    }
    error = null;
    ref = PivotChartUtils.getAllSegments(design.rows);
    for (i = 0, len = ref.length; i < len; i++) {
      segment = ref[i];
      if (segment.valueAxis) {
        error = error || axisBuilder.validateAxis({
          axis: segment.valueAxis
        });
      }
    }
    ref1 = PivotChartUtils.getAllSegments(design.columns);
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      segment = ref1[j];
      if (segment.valueAxis) {
        error = error || axisBuilder.validateAxis({
          axis: segment.valueAxis
        });
      }
    }
    ref2 = design.intersections;
    for (intersectionId in ref2) {
      intersection = ref2[intersectionId];
      if (intersection.valueAxis) {
        error = error || axisBuilder.validateAxis({
          axis: intersection.valueAxis
        });
      }
    }
    return error;
  };

  PivotChart.prototype.isAutoHeight = function() {
    return false;
  };

  PivotChart.prototype.isEmpty = function(design) {
    return !design.table || design.rows.length === 0 || design.columns.length === 0;
  };

  PivotChart.prototype.hasDesignerPreview = function() {
    return false;
  };

  PivotChart.prototype.getEditLabel = function() {
    return "Configure Table";
  };

  PivotChart.prototype.createDesignerElement = function(options) {
    var PivotChartDesignerComponent, props;
    PivotChartDesignerComponent = require('./PivotChartDesignerComponent');
    props = {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: (function(_this) {
        return function(design) {
          design = _this.cleanDesign(design, options.schema);
          return options.onDesignChange(design);
        };
      })(this)
    };
    return React.createElement(PivotChartDesignerComponent, props);
  };

  PivotChart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var queries, queryBuilder;
    queryBuilder = new PivotChartQueryBuilder({
      schema: schema
    });
    queries = queryBuilder.createQueries(design, filters);
    return async.map(_.pairs(queries), (function(_this) {
      return function(item, cb) {
        return dataSource.performQuery(item[1], function(err, rows) {
          return cb(err, [item[0], rows]);
        });
      };
    })(this), (function(_this) {
      return function(err, items) {
        var data, textWidget;
        if (err) {
          return callback(err);
        }
        data = _.object(items);
        textWidget = new TextWidget();
        return textWidget.getData(design.header, schema, dataSource, filters, function(error, headerData) {
          if (error) {
            return callback(error);
          }
          data.header = headerData;
          return textWidget.getData(design.footer, schema, dataSource, filters, function(error, footerData) {
            if (error) {
              return callback(error);
            }
            data.footer = footerData;
            return callback(null, data);
          });
        });
      };
    })(this));
  };

  PivotChart.prototype.createViewElement = function(options) {
    var PivotChartViewComponent, props;
    PivotChartViewComponent = require('./PivotChartViewComponent');
    props = {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      onDesignChange: options.onDesignChange,
      data: options.data,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      scope: options.scope,
      onScopeChange: options.onScopeChange
    };
    return React.createElement(PivotChartViewComponent, props);
  };

  PivotChart.prototype.createDropdownItems = function(design, schema, widgetDataSource, filters) {
    return [];
  };

  PivotChart.prototype.createDataTable = function(design, schema, dataSource, data, locale) {
    var layout;
    layout = new PivotChartLayoutBuilder({
      schema: schema
    }).buildLayout(design, data, locale);
    return _.map(layout.rows, function(row) {
      return _.map(row.cells, function(cell) {
        return cell.text;
      });
    });
  };

  PivotChart.prototype.getFilterableTables = function(design, schema) {
    var filterableTables, textWidget;
    filterableTables = design.table ? [design.table] : [];
    textWidget = new TextWidget();
    filterableTables = _.union(filterableTables, textWidget.getFilterableTables(design.header, schema));
    filterableTables = _.union(filterableTables, textWidget.getFilterableTables(design.footer, schema));
    return filterableTables;
  };

  return PivotChart;

})(Chart);


},{"../../../axes/AxisBuilder":1029,"../../text/TextWidget":1164,"../Chart":1131,"./PivotChartDesignerComponent":1149,"./PivotChartLayoutBuilder":1150,"./PivotChartQueryBuilder":1152,"./PivotChartUtils":1153,"./PivotChartViewComponent":1154,"async":29,"lodash":"lodash","mwater-expressions":14,"react":"react","uuid":1007}],1149:[function(require,module,exports){
var AxisComponent, FilterExprComponent, H, PivotChartDesignerComponent, R, React, TableSelectComponent, ui, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

ui = require('react-library/lib/bootstrap');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

TableSelectComponent = require('../../../TableSelectComponent');

AxisComponent = require('../../../axes/AxisComponent');

module.exports = PivotChartDesignerComponent = (function(superClass) {
  extend(PivotChartDesignerComponent, superClass);

  PivotChartDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  function PivotChartDesignerComponent(props) {
    this.handleIntersectionValueAxisChange = bind(this.handleIntersectionValueAxisChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleRowChange = bind(this.handleRowChange, this);
    this.handleColumnChange = bind(this.handleColumnChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    PivotChartDesignerComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      isNew: !props.design.table
    };
  }

  PivotChartDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  PivotChartDesignerComponent.prototype.handleTableChange = function(table) {
    var column, intersections, row;
    row = {
      id: uuid(),
      label: ""
    };
    column = {
      id: uuid(),
      label: ""
    };
    intersections = {};
    intersections[row.id + ":" + column.id] = {
      valueAxis: {
        expr: {
          type: "op",
          op: "count",
          table: table,
          exprs: []
        }
      }
    };
    return this.updateDesign({
      table: table,
      rows: [row],
      columns: [column],
      intersections: intersections
    });
  };

  PivotChartDesignerComponent.prototype.handleColumnChange = function(axis) {
    return this.updateDesign({
      columns: [
        _.extend({}, this.props.design.columns[0], {
          valueAxis: axis
        })
      ]
    });
  };

  PivotChartDesignerComponent.prototype.handleRowChange = function(axis) {
    return this.updateDesign({
      rows: [
        _.extend({}, this.props.design.rows[0], {
          valueAxis: axis
        })
      ]
    });
  };

  PivotChartDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.updateDesign({
      filter: filter
    });
  };

  PivotChartDesignerComponent.prototype.handleIntersectionValueAxisChange = function(valueAxis) {
    var intersectionId, intersections;
    intersectionId = this.props.design.rows[0].id + ":" + this.props.design.columns[0].id;
    intersections = {};
    intersections[intersectionId] = {
      valueAxis: valueAxis
    };
    return this.updateDesign({
      intersections: intersections
    });
  };

  PivotChartDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    }));
  };

  PivotChartDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " ", "Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  PivotChartDesignerComponent.prototype.renderStriping = function() {
    if (!this.props.design.table) {
      return null;
    }
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Striping"
    }, H.label({
      key: "none",
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: !this.props.design.striping,
      onClick: (function(_this) {
        return function() {
          return _this.updateDesign({
            striping: null
          });
        };
      })(this)
    }), "None"), H.label({
      key: "columns",
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: this.props.design.striping === "columns",
      onClick: (function(_this) {
        return function() {
          return _this.updateDesign({
            striping: "columns"
          });
        };
      })(this)
    }), "Columns"), H.label({
      key: "rows",
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: this.props.design.striping === "rows",
      onClick: (function(_this) {
        return function() {
          return _this.updateDesign({
            striping: "rows"
          });
        };
      })(this)
    }), "Rows"));
  };

  PivotChartDesignerComponent.prototype.renderSetup = function() {
    var intersectionId;
    intersectionId = this.props.design.rows[0].id + ":" + this.props.design.columns[0].id;
    return H.div(null, R(ui.FormGroup, {
      labelMuted: true,
      label: "Columns",
      help: "Field to optionally make columns out of"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["enum", "text", "boolean", "date"],
      aggrNeed: "none",
      value: this.props.design.columns[0].valueAxis,
      onChange: this.handleColumnChange
    })), R(ui.FormGroup, {
      labelMuted: true,
      label: "Rows",
      help: "Field to optionally make rows out of"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["enum", "text", "boolean", "date"],
      aggrNeed: "none",
      value: this.props.design.rows[0].valueAxis,
      onChange: this.handleRowChange
    })), R(ui.FormGroup, {
      labelMuted: true,
      label: "Value",
      help: "Field show in cells"
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      types: ["enum", "text", "boolean", "date", "number"],
      aggrNeed: "required",
      value: this.props.design.intersections[intersectionId].valueAxis,
      onChange: this.handleIntersectionValueAxisChange,
      showFormat: true
    })));
  };

  PivotChartDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.state.isNew && this.props.design.table ? this.renderSetup() : void 0, this.renderFilter(), this.renderStriping());
  };

  return PivotChartDesignerComponent;

})(React.Component);


},{"../../../TableSelectComponent":1025,"../../../axes/AxisComponent":1031,"mwater-expressions-ui":362,"react":"react","react-library/lib/bootstrap":793,"uuid":1007}],1150:[function(require,module,exports){
var AxisBuilder, Color, ExprUtils, PivotChartLayoutBuilder, PivotChartUtils, _,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

Color = require('color');

PivotChartUtils = require('./PivotChartUtils');

module.exports = PivotChartLayoutBuilder = (function() {
  function PivotChartLayoutBuilder(options) {
    this.schema = options.schema;
    this.exprUtils = new ExprUtils(this.schema);
    this.axisBuilder = new AxisBuilder({
      schema: this.schema
    });
  }

  PivotChartLayoutBuilder.prototype.buildLayout = function(design, data, locale) {
    var cell, cells, column, columnIndex, columns, columnsDepth, depth, i, i1, intersectionId, j, j1, k, k1, l, l1, layout, layoutRow, len, len1, len10, len2, len3, len4, len5, len6, len7, len8, len9, m, m1, n, n1, needsSpecialRowHeader, o, o1, p, q, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref21, ref22, ref23, ref24, ref25, ref26, ref27, ref28, ref29, ref3, ref30, ref31, ref32, ref33, ref34, ref35, ref36, ref37, ref38, ref39, ref4, ref40, ref41, ref42, ref43, ref44, ref45, ref46, ref47, ref48, ref49, ref5, ref50, ref51, ref52, ref53, ref54, ref55, ref56, ref57, ref58, ref59, ref6, ref60, ref61, ref62, ref7, ref8, ref9, refCell, row, rowIndex, rowSegments, rows, rowsDepth, s, segment, t, u, v, w, x, y, z;
    layout = {
      rows: [],
      striping: design.striping
    };
    columns = [];
    ref = design.columns;
    for (j = 0, len = ref.length; j < len; j++) {
      segment = ref[j];
      columns = columns.concat(this.getRowsOrColumns(false, segment, data, locale));
    }
    rows = [];
    ref1 = design.rows;
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      segment = ref1[k];
      rows = rows.concat(this.getRowsOrColumns(true, segment, data, locale));
    }
    rowsDepth = _.max(_.map(rows, function(row) {
      return row.length;
    }));
    columnsDepth = _.max(_.map(columns, function(column) {
      return column.length;
    }));
    for (depth = l = 0, ref2 = columnsDepth; 0 <= ref2 ? l < ref2 : l > ref2; depth = 0 <= ref2 ? ++l : --l) {
      if (_.any(columns, function(column) {
        return column[depth] && column[depth].segment.label && column[depth].segment.valueAxis;
      })) {
        cells = [];
        for (i = m = 1, ref3 = rowsDepth; 1 <= ref3 ? m <= ref3 : m >= ref3; i = 1 <= ref3 ? ++m : --m) {
          cells.push({
            type: "blank",
            text: null
          });
        }
        for (n = 0, len2 = columns.length; n < len2; n++) {
          column = columns[n];
          cells.push({
            type: "column",
            subtype: "valueLabel",
            segment: (ref4 = column[depth]) != null ? ref4.segment : void 0,
            section: (ref5 = column[depth]) != null ? ref5.segment.id : void 0,
            text: (ref6 = column[depth]) != null ? ref6.segment.label : void 0,
            align: "center",
            unconfigured: ((ref7 = column[depth]) != null ? ref7.segment : void 0) && (((ref8 = column[depth]) != null ? ref8.segment.label : void 0) == null) && !((ref9 = column[depth]) != null ? ref9.segment.valueAxis : void 0),
            bold: ((ref10 = column[depth]) != null ? ref10.segment.bold : void 0) || ((ref11 = column[depth]) != null ? ref11.segment.valueLabelBold : void 0),
            italic: (ref12 = column[depth]) != null ? ref12.segment.italic : void 0
          });
        }
        layout.rows.push({
          cells: cells
        });
      }
      cells = [];
      for (i = o = 1, ref13 = rowsDepth; 1 <= ref13 ? o <= ref13 : o >= ref13; i = 1 <= ref13 ? ++o : --o) {
        cells.push({
          type: "blank",
          text: null
        });
      }
      for (p = 0, len3 = columns.length; p < len3; p++) {
        column = columns[p];
        cells.push({
          type: "column",
          subtype: ((ref14 = column[depth]) != null ? (ref15 = ref14.segment) != null ? ref15.valueAxis : void 0 : void 0) ? "value" : "label",
          segment: (ref16 = column[depth]) != null ? ref16.segment : void 0,
          section: (ref17 = column[depth]) != null ? ref17.segment.id : void 0,
          text: (ref18 = column[depth]) != null ? ref18.label : void 0,
          align: "center",
          unconfigured: ((ref19 = column[depth]) != null ? ref19.segment : void 0) && (((ref20 = column[depth]) != null ? ref20.segment.label : void 0) == null) && !((ref21 = column[depth]) != null ? ref21.segment.valueAxis : void 0),
          bold: (ref22 = column[depth]) != null ? ref22.segment.bold : void 0,
          italic: (ref23 = column[depth]) != null ? ref23.segment.italic : void 0
        });
      }
      layout.rows.push({
        cells: cells
      });
    }
    rowSegments = [];
    for (q = 0, len4 = rows.length; q < len4; q++) {
      row = rows[q];
      needsSpecialRowHeader = [];
      for (depth = s = 0, ref24 = rowsDepth; 0 <= ref24 ? s < ref24 : s > ref24; depth = 0 <= ref24 ? ++s : --s) {
        if (row[depth] && rowSegments[depth] !== row[depth].segment && row[depth].segment.label && row[depth].segment.valueAxis) {
          needsSpecialRowHeader.push(true);
        } else {
          needsSpecialRowHeader.push(false);
        }
      }
      if (_.any(needsSpecialRowHeader)) {
        cells = [];
        for (depth = t = 0, ref25 = rowsDepth; 0 <= ref25 ? t < ref25 : t > ref25; depth = 0 <= ref25 ? ++t : --t) {
          if (needsSpecialRowHeader[depth]) {
            cells.push({
              type: "row",
              subtype: "valueLabel",
              segment: (ref26 = row[depth]) != null ? ref26.segment : void 0,
              section: (ref27 = row[depth]) != null ? ref27.segment.id : void 0,
              text: row[depth].segment.label,
              bold: ((ref28 = row[depth]) != null ? ref28.segment.bold : void 0) || ((ref29 = row[depth]) != null ? ref29.segment.valueLabelBold : void 0),
              italic: (ref30 = row[depth]) != null ? ref30.segment.italic : void 0
            });
          } else {
            cells.push({
              type: "row",
              subtype: "label",
              segment: (ref31 = row[depth]) != null ? ref31.segment : void 0,
              section: (ref32 = row[depth]) != null ? ref32.segment.id : void 0,
              text: null,
              unconfigured: ((ref33 = row[depth]) != null ? ref33.segment : void 0) && (((ref34 = row[depth]) != null ? ref34.segment.label : void 0) == null) && !((ref35 = row[depth]) != null ? ref35.segment.valueAxis : void 0),
              bold: (ref36 = row[depth]) != null ? ref36.segment.bold : void 0,
              italic: (ref37 = row[depth]) != null ? ref37.segment.italic : void 0
            });
          }
        }
        for (u = 0, len5 = columns.length; u < len5; u++) {
          column = columns[u];
          intersectionId = PivotChartUtils.getIntersectionId(_.map(row, function(r) {
            return r.segment;
          }), _.map(column, function(c) {
            return c.segment;
          }));
          cells.push({
            type: "intersection",
            subtype: "filler",
            section: intersectionId,
            text: null,
            backgroundColor: _.reduce(row, (function(total, r) {
              var ref38;
              return total || ((ref38 = r.segment) != null ? ref38.fillerColor : void 0) || null;
            }), null)
          });
        }
        layout.rows.push({
          cells: cells
        });
      }
      rowSegments = _.pluck(row, "segment");
      cells = [];
      for (depth = v = 0, ref38 = rowsDepth; 0 <= ref38 ? v < ref38 : v > ref38; depth = 0 <= ref38 ? ++v : --v) {
        cells.push({
          type: "row",
          subtype: ((ref39 = row[depth]) != null ? (ref40 = ref39.segment) != null ? ref40.valueAxis : void 0 : void 0) ? "value" : "label",
          segment: (ref41 = row[depth]) != null ? ref41.segment : void 0,
          section: (ref42 = row[depth]) != null ? ref42.segment.id : void 0,
          text: (ref43 = row[depth]) != null ? ref43.label : void 0,
          unconfigured: ((ref44 = row[depth]) != null ? ref44.segment : void 0) && (((ref45 = row[depth]) != null ? ref45.segment.label : void 0) == null) && !((ref46 = row[depth]) != null ? ref46.segment.valueAxis : void 0),
          bold: (ref47 = row[depth]) != null ? ref47.segment.bold : void 0,
          italic: (ref48 = row[depth]) != null ? ref48.segment.italic : void 0,
          indent: ((ref49 = row[depth]) != null ? (ref50 = ref49.segment) != null ? ref50.valueAxis : void 0 : void 0) && ((ref51 = row[depth]) != null ? (ref52 = ref51.segment) != null ? ref52.label : void 0 : void 0) ? 1 : void 0
        });
      }
      for (w = 0, len6 = columns.length; w < len6; w++) {
        column = columns[w];
        cells.push(this.buildIntersectionCell(design, data, locale, row, column));
      }
      layout.rows.push({
        cells: cells
      });
    }
    for (columnIndex = x = 0, ref53 = layout.rows[0].cells.length; 0 <= ref53 ? x < ref53 : x > ref53; columnIndex = 0 <= ref53 ? ++x : --x) {
      for (rowIndex = y = 0, ref54 = layout.rows.length; 0 <= ref54 ? y < ref54 : y > ref54; rowIndex = 0 <= ref54 ? ++y : --y) {
        cell = layout.rows[rowIndex].cells[columnIndex];
        cell.sectionTop = (cell.section != null) && (rowIndex === 0 || layout.rows[rowIndex - 1].cells[columnIndex].section !== cell.section);
        cell.sectionLeft = (cell.section != null) && (columnIndex === 0 || layout.rows[rowIndex].cells[columnIndex - 1].section !== cell.section);
        cell.sectionRight = (cell.section != null) && (columnIndex >= layout.rows[0].cells.length - 1 || layout.rows[rowIndex].cells[columnIndex + 1].section !== cell.section);
        cell.sectionBottom = (cell.section != null) && (rowIndex >= layout.rows.length - 1 || layout.rows[rowIndex + 1].cells[columnIndex].section !== cell.section);
      }
    }
    this.setupSummarize(design, layout);
    this.setupBorders(layout);
    ref55 = layout.rows;
    for (z = 0, len7 = ref55.length; z < len7; z++) {
      layoutRow = ref55[z];
      refCell = null;
      ref56 = layoutRow.cells;
      for (i = i1 = 0, len8 = ref56.length; i1 < len8; i = ++i1) {
        cell = ref56[i];
        if (i === 0) {
          refCell = cell;
          continue;
        }
        if (cell.type === 'column' && cell.text === refCell.text && cell.type === refCell.type && cell.section === refCell.section) {
          cell.skip = true;
          refCell.columnSpan = (refCell.columnSpan || 1) + 1;
          refCell.sectionRight = true;
          refCell.borderRight = cell.borderRight;
        } else {
          refCell = cell;
        }
      }
    }
    ref57 = layout.rows;
    for (j1 = 0, len9 = ref57.length; j1 < len9; j1++) {
      layoutRow = ref57[j1];
      refCell = null;
      ref58 = layoutRow.cells;
      for (i = k1 = 0, len10 = ref58.length; k1 < len10; i = ++k1) {
        cell = ref58[i];
        if (i === 0) {
          refCell = cell;
          continue;
        }
        if (cell.type === 'intersection' && cell.subtype === "filler" && cell.type === refCell.type && cell.subtype === refCell.subtype) {
          cell.skip = true;
          refCell.columnSpan = (refCell.columnSpan || 1) + 1;
          refCell.sectionRight = true;
          refCell.borderRight = cell.borderRight;
        } else {
          refCell = cell;
        }
      }
    }
    for (columnIndex = l1 = 0, ref59 = layout.rows[0].cells.length; 0 <= ref59 ? l1 < ref59 : l1 > ref59; columnIndex = 0 <= ref59 ? ++l1 : --l1) {
      refCell = null;
      for (rowIndex = m1 = 0, ref60 = layout.rows.length; 0 <= ref60 ? m1 < ref60 : m1 > ref60; rowIndex = 0 <= ref60 ? ++m1 : --m1) {
        cell = layout.rows[rowIndex].cells[columnIndex];
        if (rowIndex === 0) {
          refCell = cell;
          continue;
        }
        if (cell.type === 'row' && cell.text === refCell.text && cell.type === refCell.type && cell.section === refCell.section) {
          cell.skip = true;
          refCell.rowSpan = (refCell.rowSpan || 1) + 1;
          refCell.sectionBottom = true;
          refCell.borderBottom = cell.borderBottom;
        } else {
          refCell = cell;
        }
      }
    }
    for (columnIndex = n1 = 0, ref61 = layout.rows[0].cells.length; 0 <= ref61 ? n1 < ref61 : n1 > ref61; columnIndex = 0 <= ref61 ? ++n1 : --n1) {
      refCell = null;
      for (rowIndex = o1 = 0, ref62 = layout.rows.length; 0 <= ref62 ? o1 < ref62 : o1 > ref62; rowIndex = 0 <= ref62 ? ++o1 : --o1) {
        cell = layout.rows[rowIndex].cells[columnIndex];
        if (rowIndex === 0) {
          refCell = cell;
          continue;
        }
        if (cell.type === 'column' && cell.text === refCell.text && cell.type === refCell.type && cell.section === refCell.section) {
          cell.skip = true;
          refCell.rowSpan = (refCell.rowSpan || 1) + 1;
          refCell.sectionBottom = true;
          refCell.borderBottom = cell.borderBottom;
        } else {
          refCell = cell;
        }
      }
    }
    return layout;
  };

  PivotChartLayoutBuilder.prototype.buildIntersectionCell = function(design, data, locale, row, column) {
    var backgroundColor, backgroundColorCondition, cell, entry, i, intersection, intersectionData, intersectionId, j, len, ref, ref1, text, value;
    intersectionId = PivotChartUtils.getIntersectionId(_.map(row, function(r) {
      return r.segment;
    }), _.map(column, function(c) {
      return c.segment;
    }));
    intersection = design.intersections[intersectionId];
    if (!intersection) {
      return {
        type: "blank",
        text: null
      };
    }
    intersectionData = data[intersectionId];
    entry = _.find(intersectionData, function(e) {
      var i, j, k, len, len1, part;
      for (i = j = 0, len = row.length; j < len; i = ++j) {
        part = row[i];
        if (e["r" + i] !== part.value) {
          return false;
        }
      }
      for (i = k = 0, len1 = column.length; k < len1; i = ++k) {
        part = column[i];
        if (e["c" + i] !== part.value) {
          return false;
        }
      }
      return true;
    });
    value = entry != null ? entry.value : void 0;
    if (value != null) {
      text = this.axisBuilder.formatValue(intersection.valueAxis, value, locale);
    } else {
      text = ((ref = intersection.valueAxis) != null ? ref.nullLabel : void 0) || null;
    }
    cell = {
      type: "intersection",
      subtype: "value",
      section: intersectionId,
      text: text,
      align: "right",
      bold: intersection.bold,
      italic: intersection.italic
    };
    backgroundColor = null;
    ref1 = intersection.backgroundColorConditions || [];
    for (i = j = 0, len = ref1.length; j < len; i = ++j) {
      backgroundColorCondition = ref1[i];
      if (entry != null ? entry["bcc" + i] : void 0) {
        backgroundColor = backgroundColorCondition.color;
      }
    }
    if (!backgroundColor && intersection.backgroundColorAxis && ((entry != null ? entry.bc : void 0) != null)) {
      backgroundColor = this.axisBuilder.getValueColor(intersection.backgroundColorAxis, entry != null ? entry.bc : void 0);
    }
    if (!backgroundColor && intersection.backgroundColor && !intersection.colorAxis) {
      backgroundColor = intersection.backgroundColor;
    }
    if (backgroundColor) {
      backgroundColor = Color(backgroundColor).alpha(intersection.backgroundColorOpacity).string();
      cell.backgroundColor = backgroundColor;
    }
    return cell;
  };

  PivotChartLayoutBuilder.prototype.setupSummarize = function(design, layout) {
    var cell, columnIndex, j, ref, results1, rowIndex;
    results1 = [];
    for (columnIndex = j = 0, ref = layout.rows[0].cells.length; 0 <= ref ? j < ref : j > ref; columnIndex = 0 <= ref ? ++j : --j) {
      results1.push((function() {
        var k, ref1, results2;
        results2 = [];
        for (rowIndex = k = 0, ref1 = layout.rows.length; 0 <= ref1 ? k < ref1 : k > ref1; rowIndex = 0 <= ref1 ? ++k : --k) {
          cell = layout.rows[rowIndex].cells[columnIndex];
          if (cell.unconfigured && cell.type === "row") {
            cell.summarize = PivotChartUtils.canSummarizeSegment(design.rows, cell.section);
          }
          if (cell.unconfigured && cell.type === "column") {
            results2.push(cell.summarize = PivotChartUtils.canSummarizeSegment(design.columns, cell.section));
          } else {
            results2.push(void 0);
          }
        }
        return results2;
      })());
    }
    return results1;
  };

  PivotChartLayoutBuilder.prototype.setupBorders = function(layout) {
    var borderBottoms, borderLefts, borderRights, borderTops, cell, columnIndex, j, k, l, m, n, ref, ref1, ref10, ref11, ref12, ref13, ref14, ref15, ref16, ref17, ref18, ref19, ref2, ref20, ref3, ref4, ref5, ref6, ref7, ref8, ref9, results1, rowIndex;
    borderTops = [];
    borderBottoms = [];
    borderLefts = [];
    borderRights = [];
    for (columnIndex = j = 0, ref = layout.rows[0].cells.length; 0 <= ref ? j < ref : j > ref; columnIndex = 0 <= ref ? ++j : --j) {
      for (rowIndex = k = 0, ref1 = layout.rows.length; 0 <= ref1 ? k < ref1 : k > ref1; rowIndex = 0 <= ref1 ? ++k : --k) {
        cell = layout.rows[rowIndex].cells[columnIndex];
        if (cell.type === "row") {
          cell.borderLeft = 2;
          cell.borderRight = 2;
          if (cell.sectionTop) {
            if (((ref2 = cell.segment) != null ? ref2.borderBefore : void 0) != null) {
              cell.borderTop = (ref3 = cell.segment) != null ? ref3.borderBefore : void 0;
            } else {
              cell.borderTop = 2;
            }
          } else if (rowIndex > 0 && layout.rows[rowIndex - 1].cells[columnIndex].text !== cell.text) {
            if (((ref4 = cell.segment) != null ? ref4.borderWithin : void 0) != null) {
              cell.borderTop = (ref5 = cell.segment) != null ? ref5.borderWithin : void 0;
            } else {
              cell.borderTop = 1;
            }
          } else {
            cell.borderTop = 0;
          }
          if (cell.sectionBottom) {
            if (((ref6 = cell.segment) != null ? ref6.borderAfter : void 0) != null) {
              cell.borderBottom = (ref7 = cell.segment) != null ? ref7.borderAfter : void 0;
            } else {
              cell.borderBottom = 2;
            }
          } else if (rowIndex < layout.rows.length - 1 && layout.rows[rowIndex + 1].cells[columnIndex].text !== cell.text) {
            if (((ref8 = cell.segment) != null ? ref8.borderWithin : void 0) != null) {
              cell.borderBottom = (ref9 = cell.segment) != null ? ref9.borderWithin : void 0;
            } else {
              cell.borderBottom = 1;
            }
          } else {
            cell.borderBottom = 0;
          }
          borderTops[rowIndex] = Math.max(borderTops[rowIndex] || 0, cell.borderTop);
          borderBottoms[rowIndex] = Math.max(borderBottoms[rowIndex] || 0, cell.borderBottom);
        }
        if (cell.type === "column") {
          cell.borderTop = 2;
          cell.borderBottom = 2;
          if (cell.sectionLeft) {
            if (((ref10 = cell.segment) != null ? ref10.borderBefore : void 0) != null) {
              cell.borderLeft = (ref11 = cell.segment) != null ? ref11.borderBefore : void 0;
            } else {
              cell.borderLeft = 2;
            }
          } else if (columnIndex > 0 && layout.rows[rowIndex].cells[columnIndex - 1].text !== cell.text) {
            if (((ref12 = cell.segment) != null ? ref12.borderWithin : void 0) != null) {
              cell.borderLeft = (ref13 = cell.segment) != null ? ref13.borderWithin : void 0;
            } else {
              cell.borderLeft = 1;
            }
          } else {
            cell.borderLeft = 0;
          }
          if (cell.sectionRight) {
            if (((ref14 = cell.segment) != null ? ref14.borderAfter : void 0) != null) {
              cell.borderRight = (ref15 = cell.segment) != null ? ref15.borderAfter : void 0;
            } else {
              cell.borderRight = 2;
            }
          } else if (columnIndex < layout.rows[rowIndex].cells.length - 1 && layout.rows[rowIndex].cells[columnIndex + 1].text !== cell.text) {
            if (((ref16 = cell.segment) != null ? ref16.borderWithin : void 0) != null) {
              cell.borderRight = (ref17 = cell.segment) != null ? ref17.borderWithin : void 0;
            } else {
              cell.borderRight = 1;
            }
          } else {
            cell.borderRight = 0;
          }
          borderLefts[columnIndex] = Math.max(borderLefts[columnIndex] || 0, cell.borderLeft);
          borderRights[columnIndex] = Math.max(borderRights[columnIndex] || 0, cell.borderRight);
        }
      }
    }
    for (columnIndex = l = 1, ref18 = layout.rows[0].cells.length; 1 <= ref18 ? l < ref18 : l > ref18; columnIndex = 1 <= ref18 ? ++l : --l) {
      for (rowIndex = m = 1, ref19 = layout.rows.length; 1 <= ref19 ? m < ref19 : m > ref19; rowIndex = 1 <= ref19 ? ++m : --m) {
        cell = layout.rows[rowIndex].cells[columnIndex];
        if (cell.type === "row") {
          cell.borderTop = Math.max(layout.rows[rowIndex].cells[columnIndex - 1].borderTop, cell.borderTop);
          cell.borderBottom = Math.max(layout.rows[rowIndex].cells[columnIndex - 1].borderBottom, cell.borderBottom);
        }
        if (cell.type === "column") {
          cell.borderLeft = Math.max(layout.rows[rowIndex - 1].cells[columnIndex].borderLeft, cell.borderLeft);
          cell.borderRight = Math.max(layout.rows[rowIndex - 1].cells[columnIndex].borderRight, cell.borderRight);
        }
      }
    }
    results1 = [];
    for (columnIndex = n = 0, ref20 = layout.rows[0].cells.length; 0 <= ref20 ? n < ref20 : n > ref20; columnIndex = 0 <= ref20 ? ++n : --n) {
      results1.push((function() {
        var o, ref21, results2;
        results2 = [];
        for (rowIndex = o = 0, ref21 = layout.rows.length; 0 <= ref21 ? o < ref21 : o > ref21; rowIndex = 0 <= ref21 ? ++o : --o) {
          cell = layout.rows[rowIndex].cells[columnIndex];
          if (cell.type === "intersection") {
            cell.borderLeft = borderLefts[columnIndex];
            cell.borderRight = borderRights[columnIndex];
            cell.borderTop = borderTops[rowIndex];
            results2.push(cell.borderBottom = borderBottoms[rowIndex]);
          } else {
            results2.push(void 0);
          }
        }
        return results2;
      })());
    }
    return results1;
  };

  PivotChartLayoutBuilder.prototype.getRowsOrColumns = function(isRow, segment, data, locale, parentSegments, parentValues) {
    var allValues, categories, category, childResult, childResults, childSegment, intersectionData, intersectionId, j, k, l, len, len1, len2, ref, relevantData, results, segIds;
    if (parentSegments == null) {
      parentSegments = [];
    }
    if (parentValues == null) {
      parentValues = [];
    }
    if (!segment.valueAxis) {
      categories = [
        {
          value: null,
          label: segment.label
        }
      ];
    } else {
      allValues = [];
      for (intersectionId in data) {
        intersectionData = data[intersectionId];
        if (!intersectionId.match(":")) {
          continue;
        }
        if (isRow) {
          segIds = intersectionId.split(":")[0].split(",");
        } else {
          segIds = intersectionId.split(":")[1].split(",");
        }
        if (!_.isEqual(_.take(segIds, parentSegments.length + 1), _.pluck(parentSegments, "id").concat(segment.id))) {
          continue;
        }
        relevantData = _.filter(intersectionData, (function(_this) {
          return function(dataRow) {
            var i, j, len, parentValue;
            for (i = j = 0, len = parentValues.length; j < len; i = ++j) {
              parentValue = parentValues[i];
              if (isRow) {
                if (dataRow["r" + i] !== parentValue) {
                  return false;
                }
              } else {
                if (dataRow["c" + i] !== parentValue) {
                  return false;
                }
              }
            }
            return true;
          };
        })(this));
        if (isRow) {
          allValues = allValues.concat(_.pluck(relevantData, "r" + parentSegments.length));
        } else {
          allValues = allValues.concat(_.pluck(relevantData, "c" + parentSegments.length));
        }
      }
      categories = this.axisBuilder.getCategories(segment.valueAxis, allValues, locale);
      categories = _.filter(categories, function(category) {
        var ref;
        return ref = category.value, indexOf.call(segment.valueAxis.excludedValues || [], ref) < 0;
      });
      if (categories.length === 0) {
        categories = [
          {
            value: null,
            label: null
          }
        ];
      }
    }
    if (!segment.children || segment.children.length === 0) {
      return _.map(categories, function(category) {
        return [
          {
            segment: segment,
            value: category.value,
            label: category.label
          }
        ];
      });
    }
    results = [];
    for (j = 0, len = categories.length; j < len; j++) {
      category = categories[j];
      ref = segment.children;
      for (k = 0, len1 = ref.length; k < len1; k++) {
        childSegment = ref[k];
        childResults = this.getRowsOrColumns(isRow, childSegment, data, locale, parentSegments.concat([segment]), parentValues.concat([category.value]));
        for (l = 0, len2 = childResults.length; l < len2; l++) {
          childResult = childResults[l];
          results.push([
            {
              segment: segment,
              value: category.value,
              label: category.label
            }
          ].concat(childResult));
        }
      }
    }
    return results;
  };

  return PivotChartLayoutBuilder;

})();


},{"../../../axes/AxisBuilder":1029,"./PivotChartUtils":1153,"color":125,"lodash":"lodash","mwater-expressions":14}],1151:[function(require,module,exports){
var Color, H, LayoutCellComponent, PivotChartLayoutComponent, R, React, ReactDOM, _, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

ReactDOM = require('react-dom');

R = React.createElement;

H = React.DOM;

Color = require('color');

ui = require('react-library/lib/bootstrap');

module.exports = PivotChartLayoutComponent = (function(superClass) {
  extend(PivotChartLayoutComponent, superClass);

  PivotChartLayoutComponent.propTypes = {
    layout: React.PropTypes.object.isRequired,
    editable: React.PropTypes.bool,
    onEditSection: React.PropTypes.func,
    onRemoveSegment: React.PropTypes.func,
    onInsertBeforeSegment: React.PropTypes.func,
    onInsertAfterSegment: React.PropTypes.func,
    onAddChildSegment: React.PropTypes.func,
    onSummarizeSegment: React.PropTypes.func
  };

  function PivotChartLayoutComponent(props) {
    this.renderHoverControls = bind(this.renderHoverControls, this);
    this.renderHoverRemoveIcon = bind(this.renderHoverRemoveIcon, this);
    this.renderHoverPlusIcon = bind(this.renderHoverPlusIcon, this);
    this.recordCellComp = bind(this.recordCellComp, this);
    PivotChartLayoutComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      hoverSection: null
    };
    this.cellComps = {};
  }

  PivotChartLayoutComponent.prototype.recordCellComp = function(rowIndex, columnIndex, comp) {
    var key;
    key = rowIndex + ":" + columnIndex;
    if (comp) {
      return this.cellComps[key] = comp;
    } else {
      return delete this.cellComps[key];
    }
  };

  PivotChartLayoutComponent.prototype.renderRow = function(row, rowIndex) {
    return H.tr({
      key: rowIndex
    }, _.map(row.cells, (function(_this) {
      return function(cell, columnIndex) {
        return R(LayoutCellComponent, {
          ref: _this.recordCellComp.bind(null, rowIndex, columnIndex),
          key: columnIndex,
          layout: _this.props.layout,
          rowIndex: rowIndex,
          columnIndex: columnIndex,
          onHover: _this.props.editable ? (function() {
            return _this.setState({
              hoverSection: cell.section
            });
          }) : void 0,
          hoverSection: _this.props.editable ? _this.state.hoverSection : void 0,
          onEditSection: _this.props.onEditSection ? _this.props.onEditSection.bind(null, cell.section) : void 0,
          onSummarizeSegment: _this.props.onSummarizeSegment ? _this.props.onSummarizeSegment.bind(null, cell.section) : void 0
        });
      };
    })(this)));
  };

  PivotChartLayoutComponent.prototype.renderHoverPlusIcon = function(key, x, y, onClick) {
    return H.div({
      key: key,
      onClick: onClick,
      style: {
        position: "absolute",
        left: x - 7,
        top: y - 6,
        border: "solid 1px #337ab7",
        backgroundColor: "white",
        paddingLeft: 3,
        paddingRight: 3,
        paddingTop: 0,
        color: "#337ab7",
        fontSize: 9,
        cursor: "pointer",
        opacity: 0.8
      }
    }, R(ui.Icon, {
      id: "fa-plus"
    }));
  };

  PivotChartLayoutComponent.prototype.renderHoverRemoveIcon = function(key, x, y, onClick) {
    return H.div({
      key: key,
      onClick: onClick,
      style: {
        position: "absolute",
        left: x - 7,
        top: y - 6,
        border: "solid 1px #337ab7",
        backgroundColor: "white",
        paddingLeft: 3,
        paddingRight: 3,
        paddingTop: 0,
        color: "#337ab7",
        fontSize: 9,
        cursor: "pointer",
        opacity: 0.8
      }
    }, R(ui.Icon, {
      id: "fa-remove"
    }));
  };

  PivotChartLayoutComponent.prototype.renderHoverControls = function() {
    var cell, cellTd, columnIndex, controls, key, maxX, maxY, minX, minY, ref, ref1, ref2, rowIndex, sectionType;
    if (!this.state.hoverSection) {
      return;
    }
    minX = maxX = minY = maxY = null;
    sectionType = null;
    ref = this.cellComps;
    for (key in ref) {
      cell = ref[key];
      rowIndex = parseInt(key.split(":")[0]);
      columnIndex = parseInt(key.split(":")[1]);
      cellTd = cell.getTdComponent();
      if (!cellTd) {
        continue;
      }
      if (((ref1 = this.props.layout.rows[rowIndex]) != null ? (ref2 = ref1.cells[columnIndex]) != null ? ref2.section : void 0 : void 0) === this.state.hoverSection) {
        minX = (minX == null) || cellTd.offsetLeft < minX ? cellTd.offsetLeft : minX;
        minY = (minY == null) || cellTd.offsetTop < minY ? cellTd.offsetTop : minY;
        maxX = (maxX == null) || cellTd.offsetLeft + cellTd.offsetWidth > maxX ? cellTd.offsetLeft + cellTd.offsetWidth : maxX;
        maxY = (maxY == null) || cellTd.offsetTop + cellTd.offsetHeight > maxY ? cellTd.offsetTop + cellTd.offsetHeight : maxY;
        sectionType = this.props.layout.rows[rowIndex].cells[columnIndex].type;
      }
    }
    if ((minX == null) || !sectionType) {
      return null;
    }
    controls = [];
    if (sectionType === "row" && this.props.onInsertBeforeSegment) {
      controls.push(this.renderHoverPlusIcon("top", (minX + maxX) / 2, minY, this.props.onInsertBeforeSegment.bind(null, this.state.hoverSection)));
    }
    if (sectionType === "row" && this.props.onInsertAfterSegment) {
      controls.push(this.renderHoverPlusIcon("bottom", (minX + maxX) / 2, maxY, this.props.onInsertAfterSegment.bind(null, this.state.hoverSection)));
    }
    if (sectionType === "row" && this.props.onAddChildSegment) {
      controls.push(this.renderHoverPlusIcon("right", maxX, (minY + maxY) / 2, this.props.onAddChildSegment.bind(null, this.state.hoverSection)));
    }
    if (sectionType === "column" && this.props.onInsertBeforeSegment) {
      controls.push(this.renderHoverPlusIcon("left", minX, (minY + maxY) / 2, this.props.onInsertBeforeSegment.bind(null, this.state.hoverSection)));
    }
    if (sectionType === "column" && this.props.onInsertAfterSegment) {
      controls.push(this.renderHoverPlusIcon("right", maxX, (minY + maxY) / 2, this.props.onInsertAfterSegment.bind(null, this.state.hoverSection)));
    }
    if (sectionType === "column" && this.props.onAddChildSegment) {
      controls.push(this.renderHoverPlusIcon("bottom", (minX + maxX) / 2, maxY, this.props.onAddChildSegment.bind(null, this.state.hoverSection)));
    }
    if ((sectionType === 'row' || sectionType === 'column') && this.props.onRemoveSegment) {
      controls.push(this.renderHoverRemoveIcon("topright", maxX, minY, this.props.onRemoveSegment.bind(null, this.state.hoverSection)));
    }
    return H.div({
      key: "hover-controls"
    }, controls);
  };

  PivotChartLayoutComponent.prototype.render = function() {
    var style;
    style = {
      width: "100%",
      borderSpacing: 0,
      borderCollapse: "collapse",
      position: "relative"
    };
    return H.div({
      style: {
        position: "relative"
      },
      onMouseLeave: ((function(_this) {
        return function() {
          return _this.setState({
            hoverSection: null
          });
        };
      })(this))
    }, H.table({
      style: style
    }, H.tbody(null, _.map(this.props.layout.rows, (function(_this) {
      return function(row, rowIndex) {
        return _this.renderRow(row, rowIndex);
      };
    })(this)))), this.renderHoverControls());
  };

  return PivotChartLayoutComponent;

})(React.Component);

LayoutCellComponent = (function(superClass) {
  extend(LayoutCellComponent, superClass);

  function LayoutCellComponent() {
    this.handleClick = bind(this.handleClick, this);
    return LayoutCellComponent.__super__.constructor.apply(this, arguments);
  }

  LayoutCellComponent.propTypes = {
    layout: React.PropTypes.object.isRequired,
    rowIndex: React.PropTypes.number.isRequired,
    columnIndex: React.PropTypes.number.isRequired,
    hoverSection: React.PropTypes.string,
    onHover: React.PropTypes.func,
    onEditSection: React.PropTypes.func,
    onSummarizeSegment: React.PropTypes.func
  };

  LayoutCellComponent.prototype.handleClick = function(ev) {
    var cell;
    cell = this.props.layout.rows[this.props.rowIndex].cells[this.props.columnIndex];
    if (!cell.section) {
      return;
    }
    if (cell.unconfigured) {
      return;
    }
    if (this.props.onEditSection) {
      return this.props.onEditSection();
    }
  };

  LayoutCellComponent.prototype.getTdComponent = function() {
    return this.tdComponent;
  };

  LayoutCellComponent.prototype.renderUnconfigured = function(cell) {
    return H.span({
      style: {
        fontSize: "90%"
      }
    }, H.a({
      style: {
        cursor: "pointer"
      },
      onClick: this.props.onEditSection
    }, "Edit"), cell.summarize ? [
      H.span({
        className: "text-muted"
      }, " / "), H.a({
        style: {
          cursor: "pointer"
        },
        onClick: this.props.onSummarizeSegment
      }, "Summarize")
    ] : void 0);
  };

  LayoutCellComponent.prototype.render = function() {
    var backgroundColor, borderBottom, borderRight, borderWeights, cell, innerStyle, isHover, ref, ref1, ref2, ref3, style;
    cell = this.props.layout.rows[this.props.rowIndex].cells[this.props.columnIndex];
    if (cell.skip) {
      return null;
    }
    isHover = this.props.hoverSection && cell.section === this.props.hoverSection;
    backgroundColor = cell.unconfigured && this.props.onEditSection ? "#eff5fb" : cell.backgroundColor || "#FFFFFF";
    if (isHover) {
      backgroundColor = Color(backgroundColor).darken(0.03);
    }
    if (this.props.layout.striping === "columns" && ((ref = cell.type) === 'column' || ref === 'intersection') && this.props.columnIndex % 2 === 0) {
      backgroundColor = Color(backgroundColor).darken(0.03);
    } else if (this.props.layout.striping === "rows" && ((ref1 = cell.type) === 'row' || ref1 === 'intersection') && this.props.rowIndex % 2 === 0) {
      backgroundColor = Color(backgroundColor).darken(0.03);
    }
    borderWeights = [null, "solid 1px #f4f4f4", "solid 1px #ccc", "solid 1px #888"];
    borderBottom = Math.max(cell.borderBottom || 0, ((ref2 = this.props.layout.rows[this.props.rowIndex + 1]) != null ? ref2.cells[this.props.columnIndex].borderTop : void 0) || 0);
    borderRight = Math.max(cell.borderRight || 0, ((ref3 = this.props.layout.rows[this.props.rowIndex].cells[this.props.columnIndex + 1]) != null ? ref3.borderLeft : void 0) || 0);
    style = {
      padding: 5,
      verticalAlign: "top",
      backgroundColor: backgroundColor,
      position: "relative",
      textAlign: cell.align,
      cursor: isHover && !cell.unconfigured ? "pointer" : void 0,
      borderTop: borderWeights[cell.borderTop || 0],
      borderBottom: borderWeights[borderBottom],
      borderLeft: borderWeights[cell.borderLeft || 0],
      borderRight: borderWeights[borderRight]
    };
    innerStyle = {
      fontWeight: cell.bold ? "bold" : void 0,
      fontStyle: cell.italic ? "italic" : void 0,
      marginLeft: cell.indent ? cell.indent * 5 : void 0
    };
    return H.td({
      ref: ((function(_this) {
        return function(c) {
          return _this.tdComponent = c;
        };
      })(this)),
      onMouseEnter: this.props.onHover,
      onClick: this.handleClick,
      style: style,
      colSpan: cell.columnSpan || 1,
      rowSpan: cell.rowSpan || 1
    }, H.span({
      style: innerStyle
    }, cell.unconfigured && this.props.onEditSection ? this.renderUnconfigured(cell) : cell.text || "\u00A0\u00A0\u00A0"));
  };

  return LayoutCellComponent;

})(React.Component);


},{"color":125,"lodash":"lodash","react":"react","react-dom":"react-dom","react-library/lib/bootstrap":793}],1152:[function(require,module,exports){
var AxisBuilder, ExprCompiler, ExprUtils, PivotChartQueryBuilder, PivotChartUtils, _, injectTableAlias;

_ = require('lodash');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

injectTableAlias = require('mwater-expressions').injectTableAlias;

PivotChartUtils = require('./PivotChartUtils');

module.exports = PivotChartQueryBuilder = (function() {
  function PivotChartQueryBuilder(options) {
    this.schema = options.schema;
    this.exprUtils = new ExprUtils(this.schema);
    this.axisBuilder = new AxisBuilder({
      schema: this.schema
    });
  }

  PivotChartQueryBuilder.prototype.createQueries = function(design, extraFilters) {
    var backgroundColorCondition, columnPath, columnSegment, exprCompiler, filter, filters, i, intersection, intersectionId, j, k, l, len, len1, len2, len3, len4, len5, m, n, o, queries, query, ref, ref1, ref2, relevantFilters, rowPath, rowSegment, whereClauses;
    exprCompiler = new ExprCompiler(this.schema);
    queries = {};
    ref = PivotChartUtils.getSegmentPaths(design.rows);
    for (j = 0, len = ref.length; j < len; j++) {
      rowPath = ref[j];
      ref1 = PivotChartUtils.getSegmentPaths(design.columns);
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        columnPath = ref1[k];
        intersectionId = PivotChartUtils.getIntersectionId(rowPath, columnPath);
        intersection = design.intersections[intersectionId];
        query = {
          type: "query",
          selects: [],
          from: exprCompiler.compileTable(design.table, "main"),
          limit: 1000,
          groupBy: []
        };
        filters = [];
        for (i = l = 0, len2 = rowPath.length; l < len2; i = ++l) {
          rowSegment = rowPath[i];
          query.selects.push({
            type: "select",
            expr: this.axisBuilder.compileAxis({
              axis: rowSegment.valueAxis,
              tableAlias: "main"
            }),
            alias: "r" + i
          });
          query.groupBy.push(i + 1);
          if (rowSegment.filter) {
            filters.push(rowSegment.filter);
          }
        }
        for (i = m = 0, len3 = columnPath.length; m < len3; i = ++m) {
          columnSegment = columnPath[i];
          query.selects.push({
            type: "select",
            expr: this.axisBuilder.compileAxis({
              axis: columnSegment.valueAxis,
              tableAlias: "main"
            }),
            alias: "c" + i
          });
          query.groupBy.push(i + 1 + rowPath.length);
          if (columnSegment.filter) {
            filters.push(columnSegment.filter);
          }
        }
        query.selects.push({
          type: "select",
          expr: this.axisBuilder.compileAxis({
            axis: intersection != null ? intersection.valueAxis : void 0,
            tableAlias: "main"
          }),
          alias: "value"
        });
        if (intersection != null ? intersection.filter : void 0) {
          filters.push(intersection.filter);
        }
        if (intersection != null ? intersection.backgroundColorAxis : void 0) {
          query.selects.push({
            type: "select",
            expr: this.axisBuilder.compileAxis({
              axis: intersection != null ? intersection.backgroundColorAxis : void 0,
              tableAlias: "main"
            }),
            alias: "bc"
          });
        }
        ref2 = intersection.backgroundColorConditions || [];
        for (i = n = 0, len4 = ref2.length; n < len4; i = ++n) {
          backgroundColorCondition = ref2[i];
          query.selects.push({
            type: "select",
            expr: exprCompiler.compileExpr({
              expr: backgroundColorCondition.condition,
              tableAlias: "main"
            }),
            alias: "bcc" + i
          });
        }
        if (_.all(query.selects, function(select) {
          return select.expr == null;
        })) {
          continue;
        }
        whereClauses = [];
        if (design.filter) {
          whereClauses.push(exprCompiler.compileExpr({
            expr: design.filter,
            tableAlias: "main"
          }));
        }
        whereClauses = whereClauses.concat(_.map(filters, function(filter) {
          return exprCompiler.compileExpr({
            expr: filter,
            tableAlias: "main"
          });
        }));
        if (extraFilters && extraFilters.length > 0) {
          relevantFilters = _.where(extraFilters, {
            table: design.table
          });
          for (o = 0, len5 = relevantFilters.length; o < len5; o++) {
            filter = relevantFilters[o];
            whereClauses.push(injectTableAlias(filter.jsonql, "main"));
          }
        }
        whereClauses = _.compact(whereClauses);
        if (whereClauses.length === 1) {
          query.where = whereClauses[0];
        } else if (whereClauses.length > 1) {
          query.where = {
            type: "op",
            op: "and",
            exprs: whereClauses
          };
        }
        queries[intersectionId] = query;
      }
    }
    return queries;
  };

  return PivotChartQueryBuilder;

})();


},{"../../../axes/AxisBuilder":1029,"./PivotChartUtils":1153,"lodash":"lodash","mwater-expressions":14}],1153:[function(require,module,exports){
var _, findPreviousSegment, mapSegments, uuid,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

_ = require('lodash');

uuid = require('uuid');

exports.getSegmentPaths = function(segments) {
  var i, len, paths, segment;
  paths = [];
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    if (!segment.children || segment.children.length === 0) {
      paths.push([segment]);
    } else {
      paths = paths.concat(_.map(exports.getSegmentPaths(segment.children), function(childPath) {
        return [segment].concat(childPath);
      }));
    }
  }
  return paths;
};

exports.getAllSegments = function(segments) {
  var allSegments, i, len, segment;
  allSegments = [];
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    allSegments.push(segment);
    if (segment.children && segment.children.length > 0) {
      allSegments = allSegments.concat(exports.getAllSegments(segment.children));
    }
  }
  return allSegments;
};

exports.getIntersectionId = function(rowPath, columnPath) {
  return (_.pluck(rowPath, "id").join(",")) + ":" + (_.pluck(columnPath, "id").join(","));
};

exports.findSegment = function(segments, id) {
  return _.findWhere(exports.getAllSegments(segments), {
    id: id
  });
};

exports.canSummarizeSegment = function(segments, id) {
  var prevSegment, ref;
  prevSegment = findPreviousSegment(segments, id);
  if (prevSegment && prevSegment.valueAxis && !((ref = prevSegment.children) != null ? ref[0] : void 0)) {
    return true;
  }
  return false;
};

findPreviousSegment = function(segments, id) {
  var i, index, len, prevSegment, segment;
  index = _.findIndex(segments, {
    id: id
  });
  if (index === 0) {
    return false;
  }
  if (index > 0) {
    return segments[index - 1];
  }
  for (i = 0, len = segments.length; i < len; i++) {
    segment = segments[i];
    if (segment.children) {
      prevSegment = findPreviousSegment(segment.children, id);
      if (prevSegment) {
        return prevSegment;
      }
    }
  }
  return false;
};

exports.summarizeSegment = function(design, id, label) {
  var columnPath, columnSegment, i, j, k, l, len, len1, len2, len3, prevIntersection, prevSegment, ref, ref1, ref2, ref3, rowPath, rowSegment, summaryColumnPath, summaryIntersection, summaryRowPath;
  design = _.cloneDeep(design);
  rowSegment = exports.findSegment(design.rows, id);
  columnSegment = exports.findSegment(design.columns, id);
  if (rowSegment) {
    rowSegment.label = label;
  }
  if (columnSegment) {
    columnSegment.label = label;
  }
  if (rowSegment) {
    prevSegment = findPreviousSegment(design.rows, id);
    ref = exports.getSegmentPaths(design.rows);
    for (i = 0, len = ref.length; i < len; i++) {
      rowPath = ref[i];
      ref1 = exports.getSegmentPaths(design.columns);
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        columnPath = ref1[j];
        if (indexOf.call(rowPath, prevSegment) < 0) {
          continue;
        }
        prevIntersection = design.intersections[exports.getIntersectionId(rowPath, columnPath)];
        summaryIntersection = _.cloneDeep(prevIntersection);
        summaryRowPath = _.find(exports.getSegmentPaths(design.rows), function(path) {
          return indexOf.call(path, rowSegment) >= 0;
        });
        design.intersections[exports.getIntersectionId(summaryRowPath, columnPath)] = summaryIntersection;
      }
    }
  }
  if (columnSegment) {
    prevSegment = findPreviousSegment(design.columns, id);
    ref2 = exports.getSegmentPaths(design.columns);
    for (k = 0, len2 = ref2.length; k < len2; k++) {
      columnPath = ref2[k];
      ref3 = exports.getSegmentPaths(design.rows);
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        rowPath = ref3[l];
        if (indexOf.call(columnPath, prevSegment) < 0) {
          continue;
        }
        prevIntersection = design.intersections[exports.getIntersectionId(rowPath, columnPath)];
        summaryIntersection = _.cloneDeep(prevIntersection);
        summaryColumnPath = _.find(exports.getSegmentPaths(design.columns), function(path) {
          return indexOf.call(path, columnSegment) >= 0;
        });
        design.intersections[exports.getIntersectionId(rowPath, summaryColumnPath)] = summaryIntersection;
      }
    }
  }
  return design;
};

mapSegments = function(segments, mapFunc) {
  segments = _.map(segments, mapFunc);
  segments = _.map(segments, function(segment) {
    if (!segment || !segment.children || segment.children.length === 0) {
      return segment;
    }
    return _.extend({}, segment, {
      children: mapSegments(segment.children, mapFunc)
    });
  });
  return _.compact(_.flatten(segments));
};

exports.replaceSegment = function(segments, replacement) {
  return mapSegments(segments, function(segment) {
    if (segment.id === replacement.id) {
      return replacement;
    }
    return segment;
  });
};

exports.removeSegment = function(segments, id) {
  return mapSegments(segments, function(segment) {
    if (segment.id === id) {
      return null;
    }
    return segment;
  });
};

exports.insertBeforeSegment = function(segments, id) {
  return mapSegments(segments, function(segment) {
    if (segment.id === id) {
      return [
        {
          id: uuid()
        }, segment
      ];
    }
    return segment;
  });
};

exports.insertAfterSegment = function(segments, id) {
  return mapSegments(segments, function(segment) {
    if (segment.id === id) {
      return [
        segment, {
          id: uuid()
        }
      ];
    }
    return segment;
  });
};

exports.addChildSegment = function(segments, id) {
  return mapSegments(segments, function(segment) {
    if (segment.id === id) {
      return _.extend({}, segment, {
        children: (segment.children || []).concat([
          {
            id: uuid()
          }
        ])
      });
    }
    return segment;
  });
};


},{"lodash":"lodash","uuid":1007}],1154:[function(require,module,exports){
var ActionCancelModalComponent, ExprUtils, H, IntersectionDesignerComponent, PivotChartLayoutBuilder, PivotChartLayoutComponent, PivotChartUtils, PivotChartViewComponent, R, React, ReactDOM, SegmentDesignerComponent, TextComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

ReactDOM = require('react-dom');

R = React.createElement;

H = React.DOM;

ActionCancelModalComponent = require('react-library/lib/ActionCancelModalComponent');

ExprUtils = require('mwater-expressions').ExprUtils;

TextComponent = require('../../text/TextComponent');

PivotChartUtils = require('./PivotChartUtils');

PivotChartLayoutComponent = require('./PivotChartLayoutComponent');

PivotChartLayoutBuilder = require('./PivotChartLayoutBuilder');

SegmentDesignerComponent = require('./SegmentDesignerComponent');

IntersectionDesignerComponent = require('./IntersectionDesignerComponent');

module.exports = PivotChartViewComponent = (function(superClass) {
  extend(PivotChartViewComponent, superClass);

  PivotChartViewComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    width: React.PropTypes.number.isRequired,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func
  };

  PivotChartViewComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  function PivotChartViewComponent() {
    this.handleSummarizeSegment = bind(this.handleSummarizeSegment, this);
    this.handleAddChildSegment = bind(this.handleAddChildSegment, this);
    this.handleInsertAfterSegment = bind(this.handleInsertAfterSegment, this);
    this.handleInsertBeforeSegment = bind(this.handleInsertBeforeSegment, this);
    this.handleRemoveSegment = bind(this.handleRemoveSegment, this);
    this.handleCancelEditIntersection = bind(this.handleCancelEditIntersection, this);
    this.handleSaveEditIntersection = bind(this.handleSaveEditIntersection, this);
    this.handleCancelEditSegment = bind(this.handleCancelEditSegment, this);
    this.handleSaveEditSegment = bind(this.handleSaveEditSegment, this);
    this.handleEditSection = bind(this.handleEditSection, this);
    this.handleFooterChange = bind(this.handleFooterChange, this);
    this.handleHeaderChange = bind(this.handleHeaderChange, this);
    PivotChartViewComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      editSegment: null,
      editIntersectionId: null,
      editIntersection: null
    };
  }

  PivotChartViewComponent.prototype.handleHeaderChange = function(header) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      header: header
    }));
  };

  PivotChartViewComponent.prototype.handleFooterChange = function(footer) {
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      footer: footer
    }));
  };

  PivotChartViewComponent.prototype.handleEditSection = function(sectionId) {
    var segment;
    if (sectionId.match(":")) {
      return this.setState({
        editIntersectionId: sectionId,
        editIntersection: this.props.design.intersections[sectionId] || {}
      });
    } else {
      segment = PivotChartUtils.findSegment(this.props.design.rows, sectionId) || PivotChartUtils.findSegment(this.props.design.columns, sectionId);
      return this.setState({
        editSegment: segment
      });
    }
  };

  PivotChartViewComponent.prototype.handleSaveEditSegment = function() {
    var design, segment;
    segment = this.state.editSegment;
    if (segment.label == null) {
      segment = _.extend({}, segment, {
        label: ""
      });
    }
    design = _.extend({}, this.props.design, {
      rows: PivotChartUtils.replaceSegment(this.props.design.rows, segment),
      columns: PivotChartUtils.replaceSegment(this.props.design.columns, segment)
    });
    this.props.onDesignChange(design);
    return this.setState({
      editSegment: null
    });
  };

  PivotChartViewComponent.prototype.handleCancelEditSegment = function() {
    return this.setState({
      editSegment: null
    });
  };

  PivotChartViewComponent.prototype.handleSaveEditIntersection = function() {
    var design, intersections;
    intersections = _.clone(this.props.design.intersections);
    intersections[this.state.editIntersectionId] = this.state.editIntersection;
    design = _.extend({}, this.props.design, {
      intersections: intersections
    });
    this.props.onDesignChange(design);
    return this.setState({
      editIntersectionId: null,
      editIntersection: null
    });
  };

  PivotChartViewComponent.prototype.handleCancelEditIntersection = function() {
    return this.setState({
      editIntersectionId: null,
      editIntersection: null
    });
  };

  PivotChartViewComponent.prototype.handleRemoveSegment = function(segmentId) {
    var design;
    design = _.extend({}, this.props.design, {
      rows: PivotChartUtils.removeSegment(this.props.design.rows, segmentId),
      columns: PivotChartUtils.removeSegment(this.props.design.columns, segmentId)
    });
    return this.props.onDesignChange(design);
  };

  PivotChartViewComponent.prototype.handleInsertBeforeSegment = function(segmentId) {
    var design;
    design = _.extend({}, this.props.design, {
      rows: PivotChartUtils.insertBeforeSegment(this.props.design.rows, segmentId),
      columns: PivotChartUtils.insertBeforeSegment(this.props.design.columns, segmentId)
    });
    return this.props.onDesignChange(design);
  };

  PivotChartViewComponent.prototype.handleInsertAfterSegment = function(segmentId) {
    var design;
    design = _.extend({}, this.props.design, {
      rows: PivotChartUtils.insertAfterSegment(this.props.design.rows, segmentId),
      columns: PivotChartUtils.insertAfterSegment(this.props.design.columns, segmentId)
    });
    return this.props.onDesignChange(design);
  };

  PivotChartViewComponent.prototype.handleAddChildSegment = function(segmentId) {
    var design;
    design = _.extend({}, this.props.design, {
      rows: PivotChartUtils.addChildSegment(this.props.design.rows, segmentId),
      columns: PivotChartUtils.addChildSegment(this.props.design.columns, segmentId)
    });
    return this.props.onDesignChange(design);
  };

  PivotChartViewComponent.prototype.handleSummarizeSegment = function(segmentId) {
    var design;
    design = PivotChartUtils.summarizeSegment(this.props.design, segmentId, "Summary");
    return this.props.onDesignChange(design);
  };

  PivotChartViewComponent.prototype.renderHeader = function() {
    return H.div({
      ref: "header",
      style: {
        paddingLeft: 10,
        paddingRight: 10
      }
    }, R(TextComponent, {
      design: this.props.design.header,
      onDesignChange: this.props.onDesignChange ? this.handleHeaderChange : void 0,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprValues: this.props.data.header || {},
      width: this.props.width,
      standardWidth: this.props.standardWidth
    }));
  };

  PivotChartViewComponent.prototype.renderFooter = function() {
    return H.div({
      ref: "footer",
      style: {
        paddingLeft: 10,
        paddingRight: 10
      }
    }, R(TextComponent, {
      design: this.props.design.footer,
      onDesignChange: this.props.onDesignChange ? this.handleFooterChange : void 0,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprValues: this.props.data.footer || {},
      width: this.props.width,
      standardWidth: this.props.standardWidth
    }));
  };

  PivotChartViewComponent.prototype.renderEditSegmentModal = function() {
    var segmentType;
    if (!this.state.editSegment) {
      return;
    }
    segmentType = PivotChartUtils.findSegment(this.props.design.rows, this.state.editSegment.id) ? "row" : "column";
    return R(ActionCancelModalComponent, {
      header: "Edit " + segmentType,
      onAction: this.handleSaveEditSegment,
      onCancel: this.handleCancelEditSegment
    }, R(SegmentDesignerComponent, {
      segment: this.state.editSegment,
      table: this.props.design.table,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      segmentType: segmentType,
      onChange: (function(_this) {
        return function(segment) {
          return _this.setState({
            editSegment: segment
          });
        };
      })(this)
    }));
  };

  PivotChartViewComponent.prototype.renderEditIntersectionModal = function() {
    if (!this.state.editIntersectionId) {
      return;
    }
    return R(ActionCancelModalComponent, {
      header: "Edit Value",
      onAction: this.handleSaveEditIntersection,
      onCancel: this.handleCancelEditIntersection
    }, R(IntersectionDesignerComponent, {
      intersection: this.state.editIntersection,
      table: this.props.design.table,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: (function(_this) {
        return function(intersection) {
          return _this.setState({
            editIntersection: intersection
          });
        };
      })(this)
    }));
  };

  PivotChartViewComponent.prototype.render = function() {
    var layout;
    layout = new PivotChartLayoutBuilder({
      schema: this.props.schema
    }).buildLayout(this.props.design, this.props.data, this.context.locale);
    return H.div({
      style: {
        width: this.props.width,
        height: this.props.height
      }
    }, this.renderHeader(), this.renderEditSegmentModal(), this.renderEditIntersectionModal(), H.div({
      key: "layout",
      style: {
        margin: 10,
        marginTop: 15
      }
    }, R(PivotChartLayoutComponent, {
      layout: layout,
      editable: this.props.onDesignChange != null,
      onEditSection: this.props.onDesignChange != null ? this.handleEditSection : void 0,
      onRemoveSegment: this.props.onDesignChange != null ? this.handleRemoveSegment : void 0,
      onInsertBeforeSegment: this.props.onDesignChange != null ? this.handleInsertBeforeSegment : void 0,
      onInsertAfterSegment: this.props.onDesignChange != null ? this.handleInsertAfterSegment : void 0,
      onAddChildSegment: this.props.onDesignChange != null ? this.handleAddChildSegment : void 0,
      onSummarizeSegment: this.props.onDesignChange != null ? this.handleSummarizeSegment : void 0
    })), this.renderFooter());
  };

  return PivotChartViewComponent;

})(React.Component);


},{"../../text/TextComponent":1163,"./IntersectionDesignerComponent":1147,"./PivotChartLayoutBuilder":1150,"./PivotChartLayoutComponent":1151,"./PivotChartUtils":1153,"./SegmentDesignerComponent":1155,"lodash":"lodash","mwater-expressions":14,"react":"react","react-dom":"react-dom","react-library/lib/ActionCancelModalComponent":781}],1155:[function(require,module,exports){
var AxisComponent, BorderComponent, ColorComponent, FilterExprComponent, H, R, React, SegmentDesignerComponent, _, ui,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ui = require('react-library/lib/bootstrap');

AxisComponent = require('../../../axes/AxisComponent');

ColorComponent = require('../../../ColorComponent');

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

module.exports = SegmentDesignerComponent = (function(superClass) {
  extend(SegmentDesignerComponent, superClass);

  SegmentDesignerComponent.propTypes = {
    segment: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    segmentType: React.PropTypes.string.isRequired,
    onChange: React.PropTypes.func.isRequired
  };

  function SegmentDesignerComponent(props) {
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleLabelChange = bind(this.handleLabelChange, this);
    this.handleValueAxisChange = bind(this.handleValueAxisChange, this);
    this.handleMultipleMode = bind(this.handleMultipleMode, this);
    this.handleSingleMode = bind(this.handleSingleMode, this);
    SegmentDesignerComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      mode: (props.segment.label == null) && !props.segment.valueAxis ? null : props.segment.valueAxis ? "multiple" : "single"
    };
  }

  SegmentDesignerComponent.prototype.componentDidMount = function() {
    var ref;
    return (ref = this.labelElem) != null ? ref.focus() : void 0;
  };

  SegmentDesignerComponent.prototype.update = function(changes) {
    var segment;
    segment = _.extend({}, this.props.segment, changes);
    return this.props.onChange(segment);
  };

  SegmentDesignerComponent.prototype.handleSingleMode = function() {
    this.update({
      valueAxis: null
    });
    return this.setState({
      mode: "single"
    });
  };

  SegmentDesignerComponent.prototype.handleMultipleMode = function() {
    return this.setState({
      mode: "multiple"
    });
  };

  SegmentDesignerComponent.prototype.handleValueAxisChange = function(valueAxis) {
    return this.update({
      valueAxis: valueAxis
    });
  };

  SegmentDesignerComponent.prototype.handleLabelChange = function(ev) {
    return this.update({
      label: ev.target.value
    });
  };

  SegmentDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.update({
      filter: filter
    });
  };

  SegmentDesignerComponent.prototype.renderMode = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Type"
    }, H.div({
      key: "single",
      className: "radio"
    }, H.label(null, H.input({
      type: "radio",
      checked: this.state.mode === "single",
      onChange: this.handleSingleMode
    }), "Single " + this.props.segmentType, H.span({
      className: "text-muted"
    }, " - used for summary " + this.props.segmentType + "s and empty " + this.props.segmentType + "s"))), H.div({
      key: "multiple",
      className: "radio"
    }, H.label(null, H.input({
      type: "radio",
      checked: this.state.mode === "multiple",
      onChange: this.handleMultipleMode
    }), "Multiple " + this.props.segmentType + "s", H.span({
      className: "text-muted"
    }, " - disaggregate data by a field"))));
  };

  SegmentDesignerComponent.prototype.renderLabel = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Label",
      help: (this.state.mode === "multiple" ? "Optional label for the " + this.props.segmentType + "s" : void 0)
    }, H.input({
      ref: (function(_this) {
        return function(elem) {
          return _this.labelElem = elem;
        };
      })(this),
      type: "text",
      className: "form-control",
      value: this.props.segment.label || "",
      onChange: this.handleLabelChange
    }));
  };

  SegmentDesignerComponent.prototype.renderValueAxis = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Field",
      help: "Field to disaggregate data by"
    }, H.div({
      style: {
        marginLeft: 8
      }
    }, R(AxisComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ["enum", "text", "boolean", "date"],
      aggrNeed: "none",
      value: this.props.segment.valueAxis,
      onChange: this.handleValueAxisChange,
      allowExcludedValues: true
    })));
  };

  SegmentDesignerComponent.prototype.renderFilter = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: [
        R(ui.Icon, {
          id: "glyphicon-filter"
        }), " Filters"
      ],
      hint: "Filters all data associated with this " + this.props.segmentType
    }, R(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.table,
      value: this.props.segment.filter
    }));
  };

  SegmentDesignerComponent.prototype.renderStyling = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Styling"
    }, H.label({
      className: "checkbox-inline",
      key: "bold"
    }, H.input({
      type: "checkbox",
      checked: this.props.segment.bold === true,
      onChange: (function(_this) {
        return function(ev) {
          return _this.update({
            bold: ev.target.checked
          });
        };
      })(this)
    }), "Bold"), H.label({
      className: "checkbox-inline",
      key: "italic"
    }, H.input({
      type: "checkbox",
      checked: this.props.segment.italic === true,
      onChange: (function(_this) {
        return function(ev) {
          return _this.update({
            italic: ev.target.checked
          });
        };
      })(this)
    }), "Italic"), this.props.segment.valueAxis && this.props.segment.label ? H.label({
      className: "checkbox-inline",
      key: "valueLabelBold"
    }, H.input({
      type: "checkbox",
      checked: this.props.segment.valueLabelBold === true,
      onChange: (function(_this) {
        return function(ev) {
          return _this.update({
            valueLabelBold: ev.target.checked
          });
        };
      })(this)
    }), "Header Bold") : void 0, this.props.segment.valueAxis && this.props.segment.label ? H.div({
      style: {
        paddingTop: 5
      }
    }, "Shade filler cells: ", R(ColorComponent, {
      color: this.props.segment.fillerColor,
      onChange: (function(_this) {
        return function(color) {
          return _this.update({
            fillerColor: color
          });
        };
      })(this)
    })) : void 0);
  };

  SegmentDesignerComponent.prototype.renderBorders = function() {
    return R(ui.FormGroup, {
      labelMuted: true,
      label: "Borders"
    }, H.div({
      key: "before"
    }, this.props.segmentType === "row" ? "Top: " : "Left: "), R(BorderComponent, {
      value: this.props.segment.borderBefore,
      defaultValue: 2,
      onChange: (function(_this) {
        return function(value) {
          return _this.update({
            borderBefore: value
          });
        };
      })(this)
    }), H.div({
      key: "within"
    }, "Within: "), R(BorderComponent, {
      value: this.props.segment.borderWithin,
      defaultValue: 1,
      onChange: (function(_this) {
        return function(value) {
          return _this.update({
            borderWithin: value
          });
        };
      })(this)
    }), H.div({
      key: "after"
    }, this.props.segmentType === "row" ? "Bottom: " : "Right: "), R(BorderComponent, {
      value: this.props.segment.borderAfter,
      defaultValue: 2,
      onChange: (function(_this) {
        return function(value) {
          return _this.update({
            borderAfter: value
          });
        };
      })(this)
    }));
  };

  SegmentDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderMode(), this.state.mode ? this.renderLabel() : void 0, this.state.mode === "multiple" ? this.renderValueAxis() : void 0, this.state.mode ? this.renderFilter() : void 0, this.state.mode ? this.renderStyling() : void 0, this.state.mode ? this.renderBorders() : void 0);
  };

  return SegmentDesignerComponent;

})(React.Component);

BorderComponent = (function(superClass) {
  extend(BorderComponent, superClass);

  function BorderComponent() {
    return BorderComponent.__super__.constructor.apply(this, arguments);
  }

  BorderComponent.propTypes = {
    value: React.PropTypes.number,
    defaultValue: React.PropTypes.number,
    onChange: React.PropTypes.func.isRequired
  };

  BorderComponent.prototype.render = function() {
    var value;
    value = this.props.value != null ? this.props.value : this.props.defaultValue;
    return H.span(null, H.label({
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: value === 0,
      onClick: (function(_this) {
        return function() {
          return _this.props.onChange(0);
        };
      })(this)
    }), "None"), H.label({
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: value === 1,
      onClick: (function(_this) {
        return function() {
          return _this.props.onChange(1);
        };
      })(this)
    }), "Light"), H.label({
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: value === 2,
      onClick: (function(_this) {
        return function() {
          return _this.props.onChange(2);
        };
      })(this)
    }), "Medium"), H.label({
      className: "radio-inline"
    }, H.input({
      type: "radio",
      checked: value === 3,
      onClick: (function(_this) {
        return function() {
          return _this.props.onChange(3);
        };
      })(this)
    }), "Heavy"));
  };

  return BorderComponent;

})(React.Component);


},{"../../../ColorComponent":1016,"../../../axes/AxisComponent":1031,"lodash":"lodash","mwater-expressions-ui":362,"react":"react","react-library/lib/bootstrap":793}],1156:[function(require,module,exports){
var ExprComponent, H, OrderingComponent, OrderingsComponent, R, React, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

module.exports = OrderingsComponent = (function(superClass) {
  extend(OrderingsComponent, superClass);

  function OrderingsComponent() {
    this.handleOrderingChange = bind(this.handleOrderingChange, this);
    this.handleOrderingRemove = bind(this.handleOrderingRemove, this);
    this.handleAdd = bind(this.handleAdd, this);
    return OrderingsComponent.__super__.constructor.apply(this, arguments);
  }

  OrderingsComponent.propTypes = {
    orderings: React.PropTypes.array.isRequired,
    onOrderingsChange: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string
  };

  OrderingsComponent.prototype.handleAdd = function() {
    var orderings;
    orderings = this.props.orderings.slice();
    orderings.push({
      axis: null,
      direction: "asc"
    });
    return this.props.onOrderingsChange(orderings);
  };

  OrderingsComponent.prototype.handleOrderingRemove = function(index) {
    var orderings;
    orderings = this.props.orderings.slice();
    orderings.splice(index, 1);
    return this.props.onOrderingsChange(orderings);
  };

  OrderingsComponent.prototype.handleOrderingChange = function(index, ordering) {
    var orderings;
    orderings = this.props.orderings.slice();
    orderings[index] = ordering;
    return this.props.onOrderingsChange(orderings);
  };

  OrderingsComponent.prototype.render = function() {
    return H.div(null, _.map(this.props.orderings, (function(_this) {
      return function(ordering, i) {
        return R(OrderingComponent, {
          schema: _this.props.schema,
          dataSource: _this.props.dataSource,
          ordering: ordering,
          table: _this.props.table,
          onOrderingChange: _this.handleOrderingChange.bind(null, i),
          onOrderingRemove: _this.handleOrderingRemove.bind(null, i)
        });
      };
    })(this)), H.button({
      type: "button",
      className: "btn btn-sm btn-default",
      onClick: this.handleAdd,
      key: "add"
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Ordering"));
  };

  return OrderingsComponent;

})(React.Component);

OrderingComponent = (function(superClass) {
  extend(OrderingComponent, superClass);

  function OrderingComponent() {
    this.handleDirectionChange = bind(this.handleDirectionChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    this.handleAxisChange = bind(this.handleAxisChange, this);
    return OrderingComponent.__super__.constructor.apply(this, arguments);
  }

  OrderingComponent.propTypes = {
    ordering: React.PropTypes.object.isRequired,
    onOrderingChange: React.PropTypes.func.isRequired,
    onOrderingRemove: React.PropTypes.func.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string
  };

  OrderingComponent.prototype.handleAxisChange = function(axis) {
    return this.props.onOrderingChange(_.extend({}, this.props.ordering, {
      axis: axis
    }));
  };

  OrderingComponent.prototype.handleExprChange = function(expr) {
    var axis;
    axis = _.extend({}, this.props.ordering.axis || {}, {
      expr: expr
    });
    return this.handleAxisChange(axis);
  };

  OrderingComponent.prototype.handleDirectionChange = function(ev) {
    return this.props.onOrderingChange(_.extend({}, this.props.ordering, {
      direction: ev.target.checked ? "desc" : "asc"
    }));
  };

  OrderingComponent.prototype.render = function() {
    var ref;
    return H.div({
      style: {
        marginLeft: 5
      }
    }, H.div({
      style: {
        textAlign: "right"
      }
    }, H.button({
      className: "btn btn-xs btn-link",
      type: "button",
      onClick: this.props.onOrderingRemove
    }, H.span({
      className: "glyphicon glyphicon-remove"
    }))), R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.table,
      types: ['text', 'number', 'boolean', 'date', 'datetime'],
      aggrStatuses: ['individual', 'aggregate'],
      value: (ref = this.props.ordering.axis) != null ? ref.expr : void 0,
      onChange: this.handleExprChange
    }), H.div(null, H.div({
      className: "checkbox-inline"
    }, H.label(null, H.input({
      type: "checkbox",
      checked: this.props.ordering.direction === "desc",
      onChange: this.handleDirectionChange
    }), "Reverse"))));
  };

  return OrderingComponent;

})(React.Component);


},{"lodash":"lodash","mwater-expressions-ui":362,"react":"react"}],1157:[function(require,module,exports){
var AxisBuilder, Chart, ExprCompiler, ExprUtils, H, React, TableChart, TableChartViewComponent, _, injectTableAlias, uuid,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

uuid = require('uuid');

injectTableAlias = require('mwater-expressions').injectTableAlias;

Chart = require('../Chart');

ExprUtils = require('mwater-expressions').ExprUtils;

ExprCompiler = require('mwater-expressions').ExprCompiler;

AxisBuilder = require('../../../axes/AxisBuilder');

TableChartViewComponent = require('./TableChartViewComponent');


/*
Design is:

  table: table to use for data source
  titleText: title text
  columns: array of columns
  filter: optional logical expression to filter by
  orderings: array of orderings

column:
  id: unique id of column (uuid v4)
  headerText: header text
  textAxis: axis that creates the text value of the column. NOTE: now no longer using as an axis, but only using expression within!

ordering:
  axis: axis that creates the order expression. NOTE: now no longer using as an axis, but only using expression within!
  direction: "asc"/"desc"
 */

module.exports = TableChart = (function(superClass) {
  extend(TableChart, superClass);

  function TableChart() {
    return TableChart.__super__.constructor.apply(this, arguments);
  }

  TableChart.prototype.cleanDesign = function(design, schema) {
    var ExprCleaner, axisBuilder, column, columnId, exprCleaner, j, k, len, ordering, ref, ref1;
    ExprCleaner = require('mwater-expressions').ExprCleaner;
    exprCleaner = new ExprCleaner(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    design = _.cloneDeep(design);
    design.version = design.version || 1;
    design.columns = design.columns || [];
    if (design.columns.length === 0) {
      design.columns.push({
        id: uuid()
      });
    }
    design.orderings = design.orderings || [];
    for (columnId = j = 0, ref = design.columns.length; 0 <= ref ? j < ref : j > ref; columnId = 0 <= ref ? ++j : --j) {
      column = design.columns[columnId];
      if (!column.id) {
        column.id = uuid();
      }
      column.textAxis = axisBuilder.cleanAxis({
        axis: column.textAxis,
        table: design.table,
        aggrNeed: "optional"
      });
    }
    ref1 = design.orderings;
    for (k = 0, len = ref1.length; k < len; k++) {
      ordering = ref1[k];
      ordering.axis = axisBuilder.cleanAxis({
        axis: ordering.axis,
        table: design.table,
        aggrNeed: "optional"
      });
    }
    if (design.filter) {
      design.filter = exprCleaner.cleanExpr(design.filter, {
        table: design.table,
        types: ['boolean']
      });
    }
    return design;
  };

  TableChart.prototype.validateDesign = function(design, schema) {
    var axisBuilder, column, error, j, k, len, len1, ordering, ref, ref1;
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    if (!design.table) {
      return "Missing data source";
    }
    error = null;
    ref = design.columns;
    for (j = 0, len = ref.length; j < len; j++) {
      column = ref[j];
      if (!column.textAxis) {
        error = error || "Missing text";
      }
      error = error || axisBuilder.validateAxis({
        axis: column.textAxis
      });
    }
    ref1 = design.orderings;
    for (k = 0, len1 = ref1.length; k < len1; k++) {
      ordering = ref1[k];
      if (!ordering.axis) {
        error = error || "Missing order expression";
      }
      error = error || axisBuilder.validateAxis({
        axis: ordering.axis
      });
    }
    return error;
  };

  TableChart.prototype.isEmpty = function(design) {
    return !design.columns || !design.columns[0] || !design.columns[0].textAxis;
  };

  TableChart.prototype.createDesignerElement = function(options) {
    var TableChartDesignerComponent, props;
    TableChartDesignerComponent = require('./TableChartDesignerComponent');
    props = {
      schema: options.schema,
      design: this.cleanDesign(options.design, options.schema),
      dataSource: options.dataSource,
      onDesignChange: (function(_this) {
        return function(design) {
          design = _this.cleanDesign(design, options.schema);
          return options.onDesignChange(design);
        };
      })(this)
    };
    return React.createElement(TableChartDesignerComponent, props);
  };

  TableChart.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var axisBuilder, colNum, column, compiledExpr, exprCompiler, exprType, exprUtils, i, j, k, len, ordering, query, ref, ref1, ref2, ref3, ref4, ref5, whereClauses;
    exprUtils = new ExprUtils(schema);
    exprCompiler = new ExprCompiler(schema);
    axisBuilder = new AxisBuilder({
      schema: schema
    });
    query = {
      type: "query",
      selects: [],
      from: exprCompiler.compileTable(design.table, "main"),
      groupBy: [],
      orderBy: [],
      limit: 1000
    };
    for (colNum = j = 0, ref = design.columns.length; 0 <= ref ? j < ref : j > ref; colNum = 0 <= ref ? ++j : --j) {
      column = design.columns[colNum];
      exprType = exprUtils.getExprType((ref1 = column.textAxis) != null ? ref1.expr : void 0);
      compiledExpr = exprCompiler.compileExpr({
        expr: (ref2 = column.textAxis) != null ? ref2.expr : void 0,
        tableAlias: "main"
      });
      if (exprType === "geometry") {
        compiledExpr = {
          type: "op",
          op: "ST_AsGeoJSON",
          exprs: [
            {
              type: "op",
              op: "ST_Transform",
              exprs: [
                {
                  type: "op",
                  op: "::geometry",
                  exprs: [compiledExpr]
                }, 4326
              ]
            }
          ]
        };
      }
      query.selects.push({
        type: "select",
        expr: compiledExpr,
        alias: "c" + colNum
      });
      if (!axisBuilder.isAxisAggr(column.textAxis)) {
        query.groupBy.push(colNum + 1);
      }
    }
    ref3 = design.orderings || [];
    for (i = k = 0, len = ref3.length; k < len; i = ++k) {
      ordering = ref3[i];
      query.selects.push({
        type: "select",
        expr: exprCompiler.compileExpr({
          expr: (ref4 = ordering.axis) != null ? ref4.expr : void 0,
          tableAlias: "main"
        }),
        alias: "o" + i
      });
      query.orderBy.push({
        ordinal: design.columns.length + i + 1,
        direction: ordering.direction,
        nulls: (ordering.direction === "desc" ? "last" : "first")
      });
      if (exprUtils.getExprAggrStatus((ref5 = ordering.axis) != null ? ref5.expr : void 0) === "individual") {
        query.groupBy.push(design.columns.length + i + 1);
      }
    }
    query.selects.push({
      type: "select",
      expr: {
        type: "op",
        op: "min",
        exprs: [
          {
            type: "field",
            tableAlias: "main",
            column: schema.getTable(design.table).primaryKey
          }
        ]
      },
      alias: "id"
    });
    query.selects.push({
      type: "select",
      expr: {
        type: "op",
        op: "count",
        exprs: []
      },
      alias: "num_ids"
    });
    filters = _.where(filters || [], {
      table: design.table
    });
    whereClauses = _.map(filters, function(f) {
      return injectTableAlias(f.jsonql, "main");
    });
    if (design.filter) {
      whereClauses.push(exprCompiler.compileExpr({
        expr: design.filter,
        tableAlias: "main"
      }));
    }
    whereClauses = _.compact(whereClauses);
    if (whereClauses.length > 1) {
      query.where = {
        type: "op",
        op: "and",
        exprs: whereClauses
      };
    } else {
      query.where = whereClauses[0];
    }
    return dataSource.performQuery(query, (function(_this) {
      return function(error, data) {
        return callback(error, {
          main: data
        });
      };
    })(this));
  };

  TableChart.prototype.createViewElement = function(options) {
    var props;
    props = {
      schema: options.schema,
      dataSource: options.dataSource,
      design: this.cleanDesign(options.design, options.schema),
      data: options.data,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      scope: options.scope,
      onScopeChange: options.onScopeChange,
      onRowClick: options.onRowClick
    };
    return React.createElement(TableChartViewComponent, props);
  };

  TableChart.prototype.createDataTable = function(design, schema, dataSource, data, locale) {
    var exprUtils, header, renderHeaderCell, renderRow, table;
    exprUtils = new ExprUtils(schema);
    renderHeaderCell = (function(_this) {
      return function(column) {
        var ref;
        return column.headerText || exprUtils.summarizeExpr((ref = column.textAxis) != null ? ref.expr : void 0, locale);
      };
    })(this);
    header = _.map(design.columns, renderHeaderCell);
    table = [header];
    renderRow = (function(_this) {
      return function(record) {
        var renderCell;
        renderCell = function(column, columnIndex) {
          var exprType, ref, ref1, value;
          value = record["c" + columnIndex];
          exprUtils = new ExprUtils(schema);
          exprType = exprUtils.getExprType((ref = column.textAxis) != null ? ref.expr : void 0);
          if (exprType === "image" && value) {
            return dataSource.getImageUrl(value.id);
          }
          if (exprType === "imagelist" && value) {
            return _.map(value, function(img) {
              return dataSource.getImageUrl(img.id);
            }).join(" ");
          }
          return exprUtils.stringifyExprLiteral((ref1 = column.textAxis) != null ? ref1.expr : void 0, value, locale);
        };
        return _.map(design.columns, renderCell);
      };
    })(this);
    table = table.concat(_.map(data.main, renderRow));
    return table;
  };

  TableChart.prototype.getFilterableTables = function(design, schema) {
    return _.compact([design.table]);
  };

  TableChart.prototype.getType = function() {
    return "table";
  };

  return TableChart;

})(Chart);


},{"../../../axes/AxisBuilder":1029,"../Chart":1131,"./TableChartDesignerComponent":1158,"./TableChartViewComponent":1159,"lodash":"lodash","mwater-expressions":14,"react":"react","uuid":1007}],1158:[function(require,module,exports){
var AxisBuilder, ExprComponent, ExprUtils, FilterExprComponent, H, LinkComponent, OrderingsComponent, R, React, ReorderableListComponent, TableChartColumnDesignerComponent, TableChartDesignerComponent, TableSelectComponent, _, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

ExprUtils = require('mwater-expressions').ExprUtils;

AxisBuilder = require('../../../axes/AxisBuilder');

LinkComponent = require('mwater-expressions-ui').LinkComponent;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

FilterExprComponent = require("mwater-expressions-ui").FilterExprComponent;

OrderingsComponent = require('./OrderingsComponent');

TableSelectComponent = require('../../../TableSelectComponent');

ReorderableListComponent = require("react-library/lib/reorderable/ReorderableListComponent");

module.exports = TableChartDesignerComponent = (function(superClass) {
  extend(TableChartDesignerComponent, superClass);

  function TableChartDesignerComponent() {
    this.handleReorder = bind(this.handleReorder, this);
    this.renderColumn = bind(this.renderColumn, this);
    this.handleAddColumn = bind(this.handleAddColumn, this);
    this.handleRemoveColumn = bind(this.handleRemoveColumn, this);
    this.handleColumnChange = bind(this.handleColumnChange, this);
    this.handleOrderingsChange = bind(this.handleOrderingsChange, this);
    this.handleFilterChange = bind(this.handleFilterChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    this.handleTitleTextChange = bind(this.handleTitleTextChange, this);
    return TableChartDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  TableChartDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func.isRequired
  };

  TableChartDesignerComponent.prototype.updateDesign = function(changes) {
    var design;
    design = _.extend({}, this.props.design, changes);
    return this.props.onDesignChange(design);
  };

  TableChartDesignerComponent.prototype.handleTitleTextChange = function(ev) {
    return this.updateDesign({
      titleText: ev.target.value
    });
  };

  TableChartDesignerComponent.prototype.handleTableChange = function(table) {
    return this.updateDesign({
      table: table
    });
  };

  TableChartDesignerComponent.prototype.handleFilterChange = function(filter) {
    return this.updateDesign({
      filter: filter
    });
  };

  TableChartDesignerComponent.prototype.handleOrderingsChange = function(orderings) {
    return this.updateDesign({
      orderings: orderings
    });
  };

  TableChartDesignerComponent.prototype.handleColumnChange = function(index, column) {
    var columns;
    columns = this.props.design.columns.slice();
    columns[index] = column;
    return this.updateDesign({
      columns: columns
    });
  };

  TableChartDesignerComponent.prototype.handleRemoveColumn = function(index) {
    var columns;
    columns = this.props.design.columns.slice();
    columns.splice(index, 1);
    return this.updateDesign({
      columns: columns
    });
  };

  TableChartDesignerComponent.prototype.handleAddColumn = function() {
    var columns;
    columns = this.props.design.columns.slice();
    columns.push({
      id: uuid()
    });
    return this.updateDesign({
      columns: columns
    });
  };

  TableChartDesignerComponent.prototype.renderTable = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", React.createElement(TableSelectComponent, {
      schema: this.props.schema,
      value: this.props.design.table,
      onChange: this.handleTableChange
    }));
  };

  TableChartDesignerComponent.prototype.renderTitle = function() {
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Title"), H.input({
      type: "text",
      className: "form-control input-sm",
      value: this.props.design.titleText,
      onChange: this.handleTitleTextChange,
      placeholder: "Untitled"
    }));
  };

  TableChartDesignerComponent.prototype.renderColumn = function(column, index, connectDragSource, connectDragPreview, connectDropTarget) {
    var style;
    style = {
      borderTop: "solid 1px #EEE",
      paddingTop: 10,
      paddingBottom: 10
    };
    return connectDragPreview(connectDropTarget(H.div({
      key: index,
      style: style
    }, React.createElement(TableChartColumnDesignerComponent, {
      design: this.props.design,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      index: index,
      onChange: this.handleColumnChange.bind(null, index),
      onRemove: this.handleRemoveColumn.bind(null, index),
      connectDragSource: connectDragSource
    }))));
  };

  TableChartDesignerComponent.prototype.handleReorder = function(map) {
    return this.updateDesign({
      columns: map
    });
  };

  TableChartDesignerComponent.prototype.renderColumns = function() {
    if (!this.props.design.table) {
      return;
    }
    return H.div(null, R(ReorderableListComponent, {
      items: this.props.design.columns,
      onReorder: this.handleReorder,
      renderItem: this.renderColumn,
      getItemId: (function(_this) {
        return function(item) {
          return item.id;
        };
      })(this)
    }), H.button({
      className: "btn btn-default btn-sm",
      type: "button",
      onClick: this.handleAddColumn
    }, H.span({
      className: "glyphicon glyphicon-plus"
    }), " Add Column"));
  };

  TableChartDesignerComponent.prototype.renderOrderings = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-sort-by-attributes"
    }), " ", "Ordering"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(OrderingsComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      orderings: this.props.design.orderings,
      onOrderingsChange: this.handleOrderingsChange,
      table: this.props.design.table
    })));
  };

  TableChartDesignerComponent.prototype.renderFilter = function() {
    if (!this.props.design.table) {
      return null;
    }
    return H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.span({
      className: "glyphicon glyphicon-filter"
    }), " ", "Filters"), H.div({
      style: {
        marginLeft: 8
      }
    }, React.createElement(FilterExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onChange: this.handleFilterChange,
      table: this.props.design.table,
      value: this.props.design.filter
    })));
  };

  TableChartDesignerComponent.prototype.render = function() {
    return H.div(null, this.renderTable(), this.renderColumns(), this.props.design.table ? H.hr() : void 0, this.renderOrderings(), this.renderFilter(), H.hr(), this.renderTitle());
  };

  return TableChartDesignerComponent;

})(React.Component);

TableChartColumnDesignerComponent = (function(superClass) {
  extend(TableChartColumnDesignerComponent, superClass);

  function TableChartColumnDesignerComponent() {
    this.handleAggrChange = bind(this.handleAggrChange, this);
    this.handleHeaderTextChange = bind(this.handleHeaderTextChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    return TableChartColumnDesignerComponent.__super__.constructor.apply(this, arguments);
  }

  TableChartColumnDesignerComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    index: React.PropTypes.number.isRequired,
    onChange: React.PropTypes.func.isRequired,
    onRemove: React.PropTypes.func.isRequired
  };

  TableChartColumnDesignerComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  TableChartColumnDesignerComponent.prototype.updateColumn = function(changes) {
    var column;
    column = _.extend({}, this.props.design.columns[this.props.index], changes);
    return this.props.onChange(column);
  };

  TableChartColumnDesignerComponent.prototype.updateTextAxis = function(changes) {
    var textAxis;
    textAxis = _.extend({}, this.props.design.columns[this.props.index].textAxis, changes);
    return this.updateColumn({
      textAxis: textAxis
    });
  };

  TableChartColumnDesignerComponent.prototype.handleExprChange = function(expr) {
    return this.updateTextAxis({
      expr: expr
    });
  };

  TableChartColumnDesignerComponent.prototype.handleHeaderTextChange = function(ev) {
    return this.updateColumn({
      headerText: ev.target.value
    });
  };

  TableChartColumnDesignerComponent.prototype.handleAggrChange = function(aggr) {
    return this.updateTextAxis({
      aggr: aggr
    });
  };

  TableChartColumnDesignerComponent.prototype.renderRemove = function() {
    if (this.props.design.columns.length > 1) {
      return H.button({
        className: "btn btn-xs btn-link pull-right",
        type: "button",
        onClick: this.props.onRemove
      }, H.span({
        className: "glyphicon glyphicon-remove"
      }));
    }
  };

  TableChartColumnDesignerComponent.prototype.renderExpr = function() {
    var column, title;
    column = this.props.design.columns[this.props.index];
    title = "Value";
    return H.div(null, H.label({
      className: "text-muted"
    }, title), ": ", React.createElement(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.props.design.table,
      value: column.textAxis ? column.textAxis.expr : void 0,
      onChange: this.handleExprChange,
      aggrStatuses: ["literal", "individual", "aggregate"]
    }));
  };

  TableChartColumnDesignerComponent.prototype.renderHeader = function() {
    var axisBuilder, column, placeholder;
    column = this.props.design.columns[this.props.index];
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    placeholder = axisBuilder.summarizeAxis(column.textAxis, this.context.locale);
    return H.div(null, H.label({
      className: "text-muted"
    }, "Header"), ": ", H.input({
      type: "text",
      className: "form-control input-sm",
      style: {
        display: "inline-block",
        width: "15em"
      },
      value: column.headerText,
      onChange: this.handleHeaderTextChange,
      placeholder: placeholder
    }));
  };

  TableChartColumnDesignerComponent.prototype.render = function() {
    var iconStyle;
    iconStyle = {
      cursor: "move",
      marginRight: 8,
      opacity: 0.5,
      fontSize: 12,
      height: 20
    };
    return H.div(null, this.props.connectDragSource(H.i({
      className: "fa fa-bars",
      style: iconStyle
    })), this.renderRemove(), H.label(null, "Column " + (this.props.index + 1)), H.div({
      style: {
        marginLeft: 5
      }
    }, this.renderExpr(), this.renderHeader()));
  };

  return TableChartColumnDesignerComponent;

})(React.Component);


},{"../../../TableSelectComponent":1025,"../../../axes/AxisBuilder":1029,"./OrderingsComponent":1156,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/reorderable/ReorderableListComponent":795,"uuid":1007}],1159:[function(require,module,exports){
var AxisBuilder, ExprUtils, H, R, React, TableChartViewComponent, TableContentsComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

AxisBuilder = require('../../../axes/AxisBuilder');

ExprUtils = require('mwater-expressions').ExprUtils;

module.exports = TableChartViewComponent = (function(superClass) {
  extend(TableChartViewComponent, superClass);

  function TableChartViewComponent() {
    return TableChartViewComponent.__super__.constructor.apply(this, arguments);
  }

  TableChartViewComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    data: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    scope: React.PropTypes.any,
    onScopeChange: React.PropTypes.func,
    onRowClick: React.PropTypes.func
  };

  TableChartViewComponent.prototype.shouldComponentUpdate = function(prevProps) {
    return !_.isEqual(prevProps, this.props);
  };

  TableChartViewComponent.prototype.render = function() {
    var style;
    style = {
      width: this.props.standardWidth,
      height: this.props.height * (this.props.standardWidth / this.props.width),
      transform: "scale(" + (this.props.width / this.props.standardWidth) + ", " + (this.props.width / this.props.standardWidth) + ")",
      transformOrigin: "0 0"
    };
    return H.div({
      style: style,
      className: "overflow-auto-except-print"
    }, H.div({
      style: {
        fontWeight: "bold",
        textAlign: "center"
      },
      ref: "title"
    }, this.props.design.titleText), R(TableContentsComponent, {
      columns: this.props.design.columns,
      table: this.props.design.table,
      data: this.props.data,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      onRowClick: this.props.onRowClick
    }));
  };

  return TableChartViewComponent;

})(React.Component);

TableContentsComponent = (function(superClass) {
  extend(TableContentsComponent, superClass);

  function TableContentsComponent() {
    this.handleRowClick = bind(this.handleRowClick, this);
    return TableContentsComponent.__super__.constructor.apply(this, arguments);
  }

  TableContentsComponent.propTypes = {
    columns: React.PropTypes.array.isRequired,
    data: React.PropTypes.object.isRequired,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    table: React.PropTypes.string.isRequired,
    onRowClick: React.PropTypes.func
  };

  TableContentsComponent.contextTypes = {
    locale: React.PropTypes.string
  };

  TableContentsComponent.prototype.shouldComponentUpdate = function(prevProps) {
    if (prevProps.columns !== this.props.columns && !_.isEqual(prevProps.columns, this.props.columns)) {
      return true;
    }
    if (prevProps.data !== this.props.data && !_.isEqual(prevProps.data, this.props.data)) {
      return true;
    }
    if (prevProps.schema !== this.props.schema) {
      return true;
    }
    return false;
  };

  TableContentsComponent.prototype.handleRowClick = function(rowIndex) {
    var row;
    row = this.props.data.main[rowIndex];
    if (row && row.id && row.num_ids === 1 && this.props.onRowClick) {
      return this.props.onRowClick(this.props.table, row.id);
    }
  };

  TableContentsComponent.prototype.renderHeaderCell = function(index) {
    var axisBuilder, column, text;
    axisBuilder = new AxisBuilder({
      schema: this.props.schema
    });
    column = this.props.columns[index];
    text = column.headerText || axisBuilder.summarizeAxis(column.textAxis, this.context.locale);
    return H.th({
      key: index
    }, text);
  };

  TableContentsComponent.prototype.renderHeader = function() {
    return H.thead({
      key: "head"
    }, H.tr({
      key: "head"
    }, _.map(this.props.columns, (function(_this) {
      return function(column, i) {
        return _this.renderHeaderCell(i);
      };
    })(this))));
  };

  TableContentsComponent.prototype.renderImage = function(id) {
    var url;
    url = this.props.dataSource.getImageUrl(id);
    return H.a({
      href: url,
      key: id,
      target: "_blank",
      style: {
        paddingLeft: 5,
        paddingRight: 5
      }
    }, "Image");
  };

  TableContentsComponent.prototype.renderCell = function(rowIndex, columnIndex) {
    var column, exprType, exprUtils, node, ref, ref1, row, value;
    row = this.props.data.main[rowIndex];
    column = this.props.columns[columnIndex];
    exprUtils = new ExprUtils(this.props.schema);
    exprType = exprUtils.getExprType((ref = column.textAxis) != null ? ref.expr : void 0);
    value = row["c" + columnIndex];
    if (value == null) {
      node = null;
    } else {
      if ((exprType === 'image' || exprType === 'imagelist' || exprType === 'geometry' || exprType === 'text[]') && _.isString(value)) {
        value = JSON.parse(value);
      }
      switch (exprType) {
        case "text":
        case "number":
          node = value;
          break;
        case "boolean":
        case "enum":
        case "enumset":
        case "text[]":
          node = exprUtils.stringifyExprLiteral((ref1 = column.textAxis) != null ? ref1.expr : void 0, value, this.context.locale);
          break;
        case "date":
          node = moment(value, "YYYY-MM-DD").format("ll");
          break;
        case "datetime":
          node = moment(value, moment.ISO_8601).format("lll");
          break;
        case "image":
          node = this.renderImage(value.id);
          break;
        case "imagelist":
          node = _.map(value, (function(_this) {
            return function(v) {
              return _this.renderImage(v.id);
            };
          })(this));
          break;
        case "geometry":
          if (value.type === "Point") {
            node = (value.coordinates[1].toFixed(6)) + " " + (value.coordinates[0].toFixed(6));
          } else {
            node = value.type;
          }
          break;
        default:
          node = "" + value;
      }
    }
    return H.td({
      key: columnIndex
    }, node);
  };

  TableContentsComponent.prototype.renderRow = function(index) {
    return H.tr({
      key: index,
      onClick: this.handleRowClick.bind(null, index)
    }, _.map(this.props.columns, (function(_this) {
      return function(column, i) {
        return _this.renderCell(index, i);
      };
    })(this)));
  };

  TableContentsComponent.prototype.renderBody = function() {
    return H.tbody({
      key: "body"
    }, _.map(this.props.data.main, (function(_this) {
      return function(row, i) {
        return _this.renderRow(i);
      };
    })(this)));
  };

  TableContentsComponent.prototype.render = function() {
    return H.table({
      className: "table table-condensed table-hover",
      style: {
        fontSize: "10pt",
        marginBottom: 0
      }
    }, this.renderHeader(), this.renderBody());
  };

  return TableContentsComponent;

})(React.Component);


},{"../../../axes/AxisBuilder":1029,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1160:[function(require,module,exports){
var ActionCancelModalComponent, ExprComponent, ExprInsertModalComponent, ExprItemEditorComponent, ExprUtils, H, R, React, TableSelectComponent, uuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

uuid = require('uuid');

ExprUtils = require("mwater-expressions").ExprUtils;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

ActionCancelModalComponent = require("react-library/lib/ActionCancelModalComponent");

TableSelectComponent = require('../../TableSelectComponent');

ExprItemEditorComponent = require('./ExprItemEditorComponent');

module.exports = ExprInsertModalComponent = (function(superClass) {
  extend(ExprInsertModalComponent, superClass);

  ExprInsertModalComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    onInsert: React.PropTypes.func.isRequired,
    singleRowTable: React.PropTypes.string
  };

  function ExprInsertModalComponent() {
    this.handleInsert = bind(this.handleInsert, this);
    ExprInsertModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      exprItem: null
    };
  }

  ExprInsertModalComponent.prototype.open = function() {
    return this.setState({
      open: true,
      exprItem: {
        type: "expr",
        id: uuid()
      }
    });
  };

  ExprInsertModalComponent.prototype.handleInsert = function(ev) {
    if (!this.state.exprItem) {
      return;
    }
    return this.setState({
      open: false
    }, (function(_this) {
      return function() {
        return _this.props.onInsert(_this.state.exprItem);
      };
    })(this));
  };

  ExprInsertModalComponent.prototype.render = function() {
    if (!this.state.open) {
      return null;
    }
    return R(ActionCancelModalComponent, {
      actionLabel: "Insert",
      onAction: this.handleInsert,
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this),
      title: "Insert Field"
    }, R(ExprItemEditorComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprItem: this.state.exprItem,
      onChange: (function(_this) {
        return function(exprItem) {
          return _this.setState({
            exprItem: exprItem
          });
        };
      })(this),
      singleRowTable: this.props.singleRowTable
    }));
  };

  return ExprInsertModalComponent;

})(React.Component);


},{"../../TableSelectComponent":1025,"./ExprItemEditorComponent":1161,"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/ActionCancelModalComponent":781,"uuid":1007}],1161:[function(require,module,exports){
var ExprComponent, ExprItemEditorComponent, ExprUtils, H, R, React, TableSelectComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = require('lodash');

React = require('react');

H = React.DOM;

R = React.createElement;

ExprUtils = require("mwater-expressions").ExprUtils;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

TableSelectComponent = require('../../TableSelectComponent');

module.exports = ExprItemEditorComponent = (function(superClass) {
  extend(ExprItemEditorComponent, superClass);

  ExprItemEditorComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    exprItem: React.PropTypes.object.isRequired,
    onChange: React.PropTypes.func.isRequired,
    singleRowTable: React.PropTypes.string
  };

  function ExprItemEditorComponent(props) {
    this.handleFormatChange = bind(this.handleFormatChange, this);
    this.handleLabelTextChange = bind(this.handleLabelTextChange, this);
    this.handleIncludeLabelChange = bind(this.handleIncludeLabelChange, this);
    this.handleExprChange = bind(this.handleExprChange, this);
    this.handleTableChange = bind(this.handleTableChange, this);
    var ref;
    ExprItemEditorComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      table: ((ref = props.exprItem.expr) != null ? ref.table : void 0) || props.singleRowTable
    };
  }

  ExprItemEditorComponent.prototype.handleTableChange = function(table) {
    return this.setState({
      table: table
    });
  };

  ExprItemEditorComponent.prototype.handleExprChange = function(expr) {
    var exprItem;
    exprItem = _.extend({}, this.props.exprItem, {
      expr: expr
    });
    return this.props.onChange(exprItem);
  };

  ExprItemEditorComponent.prototype.handleIncludeLabelChange = function(ev) {
    var exprItem;
    exprItem = _.extend({}, this.props.exprItem, {
      includeLabel: ev.target.checked,
      labelText: ev.target.checked ? this.props.exprItem.labelText : void 0
    });
    return this.props.onChange(exprItem);
  };

  ExprItemEditorComponent.prototype.handleLabelTextChange = function(ev) {
    var exprItem;
    exprItem = _.extend({}, this.props.exprItem, {
      labelText: ev.target.value || null
    });
    return this.props.onChange(exprItem);
  };

  ExprItemEditorComponent.prototype.handleFormatChange = function(ev) {
    var exprItem;
    exprItem = _.extend({}, this.props.exprItem, {
      format: ev.target.value || null
    });
    return this.props.onChange(exprItem);
  };

  ExprItemEditorComponent.prototype.render = function() {
    var exprUtils, formats;
    formats = [
      {
        value: "",
        label: "Normal: 1234.567"
      }, {
        value: ",.0f",
        label: "Rounded: 1,234"
      }, {
        value: ",.2f",
        label: "Two decimals: 1,234.56"
      }, {
        value: "$,.2f",
        label: "Currency: $1,234.56"
      }, {
        value: "$,.0f",
        label: "Currency rounded: $1,234"
      }, {
        value: ".0%",
        label: "Percent rounded: 12%"
      }
    ];
    exprUtils = new ExprUtils(this.props.schema);
    return H.div({
      style: {
        paddingBottom: 200
      }
    }, H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, H.i({
      className: "fa fa-database"
    }), " ", "Data Source"), ": ", R(TableSelectComponent, {
      schema: this.props.schema,
      value: this.state.table,
      onChange: this.handleTableChange
    }), H.br()), this.state.table ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Field"), ": ", R(ExprComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      table: this.state.table,
      types: ['text', 'number', 'enum', 'date', 'datetime', 'boolean', 'enumset'],
      value: this.props.exprItem.expr,
      aggrStatuses: ["individual", "literal", "aggregate"],
      onChange: this.handleExprChange
    })) : void 0, this.state.table && this.props.exprItem.expr ? H.div({
      className: "form-group"
    }, H.label({
      key: "includeLabel"
    }, H.input({
      type: "checkbox",
      checked: this.props.exprItem.includeLabel,
      onChange: this.handleIncludeLabelChange
    }), " Include Label"), this.props.exprItem.includeLabel ? H.input({
      key: "labelText",
      className: "form-control",
      type: "text",
      value: this.props.exprItem.labelText || "",
      onChange: this.handleLabelTextChange,
      placeholder: new ExprUtils(this.props.schema).summarizeExpr(this.props.exprItem.expr) + ": "
    }) : void 0) : void 0, this.props.exprItem.expr && exprUtils.getExprType(this.props.exprItem.expr) === "number" ? H.div({
      className: "form-group"
    }, H.label({
      className: "text-muted"
    }, "Format"), ": ", H.select({
      value: this.props.exprItem.format || "",
      className: "form-control",
      style: {
        width: "auto",
        display: "inline-block"
      },
      onChange: this.handleFormatChange
    }, _.map(formats, function(format) {
      return H.option({
        key: format.value,
        value: format.value
      }, format.label);
    }))) : void 0);
  };

  return ExprItemEditorComponent;

})(React.Component);


},{"../../TableSelectComponent":1025,"lodash":"lodash","mwater-expressions":14,"mwater-expressions-ui":362,"react":"react"}],1162:[function(require,module,exports){
var ActionCancelModalComponent, ExprComponent, ExprItemEditorComponent, ExprUpdateModalComponent, ExprUtils, H, R, React, TableSelectComponent,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

ExprUtils = require("mwater-expressions").ExprUtils;

ExprComponent = require("mwater-expressions-ui").ExprComponent;

ActionCancelModalComponent = require("react-library/lib/ActionCancelModalComponent");

TableSelectComponent = require('../../TableSelectComponent');

ExprItemEditorComponent = require('./ExprItemEditorComponent');

module.exports = ExprUpdateModalComponent = (function(superClass) {
  extend(ExprUpdateModalComponent, superClass);

  ExprUpdateModalComponent.propTypes = {
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    singleRowTable: React.PropTypes.string
  };

  function ExprUpdateModalComponent() {
    ExprUpdateModalComponent.__super__.constructor.apply(this, arguments);
    this.state = {
      open: false,
      exprItem: null,
      onUpdate: null
    };
  }

  ExprUpdateModalComponent.prototype.open = function(item, onUpdate) {
    return this.setState({
      open: true,
      exprItem: item,
      onUpdate: onUpdate
    });
  };

  ExprUpdateModalComponent.prototype.render = function() {
    if (!this.state.open) {
      return null;
    }
    return R(ActionCancelModalComponent, {
      actionLabel: "Update",
      onAction: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          }, function() {
            return _this.state.onUpdate(_this.state.exprItem);
          });
        };
      })(this),
      onCancel: (function(_this) {
        return function() {
          return _this.setState({
            open: false
          });
        };
      })(this),
      title: "Update Field"
    }, R(ExprItemEditorComponent, {
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprItem: this.state.exprItem,
      onChange: (function(_this) {
        return function(exprItem) {
          return _this.setState({
            exprItem: exprItem
          });
        };
      })(this),
      singleRowTable: this.props.singleRowTable
    }));
  };

  return ExprUpdateModalComponent;

})(React.Component);


},{"../../TableSelectComponent":1025,"./ExprItemEditorComponent":1161,"mwater-expressions":14,"mwater-expressions-ui":362,"react":"react","react-library/lib/ActionCancelModalComponent":781}],1163:[function(require,module,exports){
var ExprInsertModalComponent, ExprItemsHtmlConverter, ExprUpdateModalComponent, H, R, React, RichTextComponent, TextComponent, _,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

RichTextComponent = require('../../richtext/RichTextComponent');

ExprInsertModalComponent = require('./ExprInsertModalComponent');

ExprUpdateModalComponent = require('./ExprUpdateModalComponent');

ExprItemsHtmlConverter = require('../../richtext/ExprItemsHtmlConverter');

module.exports = TextComponent = (function(superClass) {
  extend(TextComponent, superClass);

  function TextComponent() {
    this.handleAddExpr = bind(this.handleAddExpr, this);
    this.handleItemClick = bind(this.handleItemClick, this);
    this.handleInsertExpr = bind(this.handleInsertExpr, this);
    this.handleItemsChange = bind(this.handleItemsChange, this);
    return TextComponent.__super__.constructor.apply(this, arguments);
  }

  TextComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    exprValues: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    singleRowTable: React.PropTypes.string,
    namedStrings: React.PropTypes.object
  };

  TextComponent.prototype.createItemsHtmlConverter = function() {
    return new ExprItemsHtmlConverter(this.props.schema, this.props.onDesignChange != null, this.props.exprValues, (this.props.onDesignChange != null) && (this.props.singleRowTable != null), this.props.onDesignChange == null ? this.props.namedStrings : void 0);
  };

  TextComponent.prototype.handleItemsChange = function(items) {
    var design;
    design = _.extend({}, this.props.design, {
      items: items
    });
    return this.props.onDesignChange(design);
  };

  TextComponent.prototype.handleInsertExpr = function(item) {
    var html;
    html = '<div data-embed="' + _.escape(JSON.stringify(item)) + '"></div>';
    return this.refs.editor.pasteHTML(html);
  };

  TextComponent.prototype.replaceItem = function(item) {
    var items, replaceItemInItems;
    replaceItemInItems = function(items, item) {
      return _.map(items, function(i) {
        if (i.id === item.id) {
          return item;
        } else if (i.items) {
          return _.extend({}, i, {
            items: replaceItemInItems(i.items, item)
          });
        } else {
          return i;
        }
      });
    };
    items = replaceItemInItems(this.props.design.items || [], item);
    return this.props.onDesignChange(_.extend({}, this.props.design, {
      items: items
    }));
  };

  TextComponent.prototype.handleItemClick = function(item) {
    return this.refs.exprUpdateModal.open(item, (function(_this) {
      return function(item) {
        return _this.replaceItem(item);
      };
    })(this));
  };

  TextComponent.prototype.handleAddExpr = function(ev) {
    ev.preventDefault();
    return this.refs.exprInsertModal.open();
  };

  TextComponent.prototype.renderExtraPaletteButtons = function() {
    return H.div({
      key: "expr",
      className: "mwater-visualization-text-palette-item",
      onMouseDown: this.handleAddExpr
    }, H.i({
      className: "fa fa-plus"
    }), " Field");
  };

  TextComponent.prototype.renderModals = function() {
    return [
      R(ExprInsertModalComponent, {
        key: "exprInsertModal",
        ref: "exprInsertModal",
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        onInsert: this.handleInsertExpr,
        singleRowTable: this.props.singleRowTable
      }), R(ExprUpdateModalComponent, {
        key: "exprUpdateModal",
        ref: "exprUpdateModal",
        schema: this.props.schema,
        dataSource: this.props.dataSource,
        singleRowTable: this.props.singleRowTable
      })
    ];
  };

  TextComponent.prototype.render = function() {
    var style;
    style = {
      position: "relative"
    };
    if (this.props.standardWidth && this.props.standardWidth !== this.props.width) {
      style.width = this.props.standardWidth;
      style.height = this.props.height * (this.props.standardWidth / this.props.width);
      style.transform = "scale(" + (this.props.width / this.props.standardWidth) + ", " + (this.props.width / this.props.standardWidth) + ")";
      style.transformOrigin = "0 0";
    } else {
      style.width = this.props.width;
      style.height = this.props.height;
    }
    return H.div(null, this.renderModals(), R(RichTextComponent, {
      ref: "editor",
      className: "mwater-visualization-text-widget-style-" + (this.props.design.style || "default"),
      style: style,
      items: this.props.design.items,
      onItemsChange: this.props.onDesignChange ? this.handleItemsChange : void 0,
      onItemClick: this.handleItemClick,
      itemsHtmlConverter: this.createItemsHtmlConverter(),
      includeHeadings: this.props.design.style === "default" || !this.props.design.style,
      extraPaletteButtons: this.renderExtraPaletteButtons()
    }));
  };

  return TextComponent;

})(React.Component);


},{"../../richtext/ExprItemsHtmlConverter":1114,"../../richtext/RichTextComponent":1116,"./ExprInsertModalComponent":1160,"./ExprUpdateModalComponent":1162,"lodash":"lodash","react":"react"}],1164:[function(require,module,exports){
var ExprCleaner, ExprCompiler, H, R, React, TextWidget, Widget, _, async, injectTableAlias,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

async = require('async');

ExprCompiler = require('mwater-expressions').ExprCompiler;

ExprCleaner = require('mwater-expressions').ExprCleaner;

injectTableAlias = require('mwater-expressions').injectTableAlias;

Widget = require('../Widget');

module.exports = TextWidget = (function(superClass) {
  extend(TextWidget, superClass);

  function TextWidget() {
    return TextWidget.__super__.constructor.apply(this, arguments);
  }

  TextWidget.prototype.createViewElement = function(options) {
    var TextWidgetComponent;
    TextWidgetComponent = require('./TextWidgetComponent');
    return R(TextWidgetComponent, {
      schema: options.schema,
      dataSource: options.dataSource,
      widgetDataSource: options.widgetDataSource,
      filters: options.filters,
      design: options.design,
      onDesignChange: options.onDesignChange,
      width: options.width,
      height: options.height,
      standardWidth: options.standardWidth,
      singleRowTable: options.singleRowTable,
      namedStrings: options.namedStrings
    });
  };

  TextWidget.prototype.getData = function(design, schema, dataSource, filters, callback) {
    var evalExprItem, exprValues;
    evalExprItem = (function(_this) {
      return function(exprItem, cb) {
        var expr, exprCleaner, exprCompiler, query, relevantFilters, table, whereClauses;
        if (!exprItem.expr) {
          return cb(null);
        }
        table = exprItem.expr.table;
        exprCompiler = new ExprCompiler(schema);
        exprCleaner = new ExprCleaner(schema);
        expr = exprCleaner.cleanExpr(exprItem.expr, {
          aggrStatuses: ["individual", "literal", "aggregate"]
        });
        query = {
          distinct: true,
          selects: [
            {
              type: "select",
              expr: exprCompiler.compileExpr({
                expr: expr,
                tableAlias: "main"
              }),
              alias: "value"
            }
          ],
          from: {
            type: "table",
            table: table,
            alias: "main"
          },
          limit: 2
        };
        relevantFilters = _.where(filters || [], {
          table: table
        });
        whereClauses = _.map(relevantFilters, function(f) {
          return injectTableAlias(f.jsonql, "main");
        });
        whereClauses = _.compact(whereClauses);
        if (whereClauses.length > 1) {
          query.where = {
            type: "op",
            op: "and",
            exprs: whereClauses
          };
        } else {
          query.where = whereClauses[0];
        }
        return dataSource.performQuery(query, function(error, rows) {
          if (error) {
            return cb(error);
          } else {
            if (rows.length !== 1) {
              return cb(null, null);
            } else {
              return cb(null, rows[0].value);
            }
          }
        });
      };
    })(this);
    exprValues = {};
    return async.each(this.getExprItems(design.items), (function(_this) {
      return function(exprItem, cb) {
        return evalExprItem(exprItem, function(error, value) {
          if (error) {
            return cb(error);
          } else {
            exprValues[exprItem.id] = value;
            return cb(null);
          }
        });
      };
    })(this), (function(_this) {
      return function(error) {
        if (error) {
          return callback(error);
        } else {
          return callback(null, exprValues);
        }
      };
    })(this));
  };

  TextWidget.prototype.isAutoHeight = function() {
    return true;
  };

  TextWidget.prototype.getExprItems = function(items) {
    var exprItems, i, item, len, ref;
    exprItems = [];
    ref = items || [];
    for (i = 0, len = ref.length; i < len; i++) {
      item = ref[i];
      if (item.type === "expr") {
        exprItems.push(item);
      }
      if (item.items) {
        exprItems = exprItems.concat(this.getExprItems(item.items));
      }
    }
    return exprItems;
  };

  TextWidget.prototype.getFilterableTables = function(design, schema) {
    var exprItems, filterableTables;
    exprItems = this.getExprItems(design.items);
    filterableTables = _.map(exprItems, function(exprItem) {
      var ref;
      return (ref = exprItem.expr) != null ? ref.table : void 0;
    });
    filterableTables = _.uniq(_.compact(filterableTables));
    return filterableTables;
  };

  return TextWidget;

})(Widget);


},{"../Widget":1127,"./TextWidgetComponent":1165,"async":29,"lodash":"lodash","mwater-expressions":14,"react":"react"}],1165:[function(require,module,exports){
var AsyncLoadComponent, H, R, React, TextComponent, TextWidgetComponent, _,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

React = require('react');

H = React.DOM;

R = React.createElement;

_ = require('lodash');

TextComponent = require('./TextComponent');

AsyncLoadComponent = require('react-library/lib/AsyncLoadComponent');

module.exports = TextWidgetComponent = (function(superClass) {
  extend(TextWidgetComponent, superClass);

  TextWidgetComponent.propTypes = {
    design: React.PropTypes.object.isRequired,
    onDesignChange: React.PropTypes.func,
    filters: React.PropTypes.array,
    schema: React.PropTypes.object.isRequired,
    dataSource: React.PropTypes.object.isRequired,
    widgetDataSource: React.PropTypes.object.isRequired,
    width: React.PropTypes.number,
    height: React.PropTypes.number,
    standardWidth: React.PropTypes.number,
    singleRowTable: React.PropTypes.string,
    namedStrings: React.PropTypes.object
  };

  function TextWidgetComponent(props) {
    TextWidgetComponent.__super__.constructor.call(this, props);
    this.state = {
      exprValues: {},
      error: null
    };
  }

  TextWidgetComponent.prototype.isLoadNeeded = function(newProps, oldProps) {
    var getExprItems;
    getExprItems = function(items) {
      var exprItems, i, item, len, ref;
      exprItems = [];
      ref = items || [];
      for (i = 0, len = ref.length; i < len; i++) {
        item = ref[i];
        if (item.type === "expr") {
          exprItems.push(item);
        }
        if (item.items) {
          exprItems = exprItems.concat(getExprItems(item.items));
        }
      }
      return exprItems;
    };
    return !_.isEqual(newProps.filters, oldProps.filters) || !_.isEqual(getExprItems(newProps.design.items), getExprItems(oldProps.design.items));
  };

  TextWidgetComponent.prototype.load = function(props, prevProps, callback) {
    return props.widgetDataSource.getData(props.design, props.filters, (function(_this) {
      return function(error, data) {
        return callback({
          error: error,
          exprValues: data || {}
        });
      };
    })(this));
  };

  TextWidgetComponent.prototype.render = function() {
    var exprValues;
    exprValues = !this.state.loading ? this.state.exprValues : {};
    return R(TextComponent, {
      design: this.props.design,
      onDesignChange: this.props.onDesignChange,
      filters: this.props.filters,
      schema: this.props.schema,
      dataSource: this.props.dataSource,
      exprValues: exprValues,
      width: this.props.width,
      height: this.props.height,
      standardWidth: this.props.standardWidth,
      singleRowTable: this.props.singleRowTable,
      namedStrings: this.props.namedStrings
    });
  };

  return TextWidgetComponent;

})(AsyncLoadComponent);


},{"./TextComponent":1163,"lodash":"lodash","react":"react","react-library/lib/AsyncLoadComponent":782}],"jquery":[function(require,module,exports){
module.exports = window.$;
},{}],"lodash":[function(require,module,exports){
module.exports = window._;
},{}],"mwater-visualization":[function(require,module,exports){
var $;

exports.CachingDataSource = require('./CachingDataSource');

exports.WidgetFactory = require('./widgets/WidgetFactory');

exports.UndoStack = require('./UndoStack');

exports.DashboardComponent = require('./dashboards/DashboardComponent');

exports.DashboardViewComponent = require('./dashboards/DashboardViewComponent');

exports.BingLayer = require('./maps/BingLayer');

exports.UtfGridLayer = require('./maps/UtfGridLayer');

exports.LeafletMapComponent = require('./maps/LeafletMapComponent');

exports.LayerFactory = require('./maps/LayerFactory');

exports.MapViewComponent = require('./maps/MapViewComponent');

exports.MapDesignerComponent = require('./maps/MapDesignerComponent');

exports.MapComponent = require('./maps/MapComponent');

exports.VerticalLayoutComponent = require('./VerticalLayoutComponent');

exports.RadioButtonComponent = require('./RadioButtonComponent');

exports.CheckboxComponent = require('./CheckboxComponent');

exports.mWaterLoader = require('./mWaterLoader');

exports.MWaterLoaderComponent = require('./MWaterLoaderComponent');

exports.LayeredChart = require('./widgets/charts/layered/LayeredChart');

exports.TableChart = require('./widgets/charts/table/TableChart');

exports.CalendarChart = require('./widgets/charts/calendar/CalendarChart');

exports.ImageMosaicChart = require('./widgets/charts/imagemosaic/ImageMosaicChart');

exports.ChartViewComponent = require('./widgets/charts/ChartViewComponent');

exports.WidgetScoper = require('./widgets/WidgetScoper');

exports.WidgetScopesViewComponent = require('./widgets/WidgetScopesViewComponent');

exports.TableSelectComponent = require('./TableSelectComponent');

exports.AxisBuilder = require('./axes/AxisBuilder');

exports.ColorSchemeFactory = require('./ColorSchemeFactory');

exports.DatagridComponent = require('./datagrids/DatagridComponent');

exports.DatagridViewComponent = require('./datagrids/DatagridViewComponent');

exports.DatagridUtils = require('./datagrids/DatagridUtils');

exports.ServerDashboardDataSource = require('./dashboards/ServerDashboardDataSource');

exports.DirectDashboardDataSource = require('./dashboards/DirectDashboardDataSource');

exports.DirectWidgetDataSource = require('./widgets/DirectWidgetDataSource');

exports.ServerMapDataSource = require('./maps/ServerMapDataSource');

exports.DirectMapDataSource = require('./maps/DirectMapDataSource');

exports.ServerDatagridDataSource = require('./datagrids/ServerDatagridDataSource');

exports.DirectDatagridDataSource = require('./datagrids/DirectDatagridDataSource');

exports.LabeledExprGenerator = require('./datagrids/LabeledExprGenerator');

exports.LayoutManager = require('./layouts/LayoutManager');

exports.RegionSelectComponent = require('./maps/RegionSelectComponent');

exports.DetailLevelSelectComponent = require('./maps/DetailLevelSelectComponent');

exports.MarkerSymbolSelectComponent = require('./maps/MarkerSymbolSelectComponent');

exports.AxisColorEditorComponent = require('./axes/AxisColorEditorComponent');

exports.RichTextComponent = require('./richtext/RichTextComponent');

exports.ItemsHtmlConverter = require('./richtext/ItemsHtmlConverter');

exports.DropdownWidgetComponent = require('./widgets/DropdownWidgetComponent');

exports.QuickfilterCompiler = require('./quickfilter/QuickfilterCompiler');

require('./pathseg-polyfill.js');

$ = require('jquery');


$(document).on('show.bs.modal', '.modal', function () {
    var zIndex = 1040 + (10 * $('.modal:visible').length);
    $(this).css('z-index', zIndex);
    setTimeout(function() {
        $('.modal-backdrop').not('.modal-stack').css('z-index', zIndex - 1).addClass('modal-stack');
    }, 0);
});
$(document).on('hidden.bs.modal', '.modal', function () {
    $('.modal:visible').length && $(document.body).addClass('modal-open');
});
;


},{"./CachingDataSource":1014,"./CheckboxComponent":1015,"./ColorSchemeFactory":1017,"./MWaterLoaderComponent":1022,"./RadioButtonComponent":1024,"./TableSelectComponent":1025,"./UndoStack":1027,"./VerticalLayoutComponent":1028,"./axes/AxisBuilder":1029,"./axes/AxisColorEditorComponent":1030,"./dashboards/DashboardComponent":1036,"./dashboards/DashboardViewComponent":1039,"./dashboards/DirectDashboardDataSource":1040,"./dashboards/ServerDashboardDataSource":1041,"./datagrids/DatagridComponent":1043,"./datagrids/DatagridUtils":1047,"./datagrids/DatagridViewComponent":1048,"./datagrids/DirectDatagridDataSource":1049,"./datagrids/LabeledExprGenerator":1053,"./datagrids/ServerDatagridDataSource":1055,"./layouts/LayoutManager":1058,"./mWaterLoader":1070,"./maps/BingLayer":1076,"./maps/DetailLevelSelectComponent":1081,"./maps/DirectMapDataSource":1082,"./maps/LayerFactory":1085,"./maps/LeafletMapComponent":1087,"./maps/MapComponent":1092,"./maps/MapDesignerComponent":1095,"./maps/MapViewComponent":1100,"./maps/MarkerSymbolSelectComponent":1101,"./maps/RegionSelectComponent":1104,"./maps/ServerMapDataSource":1105,"./maps/UtfGridLayer":1107,"./pathseg-polyfill.js":1109,"./quickfilter/QuickfilterCompiler":1110,"./richtext/ItemsHtmlConverter":1115,"./richtext/RichTextComponent":1116,"./widgets/DirectWidgetDataSource":1117,"./widgets/DropdownWidgetComponent":1118,"./widgets/WidgetFactory":1128,"./widgets/WidgetScoper":1129,"./widgets/WidgetScopesViewComponent":1130,"./widgets/charts/ChartViewComponent":1132,"./widgets/charts/calendar/CalendarChart":1134,"./widgets/charts/imagemosaic/ImageMosaicChart":1137,"./widgets/charts/layered/LayeredChart":1140,"./widgets/charts/table/TableChart":1157,"jquery":"jquery"}],"react-dom":[function(require,module,exports){
module.exports = window.ReactDOM;
},{}],"react":[function(require,module,exports){
module.exports = window.React;
},{}]},{},[]);
